var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
import { Scope, TFolder, Setting, Modal, PluginSettingTab, getIcon, TFile, Notice, EditorSuggest, MarkdownView, Plugin as Plugin$1 } from "obsidian";
import { DateTime as DateTime$1 } from "luxon";
var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule) return n2;
  var f = n2.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k];
      }
    });
  });
  return a;
}
var lib$1 = {};
Object.defineProperty(lib$1, "__esModule", { value: true });
class LuxonError extends Error {
}
class InvalidDateTimeError extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
}
class InvalidIntervalError extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
}
class InvalidDurationError extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
}
class ConflictingSpecificationError extends LuxonError {
}
class InvalidUnitError extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
}
class InvalidArgumentError extends LuxonError {
}
class ZoneIsAbstractError extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
}
const n = "numeric", s$1 = "short", l = "long";
const DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
const DATE_MED = {
  year: n,
  month: s$1,
  day: n
};
const DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s$1,
  day: n,
  weekday: s$1
};
const DATE_FULL = {
  year: n,
  month: l,
  day: n
};
const DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
const TIME_SIMPLE = {
  hour: n,
  minute: n
};
const TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
};
const TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s$1
};
const TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
const TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23"
};
const TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23"
};
const TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s$1
};
const TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l
};
const DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
};
const DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
};
const DATETIME_MED = {
  year: n,
  month: s$1,
  day: n,
  hour: n,
  minute: n
};
const DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s$1,
  day: n,
  hour: n,
  minute: n,
  second: n
};
const DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s$1,
  day: n,
  weekday: s$1,
  hour: n,
  minute: n
};
const DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s$1
};
const DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s$1
};
const DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l
};
const DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
class Zone {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format2) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
}
let singleton$1 = null;
class SystemZone extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton$1 === null) {
      singleton$1 = new SystemZone();
    }
    return singleton$1;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format: format2, locale }) {
    return parseZoneInfo(ts, format2, locale);
  }
  /** @override **/
  formatOffset(ts, format2) {
    return formatOffset(this.offset(ts), format2);
  }
  /** @override **/
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }
  /** @override **/
  get isValid() {
    return true;
  }
}
let dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone];
}
const typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date);
  const filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const { type, value: value2 } = formatted[i];
    const pos = typeToPos[type];
    if (type === "era") {
      filled[pos] = value2;
    } else if (!isUndefined$1(pos)) {
      filled[pos] = parseInt(value2, 10);
    }
  }
  return filled;
}
let ianaZoneCache = {};
class IANAZone extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name2) {
    if (!ianaZoneCache[name2]) {
      ianaZoneCache[name2] = new IANAZone(name2);
    }
    return ianaZoneCache[name2];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(s2) {
    return this.isValidZone(s2);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e2) {
      return false;
    }
  }
  constructor(name2) {
    super();
    this.zoneName = name2;
    this.valid = IANAZone.isValidZone(name2);
  }
  /** @override **/
  get type() {
    return "iana";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format: format2, locale }) {
    return parseZoneInfo(ts, format2, locale, this.name);
  }
  /** @override **/
  formatOffset(ts, format2) {
    return formatOffset(this.offset(ts), format2);
  }
  /** @override **/
  offset(ts) {
    const date = new Date(ts);
    if (isNaN(date)) return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = +date;
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return (asUTC - asTS) / (60 * 1e3);
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  /** @override **/
  get isValid() {
    return this.valid;
  }
}
let intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
let intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
let intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
let intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const { base: base2, ...cacheKeyOpts } = opts;
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
let sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
function parseLocaleString(localeStr) {
  const xIndex = localeStr.indexOf("-x-");
  if (xIndex !== -1) {
    localeStr = localeStr.substring(0, xIndex);
  }
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options2;
    let selectedStr;
    try {
      options2 = getCachedDTF(localeStr).resolvedOptions();
      selectedStr = localeStr;
    } catch (e2) {
      const smaller = localeStr.substring(0, uIndex);
      options2 = getCachedDTF(smaller).resolvedOptions();
      selectedStr = smaller;
    }
    const { numberingSystem, calendar } = options2;
    return [selectedStr, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    if (!localeStr.includes("-u-")) {
      localeStr += "-u";
    }
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f) {
  const ms = [];
  for (let i = 1; i <= 12; i++) {
    const dt = DateTime.utc(2009, i, 1);
    ms.push(f(dt));
  }
  return ms;
}
function mapWeekdays(f) {
  const ms = [];
  for (let i = 1; i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }
  return ms;
}
function listStuff(loc, length2, englishFn, intlFn) {
  const mode2 = loc.listingMode();
  if (mode2 === "error") {
    return null;
  } else if (mode2 === "en") {
    return englishFn(length2);
  } else {
    return intlFn(length2);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}
class PolyNumberFormatter {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const { padTo, floor: floor2, ...otherOpts } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }
}
class PolyDateFormatter {
  constructor(dt, intl, opts) {
    this.opts = opts;
    this.originalZone = void 0;
    let z = void 0;
    if (this.opts.timeZone) {
      this.dt = dt;
    } else if (dt.zone.type === "fixed") {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z = offsetZ;
        this.dt = dt;
      } else {
        z = "UTC";
        this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
        this.originalZone = dt.zone;
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else if (dt.zone.type === "iana") {
      this.dt = dt;
      z = dt.zone.name;
    } else {
      z = "UTC";
      this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
      this.originalZone = dt.zone;
    }
    const intlOpts = { ...this.opts };
    intlOpts.timeZone = intlOpts.timeZone || z;
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    if (this.originalZone) {
      return this.formatToParts().map(({ value: value2 }) => value2).join("");
    }
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const parts = this.dtf.formatToParts(this.dt.toJSDate());
    if (this.originalZone) {
      return parts.map((part) => {
        if (part.type === "timeZoneName") {
          const offsetName = this.originalZone.offsetName(this.dt.ts, {
            locale: this.dt.locale,
            format: this.opts.timeZoneName
          });
          return {
            ...part,
            value: offsetName
          };
        } else {
          return part;
        }
      });
    }
    return parts;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class PolyRelFormatter {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
}
class Locale {
  static fromOpts(opts) {
    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
  }
  static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
    return Locale.create(locale, numberingSystem, outputCalendar);
  }
  constructor(locale, numbering, outputCalendar, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        alts.defaultToEN || false
      );
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }
  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }
  months(length2, format2 = false) {
    return listStuff(this, length2, months, () => {
      const intl = format2 ? { month: length2, day: "numeric" } : { month: length2 }, formatStr = format2 ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length2]) {
        this.monthsCache[formatStr][length2] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length2];
    });
  }
  weekdays(length2, format2 = false) {
    return listStuff(this, length2, weekdays, () => {
      const intl = format2 ? { weekday: length2, year: "numeric", month: "long", day: "numeric" } : { weekday: length2 }, formatStr = format2 ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length2]) {
        this.weekdaysCache[formatStr][length2] = mapWeekdays(
          (dt) => this.extract(dt, intl, "weekday")
        );
      }
      return this.weekdaysCache[formatStr][length2];
    });
  }
  meridiems() {
    return listStuff(
      this,
      void 0,
      () => meridiems,
      () => {
        if (!this.meridiemCache) {
          const intl = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
            (dt) => this.extract(dt, intl, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(length2) {
    return listStuff(this, length2, eras, () => {
      const intl = { era: length2 };
      if (!this.eraCache[length2]) {
        this.eraCache[length2] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
          (dt) => this.extract(dt, intl, "era")
        );
      }
      return this.eraCache[length2];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
}
let singleton = null;
class FixedOffsetZone extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton === null) {
      singleton = new FixedOffsetZone(0);
    }
    return singleton;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset2) {
    return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s2) {
    if (s2) {
      const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }
    return null;
  }
  constructor(offset2) {
    super();
    this.fixed = offset2;
  }
  /** @override **/
  get type() {
    return "fixed";
  }
  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  /** @override **/
  offsetName() {
    return this.name;
  }
  /** @override **/
  formatOffset(ts, format2) {
    return formatOffset(this.fixed, format2);
  }
  /** @override **/
  get isUniversal() {
    return true;
  }
  /** @override **/
  offset() {
    return this.fixed;
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  /** @override **/
  get isValid() {
    return true;
  }
}
class InvalidZone extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return false;
  }
  /** @override **/
  get isValid() {
    return false;
  }
}
function normalizeZone(input, defaultZone2) {
  if (isUndefined$1(input) || input === null) {
    return defaultZone2;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString$2(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default") return defaultZone2;
    else if (lowered === "local" || lowered === "system") return SystemZone.instance;
    else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;
    else return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber$2(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
    return input;
  } else {
    return new InvalidZone(input);
  }
}
let now = () => Date.now(), defaultZone = "system", defaultLocale = null, defaultNumberingSystem = null, defaultOutputCalendar = null, twoDigitCutoffYear = 60, throwOnInvalid;
class Settings {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n2) {
    now = n2;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  /**
   * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return twoDigitCutoffYear;
  }
  /**
   * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(cutoffYear) {
    twoDigitCutoffYear = cutoffYear % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t2) {
    throwOnInvalid = t2;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }
}
function isUndefined$1(o) {
  return typeof o === "undefined";
}
function isNumber$2(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString$2(o) {
  return typeof o === "string";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e2) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return void 0;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function integerBetween(thing, bottom2, top2) {
  return isInteger(thing) && thing >= bottom2 && thing <= top2;
}
function floorMod(x2, n2) {
  return x2 - n2 * Math.floor(x2 / n2);
}
function padStart(input, n2 = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n2, "0");
  } else {
    padded = ("" + input).padStart(n2, "0");
  }
  return padded;
}
function parseInteger(string) {
  if (isUndefined$1(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseInt(string, 10);
  }
}
function parseFloating(string) {
  if (isUndefined$1(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseFloat(string);
  }
}
function parseMillis(fraction) {
  if (isUndefined$1(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f);
  }
}
function roundTo(number, digits, towardZero = false) {
  const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number * factor) / factor;
}
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
  }
  return +d;
}
function weeksInWeekYear(weekYear) {
  const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
  return p1 === 4 || p2 === 3 ? 53 : 52;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
}
function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date = new Date(ts), intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = { timeZoneName: offsetFormat, ...intlOpts };
  const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m) => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value2) {
  const numericValue = Number(value2);
  if (typeof value2 === "boolean" || value2 === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value2}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty(obj, u)) {
      const v2 = obj[u];
      if (v2 === void 0 || v2 === null) continue;
      normalized[normalizer(u)] = asNumber(v2);
    }
  }
  return normalized;
}
function formatOffset(offset2, format2) {
  const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
  switch (format2) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format2} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}
const monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
const monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
const monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length2) {
  switch (length2) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
];
const weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
const weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length2) {
  switch (length2) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const meridiems = ["AM", "PM"];
const erasLong = ["Before Christ", "Anno Domini"];
const erasShort = ["BC", "AD"];
const erasNarrow = ["B", "A"];
function eras(length2) {
  switch (length2) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length2) {
  return weekdays(length2)[dt.weekday - 1];
}
function monthForDateTime(dt, length2) {
  return months(length2)[dt.month - 1];
}
function eraForDateTime(dt, length2) {
  return eras(length2)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
    }
  }
  const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}
function stringifyTokens(splits, tokenToString) {
  let s2 = "";
  for (const token of splits) {
    if (token.literal) {
      s2 += token.val;
    } else {
      s2 += tokenToString(token.val);
    }
  }
  return s2;
}
const macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
class Formatter {
  static create(locale, opts = {}) {
    return new Formatter(locale, opts);
  }
  static parseFormat(fmt) {
    let current = null, currentFull = "", bracketed = false;
    const splits = [];
    for (let i = 0; i < fmt.length; i++) {
      const c = fmt.charAt(i);
      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
        }
        currentFull = c;
        current = c;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }
  dtFormatter(dt, opts = {}) {
    return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
  }
  formatDateTime(dt, opts) {
    return this.dtFormatter(dt, opts).format();
  }
  formatDateTimeParts(dt, opts) {
    return this.dtFormatter(dt, opts).formatToParts();
  }
  formatInterval(interval, opts) {
    const df = this.dtFormatter(interval.start, opts);
    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
  }
  resolvedOptions(dt, opts) {
    return this.dtFormatter(dt, opts).resolvedOptions();
  }
  num(n2, p2 = 0) {
    if (this.opts.forceSimple) {
      return padStart(n2, p2);
    }
    const opts = { ...this.opts };
    if (p2 > 0) {
      opts.padTo = p2;
    }
    return this.loc.numberFormatter(opts).format(n2);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }
      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length2, standalone) => knownEnglish ? monthForDateTime(dt, length2) : string(standalone ? { month: length2 } : { month: length2, day: "numeric" }, "month"), weekday = (length2, standalone) => knownEnglish ? weekdayForDateTime(dt, length2) : string(
      standalone ? { weekday: length2 } : { weekday: length2, month: "long", day: "numeric" },
      "weekday"
    ), maybeMacro = (token) => {
      const formatOpts = Formatter.macroTokenToFormatOpts(token);
      if (formatOpts) {
        return this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token;
      }
    }, era = (length2) => knownEnglish ? eraForDateTime(dt, length2) : string({ era: length2 }, "era"), tokenToString = (token) => {
      switch (token) {
        case "S":
          return this.num(dt.millisecond);
        case "u":
        case "SSS":
          return this.num(dt.millisecond, 3);
        case "s":
          return this.num(dt.second);
        case "ss":
          return this.num(dt.second, 2);
        case "uu":
          return this.num(Math.floor(dt.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(dt.millisecond / 100));
        case "m":
          return this.num(dt.minute);
        case "mm":
          return this.num(dt.minute, 2);
        case "h":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
        case "hh":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
        case "H":
          return this.num(dt.hour);
        case "HH":
          return this.num(dt.hour, 2);
        case "Z":
          return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return dt.zoneName;
        case "a":
          return meridiem();
        case "d":
          return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
        case "dd":
          return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
        case "c":
          return this.num(dt.weekday);
        case "ccc":
          return weekday("short", true);
        case "cccc":
          return weekday("long", true);
        case "ccccc":
          return weekday("narrow", true);
        case "E":
          return this.num(dt.weekday);
        case "EEE":
          return weekday("short", false);
        case "EEEE":
          return weekday("long", false);
        case "EEEEE":
          return weekday("narrow", false);
        case "L":
          return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
        case "LL":
          return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
        case "LLL":
          return month("short", true);
        case "LLLL":
          return month("long", true);
        case "LLLLL":
          return month("narrow", true);
        case "M":
          return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
        case "MM":
          return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
        case "MMM":
          return month("short", false);
        case "MMMM":
          return month("long", false);
        case "MMMMM":
          return month("narrow", false);
        case "y":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
        case "yy":
          return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
        case "yyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
        case "yyyyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
        case "G":
          return era("short");
        case "GG":
          return era("long");
        case "GGGGG":
          return era("narrow");
        case "kk":
          return this.num(dt.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(dt.weekYear, 4);
        case "W":
          return this.num(dt.weekNumber);
        case "WW":
          return this.num(dt.weekNumber, 2);
        case "o":
          return this.num(dt.ordinal);
        case "ooo":
          return this.num(dt.ordinal, 3);
        case "q":
          return this.num(dt.quarter);
        case "qq":
          return this.num(dt.quarter, 2);
        case "X":
          return this.num(Math.floor(dt.ts / 1e3));
        case "x":
          return this.num(dt.ts);
        default:
          return maybeMacro(token);
      }
    };
    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) => {
      switch (token[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, tokenToString = (lildur) => (token) => {
      const mapped = tokenToField(token);
      if (mapped) {
        return this.num(lildur.get(mapped), token.length);
      } else {
        return token;
      }
    }, tokens2 = Formatter.parseFormat(fmt), realTokens = tokens2.reduce(
      (found, { literal, val }) => literal ? found : found.concat(val),
      []
    ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t2) => t2));
    return stringifyTokens(tokens2, tokenToString(collapsed));
  }
}
class Invalid {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
}
const ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function combineRegexes(...regexes2) {
  const full = regexes2.reduce((f, r) => f + r.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return (m) => extractors.reduce(
    ([mergedVals, mergedZone, cursor], ex) => {
      const [val, zone, next] = ex(m, cursor);
      return [{ ...mergedVals, ...val }, zone || mergedZone, next];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function parse$2(s2, ...patterns) {
  if (s2 == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m = regex.exec(s2);
    if (m) {
      return extractor(m);
    }
  }
  return [null, null];
}
function simpleParse(...keys) {
  return (match2, cursor) => {
    const ret = {};
    let i;
    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = parseInteger(match2[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
}
const offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
const isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
const isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
const isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
const isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
const isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
const isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
const isoOrdinalRegex = /(\d{4})-?(\d{3})/;
const extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
const extractISOOrdinalData = simpleParse("year", "ordinal");
const sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
const sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
);
const sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match2, pos, fallback) {
  const m = match2[pos];
  return isUndefined$1(m) ? fallback : parseInteger(m);
}
function extractISOYmd(match2, cursor) {
  const item2 = {
    year: int(match2, cursor),
    month: int(match2, cursor + 1, 1),
    day: int(match2, cursor + 2, 1)
  };
  return [item2, null, cursor + 3];
}
function extractISOTime(match2, cursor) {
  const item2 = {
    hours: int(match2, cursor, 0),
    minutes: int(match2, cursor + 1, 0),
    seconds: int(match2, cursor + 2, 0),
    milliseconds: parseMillis(match2[cursor + 3])
  };
  return [item2, null, cursor + 4];
}
function extractISOOffset(match2, cursor) {
  const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match2, cursor) {
  const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
  return [{}, zone, cursor + 1];
}
const isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
const isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match2) {
  const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
  const hasNegativePrefix = s2[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }
  ];
}
const obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr) result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}
const rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match2) {
  const [
    ,
    weekdayStr,
    dayStr,
    monthStr,
    yearStr,
    hourStr,
    minuteStr,
    secondStr,
    obsOffset,
    milOffset,
    offHourStr,
    offMinuteStr
  ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset2;
  if (obsOffset) {
    offset2 = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset2 = 0;
  } else {
    offset2 = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset2)];
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match2) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match2) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
const isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
const isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
const isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
const isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
const extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseISODate(s2) {
  return parse$2(
    s2,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}
function parseRFC2822Date(s2) {
  return parse$2(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s2) {
  return parse$2(
    s2,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii, extractASCII]
  );
}
function parseISODuration(s2) {
  return parse$2(s2, [isoDuration, extractISODuration]);
}
const extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s2) {
  return parse$2(s2, [isoTimeOnly, extractISOTimeOnly]);
}
const sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
const sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
const extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseSQL(s2) {
  return parse$2(
    s2,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}
const INVALID$2 = "Invalid Duration";
const lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, casualMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
}, daysInYearAccurate = 146097 / 400, daysInMonthAccurate = 146097 / 4800, accurateMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
const orderedUnits$1 = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
const reverseUnits = orderedUnits$1.slice(0).reverse();
function clone$1(dur, alts, clear = false) {
  const conf = {
    values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration(conf);
}
function durationToMillis(matrix, vals) {
  let sum = vals.milliseconds ?? 0;
  for (const unit of reverseUnits.slice(1)) {
    if (vals[unit]) {
      sum += vals[unit] * matrix[unit]["milliseconds"];
    }
  }
  return sum;
}
function normalizeValues(matrix, vals) {
  const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
  orderedUnits$1.reduceRight((previous, current) => {
    if (!isUndefined$1(vals[current])) {
      if (previous) {
        const previousVal = vals[previous] * factor;
        const conv = matrix[current][previous];
        const rollUp = Math.floor(previousVal / conv);
        vals[current] += rollUp * factor;
        vals[previous] -= rollUp * conv * factor;
      }
      return current;
    } else {
      return previous;
    }
  }, null);
  orderedUnits$1.reduce((previous, current) => {
    if (!isUndefined$1(vals[current])) {
      if (previous) {
        const fraction = vals[previous] % 1;
        vals[previous] -= fraction;
        vals[current] += fraction * matrix[previous][current];
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}
function removeZeroes(vals) {
  const newVals = {};
  for (const [key, value2] of Object.entries(vals)) {
    if (value2 !== 0) {
      newVals[key] = value2;
    }
  }
  return newVals;
}
class Duration {
  /**
   * @private
   */
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config.matrix) {
      matrix = config.matrix;
    }
    this.values = config.values;
    this.loc = config.loc || Locale.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config.invalid || null;
    this.matrix = matrix;
    this.isLuxonDuration = true;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count, opts) {
    return Duration.fromObject({ milliseconds: count }, opts);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
      );
    }
    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber$2(durationLike)) {
      return Duration.fromMillis(durationLike);
    } else if (Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(
        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
      );
    }
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text2, opts) {
    const [parsed] = parseISODuration(text2);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text2, opts) {
    const [parsed] = parseISOTimeOnly(text2);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({ invalid });
    }
  }
  /**
   * @private
   */
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized) throw new InvalidUnitError(unit);
    return normalized;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o) {
    return o && o.isLuxonDuration || false;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false
    };
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
   * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(opts = {}) {
    if (!this.isValid) return INVALID$2;
    const l2 = orderedUnits$1.map((unit) => {
      const val = this.values[unit];
      if (isUndefined$1(val)) {
        return null;
      }
      return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
    }).filter((n2) => n2);
    return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l2);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid) return {};
    return { ...this.values };
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid) return null;
    let s2 = "P";
    if (this.years !== 0) s2 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0) s2 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0) s2 += this.weeks + "W";
    if (this.days !== 0) s2 += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s2 += "T";
    if (this.hours !== 0) s2 += this.hours + "H";
    if (this.minutes !== 0) s2 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (s2 === "P") s2 += "T0S";
    return s2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid) return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5) return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts,
      includeOffset: false
    };
    const dateTime = DateTime.fromMillis(millis, { zone: "UTC" });
    return dateTime.toISOTime(opts);
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    if (!this.isValid) return NaN;
    return durationToMillis(this.matrix, this.values);
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration2) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration2), result = {};
    for (const k of orderedUnits$1) {
      if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }
    return clone$1(this, { values: result }, true);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration2) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration2);
    return this.plus(dur.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn2) {
    if (!this.isValid) return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = asNumber(fn2(this.values[k], k));
    }
    return clone$1(this, { values: result }, true);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit) {
    return this[Duration.normalizeUnit(unit)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values) {
    if (!this.isValid) return this;
    const mixed = { ...this.values, ...normalizeObject(values, Duration.normalizeUnit) };
    return clone$1(this, { values: mixed });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return clone$1(this, opts);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see second example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid) return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone$1(this, { values: vals }, true);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid) return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone$1(this, { values: vals }, true);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid) return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u) => Duration.normalizeUnit(u));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    for (const k of orderedUnits$1) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own = 0;
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }
        if (isNumber$2(vals[k])) {
          own += vals[k];
        }
        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
      } else if (isNumber$2(vals[k])) {
        accumulated[k] = vals[k];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    normalizeValues(this.matrix, built);
    return clone$1(this, { values: built }, true);
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    if (!this.isValid) return this;
    return this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    );
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid) return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone$1(this, { values: negated }, true);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq(v1, v2) {
      if (v1 === void 0 || v1 === 0) return v2 === void 0 || v2 === 0;
      return v1 === v2;
    }
    for (const u of orderedUnits$1) {
      if (!eq(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
}
const INVALID$1 = "Invalid Interval";
function validateStartEnd(start2, end2) {
  if (!start2 || !start2.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end2 || !end2.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end2 < start2) {
    return Interval.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${start2.toISO()} and end=${end2.toISO()}`
    );
  } else {
    return null;
  }
}
class Interval {
  /**
   * @private
   */
  constructor(config) {
    this.s = config.start;
    this.e = config.end;
    this.invalid = config.invalid || null;
    this.isLuxonInterval = true;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({ invalid });
    }
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start2, end2) {
    const builtStart = friendlyDateTime(start2), builtEnd = friendlyDateTime(end2);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start2, duration2) {
    const dur = Duration.fromDurationLike(duration2), dt = friendlyDateTime(start2);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end2, duration2) {
    const dur = Duration.fromDurationLike(duration2), dt = friendlyDateTime(end2);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text2, opts) {
    const [s2, e2] = (text2 || "").split("/", 2);
    if (s2 && e2) {
      let start2, startIsValid;
      try {
        start2 = DateTime.fromISO(s2, opts);
        startIsValid = start2.isValid;
      } catch (e3) {
        startIsValid = false;
      }
      let end2, endIsValid;
      try {
        end2 = DateTime.fromISO(e2, opts);
        endIsValid = end2.isValid;
      } catch (e3) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start2, end2);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e2, opts);
        if (dur.isValid) {
          return Interval.after(start2, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s2, opts);
        if (dur.isValid) {
          return Interval.before(end2, dur);
        }
      }
    }
    return Interval.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o) {
    return o && o.isLuxonInterval || false;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @return {number}
   */
  count(unit = "milliseconds") {
    if (!this.isValid) return NaN;
    const start2 = this.start.startOf(unit), end2 = this.end.startOf(unit);
    return Math.floor(end2.diff(start2, unit).get(unit)) + (end2.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid) return false;
    return this.s > dateTime;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid) return false;
    return this.e <= dateTime;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid) return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start: start2, end: end2 } = {}) {
    if (!this.isValid) return this;
    return Interval.fromDateTimes(start2 || this.s, end2 || this.e);
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...dateTimes) {
    if (!this.isValid) return [];
    const sorted = dateTimes.map(friendlyDateTime).filter((d) => this.contains(d)).sort(), results = [];
    let { s: s2 } = this, i = 0;
    while (s2 < this.e) {
      const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next));
      s2 = next;
      i += 1;
    }
    return results;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration2) {
    const dur = Duration.fromDurationLike(duration2);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s2 } = this, idx = 1, next;
    const results = [];
    while (s2 < this.e) {
      const added = this.start.plus(dur.mapUnits((x2) => x2 * idx));
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next));
      s2 = next;
      idx += 1;
    }
    return results;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid) return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid) return false;
    return +this.e === +other.s;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid) return false;
    return +other.e === +this.s;
  }
  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid) return false;
    return this.s <= other.s && this.e >= other.e;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid) return this;
    const s2 = this.s > other.s ? this.s : other.s, e2 = this.e < other.e ? this.e : other.e;
    if (s2 >= e2) {
      return null;
    } else {
      return Interval.fromDateTimes(s2, e2);
    }
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid) return this;
    const s2 = this.s < other.s ? this.s : other.s, e2 = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s2, e2);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(
      ([sofar, current], item2) => {
        if (!current) {
          return [sofar, item2];
        } else if (current.overlaps(item2) || current.abutsStart(item2)) {
          return [sofar, current.union(item2)];
        } else {
          return [sofar.concat([current]), item2];
        }
      },
      [[], null]
    );
    if (final) {
      found.push(final);
    }
    return found;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start2 = null, currentCount = 0;
    const results = [], ends = intervals.map((i) => [
      { time: i.s, type: "s" },
      { time: i.e, type: "e" }
    ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
    for (const i of arr) {
      currentCount += i.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start2 = i.time;
      } else {
        if (start2 && +start2 !== +i.time) {
          results.push(Interval.fromDateTimes(start2, i.time));
        }
        start2 = null;
      }
    }
    return Interval.merge(results);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...intervals) {
    return Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid) return INVALID$1;
    return `[${this.s.toISO()}  ${this.e.toISO()})`;
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022  11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7  8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 78 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00  8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00  8:00 p
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  '  '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(dateFormat, { separator = "  " } = {}) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
}
class Info {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({ month: 12 });
    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
   * @return {Array}
   */
  static months(length2 = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length2);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(length2 = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length2, true);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
   * @return {Array}
   */
  static weekdays(length2 = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length2);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(length2 = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length2, true);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
   * @return {Array}
   */
  static meridiems({ locale = null } = {}) {
    return Locale.create(locale).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
   * @return {Array}
   */
  static eras(length2 = "short", { locale = null } = {}) {
    return Locale.create(locale, null, "gregory").eras(length2);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * @example Info.features() //=> { relative: false }
   * @return {Object}
   */
  static features() {
    return { relative: hasRelative() };
  }
}
function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a, b) => b.year - a.year],
    ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
    ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
    [
      "weeks",
      (a, b) => {
        const days = dayDiff(a, b);
        return (days - days % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ];
  const results = {};
  const earlier = cursor;
  let lowestOrder, highWater;
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      results[unit] = differ(cursor, later);
      highWater = earlier.plus(results);
      if (highWater > later) {
        results[unit]--;
        cursor = earlier.plus(results);
        if (cursor > later) {
          highWater = cursor;
          results[unit]--;
          cursor = earlier.plus(results);
        }
      } else {
        cursor = highWater;
      }
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
function diff(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter(
    (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
  );
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration2 = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration2);
  } else {
    return duration2;
  }
}
const numberingSystems = {
  arab: "[-]",
  arabext: "[-]",
  bali: "[-]",
  beng: "[-]",
  deva: "[-]",
  fullwide: "[-]",
  gujr: "[-]",
  hanidec: "[|||||||||]",
  khmr: "[-]",
  knda: "[-]",
  laoo: "[-]",
  limb: "[-]",
  mlym: "[-]",
  mong: "[-]",
  mymr: "[-]",
  orya: "[-]",
  tamldec: "[-]",
  telu: "[-]",
  thai: "[-]",
  tibt: "[-]",
  latn: "\\d"
};
const numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
const hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value2 = parseInt(str, 10);
  if (isNaN(value2)) {
    value2 = "";
    for (let i = 0; i < str.length; i++) {
      const code2 = str.charCodeAt(i);
      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value2 += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min2, max2] = numberingSystemsUTF16[key];
          if (code2 >= min2 && code2 <= max2) {
            value2 += code2 - min2;
          }
        }
      }
    }
    return parseInt(value2, 10);
  } else {
    return value2;
  }
}
function digitRegex({ numberingSystem }, append = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
}
const MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = (i) => i) {
  return { regex, deser: ([s2]) => post(parseDigits(s2)) };
}
const NBSP = String.fromCharCode(160);
const spaceOrNBSP = `[ ${NBSP}]`;
const spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s2) {
  return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s2) {
  return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
    };
  }
}
function offset$2(regex, groups) {
  return { regex, deser: ([, h, m]) => signedOffset(h, m), groups };
}
function simple(regex) {
  return { regex, deser: ([s2]) => s2 };
}
function escapeToken(value2) {
  return value2.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token, loc) {
  const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t2) => ({ regex: RegExp(escapeToken(t2.val)), deser: ([s2]) => s2, literal: true }), unitate = (t2) => {
    if (token.literal) {
      return literal(t2);
    }
    switch (t2.val) {
      case "G":
        return oneOf(loc.eras("short"), 0);
      case "GG":
        return oneOf(loc.eras("long"), 0);
      case "y":
        return intUnit(oneToSix);
      case "yy":
        return intUnit(twoToFour, untruncateYear);
      case "yyyy":
        return intUnit(four);
      case "yyyyy":
        return intUnit(fourToSix);
      case "yyyyyy":
        return intUnit(six);
      case "M":
        return intUnit(oneOrTwo);
      case "MM":
        return intUnit(two);
      case "MMM":
        return oneOf(loc.months("short", true), 1);
      case "MMMM":
        return oneOf(loc.months("long", true), 1);
      case "L":
        return intUnit(oneOrTwo);
      case "LL":
        return intUnit(two);
      case "LLL":
        return oneOf(loc.months("short", false), 1);
      case "LLLL":
        return oneOf(loc.months("long", false), 1);
      case "d":
        return intUnit(oneOrTwo);
      case "dd":
        return intUnit(two);
      case "o":
        return intUnit(oneToThree);
      case "ooo":
        return intUnit(three);
      case "HH":
        return intUnit(two);
      case "H":
        return intUnit(oneOrTwo);
      case "hh":
        return intUnit(two);
      case "h":
        return intUnit(oneOrTwo);
      case "mm":
        return intUnit(two);
      case "m":
        return intUnit(oneOrTwo);
      case "q":
        return intUnit(oneOrTwo);
      case "qq":
        return intUnit(two);
      case "s":
        return intUnit(oneOrTwo);
      case "ss":
        return intUnit(two);
      case "S":
        return intUnit(oneToThree);
      case "SSS":
        return intUnit(three);
      case "u":
        return simple(oneToNine);
      case "uu":
        return simple(oneOrTwo);
      case "uuu":
        return intUnit(one);
      case "a":
        return oneOf(loc.meridiems(), 0);
      case "kkkk":
        return intUnit(four);
      case "kk":
        return intUnit(twoToFour, untruncateYear);
      case "W":
        return intUnit(oneOrTwo);
      case "WW":
        return intUnit(two);
      case "E":
      case "c":
        return intUnit(one);
      case "EEE":
        return oneOf(loc.weekdays("short", false), 1);
      case "EEEE":
        return oneOf(loc.weekdays("long", false), 1);
      case "ccc":
        return oneOf(loc.weekdays("short", true), 1);
      case "cccc":
        return oneOf(loc.weekdays("long", true), 1);
      case "Z":
      case "ZZ":
        return offset$2(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
      case "ZZZ":
        return offset$2(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      case " ":
        return simple(/[^\S\n\r]/);
      default:
        return literal(t2);
    }
  };
  const unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
}
const partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(part, formatOpts, resolvedOpts) {
  const { type, value: value2 } = part;
  if (type === "literal") {
    const isSpace = /^\s+$/.test(value2);
    return {
      literal: !isSpace,
      val: isSpace ? " " : value2
    };
  }
  const style2 = formatOpts[type];
  let actualType = type;
  if (type === "hour") {
    if (formatOpts.hour12 != null) {
      actualType = formatOpts.hour12 ? "hour12" : "hour24";
    } else if (formatOpts.hourCycle != null) {
      if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
        actualType = "hour12";
      } else {
        actualType = "hour24";
      }
    } else {
      actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
    }
  }
  let val = partTypeStyleToTokenVal[actualType];
  if (typeof val === "object") {
    val = val[style2];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return void 0;
}
function buildRegex(units) {
  const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
  return [`^${re}$`, units];
}
function match(input, regex, handlers) {
  const matches = input.match(regex);
  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (hasOwnProperty(handlers, i)) {
        const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined$1(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined$1(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined$1(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined$1(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined$1(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }
    return r;
  }, {});
  return [vals, zone, specificOffset];
}
let dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens2 = formatOptsToTokens(formatOpts, locale);
  if (tokens2 == null || tokens2.includes(void 0)) {
    return token;
  }
  return tokens2;
}
function expandMacroTokens(tokens2, locale) {
  return Array.prototype.concat(...tokens2.map((t2) => maybeExpandMacroToken(t2, locale)));
}
function explainFromTokens(locale, input, format2) {
  const tokens2 = expandMacroTokens(Formatter.parseFormat(format2), locale), units = tokens2.map((t2) => unitForToken(t2, locale)), disqualifyingUnit = units.find((t2) => t2.invalidReason);
  if (disqualifyingUnit) {
    return { input, tokens: tokens2, invalidReason: disqualifyingUnit.invalidReason };
  } else {
    const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match(input, regex, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
    if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
      throw new ConflictingSpecificationError(
        "Can't include meridiem when specifying 24-hour format"
      );
    }
    return { input, tokens: tokens2, regex, rawMatches, matches, result, zone, specificOffset };
  }
}
function parseFromTokens(locale, input, format2) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format2);
  return [result, zone, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }
  const formatter = Formatter.create(locale, formatOpts);
  const df = formatter.dtFormatter(getDummyDateTime());
  const parts = df.formatToParts();
  const resolvedOpts = df.resolvedOptions();
  return parts.map((p2) => tokenForPart(p2, formatOpts, resolvedOpts));
}
const nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit, value2) {
  return new Invalid(
    "unit out of range",
    `you specified ${value2} (of type ${typeof value2}) as a ${unit}, which is invalid`
  );
}
function dayOfWeek(year, month, day) {
  const d = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  const js = d.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal) {
  const table3 = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table3.findIndex((i) => i < ordinal), day = ordinal - table3[month0];
  return { month: month0 + 1, day };
}
function gregorianToWeek(gregObj) {
  const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
  let weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear);
  } else if (weekNumber > weeksInWeekYear(year)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
}
function weekToGregorian(weekData) {
  const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(weekData) };
}
function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return { year, ordinal, ...timeObject(gregData) };
}
function ordinalToGregorian(ordinalData) {
  const { year, ordinal } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(ordinalData) };
}
function hasInvalidWeekData(obj) {
  const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.week);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else return false;
}
function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else return false;
}
const INVALID = "Invalid DateTime";
const MAX_DATE = 864e13;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}
function clone$2(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime({ ...current, ...alts, old: current });
}
function fixOffset(localTS, o, tz) {
  let utcGuess = localTS - o * 60 * 1e3;
  const o2 = tz.offset(utcGuess);
  if (o === o2) {
    return [utcGuess, o];
  }
  utcGuess -= (o2 - o) * 60 * 1e3;
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }
  return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
}
function tsToObj(ts, offset2) {
  ts += offset2 * 60 * 1e3;
  const d = new Date(ts);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
}
function objToTS(obj, offset2, zone) {
  return fixOffset(objToLocalTS(obj), offset2, zone);
}
function adjustTime(inst, dur) {
  const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = {
    ...inst.c,
    year,
    month,
    day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }, millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"), localTS = objToLocalTS(c);
  let [ts, o] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    o = inst.zone.offset(ts);
  }
  return { ts, o };
}
function parseDataToDateTime(parsed, parsedZone, opts, format2, text2, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
    const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
      ...opts,
      zone: interpretationZone,
      specificOffset
    });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(
      new Invalid("unparsable", `the input "${text2}" can't be parsed as ${format2}`)
    );
  }
}
function toTechFormat(dt, format2, allowZ = true) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format2) : null;
}
function toISODate(o, extended) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c = "";
  if (longFormat && o.c.year >= 0) c += "+";
  c += padStart(o.c.year, longFormat ? 6 : 4);
  if (extended) {
    c += "-";
    c += padStart(o.c.month);
    c += "-";
    c += padStart(o.c.day);
  } else {
    c += padStart(o.c.month);
    c += padStart(o.c.day);
  }
  return c;
}
function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c = padStart(o.c.hour);
  if (extended) {
    c += ":";
    c += padStart(o.c.minute);
    if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
      c += ":";
    }
  } else {
    c += padStart(o.c.minute);
  }
  if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
    c += padStart(o.c.second);
    if (o.c.millisecond !== 0 || !suppressMilliseconds) {
      c += ".";
      c += padStart(o.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
      c += "Z";
    } else if (o.o < 0) {
      c += "-";
      c += padStart(Math.trunc(-o.o / 60));
      c += ":";
      c += padStart(Math.trunc(-o.o % 60));
    } else {
      c += "+";
      c += padStart(Math.trunc(o.o / 60));
      c += ":";
      c += padStart(Math.trunc(o.o % 60));
    }
  }
  if (extendedZone) {
    c += "[" + o.zone.ianaName + "]";
  }
  return c;
}
const defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
const orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"], orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized) throw new InvalidUnitError(unit);
  return normalized;
}
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
  let ts, o;
  if (!isUndefined$1(obj.year)) {
    for (const u of orderedUnits) {
      if (isUndefined$1(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = zone.offset(tsNow);
    [ts, o] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = tsNow;
  }
  return new DateTime({ ts, zone, loc, o });
}
function diffRelative(start2, end2, opts) {
  const round2 = isUndefined$1(opts.round) ? true : opts.round, format2 = (c, unit) => {
    c = roundTo(c, round2 || opts.calendary ? 0 : 2, true);
    const formatter = end2.loc.clone(opts).relFormatter(opts);
    return formatter.format(c, unit);
  }, differ = (unit) => {
    if (opts.calendary) {
      if (!end2.hasSame(start2, unit)) {
        return end2.startOf(unit).diff(start2.startOf(unit), unit).get(unit);
      } else return 0;
    } else {
      return end2.diff(start2, unit).get(unit);
    }
  };
  if (opts.unit) {
    return format2(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format2(count, unit);
    }
  }
  return format2(start2 > end2 ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {}, args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}
class DateTime {
  /**
   * @access private
   */
  constructor(config) {
    const zone = config.zone || Settings.defaultZone;
    let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    this.ts = isUndefined$1(config.ts) ? Settings.now() : config.ts;
    let c = null, o = null;
    if (!invalid) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
      if (unchanged) {
        [c, o] = [config.old.c, config.old.o];
      } else {
        const ot = zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }
    this._zone = zone;
    this.loc = config.loc || Locale.create();
    this.invalid = invalid;
    this.weekData = null;
    this.c = c;
    this.o = o;
    this.isLuxonDateTime = true;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new DateTime({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date, options2 = {}) {
    const ts = isDate(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options2.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new DateTime({
      ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options2)
    });
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds, options2 = {}) {
    if (!isNumber$2(milliseconds)) {
      throw new InvalidArgumentError(
        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
      );
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options2.zone, Settings.defaultZone),
        loc: Locale.fromObject(options2)
      });
    }
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds, options2 = {}) {
    if (!isNumber$2(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1e3,
        zone: normalizeZone(options2.zone, Settings.defaultZone),
        loc: Locale.fromObject(options2)
      });
    }
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @return {DateTime}
   */
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const tsNow = Settings.now(), offsetProvis = !isUndefined$1(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined$1(normalized.ordinal), containsGregorYear = !isUndefined$1(normalized.year), containsGregorMD = !isUndefined$1(normalized.month) || !isUndefined$1(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
    let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u of units) {
      const v2 = normalized[u];
      if (!isUndefined$1(v2)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
      );
    }
    return inst;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text2, opts = {}) {
    const [vals, parsedZone] = parseISODate(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text2);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text2, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text2);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text2, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text2, fmt, opts = {}) {
    if (isUndefined$1(text2) || isUndefined$1(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text2, fmt);
    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text2, specificOffset);
    }
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text2, fmt, opts = {}) {
    return DateTime.fromFormat(text2, fmt, opts);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text2, opts = {}) {
    const [vals, parsedZone] = parseSQL(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text2);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({ invalid });
    }
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o) {
    return o && o.isLuxonDateTime || false;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t2) => t2 ? t2.val : null).join("");
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
    return expanded.map((t2) => t2.val).join("");
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit) {
    return this[unit];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed) {
      return [this];
    }
    const dayMs = 864e5;
    const minuteMs = 6e4;
    const localTS = objToLocalTS(this.c);
    const oEarlier = this.zone.offset(localTS - dayMs);
    const oLater = this.zone.offset(localTS + dayMs);
    const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
    const o2 = this.zone.offset(localTS - oLater * minuteMs);
    if (o1 === o2) {
      return [this];
    }
    const ts1 = localTS - o1 * minuteMs;
    const ts2 = localTS - o2 * minuteMs;
    const c1 = tsToObj(ts1, o1);
    const c2 = tsToObj(ts2, o2);
    if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) {
      return [clone$2(this, { ts: ts1 }), clone$2(this, { ts: ts2 })];
    }
    return [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(opts = {}) {
    const { locale, numberingSystem, calendar } = Formatter.create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
    return { locale, numberingSystem, outputCalendar: calendar };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(offset2 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset2), opts);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone$2(this, { ts: newTS, zone });
    }
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
    return clone$2(this, { loc });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale) {
    return this.reconfigure({ locale });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values) {
    if (!this.isValid) return this;
    const normalized = normalizeObject(values, normalizeUnit), settingWeekStuff = !isUndefined$1(normalized.weekYear) || !isUndefined$1(normalized.weekNumber) || !isUndefined$1(normalized.weekday), containsOrdinal = !isUndefined$1(normalized.ordinal), containsGregorYear = !isUndefined$1(normalized.year), containsGregorMD = !isUndefined$1(normalized.month) || !isUndefined$1(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian({ ...gregorianToWeek(this.c), ...normalized });
    } else if (!isUndefined$1(normalized.ordinal)) {
      mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
    } else {
      mixed = { ...this.toObject(), ...normalized };
      if (isUndefined$1(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return clone$2(this, { ts, o });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration2) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration2);
    return clone$2(this, adjustTime(this, dur));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration2) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration2).negate();
    return clone$2(this, adjustTime(this, dur));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit) {
    if (!this.isValid) return this;
    const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      case "quarters":
      case "months":
        o.day = 1;
      case "weeks":
      case "days":
        o.hour = 0;
      case "hours":
        o.minute = 0;
      case "minutes":
        o.second = 0;
      case "seconds":
        o.millisecond = 0;
        break;
    }
    if (normalizedUnit === "weeks") {
      o.weekday = 1;
    }
    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }
    return this.set(o);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit) {
    return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format: format2 = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format2 === "extended";
    let c = toISODate(this, ext);
    c += "T";
    c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format: format2 = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format2 === "extended");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format: format2 = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c = includePrefix ? "T" : "";
    return c + toISOTime(
      this,
      format2 === "extended",
      suppressSeconds,
      suppressMilliseconds,
      includeOffset,
      extendedZone
    );
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID;
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(opts = {}) {
    if (!this.isValid) return {};
    const base2 = { ...this.c };
    if (opts.includeConfig) {
      base2.outputCalendar = this.outputCalendar;
      base2.numberingSystem = this.loc.numberingSystem;
      base2.locale = this.loc.locale;
    }
    return base2;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
    const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(DateTime.now(), unit, opts);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit) {
    if (!this.isValid) return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(options2 = {}) {
    if (!this.isValid) return null;
    const base2 = options2.base || DateTime.fromObject({}, { zone: this.zone }), padding = options2.padding ? this < base2 ? -options2.padding : options2.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options2.unit;
    if (Array.isArray(options2.unit)) {
      units = options2.unit;
      unit = void 0;
    }
    return diffRelative(base2, this.plus(padding), {
      ...options2,
      numeric: "always",
      units,
      unit
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(options2 = {}) {
    if (!this.isValid) return null;
    return diffRelative(options2.base || DateTime.fromObject({}, { zone: this.zone }), this, {
      ...options2,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    });
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text2, fmt, options2 = {}) {
    const { locale = null, numberingSystem = null } = options2, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text2, fmt);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text2, fmt, options2 = {}) {
    return DateTime.fromFormatExplain(text2, fmt, options2);
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
}
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber$2(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(
      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
    );
  }
}
const DEFAULT_QUERY_SETTINGS = {
  renderNullAs: "\\-",
  taskCompletionTracking: false,
  taskCompletionUseEmojiShorthand: false,
  taskCompletionText: "completion",
  taskCompletionDateFormat: "yyyy-MM-dd",
  recursiveSubTaskCompletion: false,
  warnOnEmptyResult: true,
  refreshEnabled: true,
  refreshInterval: 2500,
  defaultDateFormat: "MMMM dd, yyyy",
  defaultDateTimeFormat: "h:mm a - MMMM dd, yyyy",
  maxRecursiveRenderDepth: 4,
  tableIdColumnName: "File",
  tableGroupColumnName: "Group",
  showResultCount: true
};
const DEFAULT_EXPORT_SETTINGS = {
  allowHtml: true
};
({
  ...DEFAULT_QUERY_SETTINGS,
  ...DEFAULT_EXPORT_SETTINGS,
  ...{
    inlineQueryPrefix: "=",
    inlineJsQueryPrefix: "$=",
    inlineQueriesInCodeblocks: true,
    enableInlineDataview: true,
    enableDataviewJs: false,
    enableInlineDataviewJs: false,
    prettyRenderInlineFields: true,
    prettyRenderInlineFieldsInLivePreview: true,
    dataviewJsKeyword: "dataviewjs"
  }
});
class Success {
  constructor(value2) {
    __publicField(this, "value");
    __publicField(this, "successful");
    this.value = value2;
    this.successful = true;
  }
  map(f) {
    return new Success(f(this.value));
  }
  flatMap(f) {
    return f(this.value);
  }
  mapErr(f) {
    return this;
  }
  bimap(succ, _fail) {
    return this.map(succ);
  }
  orElse(_value) {
    return this.value;
  }
  cast() {
    return this;
  }
  orElseThrow(_message) {
    return this.value;
  }
}
class Failure {
  constructor(error2) {
    __publicField(this, "error");
    __publicField(this, "successful");
    this.error = error2;
    this.successful = false;
  }
  map(_f2) {
    return this;
  }
  flatMap(_f2) {
    return this;
  }
  mapErr(f) {
    return new Failure(f(this.error));
  }
  bimap(_succ, fail) {
    return this.mapErr(fail);
  }
  orElse(value2) {
    return value2;
  }
  cast() {
    return this;
  }
  orElseThrow(message) {
    if (message)
      throw new Error(message(this.error));
    else
      throw new Error("" + this.error);
  }
}
var Result;
(function(Result2) {
  function success(value2) {
    return new Success(value2);
  }
  Result2.success = success;
  function failure(error2) {
    return new Failure(error2);
  }
  Result2.failure = failure;
  function flatMap2(first, second, f) {
    if (first.successful) {
      if (second.successful)
        return f(first.value, second.value);
      else
        return failure(second.error);
    } else {
      return failure(first.error);
    }
  }
  Result2.flatMap2 = flatMap2;
  function map2(first, second, f) {
    return flatMap2(first, second, (a, b) => success(f(a, b)));
  }
  Result2.map2 = map2;
})(Result || (Result = {}));
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof commonjsGlobal$1 !== "undefined" ? commonjsGlobal$1 : typeof self !== "undefined" ? self : {};
var parsimmon_umd_min = { exports: {} };
(function(module, exports) {
  !function(n2, t2) {
    module.exports = t2();
  }("undefined" != typeof self ? self : commonjsGlobal, function() {
    return function(n2) {
      var t2 = {};
      function r(e2) {
        if (t2[e2]) return t2[e2].exports;
        var u = t2[e2] = { i: e2, l: false, exports: {} };
        return n2[e2].call(u.exports, u, u.exports, r), u.l = true, u.exports;
      }
      return r.m = n2, r.c = t2, r.d = function(n3, t3, e2) {
        r.o(n3, t3) || Object.defineProperty(n3, t3, { configurable: false, enumerable: true, get: e2 });
      }, r.r = function(n3) {
        Object.defineProperty(n3, "__esModule", { value: true });
      }, r.n = function(n3) {
        var t3 = n3 && n3.__esModule ? function() {
          return n3.default;
        } : function() {
          return n3;
        };
        return r.d(t3, "a", t3), t3;
      }, r.o = function(n3, t3) {
        return Object.prototype.hasOwnProperty.call(n3, t3);
      }, r.p = "", r(r.s = 0);
    }([function(n2, t2, r) {
      function e2(n3) {
        if (!(this instanceof e2)) return new e2(n3);
        this._ = n3;
      }
      var u = e2.prototype;
      function o(n3, t3) {
        for (var r2 = 0; r2 < n3; r2++) t3(r2);
      }
      function i(n3, t3, r2) {
        return function(n4, t4) {
          o(t4.length, function(r3) {
            n4(t4[r3], r3, t4);
          });
        }(function(r3, e3, u2) {
          t3 = n3(t3, r3, e3, u2);
        }, r2), t3;
      }
      function a(n3, t3) {
        return i(function(t4, r2, e3, u2) {
          return t4.concat([n3(r2, e3, u2)]);
        }, [], t3);
      }
      function f(n3, t3) {
        var r2 = { v: 0, buf: t3 };
        return o(n3, function() {
          var n4;
          r2 = { v: r2.v << 1 | (n4 = r2.buf, n4[0] >> 7), buf: function(n5) {
            var t4 = i(function(n6, t5, r3, e3) {
              return n6.concat(r3 === e3.length - 1 ? Buffer.from([t5, 0]).readUInt16BE(0) : e3.readUInt16BE(r3));
            }, [], n5);
            return Buffer.from(a(function(n6) {
              return (n6 << 1 & 65535) >> 8;
            }, t4));
          }(r2.buf) };
        }), r2;
      }
      function c() {
        return "undefined" != typeof Buffer;
      }
      function s2() {
        if (!c()) throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
      }
      function l2(n3) {
        s2();
        var t3 = i(function(n4, t4) {
          return n4 + t4;
        }, 0, n3);
        if (t3 % 8 != 0) throw new Error("The bits [" + n3.join(", ") + "] add up to " + t3 + " which is not an even number of bytes; the total should be divisible by 8");
        var r2, u2 = t3 / 8, o2 = (r2 = function(n4) {
          return n4 > 48;
        }, i(function(n4, t4) {
          return n4 || (r2(t4) ? t4 : n4);
        }, null, n3));
        if (o2) throw new Error(o2 + " bit range requested exceeds 48 bit (6 byte) Number max.");
        return new e2(function(t4, r3) {
          var e3 = u2 + r3;
          return e3 > t4.length ? x2(r3, u2.toString() + " bytes") : b(e3, i(function(n4, t5) {
            var r4 = f(t5, n4.buf);
            return { coll: n4.coll.concat(r4.v), buf: r4.buf };
          }, { coll: [], buf: t4.slice(r3, e3) }, n3).coll);
        });
      }
      function h(n3, t3) {
        return new e2(function(r2, e3) {
          return s2(), e3 + t3 > r2.length ? x2(e3, t3 + " bytes for " + n3) : b(e3 + t3, r2.slice(e3, e3 + t3));
        });
      }
      function p2(n3, t3) {
        if ("number" != typeof (r2 = t3) || Math.floor(r2) !== r2 || t3 < 0 || t3 > 6) throw new Error(n3 + " requires integer length in range [0, 6].");
        var r2;
      }
      function d(n3) {
        return p2("uintBE", n3), h("uintBE(" + n3 + ")", n3).map(function(t3) {
          return t3.readUIntBE(0, n3);
        });
      }
      function v2(n3) {
        return p2("uintLE", n3), h("uintLE(" + n3 + ")", n3).map(function(t3) {
          return t3.readUIntLE(0, n3);
        });
      }
      function g(n3) {
        return p2("intBE", n3), h("intBE(" + n3 + ")", n3).map(function(t3) {
          return t3.readIntBE(0, n3);
        });
      }
      function m(n3) {
        return p2("intLE", n3), h("intLE(" + n3 + ")", n3).map(function(t3) {
          return t3.readIntLE(0, n3);
        });
      }
      function y2(n3) {
        return n3 instanceof e2;
      }
      function E(n3) {
        return "[object Array]" === {}.toString.call(n3);
      }
      function w(n3) {
        return c() && Buffer.isBuffer(n3);
      }
      function b(n3, t3) {
        return { status: true, index: n3, value: t3, furthest: -1, expected: [] };
      }
      function x2(n3, t3) {
        return E(t3) || (t3 = [t3]), { status: false, index: -1, value: null, furthest: n3, expected: t3 };
      }
      function B(n3, t3) {
        if (!t3) return n3;
        if (n3.furthest > t3.furthest) return n3;
        var r2 = n3.furthest === t3.furthest ? function(n4, t4) {
          if (function() {
            if (void 0 !== e2._supportsSet) return e2._supportsSet;
            var n5 = "undefined" != typeof Set;
            return e2._supportsSet = n5, n5;
          }() && Array.from) {
            for (var r3 = new Set(n4), u2 = 0; u2 < t4.length; u2++) r3.add(t4[u2]);
            var o2 = Array.from(r3);
            return o2.sort(), o2;
          }
          for (var i2 = {}, a2 = 0; a2 < n4.length; a2++) i2[n4[a2]] = true;
          for (var f2 = 0; f2 < t4.length; f2++) i2[t4[f2]] = true;
          var c2 = [];
          for (var s3 in i2) ({}).hasOwnProperty.call(i2, s3) && c2.push(s3);
          return c2.sort(), c2;
        }(n3.expected, t3.expected) : t3.expected;
        return { status: n3.status, index: n3.index, value: n3.value, furthest: t3.furthest, expected: r2 };
      }
      var j = {};
      function S(n3, t3) {
        if (w(n3)) return { offset: t3, line: -1, column: -1 };
        n3 in j || (j[n3] = {});
        for (var r2 = j[n3], e3 = 0, u2 = 0, o2 = 0, i2 = t3; i2 >= 0; ) {
          if (i2 in r2) {
            e3 = r2[i2].line, 0 === o2 && (o2 = r2[i2].lineStart);
            break;
          }
          ("\n" === n3.charAt(i2) || "\r" === n3.charAt(i2) && "\n" !== n3.charAt(i2 + 1)) && (u2++, 0 === o2 && (o2 = i2 + 1)), i2--;
        }
        var a2 = e3 + u2, f2 = t3 - o2;
        return r2[t3] = { line: a2, lineStart: o2 }, { offset: t3, line: a2 + 1, column: f2 + 1 };
      }
      function _(n3) {
        if (!y2(n3)) throw new Error("not a parser: " + n3);
      }
      function L(n3, t3) {
        return "string" == typeof n3 ? n3.charAt(t3) : n3[t3];
      }
      function O(n3) {
        if ("number" != typeof n3) throw new Error("not a number: " + n3);
      }
      function k(n3) {
        if ("function" != typeof n3) throw new Error("not a function: " + n3);
      }
      function P(n3) {
        if ("string" != typeof n3) throw new Error("not a string: " + n3);
      }
      var q = 2, A = 3, I = 8, F = 5 * I, M = 4 * I, z = "  ";
      function R(n3, t3) {
        return new Array(t3 + 1).join(n3);
      }
      function U(n3, t3, r2) {
        var e3 = t3 - n3.length;
        return e3 <= 0 ? n3 : R(r2, e3) + n3;
      }
      function W(n3, t3, r2, e3) {
        return { from: n3 - t3 > 0 ? n3 - t3 : 0, to: n3 + r2 > e3 ? e3 : n3 + r2 };
      }
      function D(n3, t3) {
        var r2, e3, u2, o2, f2, c2 = t3.index, s3 = c2.offset, l3 = 1;
        if (s3 === n3.length) return "Got the end of the input";
        if (w(n3)) {
          var h2 = s3 - s3 % I, p3 = s3 - h2, d2 = W(h2, F, M + I, n3.length), v3 = a(function(n4) {
            return a(function(n5) {
              return U(n5.toString(16), 2, "0");
            }, n4);
          }, function(n4, t4) {
            var r3 = n4.length, e4 = [], u3 = 0;
            if (r3 <= t4) return [n4.slice()];
            for (var o3 = 0; o3 < r3; o3++) e4[u3] || e4.push([]), e4[u3].push(n4[o3]), (o3 + 1) % t4 == 0 && u3++;
            return e4;
          }(n3.slice(d2.from, d2.to).toJSON().data, I));
          o2 = function(n4) {
            return 0 === n4.from && 1 === n4.to ? { from: n4.from, to: n4.to } : { from: n4.from / I, to: Math.floor(n4.to / I) };
          }(d2), e3 = h2 / I, r2 = 3 * p3, p3 >= 4 && (r2 += 1), l3 = 2, u2 = a(function(n4) {
            return n4.length <= 4 ? n4.join(" ") : n4.slice(0, 4).join(" ") + "  " + n4.slice(4).join(" ");
          }, v3), (f2 = (8 * (o2.to > 0 ? o2.to - 1 : o2.to)).toString(16).length) < 2 && (f2 = 2);
        } else {
          var g2 = n3.split(/\r\n|[\n\r\u2028\u2029]/);
          r2 = c2.column - 1, e3 = c2.line - 1, o2 = W(e3, q, A, g2.length), u2 = g2.slice(o2.from, o2.to), f2 = o2.to.toString().length;
        }
        var m2 = e3 - o2.from;
        return w(n3) && (f2 = (8 * (o2.to > 0 ? o2.to - 1 : o2.to)).toString(16).length) < 2 && (f2 = 2), i(function(t4, e4, u3) {
          var i2, a2 = u3 === m2, c3 = a2 ? "> " : z;
          return i2 = w(n3) ? U((8 * (o2.from + u3)).toString(16), f2, "0") : U((o2.from + u3 + 1).toString(), f2, " "), [].concat(t4, [c3 + i2 + " | " + e4], a2 ? [z + R(" ", f2) + " | " + U("", r2, " ") + R("^", l3)] : []);
        }, [], u2).join("\n");
      }
      function N(n3, t3) {
        return ["\n", "-- PARSING FAILED " + R("-", 50), "\n\n", D(n3, t3), "\n\n", (r2 = t3.expected, 1 === r2.length ? "Expected:\n\n" + r2[0] : "Expected one of the following: \n\n" + r2.join(", ")), "\n"].join("");
        var r2;
      }
      function G(n3) {
        return void 0 !== n3.flags ? n3.flags : [n3.global ? "g" : "", n3.ignoreCase ? "i" : "", n3.multiline ? "m" : "", n3.unicode ? "u" : "", n3.sticky ? "y" : ""].join("");
      }
      function C() {
        for (var n3 = [].slice.call(arguments), t3 = n3.length, r2 = 0; r2 < t3; r2 += 1) _(n3[r2]);
        return e2(function(r3, e3) {
          for (var u2, o2 = new Array(t3), i2 = 0; i2 < t3; i2 += 1) {
            if (!(u2 = B(n3[i2]._(r3, e3), u2)).status) return u2;
            o2[i2] = u2.value, e3 = u2.index;
          }
          return B(b(e3, o2), u2);
        });
      }
      function J() {
        var n3 = [].slice.call(arguments);
        if (0 === n3.length) throw new Error("seqMap needs at least one argument");
        var t3 = n3.pop();
        return k(t3), C.apply(null, n3).map(function(n4) {
          return t3.apply(null, n4);
        });
      }
      function T() {
        var n3 = [].slice.call(arguments), t3 = n3.length;
        if (0 === t3) return Y("zero alternates");
        for (var r2 = 0; r2 < t3; r2 += 1) _(n3[r2]);
        return e2(function(t4, r3) {
          for (var e3, u2 = 0; u2 < n3.length; u2 += 1) if ((e3 = B(n3[u2]._(t4, r3), e3)).status) return e3;
          return e3;
        });
      }
      function V(n3, t3) {
        return H(n3, t3).or(X([]));
      }
      function H(n3, t3) {
        return _(n3), _(t3), J(n3, t3.then(n3).many(), function(n4, t4) {
          return [n4].concat(t4);
        });
      }
      function K(n3) {
        P(n3);
        var t3 = "'" + n3 + "'";
        return e2(function(r2, e3) {
          var u2 = e3 + n3.length, o2 = r2.slice(e3, u2);
          return o2 === n3 ? b(u2, o2) : x2(e3, t3);
        });
      }
      function Q(n3, t3) {
        !function(n4) {
          if (!(n4 instanceof RegExp)) throw new Error("not a regexp: " + n4);
          for (var t4 = G(n4), r3 = 0; r3 < t4.length; r3++) {
            var e3 = t4.charAt(r3);
            if ("i" !== e3 && "m" !== e3 && "u" !== e3 && "s" !== e3) throw new Error('unsupported regexp flag "' + e3 + '": ' + n4);
          }
        }(n3), arguments.length >= 2 ? O(t3) : t3 = 0;
        var r2 = function(n4) {
          return RegExp("^(?:" + n4.source + ")", G(n4));
        }(n3), u2 = "" + n3;
        return e2(function(n4, e3) {
          var o2 = r2.exec(n4.slice(e3));
          if (o2) {
            if (0 <= t3 && t3 <= o2.length) {
              var i2 = o2[0], a2 = o2[t3];
              return b(e3 + i2.length, a2);
            }
            return x2(e3, "valid match group (0 to " + o2.length + ") in " + u2);
          }
          return x2(e3, u2);
        });
      }
      function X(n3) {
        return e2(function(t3, r2) {
          return b(r2, n3);
        });
      }
      function Y(n3) {
        return e2(function(t3, r2) {
          return x2(r2, n3);
        });
      }
      function Z(n3) {
        if (y2(n3)) return e2(function(t3, r2) {
          var e3 = n3._(t3, r2);
          return e3.index = r2, e3.value = "", e3;
        });
        if ("string" == typeof n3) return Z(K(n3));
        if (n3 instanceof RegExp) return Z(Q(n3));
        throw new Error("not a string, regexp, or parser: " + n3);
      }
      function $(n3) {
        return _(n3), e2(function(t3, r2) {
          var e3 = n3._(t3, r2), u2 = t3.slice(r2, e3.index);
          return e3.status ? x2(r2, 'not "' + u2 + '"') : b(r2, null);
        });
      }
      function nn(n3) {
        return k(n3), e2(function(t3, r2) {
          var e3 = L(t3, r2);
          return r2 < t3.length && n3(e3) ? b(r2 + 1, e3) : x2(r2, "a character/byte matching " + n3);
        });
      }
      function tn(n3, t3) {
        arguments.length < 2 && (t3 = n3, n3 = void 0);
        var r2 = e2(function(n4, e3) {
          return r2._ = t3()._, r2._(n4, e3);
        });
        return n3 ? r2.desc(n3) : r2;
      }
      function rn() {
        return Y("fantasy-land/empty");
      }
      u.parse = function(n3) {
        if ("string" != typeof n3 && !w(n3)) throw new Error(".parse must be called with a string or Buffer as its argument");
        var t3, r2 = this.skip(an)._(n3, 0);
        return t3 = r2.status ? { status: true, value: r2.value } : { status: false, index: S(n3, r2.furthest), expected: r2.expected }, delete j[n3], t3;
      }, u.tryParse = function(n3) {
        var t3 = this.parse(n3);
        if (t3.status) return t3.value;
        var r2 = N(n3, t3), e3 = new Error(r2);
        throw e3.type = "ParsimmonError", e3.result = t3, e3;
      }, u.assert = function(n3, t3) {
        return this.chain(function(r2) {
          return n3(r2) ? X(r2) : Y(t3);
        });
      }, u.or = function(n3) {
        return T(this, n3);
      }, u.trim = function(n3) {
        return this.wrap(n3, n3);
      }, u.wrap = function(n3, t3) {
        return J(n3, this, t3, function(n4, t4) {
          return t4;
        });
      }, u.thru = function(n3) {
        return n3(this);
      }, u.then = function(n3) {
        return _(n3), C(this, n3).map(function(n4) {
          return n4[1];
        });
      }, u.many = function() {
        var n3 = this;
        return e2(function(t3, r2) {
          for (var e3 = [], u2 = void 0; ; ) {
            if (!(u2 = B(n3._(t3, r2), u2)).status) return B(b(r2, e3), u2);
            if (r2 === u2.index) throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
            r2 = u2.index, e3.push(u2.value);
          }
        });
      }, u.tieWith = function(n3) {
        return P(n3), this.map(function(t3) {
          if (function(n4) {
            if (!E(n4)) throw new Error("not an array: " + n4);
          }(t3), t3.length) {
            P(t3[0]);
            for (var r2 = t3[0], e3 = 1; e3 < t3.length; e3++) P(t3[e3]), r2 += n3 + t3[e3];
            return r2;
          }
          return "";
        });
      }, u.tie = function() {
        return this.tieWith("");
      }, u.times = function(n3, t3) {
        var r2 = this;
        return arguments.length < 2 && (t3 = n3), O(n3), O(t3), e2(function(e3, u2) {
          for (var o2 = [], i2 = void 0, a2 = void 0, f2 = 0; f2 < n3; f2 += 1) {
            if (a2 = B(i2 = r2._(e3, u2), a2), !i2.status) return a2;
            u2 = i2.index, o2.push(i2.value);
          }
          for (; f2 < t3 && (a2 = B(i2 = r2._(e3, u2), a2), i2.status); f2 += 1) u2 = i2.index, o2.push(i2.value);
          return B(b(u2, o2), a2);
        });
      }, u.result = function(n3) {
        return this.map(function() {
          return n3;
        });
      }, u.atMost = function(n3) {
        return this.times(0, n3);
      }, u.atLeast = function(n3) {
        return J(this.times(n3), this.many(), function(n4, t3) {
          return n4.concat(t3);
        });
      }, u.map = function(n3) {
        k(n3);
        var t3 = this;
        return e2(function(r2, e3) {
          var u2 = t3._(r2, e3);
          return u2.status ? B(b(u2.index, n3(u2.value)), u2) : u2;
        });
      }, u.contramap = function(n3) {
        k(n3);
        var t3 = this;
        return e2(function(r2, e3) {
          var u2 = t3.parse(n3(r2.slice(e3)));
          return u2.status ? b(e3 + r2.length, u2.value) : u2;
        });
      }, u.promap = function(n3, t3) {
        return k(n3), k(t3), this.contramap(n3).map(t3);
      }, u.skip = function(n3) {
        return C(this, n3).map(function(n4) {
          return n4[0];
        });
      }, u.mark = function() {
        return J(en, this, en, function(n3, t3, r2) {
          return { start: n3, value: t3, end: r2 };
        });
      }, u.node = function(n3) {
        return J(en, this, en, function(t3, r2, e3) {
          return { name: n3, value: r2, start: t3, end: e3 };
        });
      }, u.sepBy = function(n3) {
        return V(this, n3);
      }, u.sepBy1 = function(n3) {
        return H(this, n3);
      }, u.lookahead = function(n3) {
        return this.skip(Z(n3));
      }, u.notFollowedBy = function(n3) {
        return this.skip($(n3));
      }, u.desc = function(n3) {
        E(n3) || (n3 = [n3]);
        var t3 = this;
        return e2(function(r2, e3) {
          var u2 = t3._(r2, e3);
          return u2.status || (u2.expected = n3), u2;
        });
      }, u.fallback = function(n3) {
        return this.or(X(n3));
      }, u.ap = function(n3) {
        return J(n3, this, function(n4, t3) {
          return n4(t3);
        });
      }, u.chain = function(n3) {
        var t3 = this;
        return e2(function(r2, e3) {
          var u2 = t3._(r2, e3);
          return u2.status ? B(n3(u2.value)._(r2, u2.index), u2) : u2;
        });
      }, u.concat = u.or, u.empty = rn, u.of = X, u["fantasy-land/ap"] = u.ap, u["fantasy-land/chain"] = u.chain, u["fantasy-land/concat"] = u.concat, u["fantasy-land/empty"] = u.empty, u["fantasy-land/of"] = u.of, u["fantasy-land/map"] = u.map;
      var en = e2(function(n3, t3) {
        return b(t3, S(n3, t3));
      }), un = e2(function(n3, t3) {
        return t3 >= n3.length ? x2(t3, "any character/byte") : b(t3 + 1, L(n3, t3));
      }), on = e2(function(n3, t3) {
        return b(n3.length, n3.slice(t3));
      }), an = e2(function(n3, t3) {
        return t3 < n3.length ? x2(t3, "EOF") : b(t3, null);
      }), fn2 = Q(/[0-9]/).desc("a digit"), cn = Q(/[0-9]*/).desc("optional digits"), sn = Q(/[a-z]/i).desc("a letter"), ln = Q(/[a-z]*/i).desc("optional letters"), hn = Q(/\s*/).desc("optional whitespace"), pn = Q(/\s+/).desc("whitespace"), dn = K("\r"), vn = K("\n"), gn = K("\r\n"), mn = T(gn, vn, dn).desc("newline"), yn = T(mn, an);
      e2.all = on, e2.alt = T, e2.any = un, e2.cr = dn, e2.createLanguage = function(n3) {
        var t3 = {};
        for (var r2 in n3) ({}).hasOwnProperty.call(n3, r2) && function(r3) {
          t3[r3] = tn(function() {
            return n3[r3](t3);
          });
        }(r2);
        return t3;
      }, e2.crlf = gn, e2.custom = function(n3) {
        return e2(n3(b, x2));
      }, e2.digit = fn2, e2.digits = cn, e2.empty = rn, e2.end = yn, e2.eof = an, e2.fail = Y, e2.formatError = N, e2.index = en, e2.isParser = y2, e2.lazy = tn, e2.letter = sn, e2.letters = ln, e2.lf = vn, e2.lookahead = Z, e2.makeFailure = x2, e2.makeSuccess = b, e2.newline = mn, e2.noneOf = function(n3) {
        return nn(function(t3) {
          return n3.indexOf(t3) < 0;
        }).desc("none of '" + n3 + "'");
      }, e2.notFollowedBy = $, e2.of = X, e2.oneOf = function(n3) {
        for (var t3 = n3.split(""), r2 = 0; r2 < t3.length; r2++) t3[r2] = "'" + t3[r2] + "'";
        return nn(function(t4) {
          return n3.indexOf(t4) >= 0;
        }).desc(t3);
      }, e2.optWhitespace = hn, e2.Parser = e2, e2.range = function(n3, t3) {
        return nn(function(r2) {
          return n3 <= r2 && r2 <= t3;
        }).desc(n3 + "-" + t3);
      }, e2.regex = Q, e2.regexp = Q, e2.sepBy = V, e2.sepBy1 = H, e2.seq = C, e2.seqMap = J, e2.seqObj = function() {
        for (var n3, t3 = {}, r2 = 0, u2 = (n3 = arguments, Array.prototype.slice.call(n3)), o2 = u2.length, i2 = 0; i2 < o2; i2 += 1) {
          var a2 = u2[i2];
          if (!y2(a2)) {
            if (E(a2) && 2 === a2.length && "string" == typeof a2[0] && y2(a2[1])) {
              var f2 = a2[0];
              if (Object.prototype.hasOwnProperty.call(t3, f2)) throw new Error("seqObj: duplicate key " + f2);
              t3[f2] = true, r2++;
              continue;
            }
            throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
          }
        }
        if (0 === r2) throw new Error("seqObj expects at least one named parser, found zero");
        return e2(function(n4, t4) {
          for (var r3, e3 = {}, i3 = 0; i3 < o2; i3 += 1) {
            var a3, f3;
            if (E(u2[i3]) ? (a3 = u2[i3][0], f3 = u2[i3][1]) : (a3 = null, f3 = u2[i3]), !(r3 = B(f3._(n4, t4), r3)).status) return r3;
            a3 && (e3[a3] = r3.value), t4 = r3.index;
          }
          return B(b(t4, e3), r3);
        });
      }, e2.string = K, e2.succeed = X, e2.takeWhile = function(n3) {
        return k(n3), e2(function(t3, r2) {
          for (var e3 = r2; e3 < t3.length && n3(L(t3, e3)); ) e3++;
          return b(e3, t3.slice(r2, e3));
        });
      }, e2.test = nn, e2.whitespace = pn, e2["fantasy-land/empty"] = rn, e2["fantasy-land/of"] = X, e2.Binary = { bitSeq: l2, bitSeqObj: function(n3) {
        s2();
        var t3 = {}, r2 = 0, e3 = a(function(n4) {
          if (E(n4)) {
            var e4 = n4;
            if (2 !== e4.length) throw new Error("[" + e4.join(", ") + "] should be length 2, got length " + e4.length);
            if (P(e4[0]), O(e4[1]), Object.prototype.hasOwnProperty.call(t3, e4[0])) throw new Error("duplicate key in bitSeqObj: " + e4[0]);
            return t3[e4[0]] = true, r2++, e4;
          }
          return O(n4), [null, n4];
        }, n3);
        if (r2 < 1) throw new Error("bitSeqObj expects at least one named pair, got [" + n3.join(", ") + "]");
        var u2 = a(function(n4) {
          return n4[0];
        }, e3);
        return l2(a(function(n4) {
          return n4[1];
        }, e3)).map(function(n4) {
          return i(function(n5, t4) {
            return null !== t4[0] && (n5[t4[0]] = t4[1]), n5;
          }, {}, a(function(t4, r3) {
            return [t4, n4[r3]];
          }, u2));
        });
      }, byte: function(n3) {
        if (s2(), O(n3), n3 > 255) throw new Error("Value specified to byte constructor (" + n3 + "=0x" + n3.toString(16) + ") is larger in value than a single byte.");
        var t3 = (n3 > 15 ? "0x" : "0x0") + n3.toString(16);
        return e2(function(r2, e3) {
          var u2 = L(r2, e3);
          return u2 === n3 ? b(e3 + 1, u2) : x2(e3, t3);
        });
      }, buffer: function(n3) {
        return h("buffer", n3).map(function(n4) {
          return Buffer.from(n4);
        });
      }, encodedString: function(n3, t3) {
        return h("string", t3).map(function(t4) {
          return t4.toString(n3);
        });
      }, uintBE: d, uint8BE: d(1), uint16BE: d(2), uint32BE: d(4), uintLE: v2, uint8LE: v2(1), uint16LE: v2(2), uint32LE: v2(4), intBE: g, int8BE: g(1), int16BE: g(2), int32BE: g(4), intLE: m, int8LE: m(1), int16LE: m(2), int32LE: m(4), floatBE: h("floatBE", 4).map(function(n3) {
        return n3.readFloatBE(0);
      }), floatLE: h("floatLE", 4).map(function(n3) {
        return n3.readFloatLE(0);
      }), doubleBE: h("doubleBE", 8).map(function(n3) {
        return n3.readDoubleBE(0);
      }), doubleLE: h("doubleLE", 8).map(function(n3) {
        return n3.readDoubleLE(0);
      }) }, n2.exports = e2;
    }]);
  });
})(parsimmon_umd_min);
var parsimmon_umd_minExports = parsimmon_umd_min.exports;
var emojiRegex = () => {
  return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC08\uDC26](?:\u200D\u2B1B)?|[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
};
function normalizeDuration(dur) {
  if (dur === void 0 || dur === null)
    return dur;
  return dur.shiftToAll().normalize();
}
function getFileTitle(path) {
  if (path.includes("/"))
    path = path.substring(path.lastIndexOf("/") + 1);
  if (path.endsWith(".md"))
    path = path.substring(0, path.length - 3);
  return path;
}
parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_minExports.regex(/[0-9\p{Letter}_-]+/u).map((str) => str.toLocaleLowerCase()), parsimmon_umd_minExports.whitespace.map((_) => "-"), parsimmon_umd_minExports.any.map((_) => "")).many().map((result) => result.join(""));
const HEADER_CANONICALIZER = parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_minExports.regex(/[0-9\p{Letter}_-]+/u), parsimmon_umd_minExports.whitespace.map((_) => " "), parsimmon_umd_minExports.any.map((_) => " ")).many().map((result) => {
  return result.join("").split(/\s+/).join(" ").trim();
});
function normalizeHeaderForLink(header) {
  return HEADER_CANONICALIZER.tryParse(header);
}
function renderMinimalDuration(dur) {
  dur = normalizeDuration(dur);
  dur = Duration.fromObject(Object.fromEntries(Object.entries(dur.toObject()).filter(([, quantity]) => quantity != 0)));
  return dur.toHuman();
}
var Values;
(function(Values2) {
  function toString(field, setting = DEFAULT_QUERY_SETTINGS, recursive = false) {
    let wrapped = wrapValue(field);
    if (!wrapped)
      return setting.renderNullAs;
    switch (wrapped.type) {
      case "null":
        return setting.renderNullAs;
      case "string":
        return wrapped.value;
      case "number":
      case "boolean":
        return "" + wrapped.value;
      case "html":
        return wrapped.value.outerHTML;
      case "widget":
        return wrapped.value.markdown();
      case "link":
        return wrapped.value.markdown();
      case "function":
        return "<function>";
      case "array":
        let result = "";
        if (recursive)
          result += "[";
        result += wrapped.value.map((f) => toString(f, setting, true)).join(", ");
        if (recursive)
          result += "]";
        return result;
      case "object":
        return "{ " + Object.entries(wrapped.value).map((e2) => e2[0] + ": " + toString(e2[1], setting, true)).join(", ") + " }";
      case "date":
        if (wrapped.value.second == 0 && wrapped.value.hour == 0 && wrapped.value.minute == 0) {
          return wrapped.value.toFormat(setting.defaultDateFormat);
        }
        return wrapped.value.toFormat(setting.defaultDateTimeFormat);
      case "duration":
        return renderMinimalDuration(wrapped.value);
    }
  }
  Values2.toString = toString;
  function wrapValue(val) {
    if (isNull(val))
      return { type: "null", value: val };
    else if (isNumber2(val))
      return { type: "number", value: val };
    else if (isString2(val))
      return { type: "string", value: val };
    else if (isBoolean2(val))
      return { type: "boolean", value: val };
    else if (isDuration(val))
      return { type: "duration", value: val };
    else if (isDate2(val))
      return { type: "date", value: val };
    else if (isWidget(val))
      return { type: "widget", value: val };
    else if (isArray2(val))
      return { type: "array", value: val };
    else if (isLink2(val))
      return { type: "link", value: val };
    else if (isFunction2(val))
      return { type: "function", value: val };
    else if (isHtml(val))
      return { type: "html", value: val };
    else if (isObject2(val))
      return { type: "object", value: val };
    else
      return void 0;
  }
  Values2.wrapValue = wrapValue;
  function mapLeaves(val, func) {
    if (isObject2(val)) {
      let result = {};
      for (let [key, value2] of Object.entries(val))
        result[key] = mapLeaves(value2, func);
      return result;
    } else if (isArray2(val)) {
      let result = [];
      for (let value2 of val)
        result.push(mapLeaves(value2, func));
      return result;
    } else {
      return func(val);
    }
  }
  Values2.mapLeaves = mapLeaves;
  function compareValue(val1, val2, linkNormalizer) {
    if (val1 === void 0)
      val1 = null;
    if (val2 === void 0)
      val2 = null;
    if (val1 === null && val2 === null)
      return 0;
    else if (val1 === null)
      return -1;
    else if (val2 === null)
      return 1;
    let wrap1 = wrapValue(val1);
    let wrap2 = wrapValue(val2);
    if (wrap1 === void 0 && wrap2 === void 0)
      return 0;
    else if (wrap1 === void 0)
      return -1;
    else if (wrap2 === void 0)
      return 1;
    if (wrap1.type != wrap2.type)
      return wrap1.type.localeCompare(wrap2.type);
    if (wrap1.value === wrap2.value)
      return 0;
    switch (wrap1.type) {
      case "string":
        return wrap1.value.localeCompare(wrap2.value);
      case "number":
        if (wrap1.value < wrap2.value)
          return -1;
        else if (wrap1.value == wrap2.value)
          return 0;
        return 1;
      case "null":
        return 0;
      case "boolean":
        if (wrap1.value == wrap2.value)
          return 0;
        else
          return wrap1.value ? 1 : -1;
      case "link":
        let link1 = wrap1.value;
        let link2 = wrap2.value;
        let normalize = linkNormalizer ?? ((x2) => x2);
        let pathCompare = normalize(link1.path).localeCompare(normalize(link2.path));
        if (pathCompare != 0)
          return pathCompare;
        let typeCompare = link1.type.localeCompare(link2.type);
        if (typeCompare != 0)
          return typeCompare;
        if (link1.subpath && !link2.subpath)
          return 1;
        if (!link1.subpath && link2.subpath)
          return -1;
        if (!link1.subpath && !link2.subpath)
          return 0;
        return (link1.subpath ?? "").localeCompare(link2.subpath ?? "");
      case "date":
        return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
      case "duration":
        return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
      case "array":
        let f1 = wrap1.value;
        let f2 = wrap2.value;
        for (let index = 0; index < Math.min(f1.length, f2.length); index++) {
          let comp = compareValue(f1[index], f2[index]);
          if (comp != 0)
            return comp;
        }
        return f1.length - f2.length;
      case "object":
        let o1 = wrap1.value;
        let o2 = wrap2.value;
        let k1 = Array.from(Object.keys(o1));
        let k2 = Array.from(Object.keys(o2));
        k1.sort();
        k2.sort();
        let keyCompare = compareValue(k1, k2);
        if (keyCompare != 0)
          return keyCompare;
        for (let key of k1) {
          let comp = compareValue(o1[key], o2[key]);
          if (comp != 0)
            return comp;
        }
        return 0;
      case "widget":
      case "html":
      case "function":
        return 0;
    }
  }
  Values2.compareValue = compareValue;
  function typeOf(val) {
    var _a2;
    return (_a2 = wrapValue(val)) == null ? void 0 : _a2.type;
  }
  Values2.typeOf = typeOf;
  function isTruthy(field) {
    let wrapped = wrapValue(field);
    if (!wrapped)
      return false;
    switch (wrapped.type) {
      case "number":
        return wrapped.value != 0;
      case "string":
        return wrapped.value.length > 0;
      case "boolean":
        return wrapped.value;
      case "link":
        return !!wrapped.value.path;
      case "date":
        return wrapped.value.toMillis() != 0;
      case "duration":
        return wrapped.value.as("seconds") != 0;
      case "object":
        return Object.keys(wrapped.value).length > 0;
      case "array":
        return wrapped.value.length > 0;
      case "null":
        return false;
      case "html":
      case "widget":
      case "function":
        return true;
    }
  }
  Values2.isTruthy = isTruthy;
  function deepCopy(field) {
    if (field === null || field === void 0)
      return field;
    if (Values2.isArray(field)) {
      return [].concat(field.map((v2) => deepCopy(v2)));
    } else if (Values2.isObject(field)) {
      let result = {};
      for (let [key, value2] of Object.entries(field))
        result[key] = deepCopy(value2);
      return result;
    } else {
      return field;
    }
  }
  Values2.deepCopy = deepCopy;
  function isString2(val) {
    return typeof val == "string";
  }
  Values2.isString = isString2;
  function isNumber2(val) {
    return typeof val == "number";
  }
  Values2.isNumber = isNumber2;
  function isDate2(val) {
    return val instanceof DateTime;
  }
  Values2.isDate = isDate2;
  function isDuration(val) {
    return val instanceof Duration;
  }
  Values2.isDuration = isDuration;
  function isNull(val) {
    return val === null || val === void 0;
  }
  Values2.isNull = isNull;
  function isArray2(val) {
    return Array.isArray(val);
  }
  Values2.isArray = isArray2;
  function isBoolean2(val) {
    return typeof val === "boolean";
  }
  Values2.isBoolean = isBoolean2;
  function isLink2(val) {
    return val instanceof Link;
  }
  Values2.isLink = isLink2;
  function isWidget(val) {
    return val instanceof Widget;
  }
  Values2.isWidget = isWidget;
  function isHtml(val) {
    if (typeof HTMLElement !== "undefined") {
      return val instanceof HTMLElement;
    } else {
      return false;
    }
  }
  Values2.isHtml = isHtml;
  function isObject2(val) {
    return typeof val == "object" && !isHtml(val) && !isWidget(val) && !isArray2(val) && !isDuration(val) && !isDate2(val) && !isLink2(val) && val !== void 0 && !isNull(val);
  }
  Values2.isObject = isObject2;
  function isFunction2(val) {
    return typeof val == "function";
  }
  Values2.isFunction = isFunction2;
})(Values || (Values = {}));
var Groupings;
(function(Groupings2) {
  function isElementGroup(entry2) {
    return Values.isObject(entry2) && Object.keys(entry2).length == 2 && "key" in entry2 && "rows" in entry2;
  }
  Groupings2.isElementGroup = isElementGroup;
  function isGrouping(entry2) {
    for (let element of entry2)
      if (!isElementGroup(element))
        return false;
    return true;
  }
  Groupings2.isGrouping = isGrouping;
  function count(elements2) {
    if (isGrouping(elements2)) {
      let result = 0;
      for (let subgroup of elements2)
        result += count(subgroup.rows);
      return result;
    } else {
      return elements2.length;
    }
  }
  Groupings2.count = count;
})(Groupings || (Groupings = {}));
class Link {
  constructor(fields) {
    /** The file path this link points to. */
    __publicField(this, "path");
    /** The display name associated with the link. */
    __publicField(this, "display");
    /** The block ID or header this link points to within a file, if relevant. */
    __publicField(this, "subpath");
    /** Is this link an embedded link (!)? */
    __publicField(this, "embed");
    /** The type of this link, which determines what 'subpath' refers to, if anything. */
    __publicField(this, "type");
    Object.assign(this, fields);
  }
  /** Create a link to a specific file. */
  static file(path, embed = false, display) {
    return new Link({
      path,
      embed,
      display,
      subpath: void 0,
      type: "file"
    });
  }
  static infer(linkpath, embed = false, display) {
    if (linkpath.includes("#^")) {
      let split2 = linkpath.split("#^");
      return Link.block(split2[0], split2[1], embed, display);
    } else if (linkpath.includes("#")) {
      let split2 = linkpath.split("#");
      return Link.header(split2[0], split2[1], embed, display);
    } else
      return Link.file(linkpath, embed, display);
  }
  /** Create a link to a specific file and header in that file. */
  static header(path, header, embed, display) {
    return new Link({
      path,
      embed,
      display,
      subpath: normalizeHeaderForLink(header),
      type: "header"
    });
  }
  /** Create a link to a specific file and block in that file. */
  static block(path, blockId, embed, display) {
    return new Link({
      path,
      embed,
      display,
      subpath: blockId,
      type: "block"
    });
  }
  static fromObject(object) {
    return new Link(object);
  }
  /** Checks for link equality (i.e., that the links are pointing to the same exact location). */
  equals(other) {
    if (other == void 0 || other == null)
      return false;
    return this.path == other.path && this.type == other.type && this.subpath == other.subpath;
  }
  /** Convert this link to it's markdown representation. */
  toString() {
    return this.markdown();
  }
  /** Convert this link to a raw object which is serialization-friendly. */
  toObject() {
    return { path: this.path, type: this.type, subpath: this.subpath, display: this.display, embed: this.embed };
  }
  /** Update this link with a new path. */
  //@ts-ignore; error appeared after updating Obsidian to 0.15.4; it also updated other packages but didn't say which
  withPath(path) {
    return new Link(Object.assign({}, this, { path }));
  }
  /** Return a new link which points to the same location but with a new display value. */
  withDisplay(display) {
    return new Link(Object.assign({}, this, { display }));
  }
  /** Convert a file link into a link to a specific header. */
  withHeader(header) {
    return Link.header(this.path, header, this.embed, this.display);
  }
  /** Convert any link into a link to its file. */
  toFile() {
    return Link.file(this.path, this.embed, this.display);
  }
  /** Convert this link into an embedded link. */
  toEmbed() {
    if (this.embed) {
      return this;
    } else {
      let link2 = new Link(this);
      link2.embed = true;
      return link2;
    }
  }
  /** Convert this link into a non-embedded link. */
  fromEmbed() {
    if (!this.embed) {
      return this;
    } else {
      let link2 = new Link(this);
      link2.embed = false;
      return link2;
    }
  }
  /** Convert this link to markdown so it can be rendered. */
  markdown() {
    let result = (this.embed ? "!" : "") + "[[" + this.obsidianLink();
    if (this.display) {
      result += "|" + this.display;
    } else {
      result += "|" + getFileTitle(this.path);
      if (this.type == "header" || this.type == "block")
        result += " > " + this.subpath;
    }
    result += "]]";
    return result;
  }
  /** Convert the inner part of the link to something that Obsidian can open / understand. */
  obsidianLink() {
    var _a2, _b2;
    const escaped = this.path.replaceAll("|", "\\|");
    if (this.type == "header")
      return escaped + "#" + ((_a2 = this.subpath) == null ? void 0 : _a2.replaceAll("|", "\\|"));
    if (this.type == "block")
      return escaped + "#^" + ((_b2 = this.subpath) == null ? void 0 : _b2.replaceAll("|", "\\|"));
    else
      return escaped;
  }
  /** The stripped name of the file this link points to. */
  fileName() {
    return getFileTitle(this.path).replace(".md", "");
  }
}
class Widget {
  constructor($widget) {
    __publicField(this, "$widget");
    this.$widget = $widget;
  }
}
class ListPairWidget extends Widget {
  constructor(key, value2) {
    super("dataview:list-pair");
    __publicField(this, "key");
    __publicField(this, "value");
    this.key = key;
    this.value = value2;
  }
  markdown() {
    return `${Values.toString(this.key)}: ${Values.toString(this.value)}`;
  }
}
class ExternalLinkWidget extends Widget {
  constructor(url, display) {
    super("dataview:external-link");
    __publicField(this, "url");
    __publicField(this, "display");
    this.url = url;
    this.display = display;
  }
  markdown() {
    return `[${this.display ?? this.url}](${this.url})`;
  }
}
var Widgets;
(function(Widgets2) {
  function listPair(key, value2) {
    return new ListPairWidget(key, value2);
  }
  Widgets2.listPair = listPair;
  function externalLink(url, display) {
    return new ExternalLinkWidget(url, display);
  }
  Widgets2.externalLink = externalLink;
  function isListPair(widget) {
    return widget.$widget === "dataview:list-pair";
  }
  Widgets2.isListPair = isListPair;
  function isExternalLink(widget) {
    return widget.$widget === "dataview:external-link";
  }
  Widgets2.isExternalLink = isExternalLink;
  function isBuiltin(widget) {
    return isListPair(widget) || isExternalLink(widget);
  }
  Widgets2.isBuiltin = isBuiltin;
})(Widgets || (Widgets = {}));
var Fields;
(function(Fields2) {
  function variable(name2) {
    return { type: "variable", name: name2 };
  }
  Fields2.variable = variable;
  function literal(value2) {
    return { type: "literal", value: value2 };
  }
  Fields2.literal = literal;
  function binaryOp(left2, op, right2) {
    return { type: "binaryop", left: left2, op, right: right2 };
  }
  Fields2.binaryOp = binaryOp;
  function index(obj, index2) {
    return { type: "index", object: obj, index: index2 };
  }
  Fields2.index = index;
  function indexVariable(name2) {
    let parts = name2.split(".");
    let result = Fields2.variable(parts[0]);
    for (let index2 = 1; index2 < parts.length; index2++) {
      result = Fields2.index(result, Fields2.literal(parts[index2]));
    }
    return result;
  }
  Fields2.indexVariable = indexVariable;
  function lambda(args, value2) {
    return { type: "lambda", arguments: args, value: value2 };
  }
  Fields2.lambda = lambda;
  function func(func2, args) {
    return { type: "function", func: func2, arguments: args };
  }
  Fields2.func = func;
  function list2(values) {
    return { type: "list", values };
  }
  Fields2.list = list2;
  function object(values) {
    return { type: "object", values };
  }
  Fields2.object = object;
  function negate(child) {
    return { type: "negated", child };
  }
  Fields2.negate = negate;
  function isCompareOp(op) {
    return op == "<=" || op == "<" || op == ">" || op == ">=" || op == "!=" || op == "=";
  }
  Fields2.isCompareOp = isCompareOp;
  Fields2.NULL = Fields2.literal(null);
})(Fields || (Fields = {}));
var Sources;
(function(Sources2) {
  function tag(tag2) {
    return { type: "tag", tag: tag2 };
  }
  Sources2.tag = tag;
  function csv2(path) {
    return { type: "csv", path };
  }
  Sources2.csv = csv2;
  function folder(prefix2) {
    return { type: "folder", folder: prefix2 };
  }
  Sources2.folder = folder;
  function link2(file, incoming) {
    return { type: "link", file, direction: incoming ? "incoming" : "outgoing" };
  }
  Sources2.link = link2;
  function binaryOp(left2, op, right2) {
    return { type: "binaryop", left: left2, op, right: right2 };
  }
  Sources2.binaryOp = binaryOp;
  function and2(left2, right2) {
    return { type: "binaryop", left: left2, op: "&", right: right2 };
  }
  Sources2.and = and2;
  function or2(left2, right2) {
    return { type: "binaryop", left: left2, op: "|", right: right2 };
  }
  Sources2.or = or2;
  function negate(child) {
    return { type: "negate", child };
  }
  Sources2.negate = negate;
  function empty() {
    return { type: "empty" };
  }
  Sources2.empty = empty;
})(Sources || (Sources = {}));
const EMOJI_REGEX = new RegExp(emojiRegex(), "");
const DURATION_TYPES = {
  year: Duration.fromObject({ years: 1 }),
  years: Duration.fromObject({ years: 1 }),
  yr: Duration.fromObject({ years: 1 }),
  yrs: Duration.fromObject({ years: 1 }),
  month: Duration.fromObject({ months: 1 }),
  months: Duration.fromObject({ months: 1 }),
  mo: Duration.fromObject({ months: 1 }),
  mos: Duration.fromObject({ months: 1 }),
  week: Duration.fromObject({ weeks: 1 }),
  weeks: Duration.fromObject({ weeks: 1 }),
  wk: Duration.fromObject({ weeks: 1 }),
  wks: Duration.fromObject({ weeks: 1 }),
  w: Duration.fromObject({ weeks: 1 }),
  day: Duration.fromObject({ days: 1 }),
  days: Duration.fromObject({ days: 1 }),
  d: Duration.fromObject({ days: 1 }),
  hour: Duration.fromObject({ hours: 1 }),
  hours: Duration.fromObject({ hours: 1 }),
  hr: Duration.fromObject({ hours: 1 }),
  hrs: Duration.fromObject({ hours: 1 }),
  h: Duration.fromObject({ hours: 1 }),
  minute: Duration.fromObject({ minutes: 1 }),
  minutes: Duration.fromObject({ minutes: 1 }),
  min: Duration.fromObject({ minutes: 1 }),
  mins: Duration.fromObject({ minutes: 1 }),
  m: Duration.fromObject({ minutes: 1 }),
  second: Duration.fromObject({ seconds: 1 }),
  seconds: Duration.fromObject({ seconds: 1 }),
  sec: Duration.fromObject({ seconds: 1 }),
  secs: Duration.fromObject({ seconds: 1 }),
  s: Duration.fromObject({ seconds: 1 })
};
const DATE_SHORTHANDS = {
  now: () => DateTime.local(),
  today: () => DateTime.local().startOf("day"),
  yesterday: () => DateTime.local().startOf("day").minus(Duration.fromObject({ days: 1 })),
  tomorrow: () => DateTime.local().startOf("day").plus(Duration.fromObject({ days: 1 })),
  sow: () => DateTime.local().startOf("week"),
  "start-of-week": () => DateTime.local().startOf("week"),
  eow: () => DateTime.local().endOf("week"),
  "end-of-week": () => DateTime.local().endOf("week"),
  soy: () => DateTime.local().startOf("year"),
  "start-of-year": () => DateTime.local().startOf("year"),
  eoy: () => DateTime.local().endOf("year"),
  "end-of-year": () => DateTime.local().endOf("year"),
  som: () => DateTime.local().startOf("month"),
  "start-of-month": () => DateTime.local().startOf("month"),
  eom: () => DateTime.local().endOf("month"),
  "end-of-month": () => DateTime.local().endOf("month")
};
const KEYWORDS = ["FROM", "WHERE", "LIMIT", "GROUP", "FLATTEN"];
function splitOnUnescapedPipe(link2) {
  let pipe = -1;
  while ((pipe = link2.indexOf("|", pipe + 1)) >= 0) {
    if (pipe > 0 && link2[pipe - 1] == "\\")
      continue;
    return [link2.substring(0, pipe).replace(/\\\|/g, "|"), link2.substring(pipe + 1)];
  }
  return [link2.replace(/\\\|/g, "|"), void 0];
}
function parseInnerLink(rawlink) {
  let [link2, display] = splitOnUnescapedPipe(rawlink);
  return Link.infer(link2, false, display);
}
function createBinaryParser(child, sep, combine) {
  return parsimmon_umd_minExports.seqMap(child, parsimmon_umd_minExports.seq(parsimmon_umd_minExports.optWhitespace, sep, parsimmon_umd_minExports.optWhitespace, child).many(), (first, rest) => {
    if (rest.length == 0)
      return first;
    let node2 = combine(first, rest[0][1], rest[0][3]);
    for (let index = 1; index < rest.length; index++) {
      node2 = combine(node2, rest[index][1], rest[index][3]);
    }
    return node2;
  });
}
function chainOpt(base2, ...funcs) {
  return parsimmon_umd_minExports.custom((success, failure) => {
    return (input, i) => {
      let result = base2._(input, i);
      if (!result.status)
        return result;
      for (let func of funcs) {
        let next = func(result.value)._(input, result.index);
        if (!next.status)
          return result;
        result = next;
      }
      return result;
    };
  });
}
const EXPRESSION = parsimmon_umd_minExports.createLanguage({
  // A floating point number; the decimal point is optional.
  number: (q) => parsimmon_umd_minExports.regexp(/-?[0-9]+(\.[0-9]+)?/).map((str) => Number.parseFloat(str)).desc("number"),
  // A quote-surrounded string which supports escape characters ('\').
  string: (q) => parsimmon_umd_minExports.string('"').then(parsimmon_umd_minExports.alt(q.escapeCharacter, parsimmon_umd_minExports.noneOf('"\\')).atLeast(0).map((chars) => chars.join(""))).skip(parsimmon_umd_minExports.string('"')).desc("string"),
  escapeCharacter: (_) => parsimmon_umd_minExports.string("\\").then(parsimmon_umd_minExports.any).map((escaped) => {
    if (escaped === '"')
      return '"';
    if (escaped === "\\")
      return "\\";
    else
      return "\\" + escaped;
  }),
  // A boolean true/false value.
  bool: (_) => parsimmon_umd_minExports.regexp(/true|false|True|False/).map((str) => str.toLowerCase() == "true").desc("boolean ('true' or 'false')"),
  // A tag of the form '#stuff/hello-there'.
  tag: (_) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("#"), parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/[^\u2000-\u206F\u2E00-\u2E7F'!"#$%&()*+,.:;<=>?@^`{|}~\[\]\\\s]/).desc("text")).many(), (start2, rest) => start2 + rest.join("")).desc("tag ('#hello/stuff')"),
  // A variable identifier, which is alphanumeric and must start with a letter or... emoji.
  identifier: (_) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(new RegExp("\\p{Letter}", "u")), parsimmon_umd_minExports.regexp(EMOJI_REGEX).desc("text")), parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/[0-9\p{Letter}_-]/u), parsimmon_umd_minExports.regexp(EMOJI_REGEX).desc("text")).many(), (first, rest) => first + rest.join("")).desc("variable identifier"),
  // An Obsidian link of the form [[<link>]].
  link: (_) => parsimmon_umd_minExports.regexp(/\[\[([^\[\]]*?)\]\]/u, 1).map((linkInner) => parseInnerLink(linkInner)).desc("file link"),
  // An embeddable link which can start with '!'. This overlaps with the normal negation operator, so it is only
  // provided for metadata parsing.
  embedLink: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("!").atMost(1), q.link, (p2, l2) => {
    if (p2.length > 0)
      l2.embed = true;
    return l2;
  }).desc("file link"),
  // Binary plus or minus operator.
  binaryPlusMinus: (_) => parsimmon_umd_minExports.regexp(/\+|-/).map((str) => str).desc("'+' or '-'"),
  // Binary times or divide operator.
  binaryMulDiv: (_) => parsimmon_umd_minExports.regexp(/\*|\/|%/).map((str) => str).desc("'*' or '/' or '%'"),
  // Binary comparison operator.
  binaryCompareOp: (_) => parsimmon_umd_minExports.regexp(/>=|<=|!=|>|<|=/).map((str) => str).desc("'>=' or '<=' or '!=' or '=' or '>' or '<'"),
  // Binary boolean combination operator.
  binaryBooleanOp: (_) => parsimmon_umd_minExports.regexp(/and|or|&|\|/i).map((str) => {
    if (str.toLowerCase() == "and")
      return "&";
    else if (str.toLowerCase() == "or")
      return "|";
    else
      return str;
  }).desc("'and' or 'or'"),
  // A date which can be YYYY-MM[-DDTHH:mm:ss].
  rootDate: (_) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/\d{4}/), parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.regexp(/\d{2}/), (year, _2, month) => {
    return DateTime.fromObject({ year: Number.parseInt(year), month: Number.parseInt(month) });
  }).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
  dateShorthand: (_) => parsimmon_umd_minExports.alt(...Object.keys(DATE_SHORTHANDS).sort((a, b) => b.length - a.length).map(parsimmon_umd_minExports.string)),
  date: (q) => chainOpt(q.rootDate, (ym) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.regexp(/\d{2}/), (_, day) => ym.set({ day: Number.parseInt(day) })), (ymd) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("T"), parsimmon_umd_minExports.regexp(/\d{2}/), (_, hour) => ymd.set({ hour: Number.parseInt(hour) })), (ymdh) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string(":"), parsimmon_umd_minExports.regexp(/\d{2}/), (_, minute) => ymdh.set({ minute: Number.parseInt(minute) })), (ymdhm) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string(":"), parsimmon_umd_minExports.regexp(/\d{2}/), (_, second) => ymdhm.set({ second: Number.parseInt(second) })), (ymdhms) => parsimmon_umd_minExports.alt(
    parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("."), parsimmon_umd_minExports.regexp(/\d{3}/), (_, millisecond) => ymdhms.set({ millisecond: Number.parseInt(millisecond) })),
    parsimmon_umd_minExports.succeed(ymdhms)
    // pass
  ), (dt) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("+").or(parsimmon_umd_minExports.string("-")), parsimmon_umd_minExports.regexp(/\d{1,2}(:\d{2})?/), (pm, hr2) => dt.setZone("UTC" + pm + hr2, { keepLocalTime: true })), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("Z"), () => dt.setZone("utc", { keepLocalTime: true })), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("["), parsimmon_umd_minExports.regexp(/[0-9A-Za-z+-\/]+/u), parsimmon_umd_minExports.string("]"), (_a2, zone, _b2) => dt.setZone(zone, { keepLocalTime: true })))).assert((dt) => dt.isValid, "valid date").desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
  // A date, plus various shorthand times of day it could be.
  datePlus: (q) => parsimmon_umd_minExports.alt(q.dateShorthand.map((d) => DATE_SHORTHANDS[d]()), q.date).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS] or in shorthand"),
  // A duration of time.
  durationType: (_) => parsimmon_umd_minExports.alt(...Object.keys(DURATION_TYPES).sort((a, b) => b.length - a.length).map(parsimmon_umd_minExports.string)),
  duration: (q) => parsimmon_umd_minExports.seqMap(q.number, parsimmon_umd_minExports.optWhitespace, q.durationType, (count, _, t2) => DURATION_TYPES[t2].mapUnits((x2) => x2 * count)).sepBy1(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace).or(parsimmon_umd_minExports.optWhitespace)).map((durations) => durations.reduce((p2, c) => p2.plus(c))).desc("duration like 4hr2min"),
  // A raw null value.
  rawNull: (_) => parsimmon_umd_minExports.string("null"),
  // Source parsing.
  tagSource: (q) => q.tag.map((tag) => Sources.tag(tag)),
  csvSource: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("csv(").skip(parsimmon_umd_minExports.optWhitespace), q.string, parsimmon_umd_minExports.string(")"), (_1, path, _2) => Sources.csv(path)),
  linkIncomingSource: (q) => q.link.map((link2) => Sources.link(link2.path, true)),
  linkOutgoingSource: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("outgoing(").skip(parsimmon_umd_minExports.optWhitespace), q.link, parsimmon_umd_minExports.string(")"), (_1, link2, _2) => Sources.link(link2.path, false)),
  folderSource: (q) => q.string.map((str) => Sources.folder(str)),
  parensSource: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q.source, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_1, _2, field, _3, _4) => field),
  negateSource: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.alt(parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.string("!")), q.atomSource, (_, source) => Sources.negate(source)),
  atomSource: (q) => parsimmon_umd_minExports.alt(q.parensSource, q.negateSource, q.linkOutgoingSource, q.linkIncomingSource, q.folderSource, q.tagSource, q.csvSource),
  binaryOpSource: (q) => createBinaryParser(q.atomSource, q.binaryBooleanOp.map((s2) => s2), Sources.binaryOp),
  source: (q) => q.binaryOpSource,
  // Field parsing.
  variableField: (q) => q.identifier.chain((r) => {
    if (KEYWORDS.includes(r.toUpperCase())) {
      return parsimmon_umd_minExports.fail("Variable fields cannot be a keyword (" + KEYWORDS.join(" or ") + ")");
    } else {
      return parsimmon_umd_minExports.succeed(Fields.variable(r));
    }
  }).desc("variable"),
  numberField: (q) => q.number.map((val) => Fields.literal(val)).desc("number"),
  stringField: (q) => q.string.map((val) => Fields.literal(val)).desc("string"),
  boolField: (q) => q.bool.map((val) => Fields.literal(val)).desc("boolean"),
  dateField: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("date("), parsimmon_umd_minExports.optWhitespace, q.datePlus, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (prefix2, _1, date, _2, postfix) => Fields.literal(date)).desc("date"),
  durationField: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("dur("), parsimmon_umd_minExports.optWhitespace, q.duration, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (prefix2, _1, dur, _2, postfix) => Fields.literal(dur)).desc("duration"),
  nullField: (q) => q.rawNull.map((_) => Fields.NULL),
  linkField: (q) => q.link.map((f) => Fields.literal(f)),
  listField: (q) => q.field.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("[").skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.optWhitespace.then(parsimmon_umd_minExports.string("]"))).map((l2) => Fields.list(l2)).desc("list ('[1, 2, 3]')"),
  objectField: (q) => parsimmon_umd_minExports.seqMap(q.identifier.or(q.string), parsimmon_umd_minExports.string(":").trim(parsimmon_umd_minExports.optWhitespace), q.field, (name2, _sep, value2) => {
    return { name: name2, value: value2 };
  }).sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("{").skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.optWhitespace.then(parsimmon_umd_minExports.string("}"))).map((vals) => {
    let res = {};
    for (let entry2 of vals)
      res[entry2.name] = entry2.value;
    return Fields.object(res);
  }).desc("object ('{ a: 1, b: 2 }')"),
  atomInlineField: (q) => parsimmon_umd_minExports.alt(q.date, q.duration.map((d) => normalizeDuration(d)), q.string, q.tag, q.embedLink, q.bool, q.number, q.rawNull),
  inlineFieldList: (q) => q.atomInlineField.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace).lookahead(q.atomInlineField)),
  inlineField: (q) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.seqMap(q.atomInlineField, parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace), q.inlineFieldList, (f, _s2, l2) => [f].concat(l2)), q.atomInlineField),
  atomField: (q) => parsimmon_umd_minExports.alt(
    // Place embed links above negated fields as they are the special parser case '![[thing]]' and are generally unambigious.
    q.embedLink.map((l2) => Fields.literal(l2)),
    q.negatedField,
    q.linkField,
    q.listField,
    q.objectField,
    q.lambdaField,
    q.parensField,
    q.boolField,
    q.numberField,
    q.stringField,
    q.dateField,
    q.durationField,
    q.nullField,
    q.variableField
  ),
  indexField: (q) => parsimmon_umd_minExports.seqMap(q.atomField, parsimmon_umd_minExports.alt(q.dotPostfix, q.indexPostfix, q.functionPostfix).many(), (obj, postfixes) => {
    let result = obj;
    for (let post of postfixes) {
      switch (post.type) {
        case "dot":
          result = Fields.index(result, Fields.literal(post.field));
          break;
        case "index":
          result = Fields.index(result, post.field);
          break;
        case "function":
          result = Fields.func(result, post.fields);
          break;
      }
    }
    return result;
  }),
  negatedField: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("!"), q.indexField, (_, field) => Fields.negate(field)).desc("negated field"),
  parensField: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q.field, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_1, _2, field, _3, _4) => field),
  lambdaField: (q) => parsimmon_umd_minExports.seqMap(q.identifier.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("(").trim(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.string(")").trim(parsimmon_umd_minExports.optWhitespace)), parsimmon_umd_minExports.string("=>").trim(parsimmon_umd_minExports.optWhitespace), q.field, (ident, _ignore, value2) => {
    return { type: "lambda", arguments: ident, value: value2 };
  }),
  dotPostfix: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("."), q.identifier, (_, field) => {
    return { type: "dot", field };
  }),
  indexPostfix: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("["), parsimmon_umd_minExports.optWhitespace, q.field, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string("]"), (_, _2, field, _3, _4) => {
    return { type: "index", field };
  }),
  functionPostfix: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q.field.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_, _1, fields, _2, _3) => {
    return { type: "function", fields };
  }),
  // The precedence hierarchy of operators - multiply/divide, add/subtract, compare, and then boolean operations.
  binaryMulDivField: (q) => createBinaryParser(q.indexField, q.binaryMulDiv, Fields.binaryOp),
  binaryPlusMinusField: (q) => createBinaryParser(q.binaryMulDivField, q.binaryPlusMinus, Fields.binaryOp),
  binaryCompareField: (q) => createBinaryParser(q.binaryPlusMinusField, q.binaryCompareOp, Fields.binaryOp),
  binaryBooleanField: (q) => createBinaryParser(q.binaryCompareField, q.binaryBooleanOp, Fields.binaryOp),
  binaryOpField: (q) => q.binaryBooleanField,
  field: (q) => q.binaryOpField
});
function parseField(text2) {
  try {
    return Result.success(EXPRESSION.field.tryParse(text2));
  } catch (error2) {
    return Result.failure("" + error2);
  }
}
var QueryFields;
(function(QueryFields2) {
  function named(name2, field) {
    return { name: name2, field };
  }
  QueryFields2.named = named;
  function sortBy(field, dir) {
    return { field, direction: dir };
  }
  QueryFields2.sortBy = sortBy;
})(QueryFields || (QueryFields = {}));
function captureRaw(base2) {
  return parsimmon_umd_minExports.custom((success, failure) => {
    return (input, i) => {
      let result = base2._(input, i);
      if (!result.status)
        return result;
      return Object.assign({}, result, { value: [result.value, input.substring(i, result.index)] });
    };
  });
}
function stripNewlines(text2) {
  return text2.split(/[\r\n]+/).map((t2) => t2.trim()).join("");
}
function precededByWhitespaceIfNotEof(if_eof, parser2) {
  return parsimmon_umd_minExports.eof.map(if_eof).or(parsimmon_umd_minExports.whitespace.then(parser2));
}
const QUERY_LANGUAGE = parsimmon_umd_minExports.createLanguage({
  // Simple atom parsing, like words, identifiers, numbers.
  queryType: (q) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/TABLE|LIST|TASK|CALENDAR/i)).map((str) => str.toLowerCase()).desc("query type ('TABLE', 'LIST', 'TASK', or 'CALENDAR')"),
  explicitNamedField: (q) => parsimmon_umd_minExports.seqMap(EXPRESSION.field.skip(parsimmon_umd_minExports.whitespace), parsimmon_umd_minExports.regexp(/AS/i).skip(parsimmon_umd_minExports.whitespace), EXPRESSION.identifier.or(EXPRESSION.string), (field, _as, ident) => QueryFields.named(ident, field)),
  comment: () => parsimmon_umd_minExports.Parser((input, i) => {
    let line = input.substring(i);
    if (!line.startsWith("//"))
      return parsimmon_umd_minExports.makeFailure(i, "Not a comment");
    line = line.split("\n")[0];
    let comment2 = line.substring(2).trim();
    return parsimmon_umd_minExports.makeSuccess(i + line.length, comment2);
  }),
  namedField: (q) => parsimmon_umd_minExports.alt(q.explicitNamedField, captureRaw(EXPRESSION.field).map(([value2, text2]) => QueryFields.named(stripNewlines(text2), value2))),
  sortField: (q) => parsimmon_umd_minExports.seqMap(EXPRESSION.field.skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.regexp(/ASCENDING|DESCENDING|ASC|DESC/i).atMost(1), (field, dir) => {
    let direction = dir.length == 0 ? "ascending" : dir[0].toLowerCase();
    if (direction == "desc")
      direction = "descending";
    if (direction == "asc")
      direction = "ascending";
    return {
      field,
      direction
    };
  }),
  headerClause: (q) => q.queryType.chain((type) => {
    switch (type) {
      case "table": {
        return precededByWhitespaceIfNotEof(() => ({ type, fields: [], showId: true }), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_minExports.optWhitespace).atMost(1), parsimmon_umd_minExports.sepBy(q.namedField, parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), (withoutId, fields) => {
          return { type, fields, showId: withoutId.length == 0 };
        }));
      }
      case "list":
        return precededByWhitespaceIfNotEof(() => ({ type, format: void 0, showId: true }), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_minExports.optWhitespace).atMost(1), EXPRESSION.field.atMost(1), (withoutId, format2) => {
          return {
            type,
            format: format2.length == 1 ? format2[0] : void 0,
            showId: withoutId.length == 0
          };
        }));
      case "task":
        return parsimmon_umd_minExports.succeed({ type });
      case "calendar":
        return parsimmon_umd_minExports.whitespace.then(parsimmon_umd_minExports.seqMap(q.namedField, (field) => {
          return {
            type,
            showId: true,
            field
          };
        }));
      default:
        return parsimmon_umd_minExports.fail(`Unrecognized query type '${type}'`);
    }
  }).desc("TABLE or LIST or TASK or CALENDAR"),
  fromClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/FROM/i), parsimmon_umd_minExports.whitespace, EXPRESSION.source, (_1, _2, source) => source),
  whereClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WHERE/i), parsimmon_umd_minExports.whitespace, EXPRESSION.field, (where, _, field) => {
    return { type: "where", clause: field };
  }).desc("WHERE <expression>"),
  sortByClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/SORT/i), parsimmon_umd_minExports.whitespace, q.sortField.sepBy1(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), (sort, _1, fields) => {
    return { type: "sort", fields };
  }).desc("SORT field [ASC/DESC]"),
  limitClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/LIMIT/i), parsimmon_umd_minExports.whitespace, EXPRESSION.field, (limit, _1, field) => {
    return { type: "limit", amount: field };
  }).desc("LIMIT <value>"),
  flattenClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/FLATTEN/i).skip(parsimmon_umd_minExports.whitespace), q.namedField, (_, field) => {
    return { type: "flatten", field };
  }).desc("FLATTEN <value> [AS <name>]"),
  groupByClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/GROUP BY/i).skip(parsimmon_umd_minExports.whitespace), q.namedField, (_, field) => {
    return { type: "group", field };
  }).desc("GROUP BY <value> [AS <name>]"),
  // Full query parsing.
  clause: (q) => parsimmon_umd_minExports.alt(q.fromClause, q.whereClause, q.sortByClause, q.limitClause, q.groupByClause, q.flattenClause),
  query: (q) => parsimmon_umd_minExports.seqMap(q.headerClause.trim(optionalWhitespaceOrComment), q.fromClause.trim(optionalWhitespaceOrComment).atMost(1), q.clause.trim(optionalWhitespaceOrComment).many(), (header, from, clauses) => {
    return {
      header,
      source: from.length == 0 ? Sources.folder("") : from[0],
      operations: clauses,
      settings: DEFAULT_QUERY_SETTINGS
    };
  })
});
const optionalWhitespaceOrComment = parsimmon_umd_minExports.alt(parsimmon_umd_minExports.whitespace, QUERY_LANGUAGE.comment).many().map((arr) => arr.join(""));
const getAPI = (app2) => {
  var _a2;
  if (app2)
    return (_a2 = app2.plugins.plugins.dataview) == null ? void 0 : _a2.api;
  else
    return window.DataviewAPI;
};
const isPluginEnabled = (app2) => app2.plugins.enabledPlugins.has("dataview");
lib$1.DATE_SHORTHANDS = DATE_SHORTHANDS;
lib$1.DURATION_TYPES = DURATION_TYPES;
lib$1.EXPRESSION = EXPRESSION;
lib$1.KEYWORDS = KEYWORDS;
lib$1.QUERY_LANGUAGE = QUERY_LANGUAGE;
var getAPI_1 = lib$1.getAPI = getAPI;
lib$1.isPluginEnabled = isPluginEnabled;
lib$1.parseField = parseField;
const CLASSIFICATION = [
  "category",
  "category and subcategory",
  "categories",
  "grouped categories"
];
const TAG_HANDLING = [
  "Always move to Frontmatter",
  "Always move to Page",
  "Do not Change"
];
const LOG_LEVELS = [
  "debug",
  "info",
  "warn",
  "error"
];
const DEFAULT_SETTINGS = {
  kinds: {},
  types: {},
  kind_folder: "kind",
  cache: null,
  handle_tags: "Do not Change",
  default_classification: "category and subcategory",
  page_blocks: [],
  url_patterns: [],
  url_props: [],
  log_level: "warn"
};
const DEFAULT_KIND = {
  name: "",
  _classification_type: "category and subcategory",
  _filename_date_prefix: false,
  _folder_include_cwd: false,
  _folder_choices_sub_dirs: false,
  _folder_favorite: "",
  _show_sub_dirs: false,
  _relationships: [],
  tag: "",
  _metric_props: [],
  _aliases_lowercase: false,
  _aliases_plural: false
};
const FOLDER_DEFAULT = [
  "Favorite folder is default",
  "Current folder is default"
];
const UOM_TYPES = [
  "mass",
  "volume",
  "density",
  "speed",
  "currency",
  "distance",
  "duration_min",
  "duration_sec",
  "duration_ms"
];
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start$1 = "start";
var end$1 = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start$1, placement + "-" + end$1]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start$1, placement + "-" + end$1]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node2) {
  if (node2 == null) {
    return window;
  }
  if (node2.toString() !== "[object Window]") {
    var ownerDocument2 = node2.ownerDocument;
    return ownerDocument2 ? ownerDocument2.defaultView || window : window;
  }
  return node2;
}
function isElement$1(node2) {
  var OwnElement = getWindow(node2).Element;
  return node2 instanceof OwnElement || node2 instanceof Element;
}
function isHTMLElement(node2) {
  var OwnElement = getWindow(node2).HTMLElement;
  return node2 instanceof OwnElement || node2 instanceof HTMLElement;
}
function isShadowRoot(node2) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node2).ShadowRoot;
  return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name2) {
    var style2 = state.styles[name2] || {};
    var attributes2 = state.attributes[name2] || {};
    var element = state.elements[name2];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes2).forEach(function(name3) {
      var value2 = attributes2[name3];
      if (value2 === false) {
        element.removeAttribute(name3);
      } else {
        element.setAttribute(name3, value2 === true ? "" : value2);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name2) {
      var element = state.elements[name2];
      var attributes2 = state.attributes[name2] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
      var style2 = styleProperties.reduce(function(style3, property) {
        style3[property] = "";
        return style3;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes2).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max$1 = Math.max;
var min = Math.min;
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item2) {
      return item2.brand + "/" + item2.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement$1(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width2 = clientRect.width / scaleX;
  var height2 = clientRect.height / scaleY;
  return {
    width: width2,
    height: height2,
    top: y2,
    right: x2 + width2,
    bottom: y2 + height2,
    left: x2,
    x: x2,
    y: y2
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width2 = element.offsetWidth;
  var height2 = element.offsetHeight;
  if (Math.abs(clientRect.width - width2) <= 1) {
    width2 = clientRect.width;
  }
  if (Math.abs(clientRect.height - height2) <= 1) {
    height2 = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width2,
    height: height2
  };
}
function contains(parent, child) {
  var rootNode2 = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode2 && isShadowRoot(rootNode2)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement$1(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value2, max2) {
  return max$1(min$1, min(value2, max2));
}
function withinMaxClamp(min2, value2, max2) {
  var v2 = within(min2, value2, max2);
  return v2 > max2 ? max2 : v2;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value2, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value2;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name2 = _ref.name, options2 = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options2.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options2 = _ref2.options;
  var _options$element = options2.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x2 = _ref.x, y2 = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x2 * dpr) / dpr || 0,
    y: round(y2 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref3.x;
  y2 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end$1) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y2 -= offsetY - popperRect.height;
      y2 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end$1) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y2
  }, getWindow(popper2)) : {
    x: x2,
    y: y2
  };
  x2 = _ref4.x;
  y2 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options2 = _ref5.options;
  var _options$gpuAccelerat = options2.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options2.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options2.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options2 = _ref.options;
  var _options$scroll = options2.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options2.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node2) {
  var win = getWindow(node2);
  var scrollLeft2 = win.pageXOffset;
  var scrollTop2 = win.pageYOffset;
  return {
    scrollLeft: scrollLeft2,
    scrollTop: scrollTop2
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width2 = html.clientWidth;
  var height2 = html.clientHeight;
  var x2 = 0;
  var y2 = 0;
  if (visualViewport) {
    width2 = visualViewport.width;
    height2 = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width: width2,
    height: height2,
    x: x2 + getWindowScrollBarX(element),
    y: y2
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width2 = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height2 = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y2 = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x2 += max$1(html.clientWidth, body ? body.clientWidth : 0) - width2;
  }
  return {
    width: width2,
    height: height2,
    x: x2,
    y: y2
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node2) {
  if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
    return node2.ownerDocument.body;
  }
  if (isHTMLElement(node2) && isScrollParent(node2)) {
    return node2;
  }
  return getScrollParent(getParentNode(node2));
}
function listScrollParents(element, list2) {
  var _element$ownerDocumen;
  if (list2 === void 0) {
    list2 = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target2 = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list2.concat(target2);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target2)))
  );
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement$1(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max$1(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max$1(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start$1:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end$1:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options2 = _ref.options, name2 = _ref.name;
  if (state.modifiersData[name2]._skip) {
    return;
  }
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options2.fallbackPlacements, padding = options2.padding, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, _options$flipVariatio = options2.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options2.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start$1;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name2]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name2 = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name2] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options2 = _ref2.options, name2 = _ref2.name;
  var _options$offset = options2.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data2 = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data2[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y2;
  }
  state.modifiersData[name2] = data2;
}
const offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state = _ref.state, name2 = _ref.name;
  state.modifiersData[name2] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options2 = _ref.options, name2 = _ref.name;
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, padding = options2.padding, _options$tether = options2.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options2.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data2 = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$1 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start$1 ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start$1 ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max$1(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data2[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data2[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name2] = data2;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node2) {
  if (node2 === getWindow(node2) || !isHTMLElement(node2)) {
    return getWindowScroll(node2);
  } else {
    return getHTMLElementScroll(node2);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map2 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve3) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve3(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options2) {
    if (options2 === void 0) {
      options2 = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options3 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options3);
        state.scrollParents = {
          reference: isElement$1(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name: name2,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve3) {
          instance.forceUpdate();
          resolve3(state);
        });
      }),
      destroy: function destroy2() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options2).then(function(state2) {
      if (!isDestroyed && options2.onFirstUpdate) {
        options2.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name2 = _ref.name, _ref$options = _ref.options, options3 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name: name2,
            instance,
            options: options3
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
const wrapAround = (value2, size) => {
  return (value2 % size + size) % size;
};
class Suggest {
  constructor(owner, containerEl, scope) {
    __publicField(this, "owner");
    __publicField(this, "values");
    __publicField(this, "suggestions");
    __publicField(this, "selectedItem");
    __publicField(this, "containerEl");
    this.owner = owner;
    this.containerEl = containerEl;
    containerEl.on(
      "click",
      ".suggestion-item",
      this.onSuggestionClick.bind(this)
    );
    containerEl.on(
      "mousemove",
      ".suggestion-item",
      this.onSuggestionMouseover.bind(this)
    );
    scope.register([], "ArrowUp", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem - 1, true);
        return false;
      }
    });
    scope.register([], "ArrowDown", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem + 1, true);
        return false;
      }
    });
    scope.register([], "Enter", (event) => {
      if (!event.isComposing) {
        this.useSelectedItem(event);
        return false;
      }
    });
  }
  onSuggestionClick(event, el) {
    event.preventDefault();
    const item2 = this.suggestions.indexOf(el);
    this.setSelectedItem(item2, false);
    this.useSelectedItem(event);
  }
  onSuggestionMouseover(_event, el) {
    const item2 = this.suggestions.indexOf(el);
    this.setSelectedItem(item2, false);
  }
  setSuggestions(values) {
    this.containerEl.empty();
    const suggestionEls = [];
    values.forEach((value2) => {
      const suggestionEl = this.containerEl.createDiv("suggestion-item");
      this.owner.renderSuggestion(value2, suggestionEl);
      suggestionEls.push(suggestionEl);
    });
    this.values = values;
    this.suggestions = suggestionEls;
    this.setSelectedItem(0, false);
  }
  useSelectedItem(event) {
    const currentValue = this.values[this.selectedItem];
    if (currentValue) {
      this.owner.selectSuggestion(currentValue, event);
    }
  }
  setSelectedItem(selectedIndex, scrollIntoView) {
    const normalizedIndex = wrapAround(
      selectedIndex,
      this.suggestions.length
    );
    const prevSelectedSuggestion = this.suggestions[this.selectedItem];
    const selectedSuggestion = this.suggestions[normalizedIndex];
    prevSelectedSuggestion == null ? void 0 : prevSelectedSuggestion.removeClass("is-selected");
    selectedSuggestion == null ? void 0 : selectedSuggestion.addClass("is-selected");
    this.selectedItem = normalizedIndex;
    if (scrollIntoView) {
      selectedSuggestion.scrollIntoView(false);
    }
  }
}
class TextInputSuggest {
  constructor(inputEl) {
    __publicField(this, "inputEl");
    __publicField(this, "popper");
    __publicField(this, "scope");
    __publicField(this, "suggestEl");
    __publicField(this, "suggest");
    this.inputEl = inputEl;
    this.scope = new Scope();
    this.suggestEl = createDiv("suggestion-container");
    const suggestion = this.suggestEl.createDiv("suggestion");
    this.suggest = new Suggest(this, suggestion, this.scope);
    this.scope.register([], "Escape", this.close.bind(this));
    this.inputEl.addEventListener("input", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("focus", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("blur", this.close.bind(this));
    this.suggestEl.on(
      "mousedown",
      ".suggestion-container",
      (event) => {
        event.preventDefault();
      }
    );
  }
  onInputChanged() {
    const inputStr = this.inputEl.value;
    const suggestions = this.getSuggestions(inputStr);
    if (!suggestions) {
      this.close();
      return;
    }
    if (suggestions.length > 0) {
      this.suggest.setSuggestions(suggestions);
      this.open(app.dom.appContainerEl, this.inputEl);
    } else {
      this.close();
    }
  }
  open(container, inputEl) {
    app.keymap.pushScope(this.scope);
    container.appendChild(this.suggestEl);
    this.popper = createPopper(inputEl, this.suggestEl, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "sameWidth",
          enabled: true,
          fn: ({ state, instance }) => {
            const targetWidth = `${state.rects.reference.width}px`;
            if (state.styles.popper.width === targetWidth) {
              return;
            }
            state.styles.popper.width = targetWidth;
            instance.update();
          },
          phase: "beforeWrite",
          requires: ["computeStyles"]
        }
      ]
    });
  }
  close() {
    app.keymap.popScope(this.scope);
    this.suggest.setSuggestions([]);
    if (this.popper) this.popper.destroy();
    this.suggestEl.detach();
  }
}
class FolderSuggest extends TextInputSuggest {
  getSuggestions(inputStr) {
    const abstractFiles = app.vault.getAllLoadedFiles();
    const folders = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    abstractFiles.forEach((folder) => {
      if (folder instanceof TFolder && folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        folders.push(folder);
      }
    });
    return folders;
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
}
const msg = (list2) => list2.find((i) => typeof i === "string") || "";
const trunc = (s2) => typeof s2 === "string" ? s2.length > 12 ? `${s2.slice(0, 12).trim()}...` : `${s2}` : "";
const debug$1 = (level) => (...args) => {
  if (level !== "debug") {
    return;
  }
  console.groupCollapsed(`KM(dbg): ${trunc(msg(args))}`);
  args.forEach((a) => {
    if (typeof a === "function") {
      console.log(`fn  `, a());
    } else if (typeof a === "object" && a !== null) {
      Object.keys(a).map((k) => console.info({ [k]: a[k] }));
    } else {
      console.log(a);
    }
  });
  console.groupEnd();
};
const info = (level) => (...args) => {
  if (["debug"].includes(level)) {
    return;
  }
  console.groupCollapsed(`KM(i): ${trunc(msg(args))}`);
  args.forEach((a) => {
    if (typeof a === "function") {
      console.log(`fn  `, String(a));
    } else if (typeof a === "object" && a !== null) {
      Object.keys(a).map((k) => console.log({ [k]: a[k] }));
    } else {
      console.log(a);
    }
  });
  console.groupEnd();
};
const warn = (level) => (...args) => {
  if (["error"].includes(level)) {
    return;
  }
  console.group("KM(warn)");
  args.forEach((a) => {
    console.warn(a);
  });
  console.groupEnd();
};
const error$3 = (level) => (...args) => {
  console.groupEnd();
  new Notification(`KM(err): ${msg(args) || ""}`, { body: "see developer console for more details" });
  class KindModelError extends Error {
    constructor(msg2) {
      super(msg2);
      __publicField(this, "kind");
    }
  }
  throw new KindModelError(args.map((i) => String(i)).join(", ") || "Kind Model error");
};
const logger = (level, context) => {
  const api2 = {
    level,
    debug: debug$1(level),
    info: info(level),
    warn: warn(level),
    error: error$3()
  };
  return api2;
};
const isNotNull = (prop, base2) => {
  return prop === null ? false : prop in base2 ? true : false;
};
const resolve$2 = (val) => typeof val === "function" ? val() : val;
const contextApi = (el, base2, global_opt, log_level) => ({
  sectionHeading: (heading2, sub_text) => {
    const color = "rgba(15, 117, 224, .75) ";
    const headingText = createEl(
      "h2",
      {
        cls: "section-header",
        text: heading2,
        attr: { style: `font-size: larger; padding-bottom: 0; margin-bottom: 0; margin-top: 0.75rem` }
      }
    );
    const sub_text_el = sub_text ? createEl("div", {
      cls: "section-sub-text",
      text: sub_text,
      attr: { style: `font-size: smaller; border-left: 2px solid ${color}; padding-left: 8px;` }
    }) : void 0;
    const sectionInput = createEl("div", {
      cls: "input-section",
      text: "",
      attr: { style: `border-left: 2px solid ${color}; padding-left: 8px; ` }
    });
    const section_heading = createEl("div").appendChild(headingText);
    if (sub_text_el) {
      section_heading.appendChild(sub_text_el);
    }
    section_heading.appendChild(sectionInput);
    const bottom_pad = "padding-bottom: 0.25rem";
    el.createEl("h2", { text: heading2, attr: { style: `font-size: larger; padding-top: 0.75rem"; ${sub_text ? "" : bottom_pad}` } });
    if (sub_text) {
      el.createEl("p", { cls: "settings-desc", text: sub_text, attr: { style: `${bottom_pad}; font-size: smaller` } });
    }
    el.appendChild(sectionInput);
    const fn2 = inputRow(sectionInput, base2, global_opt, log_level);
    fn2["section"] = heading2;
    return fn2;
  },
  iterateOver: (prop, cb) => {
    const settings = [];
    base2[prop];
    return settings;
  }
});
const componentApi = (el, base2, global_opt, log_level) => (name2, desc, prop) => (s2) => {
  const { debug: debug2, info: info2, warn: warn2, error: error2 } = logger(log_level);
  return {
    addDropdown(choices) {
      s2.addDropdown((dd) => {
        const isKeyValueDict = !Array.isArray(choices);
        for (const opt of isKeyValueDict ? Object.keys(choices) : choices) {
          const value2 = isKeyValueDict ? String(choices[opt]) : opt;
          dd.addOption(value2, opt);
          if (isNotNull(prop, base2) && value2 === base2[prop]) {
            dd.setValue(value2);
          }
        }
        dd.onChange((v2) => {
          if (isNotNull(prop, base2)) {
            const prior_value = base2[prop];
            base2[prop] = isKeyValueDict ? choices[v2] : v2;
            debug2(`Updating ${name2} dropdown`, `new value is:
${JSON.stringify(v2, null, 2)}`, `prior value was:
${JSON.stringify(prior_value, null, 2)}`);
            if ((global_opt == null ? void 0 : global_opt.saveState) && prop !== null) {
              if (typeof (global_opt == null ? void 0 : global_opt.saveState) !== "function") {
                error2(`saveState property was passed into UiBuilder but it's type is "${typeof (global_opt == null ? void 0 : global_opt.saveState)}" instead of being a function!`);
              } else {
                info2(`auto save`, `the dropdown "${String(prop)}" triggered saving state`, `the current state is: 
${JSON.stringify(base2, null, 2)}`);
                global_opt.saveState();
              }
            } else {
              debug2(`no auto save: state changed on "${name2}" property but state is not automatically save after state changes`);
            }
            s2.setName(resolve$2(name2));
            s2.setDesc(resolve$2(desc));
          } else {
            debug2(`the dropdown "${name2}" changed state but no property was set to record this.`, "this may be ok but is typically an error", `the new state is now: ${v2}`);
          }
        });
      });
      return componentApi(el, base2, global_opt, log_level)(name2, desc, prop)(s2);
    },
    addToggleSwitch(opt = {}) {
      s2.addToggle((t2) => {
        if (isNotNull(prop, base2)) {
          t2.setValue(base2[prop]);
        }
        t2.onChange((v2) => {
          if (isNotNull(prop, base2)) {
            s2.setName(resolve$2(name2));
            s2.setDesc(resolve$2(desc));
            base2[prop] = v2;
            if ((global_opt == null ? void 0 : global_opt.saveState) && prop !== null) {
              if (typeof (global_opt == null ? void 0 : global_opt.saveState) !== "function") {
                error2(`saveState property was passed into UiBuilder but it's type is "${typeof (global_opt == null ? void 0 : global_opt.saveState)}" instead of being a function!`);
              }
              info2("auto save", `the toggle switch for "${prop}" detected a change`, `the new value for "${prop}" is: ${v2}`);
              global_opt.saveState();
            } else {
              debug2(`no auto save: state changed on "${name2}" on property`);
            }
          }
          if (opt.refreshDomOnChange) {
            warn2("do not know how to refresh DOM yet");
          }
        });
      });
      return componentApi(el, base2, global_opt, log_level)(name2, desc, prop)(s2);
    },
    addTextInput(opt = {}) {
      s2.addText((t2) => {
        if (isNotNull(prop, base2)) {
          t2.setValue(base2[prop]);
        }
        t2.onChange((v2) => {
          if (isNotNull(prop, base2)) {
            base2[prop] = v2;
          } else {
            debug2(`state changed on the property "${name2}" but because "prop" was null it will not be recorded.`);
          }
          s2.setName(resolve$2(name2));
          s2.setDesc(resolve$2(desc));
          if (opt.refreshDomOnChange) {
            warn2("do not know how to refresh DOM yet");
          }
          if ((global_opt == null ? void 0 : global_opt.saveState) && prop !== null) {
            if (typeof (global_opt == null ? void 0 : global_opt.saveState) !== "function") {
              error2(`saveState property was passed into UiBuilder but it's type is "${typeof (global_opt == null ? void 0 : global_opt.saveState)}" instead of being a function!`);
            }
            debug2(`toggle switch for "${String(prop)}" saving state`);
            global_opt.saveState();
          } else {
            debug2(`no auto save: state changed on "${name2}" on property`);
          }
        });
      });
      return componentApi(el, base2, global_opt, log_level)(name2, desc, prop)(s2);
    },
    addFolderSearch(opt = {}) {
      s2.addSearch((t2) => {
        new FolderSuggest(t2.inputEl);
        t2.setPlaceholder(opt.placeholder || "Example: folder1/folder2");
        if (isNotNull(prop, base2)) {
          t2.setValue(base2[prop]);
        }
        t2.onChange((v2) => {
          s2.setName(resolve$2(name2));
          s2.setDesc(resolve$2(desc));
          if (isNotNull(prop, base2)) {
            base2[prop] = v2;
            if (global_opt == null ? void 0 : global_opt.saveState) {
              if (typeof (global_opt == null ? void 0 : global_opt.saveState) !== "function") {
                error2(`saveState property was passed into UiBuilder but it's type is "${typeof (global_opt == null ? void 0 : global_opt.saveState)}" instead of being a function!`);
              } else {
                info2(`auto save`, `folder prop ${name2} [${prop}] changed state to:`, v2);
                global_opt.saveState();
              }
            } else {
              debug2(`no auto save: state changed on "${name2}" on property`);
            }
          }
          if (opt.refreshDomOnChange) {
            warn2("do not know how to refresh DOM yet");
          }
        });
      });
      return componentApi(el, base2, global_opt, log_level)(name2, desc, prop)(s2);
    },
    addButton: (o) => {
      s2.addButton((b) => {
        b.setTooltip((o == null ? void 0 : o.tooltip) || resolve$2(desc)).setButtonText((o == null ? void 0 : o.buttonText) || "+").setCta().onClick((o == null ? void 0 : o.onClick) ? o.onClick : () => warn2(`${name2} button for "${String(o == null ? void 0 : o.buttonText)}" does not have a click handler`));
        if (o == null ? void 0 : o.backgroundColor) {
          b.setClass(`bg-${o.backgroundColor}`);
        }
        if (o == null ? void 0 : o.icon) {
          b.setIcon(o.icon);
        }
      });
      return componentApi(el, base2, global_opt, log_level)(name2, desc, prop)(s2);
    },
    done: () => s2
  };
};
const inputRow = (el, base2, global_opt, log_level) => (name2, desc, prop) => {
  const s2 = new Setting(el).setName(resolve$2(name2)).setDesc(resolve$2(desc));
  return componentApi(el, base2, global_opt, log_level)(name2, desc, prop)(s2);
};
const UiBuilder = (el, base2, log_level, global_opt = {}) => {
  const { h1, style: style2 } = global_opt;
  const context = contextApi(el, base2, global_opt, log_level);
  const settings = inputRow(el, base2, global_opt, log_level);
  el.empty();
  for (const prop of Object.keys(context)) {
    settings[prop] = context[prop];
  }
  if (h1) {
    const attrs = style2 ? { attrs: { style: style2 } } : {};
    el.createEl("h1", { text: h1, ...attrs, cls: "page-header" });
  }
  return settings;
};
class KindModal extends Modal {
  constructor(app2, kind, log_level) {
    super(app2);
    __publicField(this, "kind");
    __publicField(this, "log_level");
    __publicField(this, "contentEl");
    this.kind = kind;
    this.log_level = log_level;
  }
  onOpen() {
    const ui = UiBuilder(this.contentEl, this.kind, this.log_level, { h1: "New Kind model" });
    const core2 = ui.sectionHeading("Core Config");
    core2("Name", "the unique name for this Kind", "name").addTextInput();
    core2(
      "Tag",
      "the tag which will be used to identify this Kind; no need to include '#' symbol though you're free to.",
      "tag"
    ).addTextInput();
    core2(
      "Classification",
      () => classification(this.kind._classification_type).desc,
      "_classification_type"
    ).addDropdown(CLASSIFICATION);
    const filesAndFolders = ui.sectionHeading(
      "Filename and Folders",
      'When you use the "add kinded page" command, this will determine which folders are offered as possible locations'
    );
    filesAndFolders(
      "Favorite Folder",
      "the folder you most associate with this kind",
      "_folder_favorite"
    ).addTextInput();
    filesAndFolders(
      "Include Subdirectories",
      "whether the sub-directories under your favorite folder should be offered as options",
      "_show_sub_dirs"
    ).addToggleSwitch();
    filesAndFolders(
      "Current Directory",
      "whether to allow current directory to be a valid location",
      "_folder_include_cwd"
    ).addToggleSwitch({
      refreshDomOnChange: true
    });
    if (this.kind._folder_include_cwd) {
      filesAndFolders(
        "Default Directory",
        "whether the current directory or the favorite dir should be the default",
        "_classification_type"
      ).addDropdown(FOLDER_DEFAULT);
    }
    filesAndFolders(
      "Filename Date Prefix",
      "whether or not the file name should be prefixed with a date",
      "_filename_date_prefix"
    ).addToggleSwitch();
    const properties = ui.sectionHeading(
      "Properties",
      "In this section you can add Relationships and Metrics"
    );
    properties(
      "Add Relationship",
      "The classification strategy sets up an abstracted set of relationships but sometimes you want a direct relationship to another kind. You can add them here.",
      "_relationships"
    ).addButton({
      icon: "key",
      buttonText: "+",
      onClick: () => {
        this.kind._relationships.push({ prop: "", fk_kind: "", cardinality: "0:1" });
      }
    });
    properties(
      "Add Metric",
      'Metrics are numeric properties which are associated with a unit of measure. When added to a kind these properties will be added as properties to the page; you can fill them in manually or you can use the "Add Metrics" command to be brought through it via script.',
      "_metric_props"
    ).addButton({
      icon: "binary",
      buttonText: "+",
      onClick: () => {
        this.kind._metric_props.push({ name: "", uom_type: "mass" });
      }
    });
    const metrics = this.kind._metric_props;
    for (const key in this.kind._metric_props) {
      ui(
        metrics[key].name,
        () => metrics[key].name.trim() === "" ? "new property" : "existing property",
        "_metric_props",
        key
      ).addDropdown(UOM_TYPES);
    }
    const auto2 = ui.sectionHeading("Auto Aliases", "When you're working on a kind page -- or any classification of a kind page -- you configure whether the `aliases` assigned to that page are automatically added to in smart ways.");
    auto2(
      "Plural/Singular",
      "Ensure that both the singular and plural versions of a Kind page are available",
      "_aliases_plural"
    ).addToggleSwitch();
    auto2(
      "Casing",
      "Ensure that the page's name is available in lowercase as well as capitalized",
      "_aliases_lowercase"
    ).addToggleSwitch();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}
const ClassificationLookup = {
  category: [
    ["category"],
    {},
    "A 0:1 relationship to a category only"
  ],
  "category and subcategory": [
    ["category", "sub_category"],
    {},
    "A 0:1 hierarchical classification: a category and a sub-category of the parent category."
  ],
  categories: [
    ["categories"],
    {},
    "A 0:M relationship to any number of categories."
  ],
  "grouped categories": [
    ["categories"],
    { categories: "group" },
    "A 0:M relationship to any number of categories where the categories themselves have a 'group' property which organizes them."
  ]
};
const classification = (c) => ({
  name: c,
  kind_props: ClassificationLookup[c][0],
  other_props: ClassificationLookup[c][1],
  desc: ClassificationLookup[c][2]
});
class SettingsTab extends PluginSettingTab {
  constructor(app2, plugin4) {
    super(app2, plugin4);
    __publicField(this, "app");
    __publicField(this, "plugin");
    __publicField(this, "saveSettings");
    __publicField(this, "debug");
    __publicField(this, "info");
    __publicField(this, "warn");
    __publicField(this, "error");
    this.app = app2;
    this.plugin = plugin4;
  }
  display() {
    const { info: info2, debug: debug2 } = logger(this.plugin.settings.log_level);
    debug2(`The settings menu has been brought up and we start in this state: `, this.plugin.settings);
    const ui = UiBuilder(
      this.containerEl,
      this.plugin.settings,
      this.plugin.settings.log_level,
      { h1: "Kind Models", saveState: this.plugin.saveSettings.bind(this.plugin) }
    );
    ui(
      "Handle Tags",
      "how to manage tags between page and frontmatter",
      "handle_tags"
    ).addDropdown(TAG_HANDLING);
    ui(
      "Folder Location",
      "All 'kind', and 'type' definitions will be located here",
      "kind_folder"
    ).addFolderSearch();
    const kinds = ui.sectionHeading(
      "Kinds",
      'The basic building block this plugin provides is a Kind. Each Kind represents some sort of entity. These entities can be "classified ", grouped into broader "types", have relationships to other pages formalized, and have metrics added so that summary views of this kind can provide useful comparison metrics.'
    );
    kinds(
      "Default Classification",
      "Each kind gets to state it's classification model but here you can state the default choice",
      "default_classification"
    ).addDropdown(CLASSIFICATION);
    kinds(
      "List of Kind Models",
      "Existing kinds are listed below; use button to add another",
      "kinds"
    ).addButton({
      icon: "package-plus",
      onClick: () => {
        new KindModal(this.app, DEFAULT_KIND, this.plugin.settings.log_level).open();
      }
    });
    const types = ui.sectionHeading(
      "Types",
      `Types provide a grouping function for Kinds. You can specify as many as you like and then later map 1:M Kinds to these types. Each type will receive it's own page and the kinds related to it will have a "type" property which points to this page.`
    );
    types(
      "List of Types",
      'Add a new "type" by pressing button or manually by creating a file in `${}.',
      "types"
    ).addButton({
      icon: "plus-circle",
      onClick: () => {
        console.log("add new type");
      }
    });
    const urls = ui.sectionHeading(
      "URLs",
      "This section deals with understanding URLs in the body of content as well as what properties in frontmatter should be considered for URL links."
    );
    urls(
      "URL Properties",
      "Add a property that may reside in frontmatter and indicate a URL or list of URLs",
      "url_props"
    ).addButton({
      icon: "list-plus",
      onClick: () => console.log("add URL props")
    });
    urls(
      "URL Patterns",
      "Setup regular expressions to map links in the page to a property or to modify the icon for that link in summary views.",
      "url_patterns"
    ).addButton({
      icon: "git-branch-plus",
      onClick: () => console.log("add URL patterns", this.plugin.settings)
    });
    const blocks = ui.sectionHeading(
      "Page Blocks",
      'With page blocks you can map page template blocks to various kind types and by doing so that page will be updated with these sections whenever the "update page" command is run.'
    );
    blocks(
      "Page Blocks",
      "Add to the page blocks made available to kinds.",
      "page_blocks"
    ).addButton({
      icon: "file-plus"
    });
    const ops = ui.sectionHeading("Operations");
    ops(
      "Bulk Operations",
      "Use buttons to take desired action: sync, snapshot, restore, reset.",
      null
    ).addButton({
      icon: "refresh-ccw",
      buttonText: "Sync",
      backgroundColor: "indigo",
      tooltip: `Synchronize the kind definitions in your vault's "kind folder" with the settings here.`
    }).addButton({
      icon: "download",
      buttonText: "Snapshot",
      backgroundColor: "blue",
      tooltip: "Save current configuration as a Snapshot (which can be restored later)"
    }).addButton({
      icon: "clipboard-copy",
      buttonText: "Clipboard",
      backgroundColor: "blue",
      tooltip: "Copy your current configuration to the clipboard"
    }).addButton({
      icon: "upload",
      buttonText: "Restore",
      backgroundColor: "blue",
      tooltip: "Restore configuration from a snapshot or clipboard"
    }).addButton({
      icon: "reset",
      buttonText: "Reset",
      onClick: () => info2("reset clicked"),
      backgroundColor: "red",
      tooltip: "Restore configuration to Plugin Default"
    });
    ops(
      "Log Level",
      "if you're experiencing problems you think could be related to this plugin you can change the log level to get more info sent to the developer console.",
      "log_level"
    ).addDropdown(LOG_LEVELS);
  }
}
const FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
const CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
const SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code\])?$/;
function parse$1(error2, options2) {
  if (typeof error2.stacktrace !== "undefined" || typeof error2["opera#sourceloc"] !== "undefined")
    return parseOpera(error2);
  else if (error2.stack && error2.stack.match(CHROME_IE_STACK_REGEXP))
    return parseV8OrIE(error2);
  else if (error2.stack)
    return parseFFOrSafari(error2);
  else throw new Error("Cannot parse given Error object");
}
function extractLocation(urlLike) {
  if (!urlLike.includes(":"))
    return [urlLike, void 0, void 0];
  const regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
  const parts = regExp.exec(urlLike.replace(/[()]/g, ""));
  return [parts[1], parts[2] || void 0, parts[3] || void 0];
}
function applySlice(lines, options2) {
  return lines;
}
function parseV8OrIE(error2, options2) {
  return parseV8OrIeString(error2.stack);
}
function parseV8OrIeString(stack, options2) {
  const filtered = applySlice(
    stack.split("\n").filter((line) => {
      return !!line.match(CHROME_IE_STACK_REGEXP);
    })
  );
  return filtered.map((line) => {
    if (line.includes("(eval ")) {
      line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, "");
    }
    let sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, "");
    const location2 = sanitizedLine.match(/ (\(.+\)$)/);
    sanitizedLine = location2 ? sanitizedLine.replace(location2[0], "") : sanitizedLine;
    const locationParts = extractLocation(location2 ? location2[1] : sanitizedLine);
    const functionName = location2 && sanitizedLine || void 0;
    const fileName = ["eval", "<anonymous>"].includes(locationParts[0]) ? void 0 : locationParts[0];
    return {
      function: functionName,
      file: fileName,
      line: locationParts[1] ? +locationParts[1] : void 0,
      col: locationParts[2] ? +locationParts[2] : void 0,
      raw: line
    };
  });
}
function parseFFOrSafari(error2, options2) {
  return parseFFOrSafariString(error2.stack);
}
function parseFFOrSafariString(stack, options2) {
  const filtered = applySlice(
    stack.split("\n").filter((line) => {
      return !line.match(SAFARI_NATIVE_CODE_REGEXP);
    })
  );
  return filtered.map((line) => {
    if (line.includes(" > eval"))
      line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1");
    if (!line.includes("@") && !line.includes(":")) {
      return {
        function: line
      };
    } else {
      const functionNameRegex = /(([^\n\r"\u2028\u2029]*".[^\n\r"\u2028\u2029]*"[^\n\r@\u2028\u2029]*(?:@[^\n\r"\u2028\u2029]*"[^\n\r@\u2028\u2029]*)*(?:[\n\r\u2028\u2029][^@]*)?)?[^@]*)@/;
      const matches = line.match(functionNameRegex);
      const functionName = matches && matches[1] ? matches[1] : void 0;
      const locationParts = extractLocation(line.replace(functionNameRegex, ""));
      return {
        function: functionName,
        file: locationParts[0],
        line: locationParts[1] ? +locationParts[1] : void 0,
        col: locationParts[2] ? +locationParts[2] : void 0,
        raw: line
      };
    }
  });
}
function parseOpera(e2, options2) {
  if (!e2.stacktrace || e2.message.includes("\n") && e2.message.split("\n").length > e2.stacktrace.split("\n").length)
    return parseOpera9(e2);
  else if (!e2.stack)
    return parseOpera10(e2);
  else
    return parseOpera11(e2);
}
function parseOpera9(e2, options2) {
  const lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
  const lines = e2.message.split("\n");
  const result = [];
  for (let i = 2, len = lines.length; i < len; i += 2) {
    const match2 = lineRE.exec(lines[i]);
    if (match2) {
      result.push({
        file: match2[2],
        line: +match2[1],
        raw: lines[i]
      });
    }
  }
  return applySlice(result);
}
function parseOpera10(e2, options2) {
  const lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
  const lines = e2.stacktrace.split("\n");
  const result = [];
  for (let i = 0, len = lines.length; i < len; i += 2) {
    const match2 = lineRE.exec(lines[i]);
    if (match2) {
      result.push({
        function: match2[3] || void 0,
        file: match2[2],
        line: match2[1] ? +match2[1] : void 0,
        raw: lines[i]
      });
    }
  }
  return applySlice(result);
}
function parseOpera11(error2, options2) {
  const filtered = applySlice(
    // @ts-expect-error missing stack property
    error2.stack.split("\n").filter((line) => {
      return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
    })
  );
  return filtered.map((line) => {
    const tokens2 = line.split("@");
    const locationParts = extractLocation(tokens2.pop());
    const functionCall = tokens2.shift() || "";
    const functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^)]*\)/g, "") || void 0;
    let argsRaw;
    if (functionCall.match(/\(([^)]*)\)/))
      argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, "$1");
    const args = argsRaw === void 0 || argsRaw === "[arguments not available]" ? void 0 : argsRaw.split(",");
    return {
      function: functionName,
      args,
      file: locationParts[0],
      line: locationParts[1] ? +locationParts[1] : void 0,
      col: locationParts[2] ? +locationParts[2] : void 0,
      raw: line
    };
  });
}
const _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath(input = "") {
  if (!input) {
    return input;
  }
  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());
}
const _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
const _ROOT_FOLDER_RE = /^\/([A-Za-z]:)?$/;
function cwd() {
  if (typeof process !== "undefined" && typeof process.cwd === "function") {
    return process.cwd().replace(/\\/g, "/");
  }
  return "/";
}
const resolve$1 = function(...arguments_) {
  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
    const path = index >= 0 ? arguments_[index] : cwd();
    if (!path || path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = isAbsolute(path);
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {
    return `/${resolvedPath}`;
  }
  return resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString(path, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char = null;
  for (let index = 0; index <= path.length; ++index) {
    if (index < path.length) {
      char = path[index];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index - 1 || dots === 1) ;
      else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path.slice(lastSlash + 1, index)}`;
        } else {
          res = path.slice(lastSlash + 1, index);
        }
        lastSegmentLength = index - lastSlash - 1;
      }
      lastSlash = index;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
const isAbsolute = function(p2) {
  return _IS_ABSOLUTE_RE.test(p2);
};
const relative = function(from, to) {
  const _from = resolve$1(from).replace(_ROOT_FOLDER_RE, "$1").split("/");
  const _to = resolve$1(to).replace(_ROOT_FOLDER_RE, "$1").split("/");
  if (_to[0][1] === ":" && _from[0][1] === ":" && _from[0] !== _to[0]) {
    return _to.join("/");
  }
  const _fromCopy = [..._from];
  for (const segment of _fromCopy) {
    if (_to[0] !== segment) {
      break;
    }
    _from.shift();
    _to.shift();
  }
  return [..._from.map(() => ".."), ..._to].join("/");
};
var LOWER_ALPHA_CHARS = [
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z"
];
var NUMERIC_CHAR = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9"
];
var WideAssignment = {
  boolean: () => "<<boolean>>",
  string: () => "<<string>>",
  number: () => "<<number>>",
  symbol: () => "<<symbol>>",
  null: () => "<<null>>",
  function: () => "<<function>>",
  tuple: () => "<<tuple>>",
  singularTuple: () => ["<<tuple>>"],
  object: () => "<<object>>",
  emptyObject: () => "<<empty-object>>",
  undefined: () => "<<undefined>>",
  /**
   * run-time value is a type token for `unknown` and type is of course `unknown`
   */
  unknown: () => "<<unknown>>",
  nothing: () => "<<nothing>>",
  something: () => "<<something>>"
};
var wide = WideAssignment;
var entry = (refType, desc, ...params) => [
  refType(wide),
  desc,
  params.map(
    (i) => typeof i === "function" ? i(wide) : i
  )
];
({
  "Extends": entry((t2) => t2.unknown(), "extends the type", (t2) => t2.unknown()),
  "NotExtends": entry((t2) => t2.unknown(), "does not extent the type", (t2) => t2.unknown()),
  "Equals": entry((t2) => t2.unknown(), "equals the type", (t2) => t2.unknown()),
  "NotEqual": entry((t2) => t2.unknown(), "does not equal the type", (t2) => t2.unknown()),
  "Truthy": entry((t2) => t2.unknown(), "must be a truthy value"),
  "Falsy": entry((t2) => t2.unknown(), "must be a falsy value"),
  "IsSomething": entry((t2) => t2.unknown(), "must be 'something' (aka, not null or undefined)"),
  "IsNothing": entry((t2) => t2.unknown(), "must be 'nothing' (aka, null or undefined)"),
  "IsString": entry((t2) => t2.string(), "must extend a string type"),
  "IsNumber": entry((t2) => t2.number(), "must extend a number type"),
  "IsBoolean": entry((t2) => t2.boolean(), "must extend a boolean type"),
  // numeric
  "GreaterThan": entry((t2) => t2.number(), "must be a numeric literal greater than [[0]]", (t2) => t2.number()),
  "LessThan": entry((t2) => t2.number(), "must be a numeric literal less than [[0]]", (t2) => t2.number()),
  // string
  "StartsWith": entry((t2) => t2.string(), "must be a string literal that starts with '[[0]]'", (t2) => t2.string()),
  "EndsWith": entry((t2) => t2.string(), "must be a string literal that ends with '[[0]]'", (t2) => t2.string()),
  "Includes": entry((t2) => t2.string(), "must be a string literal that includes the substring '[[0]]'", (t2) => t2.string()),
  // function
  "ReturnsSomething": entry((t2) => t2.function(), "must be a function which returns 'something' (aka, not null or undefined)"),
  "ReturnsNothing": entry((t2) => t2.function(), "must be a function which returns 'nothing' (aka, null or undefined)"),
  "ReturnsTrue": entry((t2) => t2.function(), "must be a function which returns 'true'"),
  "ReturnsFalse": entry((t2) => t2.function(), "must be a function which returns 'false'"),
  "ReturnsTruthy": entry((t2) => t2.function(), "must be a function which returns a 'truthy' value"),
  "ReturnsFalsy": entry((t2) => t2.function(), "must be a function which returns a 'falsy' value"),
  "ReturnsExtends": entry((t2) => t2.unknown(), "must be a function which returns a value which extends [[0]]", (t2) => t2.unknown()),
  "ReturnsEquals": entry((t2) => t2.unknown(), "must be a function which returns a value which equals [[0]]", (t2) => t2.unknown()),
  "Contains": entry((t2) => t2.tuple(), "must be a tuple and have elements that extends the value [[0]]", (t2) => t2.unknown()),
  // TODO: get the below working`
  "ContainsSome": entry((t2) => t2.tuple(), "must be a tuple and have elements that extends the value [[0]]", (t2) => t2.singularTuple())
});
var SIMPLE_SCALAR_TOKENS = [
  "string",
  "number",
  `string(TOKEN)`,
  `number(TOKEN)`,
  "boolean",
  "true",
  "false",
  "null",
  "undefined",
  "unknown",
  "any",
  "never"
];
var SIMPLE_OPT_SCALAR_TOKENS = [
  "Opt<string>",
  "Opt<number>",
  "Opt<boolean>",
  "Opt<true>",
  "Opt<false>",
  "Opt<null>",
  "Opt<undefined>",
  "Opt<unknown>",
  "Opt<any>",
  "Opt<string(TOKEN)>",
  "Opt<number(TOKEN)>",
  "Opt<undefined>"
];
var SIMPLE_UNION_TOKENS = [
  `Union(TOKEN)`
];
var SIMPLE_DICT_TOKENS = [
  "Dict",
  "Dict<string, string>",
  "Dict<string, number>",
  "Dict<string, boolean>",
  "Dict<string, unknown>",
  "Dict<string, Opt<string>>",
  "Dict<string, Opt<number>>",
  "Dict<string, Opt<boolean>>",
  "Dict<string, Opt<unknown>>",
  "Dict<{TOKEN: TOKEN}>",
  "Dict<{TOKEN: TOKEN, TOKEN: TOKEN}>"
];
var SIMPLE_ARRAY_TOKENS = [
  "Array",
  "Array<string>",
  "Array<string(TOKEN)>",
  "Array<number>",
  "Array<number(TOKEN)>",
  "Array<boolean>",
  "Array<unknown>",
  `Array<Dict>`,
  `Array<Set>`,
  `Array<Map>`
];
var SIMPLE_MAP_TOKENS = [
  "Map",
  "Map<TOKEN, TOKEN>",
  "WeakMap"
];
var SIMPLE_SET_TOKENS = [
  "Set",
  "Set<TOKEN>"
];
var SIMPLE_CONTAINER_TOKENS = [
  ...SIMPLE_DICT_TOKENS,
  ...SIMPLE_ARRAY_TOKENS,
  ...SIMPLE_MAP_TOKENS,
  ...SIMPLE_SET_TOKENS
];
var SIMPLE_TOKENS = [
  ...SIMPLE_SCALAR_TOKENS,
  ...SIMPLE_OPT_SCALAR_TOKENS,
  ...SIMPLE_CONTAINER_TOKENS,
  ...SIMPLE_UNION_TOKENS
];
var US_STATE_LOOKUP_STRICT = [
  { name: "Alabama", abbrev: "AL" },
  { name: "Alaska", abbrev: "AK" },
  { name: "Arizona", abbrev: "AZ" },
  { name: "Arkansas", abbrev: "AR" },
  { name: "California", abbrev: "CA" },
  { name: "Colorado", abbrev: "CO" },
  { name: "Connecticut", abbrev: "CT" },
  { name: "Delaware", abbrev: "DE" },
  { name: "Florida", abbrev: "FL" },
  { name: "Georgia", abbrev: "GA" },
  { name: "Hawaii", abbrev: "HI" },
  { name: "Idaho", abbrev: "ID" },
  { name: "Illinois", abbrev: "IL" },
  { name: "Indiana", abbrev: "IN" },
  { name: "Iowa", abbrev: "IA" },
  { name: "Kansas", abbrev: "KS" },
  { name: "Kentucky", abbrev: "KY" },
  { name: "Louisiana", abbrev: "LA" },
  { name: "Maine", abbrev: "ME" },
  { name: "Maryland", abbrev: "MD" },
  { name: "Massachusetts", abbrev: "MA" },
  { name: "Michigan", abbrev: "MI" },
  { name: "Minnesota", abbrev: "MN" },
  { name: "Mississippi", abbrev: "MS" },
  { name: "Missouri", abbrev: "MO" },
  { name: "Montana", abbrev: "MT" },
  { name: "Nebraska", abbrev: "NE" },
  { name: "Nevada", abbrev: "NV" },
  { name: "New Hampshire", abbrev: "NH" },
  { name: "New Jersey", abbrev: "NJ" },
  { name: "New Mexico", abbrev: "NM" },
  { name: "New York", abbrev: "NY" },
  { name: "North Carolina", abbrev: "NC" },
  { name: "North Dakota", abbrev: "ND" },
  { name: "Ohio", abbrev: "OH" },
  { name: "Oklahoma", abbrev: "OK" },
  { name: "Oregon", abbrev: "OR" },
  { name: "Pennsylvania", abbrev: "PA" },
  { name: "Rhode Island", abbrev: "RI" },
  { name: "South Carolina", abbrev: "SC" },
  { name: "South Dakota", abbrev: "SD" },
  { name: "Tennessee", abbrev: "TN" },
  { name: "Texas", abbrev: "TX" },
  { name: "Utah", abbrev: "UT" },
  { name: "Vermont", abbrev: "VT" },
  { name: "Virginia", abbrev: "VA" },
  { name: "Washington", abbrev: "WA" },
  { name: "West Virginia", abbrev: "WV" },
  { name: "Wisconsin", abbrev: "WI" },
  { name: "Wyoming", abbrev: "WY" }
];
var US_STATE_LOOKUP_PROVINCES = [
  { name: "Puerto Rico", abbrev: "PR" },
  { name: "Virgin Islands", abbrev: "VI" },
  { name: "Palau", abbrev: "PW" },
  { name: "Federated States of Micronesia", abbrev: "FM" },
  { name: "Northern Mariana Islands", abbrev: "MP" },
  { name: "District of Columbia", abbrev: "DC" },
  { name: "Marshall Islands", abbrev: "MH" },
  { name: "American Samoa", abbrev: "AS" },
  { name: "Guam", abbrev: "GU" }
];
var US_STATE_LOOKUP = [
  ...US_STATE_LOOKUP_STRICT,
  ...US_STATE_LOOKUP_PROVINCES
];
var REPO_SOURCE_LOOKUP = {
  "github": [`https://github.com`, "https://github.io"],
  "bitbucket": ["https://bitbucket.org"],
  "gitlab": ["https://gitlab.com"],
  "codecommit": ["https://aws.amazon.com/codecommit/"],
  "local": []
};
var NETWORK_PROTOCOL_LOOKUP = {
  http: ["http", "https"],
  ftp: ["ftp", "sftp"],
  file: ["", "file"],
  ws: ["ws", "wss"],
  ssh: ["", "ssh"],
  "scp": ["", "scp"]
};
var WHITESPACE_CHARS = [
  " ",
  "\n",
  "	",
  "\b"
];
var AMAZON_DNS = [
  "www.amazon.com",
  `www.amazon.co.uk`,
  `www.amazon.fr`,
  `www.amazon.de`,
  `www.amazon.it`,
  `www.amazon.es`
];
var APPLE_DNS = [
  "store.apple.com",
  "www.apple.com"
];
var HOME_DEPOT_DNS = [
  "www.homedepot.com",
  "www.homedepot.ca"
];
var EBAY_DNS = [
  "www.ebay.com",
  "www.ebay.co.uk",
  "www.ebay.fr",
  "www.ebay.de",
  "www.ebay.it"
];
var TARGET_DNS = [
  "www.target.com"
];
var ETSY_DNS = [
  "www.etsy.com"
];
var COSTCO_DNS = [
  "www.costco.com",
  "www.costco.co.uk",
  "www.costco.ca"
];
var BEST_BUY_DNS = [
  "www.bestbuy.com",
  "www.bestbuy.ca"
];
var WAYFAIR_DNS = [
  "www.wayfair.com",
  "www.wayfair.ca",
  "www.wayfair.co.uk"
];
var NIKE_DNS = [
  "www.nike.com"
];
var MACYS_DNS = [
  "www.macys.com"
];
var DELL_DNS = [
  "www.dell.com"
];
var HM_DNS = [
  "www2.hm.com"
];
var ZARA_DNS = [
  "www.zara.com"
];
var KROGER_DNS = [
  "www.kroger.com"
];
var WALGREENS_DNS = [
  "www.walgreens.com"
];
var CVS_DNS = [
  "www.cvs.com"
];
var WHOLE_FOODS_DNS = [
  "www.wholefoodsmarket.com",
  "www.wholefoodsmarket.co.uk"
];
var ISO3166_1 = [
  { name: "Afghanistan", alpha2: "AF", countryCode: "004", alpha3: "AFG" },
  { name: "Albania", alpha2: "AL", countryCode: "008", alpha3: "ALB" },
  { name: "Algeria", alpha2: "DZ", countryCode: "012", alpha3: "DZA" },
  { name: "Andorra", alpha2: "AD", countryCode: "020", alpha3: "AND" },
  { name: "Angola", alpha2: "AO", countryCode: "024", alpha3: "AGO" },
  { name: "Argentina", alpha2: "AR", countryCode: "032", alpha3: "ARG" },
  { name: "Australia", alpha2: "AU", countryCode: "036", alpha3: "AUS" },
  { name: "Austria", alpha2: "AT", countryCode: "040", alpha3: "AUT" },
  { name: "Azerbaijan", alpha2: "AZ", countryCode: "031", alpha3: "AZE" },
  { name: "Bahamas", alpha2: "BS", countryCode: "044", alpha3: "BHS" },
  { name: "Bangladesh", alpha2: "BD", countryCode: "050", alpha3: "BGD" },
  { name: "Belgium", alpha2: "BE", countryCode: "056", alpha3: "BEL" },
  { name: "Belize", alpha2: "BZ", countryCode: "084", alpha3: "BLZ" },
  { name: "Benin", alpha2: "BJ", countryCode: "204", alpha3: "BEN" },
  { name: "Bhutan", alpha2: "BT", countryCode: "064", alpha3: "BTN" },
  { name: "Bolivia", alpha2: "BO", countryCode: "068", alpha3: "BOL" },
  { name: "Bosnia and Herzegovina", alpha2: "BA", countryCode: "070", alpha3: "BIH" },
  { name: "Botswana", alpha2: "BW", countryCode: "072", alpha3: "BWA" },
  { name: "Brazil", alpha2: "BR", countryCode: "076", alpha3: "BRA" },
  { name: "Brunei Darussalam", alpha2: "BN", countryCode: "096", alpha3: "BRN" },
  { name: "Bulgaria", alpha2: "BG", countryCode: "100", alpha3: "BGR" },
  { name: "Burkina Faso", alpha2: "BF", countryCode: "854", alpha3: "BFA" },
  { name: "Burundi", alpha2: "BI", countryCode: "108", alpha3: "BDI" },
  { name: "Cambodia", alpha2: "KH", countryCode: "116", alpha3: "KHM" },
  { name: "Cameroon", alpha2: "CM", countryCode: "120", alpha3: "CMR" },
  { name: "Canada", alpha2: "CA", countryCode: "124", alpha3: "CAN" },
  { name: "Afghanistan", alpha2: "AF", countryCode: "004", alpha3: "AFG" },
  { name: "Albania", alpha2: "AL", countryCode: "008", alpha3: "ALB" },
  { name: "Algeria", alpha2: "DZ", countryCode: "012", alpha3: "DZA" },
  { name: "Andorra", alpha2: "AD", countryCode: "020", alpha3: "AND" },
  { name: "Angola", alpha2: "AO", countryCode: "024", alpha3: "AGO" },
  { name: "Argentina", alpha2: "AR", countryCode: "032", alpha3: "ARG" },
  { name: "Australia", alpha2: "AU", countryCode: "036", alpha3: "AUS" },
  { name: "Austria", alpha2: "AT", countryCode: "040", alpha3: "AUT" },
  { name: "Azerbaijan", alpha2: "AZ", countryCode: "031", alpha3: "AZE" },
  { name: "Bahamas", alpha2: "BS", countryCode: "044", alpha3: "BHS" },
  { name: "Bangladesh", alpha2: "BD", countryCode: "050", alpha3: "BGD" },
  { name: "Belgium", alpha2: "BE", countryCode: "056", alpha3: "BEL" },
  { name: "Belize", alpha2: "BZ", countryCode: "084", alpha3: "BLZ" },
  { name: "Benin", alpha2: "BJ", countryCode: "204", alpha3: "BEN" },
  { name: "Bhutan", alpha2: "BT", countryCode: "064", alpha3: "BTN" },
  { name: "Bolivia", alpha2: "BO", countryCode: "068", alpha3: "BOL" },
  { name: "Bosnia and Herzegovina", alpha2: "BA", countryCode: "070", alpha3: "BIH" },
  { name: "Botswana", alpha2: "BW", countryCode: "072", alpha3: "BWA" },
  { name: "Brazil", alpha2: "BR", countryCode: "076", alpha3: "BRA" },
  { name: "Brunei Darussalam", alpha2: "BN", countryCode: "096", alpha3: "BRN" },
  { name: "Bulgaria", alpha2: "BG", countryCode: "100", alpha3: "BGR" },
  { name: "Burkina Faso", alpha2: "BF", countryCode: "854", alpha3: "BFA" },
  { name: "Burundi", alpha2: "BI", countryCode: "108", alpha3: "BDI" },
  { name: "Cambodia", alpha2: "KH", countryCode: "116", alpha3: "KHM" },
  { name: "Cameroon", alpha2: "CM", countryCode: "120", alpha3: "CMR" },
  { name: "Canada", alpha2: "CA", countryCode: "124", alpha3: "CAN" },
  { name: "Maldives", alpha2: "MV", countryCode: "462", alpha3: "MDV" },
  { name: "Mali", alpha2: "ML", countryCode: "466", alpha3: "MLI" },
  { name: "Malta", alpha2: "MT", countryCode: "470", alpha3: "MLT" },
  { name: "Marshall Islands", alpha2: "MH", countryCode: "584", alpha3: "MHL" },
  { name: "Mauritania", alpha2: "MR", countryCode: "478", alpha3: "MRT" },
  { name: "Mauritius", alpha2: "MU", countryCode: "480", alpha3: "MUS" },
  { name: "Mexico", alpha2: "MX", countryCode: "484", alpha3: "MEX" },
  { name: "Micronesia (Federated States of)", alpha2: "FM", countryCode: "583", alpha3: "FSM" },
  { name: "Moldova (Republic of)", alpha2: "MD", countryCode: "498", alpha3: "MDA" },
  { name: "Monaco", alpha2: "MC", countryCode: "492", alpha3: "MCO" },
  { name: "Mongolia", alpha2: "MN", countryCode: "496", alpha3: "MNG" },
  { name: "Montenegro", alpha2: "ME", countryCode: "499", alpha3: "MNE" },
  { name: "Morocco", alpha2: "MA", countryCode: "504", alpha3: "MAR" },
  { name: "Mozambique", alpha2: "MZ", countryCode: "508", alpha3: "MOZ" },
  { name: "Myanmar", alpha2: "MM", countryCode: "104", alpha3: "MMR" },
  { name: "Namibia", alpha2: "NA", countryCode: "516", alpha3: "NAM" },
  { name: "Nauru", alpha2: "NR", countryCode: "520", alpha3: "NRU" },
  { name: "Nepal", alpha2: "NP", countryCode: "524", alpha3: "NPL" },
  { name: "Netherlands", alpha2: "NL", countryCode: "528", alpha3: "NLD" },
  { name: "New Zealand", alpha2: "NZ", countryCode: "554", alpha3: "NZL" },
  { name: "Nicaragua", alpha2: "NI", countryCode: "558", alpha3: "NIC" },
  { name: "Niger", alpha2: "NE", countryCode: "562", alpha3: "NER" },
  { name: "Nigeria", alpha2: "NG", countryCode: "566", alpha3: "NGA" },
  { name: "North Macedonia", alpha2: "MK", countryCode: "807", alpha3: "MKD" },
  { name: "Norway", alpha2: "NO", countryCode: "578", alpha3: "NOR" },
  { name: "Oman", alpha2: "OM", countryCode: "512", alpha3: "OMN" },
  { name: "Pakistan", alpha2: "PK", countryCode: "586", alpha3: "PAK" },
  { name: "Palau", alpha2: "PW", countryCode: "585", alpha3: "PLW" },
  { name: "Panama", alpha2: "PA", countryCode: "591", alpha3: "PAN" },
  { name: "Papua New Guinea", alpha2: "PG", countryCode: "598", alpha3: "PNG" },
  { name: "Paraguay", alpha2: "PY", countryCode: "600", alpha3: "PRY" },
  { name: "Peru", alpha2: "PE", countryCode: "604", alpha3: "PER" },
  { name: "Philippines", alpha2: "PH", countryCode: "608", alpha3: "PHL" },
  { name: "Poland", alpha2: "PL", countryCode: "616", alpha3: "POL" },
  { name: "Portugal", alpha2: "PT", countryCode: "620", alpha3: "PRT" },
  { name: "Qatar", alpha2: "QA", countryCode: "634", alpha3: "QAT" },
  { name: "Romania", alpha2: "RO", countryCode: "642", alpha3: "ROU" },
  { name: "Russian Federation", alpha2: "RU", countryCode: "643", alpha3: "RUS" },
  { name: "Rwanda", alpha2: "RW", countryCode: "646", alpha3: "RWA" },
  { name: "Saint Kitts and Nevis", alpha2: "KN", countryCode: "659", alpha3: "KNA" },
  { name: "Saint Lucia", alpha2: "LC", countryCode: "662", alpha3: "LCA" },
  { name: "Saint Vincent and the Grenadines", alpha2: "VC", countryCode: "670", alpha3: "VCT" },
  { name: "Samoa", alpha2: "WS", countryCode: "882", alpha3: "WSM" },
  { name: "San Marino", alpha2: "SM", countryCode: "674", alpha3: "SMR" },
  { name: "Sao Tome and Principe", alpha2: "ST", countryCode: "678", alpha3: "STP" },
  { name: "Saudi Arabia", alpha2: "SA", countryCode: "682", alpha3: "SAU" },
  { name: "Senegal", alpha2: "SN", countryCode: "686", alpha3: "SEN" },
  { name: "Serbia", alpha2: "RS", countryCode: "688", alpha3: "SRB" },
  { name: "Seychelles", alpha2: "SC", countryCode: "690", alpha3: "SYC" },
  { name: "Sierra Leone", alpha2: "SL", countryCode: "694", alpha3: "SLE" },
  { name: "Singapore", alpha2: "SG", countryCode: "702", alpha3: "SGP" },
  { name: "Slovakia", alpha2: "SK", countryCode: "703", alpha3: "SVK" },
  { name: "Slovenia", alpha2: "SI", countryCode: "705", alpha3: "SVN" },
  { name: "Solomon Islands", alpha2: "SB", countryCode: "090", alpha3: "SLB" },
  { name: "Somalia", alpha2: "SO", countryCode: "706", alpha3: "SOM" },
  { name: "South Africa", alpha2: "ZA", countryCode: "710", alpha3: "ZAF" },
  { name: "South Sudan", alpha2: "SS", countryCode: "728", alpha3: "SSD" },
  { name: "Spain", alpha2: "ES", countryCode: "724", alpha3: "ESP" },
  { name: "Sri Lanka", alpha2: "LK", countryCode: "144", alpha3: "LKA" },
  { name: "Sudan", alpha2: "SD", countryCode: "729", alpha3: "SDN" },
  { name: "Suriname", alpha2: "SR", countryCode: "740", alpha3: "SUR" },
  { name: "Sweden", alpha2: "SE", countryCode: "752", alpha3: "SWE" },
  { name: "Switzerland", alpha2: "CH", countryCode: "756", alpha3: "CHE" },
  { name: "Syrian Arab Republic", alpha2: "SY", countryCode: "760", alpha3: "SYR" },
  { name: "Taiwan", alpha2: "TW", countryCode: "158", alpha3: "TWN" },
  { name: "Tajikistan", alpha2: "TJ", countryCode: "762", alpha3: "TJK" },
  { name: "Tanzania", alpha2: "TZ", countryCode: "834", alpha3: "TZA" },
  { name: "Thailand", alpha2: "TH", countryCode: "764", alpha3: "THA" },
  { name: "Timor-Leste", alpha2: "TL", countryCode: "626", alpha3: "TLS" },
  { name: "Togo", alpha2: "TG", countryCode: "768", alpha3: "TGO" },
  { name: "Tonga", alpha2: "TO", countryCode: "776", alpha3: "TON" },
  { name: "Tonga", alpha2: "TO", countryCode: "776", alpha3: "TON" },
  { name: "Trinidad and Tobago", alpha2: "TT", countryCode: "780", alpha3: "TTO" },
  { name: "Tunisia", alpha2: "TN", countryCode: "788", alpha3: "TUN" },
  { name: "Turkey", alpha2: "TR", countryCode: "792", alpha3: "TUR" },
  { name: "Turkmenistan", alpha2: "TM", countryCode: "795", alpha3: "TKM" },
  { name: "Tuvalu", alpha2: "TV", countryCode: "798", alpha3: "TUV" },
  { name: "Uganda", alpha2: "UG", countryCode: "800", alpha3: "UGA" },
  { name: "Ukraine", alpha2: "UA", countryCode: "804", alpha3: "UKR" },
  { name: "United Arab Emirates", alpha2: "AE", countryCode: "784", alpha3: "ARE" },
  { name: "United Kingdom", alpha2: "GB", countryCode: "826", alpha3: "GBR" },
  { name: "United States of America", alpha2: "US", countryCode: "840", alpha3: "USA" },
  { name: "Uruguay", alpha2: "UY", countryCode: "858", alpha3: "URY" },
  { name: "Uzbekistan", alpha2: "UZ", countryCode: "860", alpha3: "UZB" },
  { name: "Vanuatu", alpha2: "VU", countryCode: "548", alpha3: "VUT" },
  { name: "Venezuela", alpha2: "VE", countryCode: "862", alpha3: "VEN" },
  { name: "Viet Nam", alpha2: "VN", countryCode: "704", alpha3: "VNM" },
  { name: "Yemen", alpha2: "YE", countryCode: "887", alpha3: "YEM" },
  { name: "Zambia", alpha2: "ZM", countryCode: "894", alpha3: "ZMB" },
  { name: "Zimbabwe", alpha2: "ZW", countryCode: "716", alpha3: "ZWE" }
];
var DISTANCE_METRICS_LOOKUP = [
  { abbrev: "km", name: "kilometer" },
  { abbrev: "mi", name: "mile" },
  { abbrev: "mm", name: "millimeter" },
  { abbrev: "cm", name: "centimeter" },
  { abbrev: "yd", name: "yard" },
  { abbrev: "ft", name: "foot" },
  { abbrev: "in", name: "inch" },
  { abbrev: "m", name: "meter" },
  { abbrev: "nm", name: "nautical mile" },
  { abbrev: "nmi", name: "nanometer" },
  { abbrev: "m", name: "micrometer" },
  { abbrev: "dm", name: "decimeter" },
  { abbrev: "AU", name: "astronomical unit" },
  { abbrev: "ly", name: "light year" },
  { abbrev: "pc", name: "parsec" }
];
var MASS_METRICS_LOOKUP = [
  { abbrev: "g", name: "gram" },
  { abbrev: "kg", name: "kilogram" },
  { abbrev: "mg", name: "milligram" },
  { abbrev: "g", name: "microgram" },
  { abbrev: "t", name: "tonne" },
  { abbrev: "lb", name: "pound" },
  { abbrev: "oz", name: "ounce" },
  { abbrev: "st", name: "stone" },
  { abbrev: "ct", name: "carat" },
  { abbrev: "Mt", name: "megatonne" },
  { abbrev: "gt", name: "gigatonne" },
  { abbrev: "slug", name: "slug" },
  { abbrev: "dr", name: "dram" },
  { abbrev: "gr", name: "grain" },
  { abbrev: "q", name: "quintal" }
];
var SPEED_METRICS_LOOKUP = [
  { abbrev: "m/s", name: "meters per second" },
  { abbrev: "km/h", name: "kilometers per hour" },
  { abbrev: "mph", name: "miles per hour" },
  { abbrev: "kn", name: "knot" },
  { abbrev: "ft/s", name: "feet per second" },
  { abbrev: "c", name: "speed of light" },
  { abbrev: "mach", name: "mach" },
  { abbrev: "cm/s", name: "centimeters per second" },
  { abbrev: "in/s", name: "inches per second" },
  { abbrev: "ly/y", name: "light years per year" }
];
var ACCELERATION_METRICS_LOOKUP = [
  { abbrev: "m/s", name: "meters per second squared" },
  { abbrev: "ft/s", name: "feet per second squared" },
  { abbrev: "g", name: "g-force" },
  { abbrev: "Gal", name: "galileo" },
  { abbrev: "cm/s", name: "centimeters per second squared" },
  { abbrev: "km/h", name: "kilometers per hour squared" },
  { abbrev: "in/s", name: "inches per second squared" },
  { abbrev: "mi/h", name: "miles per hour squared" },
  { abbrev: "kn/s", name: "knots per second squared" }
];
var TEMPERATURE_METRICS_LOOKUP = [
  { abbrev: "C", name: "celsius" },
  { abbrev: "F", name: "fahrenheit" },
  { abbrev: "K", name: "kelvin" }
];
var PRESSURE_METRICS_LOOKUP = [
  { abbrev: "Pa", name: "pascal" },
  { abbrev: "bar", name: "bar" },
  { abbrev: "atm", name: "atmosphere" },
  { abbrev: "mmHg", name: "millimeters of mercury" },
  { abbrev: "psi", name: "pounds per square inch" }
];
var ENERGY_METRICS_LOOKUP = [
  { abbrev: "J", name: "joule" },
  { abbrev: "cal", name: "calorie" },
  { abbrev: "kcal", name: "kilocalorie" },
  { abbrev: "kWh", name: "kilowatt-hour" },
  { abbrev: "BTU", name: "british thermal unit" },
  { abbrev: "eV", name: "electronvolt" }
];
var TIME_METRICS_LOOKUP = [
  { abbrev: "s", name: "second" },
  { abbrev: "m", name: "minute" },
  { abbrev: "h", name: "hour" },
  { abbrev: "day", name: "day" },
  { abbrev: "week", name: "week" },
  { abbrev: "mo", name: "month" },
  { abbrev: "ms", name: "millisecond" },
  { abbrev: "s", name: "microsecond" },
  { abbrev: "ns", name: "nanosecond" }
];
var POWER_METRICS_LOOKUP = [
  { abbrev: "W", name: "Watt" },
  { abbrev: "kW", name: "kilowatt" },
  { abbrev: "MW", name: "megawatt" },
  { abbrev: "hp", name: "horsepower" },
  { abbrev: "GW", name: "gigawatt" }
];
var FREQUENCY_METRICS_LOOKUP = [
  { abbrev: "Hz", name: "hertz" },
  { abbrev: "kHz", name: "kilohertz" },
  { abbrev: "MHz", name: "megahertz" },
  { abbrev: "GHz", name: "gigahertz" },
  { abbrev: "THz", name: "terahertz" }
];
var VOLTAGE_METRICS_LOOKUP = [
  { abbrev: "V", name: "volt" },
  { abbrev: "kV", name: "kilovolt" },
  { abbrev: "mV", name: "millivolt" },
  { abbrev: "V", name: "microvolt" }
];
var CURRENT_METRICS_LOOKUP = [
  { abbrev: "A", name: "ampere" },
  { abbrev: "mA", name: "milliampere" },
  { abbrev: "A", name: "microampere" },
  { abbrev: "kA", name: "kiloampere" }
];
var LUMINOSITY_METRICS_LOOKUP = [
  { abbrev: "cd", name: "candela" },
  { abbrev: "lm", name: "lumen" },
  { abbrev: "lx", name: "lux" }
];
var AREA_METRICS_LOOKUP = [
  { abbrev: "m", name: "square meter" },
  { abbrev: "cm", name: "square centimeter" },
  { abbrev: "mm", name: "square millimeter" },
  { abbrev: "km", name: "square kilometer" },
  { abbrev: "ft", name: "square foot" },
  { abbrev: "in", name: "square inch" },
  { abbrev: "acre", name: "acre" },
  { abbrev: "ha", name: "hectare" }
];
var US_NEWS = [
  { company: "New York Times", baseUrls: ["www.nytimes.com"] },
  { company: "CNN", baseUrls: ["www.cnn.com"] },
  { company: "Fox News", baseUrls: ["www.foxnews.com"] },
  { company: "NBC News", baseUrls: ["www.nbcnews.com", "www.msnbc.com"] },
  { company: "ABC News", baseUrls: ["abcnews.go.com"] },
  { company: "The Washington Post", baseUrls: ["www.washingtonpost.com"] },
  { company: "USA Today", baseUrls: ["www.usatoday.com"] },
  { company: "Bloomberg", baseUrls: ["www.bloomberg.com"] },
  { company: "NPR", baseUrls: ["www.npr.org"] },
  { company: "CBS News", baseUrls: ["www.cbsnews.com"] },
  { company: "The Wall Street Journal", baseUrls: ["www.wsj.com"] },
  { company: "Associated Press (AP)", baseUrls: ["www.apnews.com", "www.ap.org"] },
  { company: "Reuters", baseUrls: ["www.reuters.com"] },
  { company: "Newsweek", baseUrls: ["www.newsweek.com"] },
  { company: "Politico", baseUrls: ["www.politico.com"] },
  { company: "The Atlantic", baseUrls: ["www.theatlantic.com"] },
  { company: "Nexstar Media Group", baseUrls: ["www.nexstar.tv"] },
  { company: "PBS News", baseUrls: ["www.pbs.org"] },
  { company: "HuffPost", baseUrls: ["www.huffpost.com"] },
  { company: "The Boston Globe", baseUrls: ["www.bostonglobe.com"] }
];
var UK_NEWS = [
  { company: "BBC", baseUrls: ["www.bbc.co.uk", "www.bbc.com"] },
  { company: "The Guardian", baseUrls: ["www.theguardian.com/uk"] },
  { company: "The Daily Mail", baseUrls: ["www.dailymail.co.uk"] },
  { company: "The Sun", baseUrls: ["www.thesun.co.uk"] },
  { company: "The Times", baseUrls: ["www.thetimes.co.uk"] },
  { company: "Sky News", baseUrls: ["news.sky.com"] },
  { company: "The Telegraph", baseUrls: ["www.telegraph.co.uk"] },
  { company: "ITV News", baseUrls: ["www.itv.com/news"] },
  { company: "Financial Times", baseUrls: ["www.ft.com"] },
  { company: "Metro", baseUrls: ["www.metro.co.uk"] },
  { company: "The Independent", baseUrls: ["www.independent.co.uk"] },
  { company: "Evening Standard", baseUrls: ["www.standard.co.uk"] },
  { company: "Daily Mirror", baseUrls: ["www.mirror.co.uk"] },
  { company: "Channel 4 News", baseUrls: ["www.channel4.com/news"] },
  { company: "LBC", baseUrls: ["www.lbc.co.uk"] },
  { company: "Daily Express", baseUrls: ["www.express.co.uk"] },
  { company: "Birmingham Mail", baseUrls: ["www.birminghammail.co.uk"] },
  { company: "Manchester Evening News", baseUrls: ["www.manchestereveningnews.co.uk"] },
  { company: "The Scotsman", baseUrls: ["www.scotsman.com"] },
  { company: "Daily Record", baseUrls: ["www.dailyrecord.co.uk"] }
];
var GERMAN_NEWS = [
  { company: "BILD", baseUrls: ["www.bild.de"] },
  { company: "Die Zeit", baseUrls: ["www.zeit.de"] },
  { company: "Frankfurter Allgemeine Zeitung", baseUrls: ["www.faz.net"] },
  { company: "Sddeutsche Zeitung", baseUrls: ["www.sueddeutsche.de"] },
  { company: "Der Spiegel", baseUrls: ["www.spiegel.de"] },
  { company: "Die Welt", baseUrls: ["www.welt.de"] },
  { company: "Tagesschau", baseUrls: ["www.tagesschau.de"] },
  { company: "t-online", baseUrls: ["www.t-online.de"] },
  { company: "n-tv", baseUrls: ["www.n-tv.de"] },
  { company: "Handelsblatt", baseUrls: ["www.handelsblatt.com"] },
  { company: "Focus Online", baseUrls: ["www.focus.de"] },
  { company: "Frankfurter Rundschau", baseUrls: ["www.fr.de", "www.fr-online.de"] },
  { company: "taz - die tageszeitung", baseUrls: ["www.taz.de"] },
  { company: "Der Tagesspiegel", baseUrls: ["www.tagesspiegel.de"] },
  { company: "Rheinische Post", baseUrls: ["www.rp-online.de"] },
  { company: "Express", baseUrls: ["www.express.de"] },
  { company: "Mnchner Merkur", baseUrls: ["www.merkur.de"] },
  { company: "Stuttgarter Zeitung", baseUrls: ["www.stuttgarter-zeitung.de"] },
  { company: "Hamburger Abendblatt", baseUrls: ["www.abendblatt.de"] },
  { company: "Deutsche Welle", baseUrls: ["www.dw.com"] }
];
var FRENCH_NEWS = [
  { company: "Le Figaro", baseUrls: ["www.lefigaro.fr"] },
  { company: "Le Monde", baseUrls: ["www.lemonde.fr"] },
  { company: "France 24", baseUrls: ["www.france24.com"] },
  { company: "Libration", baseUrls: ["www.liberation.fr"] },
  { company: "Les Echos", baseUrls: ["www.lesechos.fr"] },
  { company: "Ouest-France", baseUrls: ["www.ouest-france.fr"] },
  { company: "Le Parisien", baseUrls: ["www.leparisien.fr"] },
  { company: "Mediapart", baseUrls: ["www.mediapart.fr"] },
  { company: "L'Express", baseUrls: ["www.lexpress.fr"] },
  { company: "La Croix", baseUrls: ["www.la-croix.com"] },
  { company: "20 Minutes", baseUrls: ["www.20minutes.fr"] },
  { company: "Courrier International", baseUrls: ["www.courrierinternational.com"] },
  { company: "Le Point", baseUrls: ["www.lepoint.fr"] },
  { company: "Marianne", baseUrls: ["www.marianne.net"] },
  { company: "BFM TV", baseUrls: ["www.bfmtv.com"] },
  { company: "RTL France", baseUrls: ["www.rtl.fr"] },
  { company: "Charlie Hebdo", baseUrls: ["www.charliehebdo.fr"] },
  { company: "Challenges", baseUrls: ["www.challenges.fr"] },
  { company: "Tlrama", baseUrls: ["www.telerama.fr"] },
  { company: "L'Obs", baseUrls: ["www.nouvelobs.com"] }
];
var CANADIAN_NEWS = [
  { company: "CBC News", baseUrls: ["www.cbc.ca"] },
  { company: "CTV News", baseUrls: ["www.ctvnews.ca"] },
  { company: "The Globe and Mail", baseUrls: ["www.theglobeandmail.com"] },
  { company: "Global News", baseUrls: ["www.globalnews.ca"] },
  { company: "Toronto Star", baseUrls: ["www.thestar.com"] },
  { company: "National Post", baseUrls: ["www.nationalpost.com"] },
  { company: "La Presse", baseUrls: ["www.lapresse.ca"] },
  { company: "Radio-Canada", baseUrls: ["ici.radio-canada.ca"] },
  { company: "The Canadian Press", baseUrls: ["www.thecanadianpress.com"] },
  { company: "Financial Post", baseUrls: ["financialpost.com"] },
  { company: "The Weather Network", baseUrls: ["www.theweathernetwork.com"] },
  { company: "Le Devoir", baseUrls: ["www.ledevoir.com"] },
  { company: "TVA Nouvelles", baseUrls: ["www.tvanouvelles.ca"] },
  { company: "Journal de Montral", baseUrls: ["www.journaldemontreal.com"] },
  { company: "CityNews", baseUrls: ["www.citynews.ca"] },
  { company: "BNN Bloomberg", baseUrls: ["www.bnnbloomberg.ca"] },
  { company: "The Hamilton Spectator", baseUrls: ["www.thespec.com"] },
  { company: "Ottawa Citizen", baseUrls: ["ottawacitizen.com"] },
  { company: "Windsor Star", baseUrls: ["windsorstar.com"] },
  { company: "Edmonton Journal", baseUrls: ["edmontonjournal.com"] }
];
var DUTCH_NEWS = [
  { company: "Algemeen Dagblad (AD)", baseUrls: ["www.ad.nl"] },
  { company: "NOS", baseUrls: ["www.nos.nl"] },
  { company: "De Telegraaf", baseUrls: ["www.telegraaf.nl"] },
  { company: "NU.nl", baseUrls: ["www.nu.nl"] },
  { company: "Volkskrant", baseUrls: ["www.volkskrant.nl"] },
  { company: "NRC Handelsblad", baseUrls: ["www.nrc.nl"] },
  { company: "Trouw", baseUrls: ["www.trouw.nl"] },
  { company: "Het Parool", baseUrls: ["www.parool.nl"] },
  { company: "RTL Nieuws", baseUrls: ["www.rtlnieuws.nl"] },
  { company: "BNR Nieuwsradio", baseUrls: ["www.bnr.nl"] },
  { company: "Emerce", baseUrls: ["www.emerce.nl"] },
  { company: "VPRO", baseUrls: ["www.vpro.nl"] },
  { company: "De Gelderlander", baseUrls: ["www.gelderlander.nl"] },
  { company: "Friesch Dagblad", baseUrls: ["www.frieschdagblad.nl"] },
  { company: "De Stentor", baseUrls: ["www.destentor.nl"] },
  { company: "Metro Nieuws", baseUrls: ["www.metronieuws.nl"] },
  { company: "ANP", baseUrls: ["www.anp.nl"] },
  { company: "Dagblad van het Noorden", baseUrls: ["www.dvhn.nl"] },
  { company: "Reformatorisch Dagblad", baseUrls: ["www.rd.nl"] },
  { company: "Financieele Dagblad", baseUrls: ["www.fd.nl"] }
];
var ITALIAN_NEWS = [
  { company: "ANSA", baseUrls: ["www.ansa.it", "www.ansamed.info"] },
  { company: "Corriere della Sera", baseUrls: ["www.corriere.it"] },
  { company: "la Repubblica", baseUrls: ["www.repubblica.it"] },
  { company: "Il Sole 24 Ore", baseUrls: ["www.ilsole24ore.com"] },
  { company: "La Stampa", baseUrls: ["www.lastampa.it"] },
  { company: "Il Messaggero", baseUrls: ["www.ilmessaggero.it"] },
  { company: "Il Giornale", baseUrls: ["www.ilgiornale.it"] },
  { company: "Avvenire", baseUrls: ["www.avvenire.it"] },
  { company: "Il Fatto Quotidiano", baseUrls: ["www.ilfattoquotidiano.it"] },
  { company: "La Nazione", baseUrls: ["www.lanazione.it"] },
  { company: "TgCom24", baseUrls: ["www.tgcom24.mediaset.it"] },
  { company: "Sky TG24", baseUrls: ["tg24.sky.it"] },
  { company: "Rai News", baseUrls: ["www.rainews.it"] },
  { company: "Gazzetta dello Sport", baseUrls: ["www.gazzetta.it"] },
  { company: "Il Resto del Carlino", baseUrls: ["www.ilrestodelcarlino.it"] },
  { company: "Il Mattino", baseUrls: ["www.ilmattino.it"] },
  { company: "Il Secolo XIX", baseUrls: ["www.ilsecoloxix.it"] },
  { company: "Italia Oggi", baseUrls: ["www.italiaoggi.it"] },
  { company: "Libero", baseUrls: ["www.liberoquotidiano.it"] },
  { company: "Il Tirreno", baseUrls: ["www.iltirreno.it"] }
];
var BELGIUM_NEWS = [
  { company: "Het Laatste Nieuws (HLN)", baseUrls: ["www.hln.be"] },
  { company: "Nieuwsblad", baseUrls: ["www.nieuwsblad.be"] },
  { company: "RTBF", baseUrls: ["www.rtbf.be"] },
  { company: "Sudinfo", baseUrls: ["www.sudinfo.be"] },
  { company: "7sur7", baseUrls: ["www.7sur7.be"] },
  { company: "Le Soir", baseUrls: ["www.lesoir.be"] },
  { company: "De Standaard", baseUrls: ["www.standaard.be"] },
  { company: "VRT NWS", baseUrls: ["www.vrt.be"] },
  { company: "La Libre", baseUrls: ["www.lalibre.be"] },
  { company: "Gazet van Antwerpen", baseUrls: ["www.gva.be"] },
  { company: "Het Belang van Limburg", baseUrls: ["www.hbvl.be"] },
  { company: "De Morgen", baseUrls: ["www.demorgen.be"] },
  { company: "L'Avenir", baseUrls: ["www.lavenir.net"] },
  { company: "The Brussels Times", baseUrls: ["www.brusselstimes.com"] },
  { company: "Metro Belgique", baseUrls: ["nl.metrotime.be"] },
  { company: "Sudpresse", baseUrls: ["www.sudpress.be"] },
  { company: "Flamish Radio and TV Broadcasting Organization (VRT)", baseUrls: ["www.vrt.be"] },
  { company: "Knack", baseUrls: ["www.knack.be"] },
  { company: "De Tijd", baseUrls: ["www.tijd.be"] },
  { company: "BX1", baseUrls: ["www.bx1.be"] }
];
var MEXICAN_NEWS = [
  { company: "Televisa", baseUrls: ["www.televisa.news"] },
  { company: "El Universal", baseUrls: ["www.eluniversal.com.mx"] },
  { company: "Milenio", baseUrls: ["www.milenio.com"] },
  { company: "Exclsior", baseUrls: ["www.excelsior.com.mx"] },
  { company: "Reforma", baseUrls: ["www.reforma.com"] },
  { company: "La Jornada", baseUrls: ["www.jornada.com.mx"] },
  { company: "El Financiero", baseUrls: ["www.elfinanciero.com.mx"] },
  { company: "Proceso", baseUrls: ["www.proceso.com.mx"] },
  { company: "SDP Noticias", baseUrls: ["www.sdpnoticias.com"] },
  { company: "Diario de Yucatn", baseUrls: ["www.yucatan.com.mx"] },
  { company: "El Economista", baseUrls: ["www.eleconomista.com.mx"] },
  { company: "El Heraldo de Mxico", baseUrls: ["www.heraldodemexico.com.mx"] },
  { company: "Noticieros Televisa", baseUrls: ["noticieros.televisa.com"] },
  { company: "Expansin", baseUrls: ["expansion.mx"] },
  { company: "La Razn", baseUrls: ["www.razon.com.mx"] },
  { company: "Noroeste", baseUrls: ["www.noroeste.com.mx"] },
  { company: "Uniradio Noticias", baseUrls: ["www.uniradionoticias.com"] },
  { company: "El Imparcial", baseUrls: ["www.elimparcial.com"] },
  { company: "Publimetro Mxico", baseUrls: ["www.publimetro.com.mx"] },
  { company: "Notimex", baseUrls: ["www.notimex.gob.mx"] }
];
var SPANISH_NEWS = [
  { company: "El Pas", baseUrls: ["www.elpais.com"] },
  { company: "El Mundo", baseUrls: ["www.elmundo.es"] },
  { company: "ABC", baseUrls: ["www.abc.es"] },
  { company: "La Vanguardia", baseUrls: ["www.lavanguardia.com"] },
  { company: "El Confidencial", baseUrls: ["www.elconfidencial.com"] },
  { company: "La Razn", baseUrls: ["www.larazon.es"] },
  { company: "20 Minutos", baseUrls: ["www.20minutos.es"] },
  { company: "Agencia EFE", baseUrls: ["www.efe.com"] },
  { company: "Europa Press", baseUrls: ["www.europapress.es"] },
  { company: "Diario AS", baseUrls: ["www.as.com"] },
  { company: "Mundo Deportivo", baseUrls: ["www.mundodeportivo.com"] },
  { company: "El Peridico", baseUrls: ["www.elperiodico.com"] },
  { company: "Cinco Das", baseUrls: ["www.cincodias.com"] },
  { company: "Expansin", baseUrls: ["www.expansion.com"] },
  { company: "La Informacin", baseUrls: ["www.lainformacion.com"] },
  { company: "OK Diario", baseUrls: ["www.okdiario.com"] },
  { company: "Heraldo de Aragn", baseUrls: ["www.heraldo.es"] },
  { company: "Faro de Vigo", baseUrls: ["www.farodevigo.es"] },
  { company: "El Correo", baseUrls: ["www.elcorreo.com"] },
  { company: "Diario Sur", baseUrls: ["www.diariosur.es"] }
];
var INDIAN_NEWS = [
  { company: "The Times of India", baseUrls: ["timesofindia.indiatimes.com"] },
  { company: "The Hindu", baseUrls: ["www.thehindu.com"] },
  { company: "Hindustan Times", baseUrls: ["www.hindustantimes.com"] },
  { company: "NDTV", baseUrls: ["www.ndtv.com"] },
  { company: "India Today", baseUrls: ["www.indiatoday.in"] },
  { company: "Zee News", baseUrls: ["zeenews.india.com"] },
  { company: "Indian Express", baseUrls: ["indianexpress.com"] },
  { company: "The Economic Times", baseUrls: ["economictimes.indiatimes.com"] },
  { company: "Deccan Herald", baseUrls: ["www.deccanherald.com"] },
  { company: "DNA India", baseUrls: ["www.dnaindia.com"] },
  { company: "The Print", baseUrls: ["theprint.in"] },
  { company: "News18", baseUrls: ["www.news18.com"] },
  { company: "Scroll.in", baseUrls: ["scroll.in"] },
  { company: "Asian News International (ANI)", baseUrls: ["www.aninews.in"] },
  { company: "Outlook India", baseUrls: ["www.outlookindia.com"] },
  { company: "Business Standard", baseUrls: ["www.business-standard.com"] },
  { company: "Mint", baseUrls: ["www.livemint.com"] },
  { company: "OneIndia", baseUrls: ["www.oneindia.com"] },
  { company: "Quint", baseUrls: ["www.thequint.com"] },
  { company: "Free Press Journal", baseUrls: ["www.freepressjournal.in"] }
];
var CHINESE_NEWS = [
  { company: "Xinhua News Agency", baseUrls: ["www.xinhuanet.com"] },
  { company: "China Central Television (CCTV)", baseUrls: ["www.cctv.com"] },
  { company: "China Daily", baseUrls: ["www.chinadaily.com.cn"] },
  { company: "CGTN (China Global Television Network)", baseUrls: ["www.cgtn.com"] },
  { company: "People's Daily", baseUrls: ["www.people.cn"] },
  { company: "Global Times", baseUrls: ["www.globaltimes.cn"] },
  { company: "South China Morning Post", baseUrls: ["www.scmp.com"] },
  { company: "Shanghai Daily", baseUrls: ["www.shanghaidaily.com"] },
  { company: "China News Service", baseUrls: ["www.ecns.cn"] },
  { company: "Caixin", baseUrls: ["www.caixinglobal.com"] },
  { company: "The Paper", baseUrls: ["www.thepaper.cn"] },
  { company: "Yicai Global", baseUrls: ["www.yicaiglobal.com"] },
  { company: "Economic Daily", baseUrls: ["www.ce.cn"] },
  { company: "21st Century Business Herald", baseUrls: ["www.21jingji.com"] },
  { company: "Beijing Review", baseUrls: ["www.bjreview.com"] },
  { company: "China Economic Net", baseUrls: ["www.ce.cn"] },
  { company: "Tencent News", baseUrls: ["news.qq.com"] },
  { company: "Sina News", baseUrls: ["news.sina.com.cn"] },
  { company: "NetEase News", baseUrls: ["news.163.com"] },
  { company: "Phoenix TV", baseUrls: ["www.ifeng.com"] }
];
var DANISH_NEWS = [
  { company: "Politiken", baseUrls: ["www.politiken.dk"] },
  { company: "Berlingske", baseUrls: ["www.berlingske.dk"] },
  { company: "Jyllands-Posten", baseUrls: ["jyllands-posten.dk"] },
  { company: "Ekstra Bladet", baseUrls: ["ekstrabladet.dk"] },
  { company: "Information", baseUrls: ["www.information.dk"] },
  { company: "BT", baseUrls: ["www.bt.dk"] },
  { company: "Weekendavisen", baseUrls: ["www.weekendavisen.dk"] },
  { company: "Fyens Stiftstidende", baseUrls: ["fyens.dk"] },
  { company: "Kristeligt Dagblad", baseUrls: ["www.kristeligt-dagblad.dk"] },
  { company: "Copenhagen Post", baseUrls: ["cphpost.dk"] },
  { company: "Nordjyske Stiftstidende", baseUrls: ["nordjyske.dk"] },
  { company: "rhus Stiftstidende", baseUrls: ["stiften.dk"] },
  { company: "Dagbladet Brsen", baseUrls: ["borsen.dk"] },
  { company: "Lokalavisen", baseUrls: ["lokalavisen.dk"] },
  { company: "TV2 Nyheder", baseUrls: ["tv2.dk"] },
  { company: "DR Nyheder", baseUrls: ["dr.dk"] },
  { company: "Avisen Danmark", baseUrls: ["avisen.dk"] },
  { company: "Fagbladet 3F", baseUrls: ["fagbladet3f.dk"] },
  { company: "Herning Folkeblad", baseUrls: ["herningfolkeblad.dk"] },
  { company: "Midtjyllands Avis", baseUrls: ["midtjyllandsavis.dk"] }
];
var SWISS_NEWS = [
  { company: "Neue Zrcher Zeitung (NZZ)", baseUrls: ["www.nzz.ch"], type: ["newspaper", "digital"] },
  { company: "Swissinfo", baseUrls: ["www.swissinfo.ch"], type: ["digital-first"] },
  { company: "20 Minuten", baseUrls: ["www.20min.ch"], type: ["newspaper", "digital"] },
  { company: "Blick", baseUrls: ["www.blick.ch"], type: ["newspaper", "digital"] },
  { company: "Le Temps", baseUrls: ["www.letemps.ch"], type: ["newspaper", "digital"] },
  { company: "Tages-Anzeiger", baseUrls: ["www.tagesanzeiger.ch"], type: ["newspaper", "digital"] },
  { company: "SRF News", baseUrls: ["www.srf.ch"], type: ["television", "radio", "digital"] },
  { company: "Luzerner Zeitung", baseUrls: ["www.luzernerzeitung.ch"], type: ["newspaper", "digital"] },
  { company: "La Tribune de Genve", baseUrls: ["www.tdg.ch"], type: ["newspaper", "digital"] },
  { company: "Aargauer Zeitung", baseUrls: ["www.aargauerzeitung.ch"], type: ["newspaper", "digital"] },
  { company: "24 Heures", baseUrls: ["www.24heures.ch"], type: ["newspaper", "digital"] },
  { company: "Radio Tlvision Suisse (RTS)", baseUrls: ["www.rts.ch"], type: ["television", "radio", "digital"] },
  { company: "Der Bund", baseUrls: ["www.derbund.ch"], type: ["newspaper", "digital"] },
  { company: "Schweizer Radio und Fernsehen (SRF)", baseUrls: ["www.srf.ch"], type: ["television", "radio", "digital"] },
  { company: "Basler Zeitung", baseUrls: ["www.bazonline.ch"], type: ["newspaper", "digital"] },
  { company: "Handelszeitung", baseUrls: ["www.handelszeitung.ch"], type: ["newspaper", "digital"] },
  { company: "Watson", baseUrls: ["www.watson.ch"], type: ["digital-first"] },
  { company: "Le Matin", baseUrls: ["www.lematin.ch"], type: ["newspaper", "digital"] },
  { company: "La Libert", baseUrls: ["www.laliberte.ch"], type: ["newspaper", "digital"] },
  { company: "The Swiss Times", baseUrls: ["www.theswisstimes.ch"], type: ["digital-first"] }
];
var AUSTRALIAN_NEWS = [
  { company: "ABC News", baseUrls: ["www.abc.net.au"], type: ["television", "radio", "digital"] },
  { company: "The Sydney Morning Herald", baseUrls: ["www.smh.com.au"], type: ["newspaper", "digital"] },
  { company: "The Australian", baseUrls: ["www.theaustralian.com.au"], type: ["newspaper", "digital"] },
  { company: "Herald Sun", baseUrls: ["www.heraldsun.com.au"], type: ["newspaper", "digital"] },
  { company: "9News", baseUrls: ["www.9news.com.au"], type: ["television", "digital"] },
  { company: "SBS News", baseUrls: ["www.sbs.com.au"], type: ["television", "digital", "multicultural"] },
  { company: "The Age", baseUrls: ["www.theage.com.au"], type: ["newspaper", "digital"] },
  { company: "Sky News Australia", baseUrls: ["www.skynews.com.au"], type: ["television", "digital"] },
  { company: "Australian Financial Review", baseUrls: ["www.afr.com"], type: ["newspaper", "digital"] },
  { company: "news.com.au", baseUrls: ["www.news.com.au"], type: ["digital-first"] },
  { company: "The Courier-Mail", baseUrls: ["www.couriermail.com.au"], type: ["newspaper", "digital"] },
  { company: "7NEWS", baseUrls: ["7news.com.au"], type: ["television", "digital"] },
  { company: "The West Australian", baseUrls: ["www.thewest.com.au"], type: ["newspaper", "digital"] },
  { company: "Daily Telegraph", baseUrls: ["www.dailytelegraph.com.au"], type: ["newspaper", "digital"] },
  { company: "Guardian Australia", baseUrls: ["www.theguardian.com/au"], type: ["digital-first"] },
  { company: "Crikey", baseUrls: ["www.crikey.com.au"], type: ["digital-first", "independent"] },
  { company: "AAP (Australian Associated Press)", baseUrls: ["www.aap.com.au"], type: ["news agency", "digital"] },
  { company: "NT News", baseUrls: ["www.ntnews.com.au"], type: ["newspaper", "digital"] },
  { company: "The Canberra Times", baseUrls: ["www.canberratimes.com.au"], type: ["newspaper", "digital"] },
  { company: "Brisbane Times", baseUrls: ["www.brisbanetimes.com.au"], type: ["digital-first"] }
];
var JAPANESE_NEWS = [
  { company: "The Asahi Shimbun", baseUrls: ["www.asahi.com"], type: ["newspaper", "digital"] },
  { company: "Yomiuri Shimbun", baseUrls: ["www.yomiuri.co.jp"], type: ["newspaper", "digital"] },
  { company: "Nikkei", baseUrls: ["www.nikkei.com"], type: ["newspaper", "digital"] },
  { company: "Mainichi Shimbun", baseUrls: ["mainichi.jp"], type: ["newspaper", "digital"] },
  { company: "Kyodo News", baseUrls: ["www.kyodonews.jp"], type: ["news agency", "digital"] },
  { company: "Japan Times", baseUrls: ["www.japantimes.co.jp"], type: ["newspaper", "digital"] },
  { company: "NHK", baseUrls: ["www.nhk.or.jp"], type: ["television", "radio", "digital"] },
  { company: "Fuji News Network (FNN)", baseUrls: ["www.fnn.jp"], type: ["television", "digital"] },
  { company: "Sankei Shimbun", baseUrls: ["www.sankei.com"], type: ["newspaper", "digital"] },
  { company: "Toyo Keizai", baseUrls: ["www.toyokeizai.net"], type: ["digital", "business magazine"] },
  { company: "Hokkaido Shimbun", baseUrls: ["www.hokkaido-np.co.jp"], type: ["newspaper", "digital"] },
  { company: "Shizuoka Shimbun", baseUrls: ["www.at-s.com"], type: ["newspaper", "digital"] },
  { company: "Tokyo Shimbun", baseUrls: ["www.tokyo-np.co.jp"], type: ["newspaper", "digital"] },
  { company: "Yahoo Japan News", baseUrls: ["news.yahoo.co.jp"], type: ["digital-first"] },
  { company: "TBS News", baseUrls: ["news.tbs.co.jp"], type: ["television", "digital"] },
  { company: "Nippon TV News 24 Japan", baseUrls: ["www.news24.jp"], type: ["television", "digital"] },
  { company: "Jiji Press", baseUrls: ["www.jiji.com"], type: ["news agency", "digital"] },
  { company: "TV Asahi News", baseUrls: ["news.tv-asahi.co.jp"], type: ["television", "digital"] },
  { company: "WOWOW Prime News", baseUrls: ["www.wowow.co.jp"], type: ["television", "digital"] },
  { company: "Kansai Telecasting Corporation (KTV)", baseUrls: ["www.ktv.jp"], type: ["television", "digital"] }
];
var SOUTH_KOREAN_NEWS = [
  { company: "Yonhap News Agency", baseUrls: ["www.yonhapnews.co.kr"], type: ["news agency", "digital"] },
  { company: "The Korea Herald", baseUrls: ["www.koreaherald.com"], type: ["newspaper", "digital"] },
  { company: "The Korea Times", baseUrls: ["www.koreatimes.co.kr"], type: ["newspaper", "digital"] },
  { company: "Chosun Ilbo", baseUrls: ["www.chosun.com"], type: ["newspaper", "digital"] },
  { company: "JoongAng Ilbo", baseUrls: ["www.joongang.co.kr"], type: ["newspaper", "digital"] },
  { company: "Dong-A Ilbo", baseUrls: ["www.donga.com"], type: ["newspaper", "digital"] },
  { company: "MBC News", baseUrls: ["www.imnews.imbc.com"], type: ["television", "digital"] },
  { company: "SBS News", baseUrls: ["news.sbs.co.kr"], type: ["television", "digital"] },
  { company: "KBS News", baseUrls: ["news.kbs.co.kr"], type: ["television", "radio", "digital"] },
  { company: "Hankyoreh", baseUrls: ["english.hani.co.kr"], type: ["newspaper", "digital"] },
  { company: "Maeil Business Newspaper", baseUrls: ["www.mk.co.kr"], type: ["newspaper", "digital"] },
  { company: "MoneyToday", baseUrls: ["www.mt.co.kr"], type: ["digital-first", "business"] },
  { company: "Seoul Shinmun", baseUrls: ["www.seoul.co.kr"], type: ["newspaper", "digital"] },
  { company: "OhmyNews", baseUrls: ["www.ohmynews.com"], type: ["digital-first"] },
  { company: "News1 Korea", baseUrls: ["www.news1.kr"], type: ["news agency", "digital"] },
  { company: "Asia Business Daily", baseUrls: ["www.asiae.co.kr"], type: ["newspaper", "digital"] },
  { company: "Herald Business", baseUrls: ["biz.heraldcorp.com"], type: ["newspaper", "digital"] },
  { company: "eDaily", baseUrls: ["www.edaily.co.kr"], type: ["digital-first", "business"] },
  { company: "Seoul Economic Daily", baseUrls: ["www.sedaily.com"], type: ["newspaper", "digital"] },
  { company: "JTBC News", baseUrls: ["news.jtbc.co.kr"], type: ["television", "digital"] }
];
var TURKISH_NEWS = [
  { company: "Anadolu Agency (AA)", baseUrls: ["www.aa.com.tr"], type: ["news agency", "digital"] },
  { company: "Hrriyet", baseUrls: ["www.hurriyet.com.tr"], type: ["newspaper", "digital"] },
  { company: "Sabah", baseUrls: ["www.sabah.com.tr"], type: ["newspaper", "digital"] },
  { company: "Milliyet", baseUrls: ["www.milliyet.com.tr"], type: ["newspaper", "digital"] },
  { company: "TRT World", baseUrls: ["www.trtworld.com"], type: ["television", "digital"] },
  { company: "CNN Trk", baseUrls: ["www.cnnturk.com"], type: ["television", "digital"] },
  { company: "Sozcu", baseUrls: ["www.sozcu.com.tr"], type: ["newspaper", "digital"] },
  { company: "Daily Sabah", baseUrls: ["www.dailysabah.com"], type: ["newspaper", "digital"] },
  { company: "Yeni afak", baseUrls: ["www.yenisafak.com"], type: ["newspaper", "digital"] },
  { company: "Habertrk", baseUrls: ["www.haberturk.com"], type: ["television", "digital"] },
  { company: "BirGn", baseUrls: ["www.birgun.net"], type: ["newspaper", "digital"] },
  { company: "Trkiye Gazetesi", baseUrls: ["www.turkiyegazetesi.com.tr"], type: ["newspaper", "digital"] },
  { company: "Cumhuriyet", baseUrls: ["www.cumhuriyet.com.tr"], type: ["newspaper", "digital"] },
  { company: "Diken", baseUrls: ["www.diken.com.tr"], type: ["digital-first"] },
  { company: "NTV", baseUrls: ["www.ntv.com.tr"], type: ["television", "digital"] },
  { company: "Ensonhaber", baseUrls: ["www.ensonhaber.com"], type: ["digital-first"] },
  { company: "T24", baseUrls: ["www.t24.com.tr"], type: ["digital-first"] },
  { company: "Karar", baseUrls: ["www.karar.com"], type: ["newspaper", "digital"] },
  { company: "Gazete Duvar", baseUrls: ["www.gazeteduvar.com.tr"], type: ["digital-first"] },
  { company: "Bloomberg HT", baseUrls: ["www.bloomberght.com"], type: ["television", "digital"] }
];
var NORWEGIAN_NEWS = [
  { company: "Aftenposten", baseUrls: ["www.aftenposten.no"], type: ["newspaper", "digital"] },
  { company: "Verdens Gang (VG)", baseUrls: ["www.vg.no"], type: ["newspaper", "digital"] },
  { company: "Dagbladet", baseUrls: ["www.dagbladet.no"], type: ["newspaper", "digital"] },
  { company: "NRK", baseUrls: ["www.nrk.no"], type: ["television", "radio", "digital"] },
  { company: "Dagens Nringsliv", baseUrls: ["www.dn.no"], type: ["newspaper", "digital"] },
  { company: "Nettavisen", baseUrls: ["www.nettavisen.no"], type: ["digital-first"] },
  { company: "Klassekampen", baseUrls: ["www.klassekampen.no"], type: ["newspaper", "digital"] },
  { company: "Morgenbladet", baseUrls: ["www.morgenbladet.no"], type: ["newspaper", "digital"] },
  { company: "E24", baseUrls: ["www.e24.no"], type: ["digital-first", "business"] },
  { company: "TV2", baseUrls: ["www.tv2.no"], type: ["television", "digital"] },
  { company: "Bergens Tidende", baseUrls: ["www.bt.no"], type: ["newspaper", "digital"] },
  { company: "Adresseavisen", baseUrls: ["www.adressa.no"], type: ["newspaper", "digital"] },
  { company: "Stavanger Aftenblad", baseUrls: ["www.aftenbladet.no"], type: ["newspaper", "digital"] },
  { company: "Fdrelandsvennen", baseUrls: ["www.fvn.no"], type: ["newspaper", "digital"] },
  { company: "ABC Nyheter", baseUrls: ["www.abcnyheter.no"], type: ["digital-first"] },
  { company: "Romerikes Blad", baseUrls: ["www.rb.no"], type: ["newspaper", "digital"] },
  { company: "Sunnmrsposten", baseUrls: ["www.smp.no"], type: ["newspaper", "digital"] },
  { company: "Finansavisen", baseUrls: ["www.finansavisen.no"], type: ["newspaper", "digital"] },
  { company: "Nordlys", baseUrls: ["www.nordlys.no"], type: ["newspaper", "digital"] },
  { company: "Hamar Arbeiderblad", baseUrls: ["www.h-a.no"], type: ["newspaper", "digital"] }
];
var SOCIAL_MEDIA = [
  {
    name: "Facebook",
    description: "Connect with friends, family, and communities worldwide on one of the largest social networks.",
    baseUrls: ["https://www.facebook.com"],
    profileUrl: "https://www.facebook.com/:user_id",
    approximateUserSize: 3e9,
    // 3 billion
    tickerSymbol: "META"
  },
  {
    name: "YouTube",
    description: "A platform for sharing and watching videos, connecting creators with audiences globally.",
    baseUrls: ["https://www.youtube.com"],
    profileUrl: "https://www.youtube.com/user/:user_id",
    approximateUserSize: 25e8,
    // 2.5 billion
    tickerSymbol: "GOOGL"
  },
  {
    name: "WhatsApp",
    description: "A secure messaging app for personal and business communication.",
    baseUrls: ["https://www.whatsapp.com", "https://wa.me"],
    profileUrl: "https://wa.me/:user_id",
    approximateUserSize: 2e9,
    // 2 billion
    tickerSymbol: "META"
  },
  {
    name: "Instagram",
    description: "Share photos and videos with friends and followers through posts, stories, and reels.",
    baseUrls: ["https://www.instagram.com"],
    profileUrl: "https://www.instagram.com/:user_id",
    approximateUserSize: 2e9,
    // 2 billion
    tickerSymbol: "META"
  },
  {
    name: "TikTok",
    description: "A short-form video platform known for its highly engaging content and viral trends.",
    baseUrls: ["https://www.tiktok.com"],
    profileUrl: "https://www.tiktok.com/@:user_id",
    approximateUserSize: 16e8
    // 1.6 billion
  },
  {
    name: "WeChat",
    description: "China's popular messaging and lifestyle app, integrating social media and mobile payments.",
    baseUrls: ["https://www.wechat.com"],
    profileUrl: "https://www.wechat.com/:user_id",
    // Profile URLs typically restricted in China
    approximateUserSize: 13e8
    // 1.3 billion
  },
  {
    name: "Facebook Messenger",
    description: "A messaging app used for personal and business interactions, seamlessly integrated with Facebook.",
    baseUrls: ["https://www.messenger.com"],
    profileUrl: "https://www.messenger.com/t/:user_id",
    approximateUserSize: 1e9,
    // 1 billion
    tickerSymbol: "META"
  },
  {
    name: "Telegram",
    description: "A messaging platform focused on privacy, with channels and group capabilities.",
    baseUrls: ["https://www.telegram.org", "https://t.me"],
    profileUrl: "https://t.me/:user_id",
    approximateUserSize: 9e8
    // 900 million
  },
  {
    name: "Snapchat",
    description: "A multimedia app popular for its disappearing messages and creative filters.",
    baseUrls: ["https://www.snapchat.com"],
    profileUrl: "https://www.snapchat.com/add/:user_id",
    approximateUserSize: 8e8,
    // 800 million
    tickerSymbol: "SNAP"
  },
  {
    name: "Douyin",
    description: "The Chinese version of TikTok, with similar short-form video content tailored for China.",
    baseUrls: ["https://www.douyin.com"],
    profileUrl: "https://www.douyin.com/user/:user_id",
    approximateUserSize: 75e7
    // 750 million
  },
  {
    name: "LinkedIn",
    description: "The largest professional networking platform, where users connect for career opportunities, insights, and business networking.",
    baseUrls: ["https://www.linkedin.com"],
    profileUrl: "https://www.linkedin.com/in/:user_id",
    approximateUserSize: 93e7,
    // 930 million
    tickerSymbol: "MSFT"
  },
  {
    name: "X (formerly Twitter)",
    description: "A platform for real-time updates, news sharing, and public discourse with a focus on brief, impactful posts.",
    baseUrls: ["https://www.twitter.com", "https://x.com"],
    profileUrl: "https://twitter.com/:user_id",
    approximateUserSize: 54e7
    // 540 million
  },
  {
    name: "Pinterest",
    description: "A visually-driven platform for sharing ideas, DIY projects, fashion, and more.",
    baseUrls: ["https://www.pinterest.com"],
    profileUrl: "https://www.pinterest.com/:user_id",
    approximateUserSize: 46e7,
    // 460 million
    tickerSymbol: "PINS"
  },
  {
    name: "Reddit",
    description: "A community-driven platform organized into niche forums or 'subreddits' focused on various topics.",
    baseUrls: ["https://www.reddit.com"],
    profileUrl: "https://www.reddit.com/user/:user_id",
    approximateUserSize: 43e7
    // 430 million
  },
  {
    name: "Clubhouse",
    description: "A voice-based social network where users engage in live audio conversations on various topics.",
    baseUrls: ["https://www.clubhouse.com"],
    profileUrl: "https://www.clubhouse.com/:user_id",
    approximateUserSize: 1e7
    // 10 million
  },
  {
    name: "Discord",
    description: "Originally aimed at gamers, Discord is now widely used by various communities for group chat, video, and voice calls.",
    baseUrls: ["https://www.discord.com", "https://discord.com"],
    profileUrl: "https://discord.com/users/:user_id",
    approximateUserSize: 3e8
    // 300 million
  }
];
var toFinalizedConfig = (config) => {
  return { ...config, finalized: true };
};
toFinalizedConfig({
  input: "req",
  output: "opt",
  cardinality: "I -> O[]"
});
toFinalizedConfig({
  input: "req",
  output: "req",
  cardinality: "I -> O"
});
toFinalizedConfig({
  input: "req",
  output: "req",
  cardinality: "I[] -> O"
});
function isString$1(value2) {
  return typeof value2 === "string";
}
function isNumber$1(value2) {
  return typeof value2 === "number";
}
function keysOf(container) {
  const keys = Array.isArray(container) ? Object.keys(container).map((i) => Number(i)) : isObject(container) ? isRef(container) ? ["value"] : Object.keys(container) : [];
  return keys;
}
var identity = (...values) => values.length === 1 ? values[0] : values.length === 0 ? void 0 : values;
function isDefined(value2) {
  return typeof value2 === "undefined" ? false : true;
}
function isUndefined(value2) {
  return typeof value2 === "undefined" ? true : false;
}
function isBoolean(value2) {
  return typeof value2 === "boolean";
}
function isObject(value2) {
  return typeof value2 === "object" && value2 !== null && Array.isArray(value2) === false;
}
function isTrue(value2) {
  return value2 === true;
}
function isArray(value2) {
  return Array.isArray(value2) === true;
}
function isContainer$1(value2) {
  return Array.isArray(value2) || isObject(value2) ? true : false;
}
function isRef(value2) {
  return isObject(value2) && "value" in value2 && Array.from(Object.keys(value2)).includes("_value");
}
function split(str, sep = "") {
  return str.split(sep);
}
function isNumberLike(value2) {
  const numericChars = [...NUMERIC_CHAR];
  return typeof value2 === "string" && split(value2).every((i) => numericChars.includes(i)) ? true : typeof value2 === "number" ? true : false;
}
function isFunction$2(value2) {
  return typeof value2 === "function" ? true : false;
}
var isUrl = (val, ...protocols) => {
  const p2 = protocols.length === 0 ? ["http", "https"] : protocols;
  return isString$1(val) && p2.some((i) => val.startsWith(`${i}://`));
};
var tokens = [
  "1",
  "inherit",
  "initial",
  "revert",
  "revert-layer",
  "unset",
  "auto"
];
var isRatio = (val) => /[0-9]{1,4}\s*\/\s*[0-9]{1,4}/.test(val);
var isCssAspectRatio = (val) => {
  return isString$1(val) && val.split(/\s+/).every((i) => tokens.includes(i) || isRatio(i));
};
var isInlineSvg = (v2) => {
  return isString$1(v2) && v2.trim().startsWith(`<svg`) && v2.trim().endsWith(`</svg>`);
};
var hasUrlQueryParameter = (val, prop) => {
  return isString$1(getUrlQueryParams(val, prop));
};
var asChars = (str) => {
  return str.split("");
};
var stripParenthesis = (val) => {
  return stripTrailing(stripLeading(val.trim(), "("), ")").trim();
};
var isEmail = (val) => {
  var _a2;
  if (!isString$1(val)) {
    return false;
  }
  const parts = val == null ? void 0 : val.split("@");
  const domain = (_a2 = parts[1]) == null ? void 0 : _a2.split(".");
  const tld = domain ? domain.pop() : "";
  const firstChar = val[0].toLowerCase();
  return isString$1(val) && (LOWER_ALPHA_CHARS.includes(firstChar) && parts.length === 2 && domain.length >= 1 && tld.length >= 2);
};
var isPhoneNumber = (val) => {
  let svelte = String(val).trim();
  let chars = svelte.split("");
  let numeric = retainChars(svelte, ...NUMERIC_CHAR);
  let valid = ["+", "(", ...NUMERIC_CHAR];
  let nothing = stripChars(svelte, ...[
    ...NUMERIC_CHAR,
    ...WHITESPACE_CHARS,
    "(",
    ")",
    "+",
    ".",
    "-"
  ]);
  return chars.every((i) => valid.includes(i)) && svelte.startsWith(`+`) ? numeric.length >= 8 : svelte.startsWith(`00`) ? numeric.length >= 10 : numeric.length >= 7 && nothing === "";
};
var isStringArray = (val) => {
  return Array.isArray(val) && val.every((i) => isString$1(i));
};
SIMPLE_TOKENS.map((i) => i.split("TOKEN"));
SIMPLE_SCALAR_TOKENS.map((i) => i.split("TOKEN"));
var isIso3166CountryCode = (val) => {
  const codes = ISO3166_1.map((i) => i["countryCode"]);
  return isString$1(val) && codes.includes(val);
};
var isIso3166CountryName = (val) => {
  const codes = ISO3166_1.map((i) => i["name"]);
  return isString$1(val) && codes.includes(val);
};
var isZipCode5 = (val) => {
  if (isNumber$1(val)) {
    return isZipCode5(`${val}`);
  }
  return isString$1(val) && val.trim().length === 5 && isNumberLike(val.trim());
};
var isZipPlus4 = (val) => {
  if (isString$1(val)) {
    const first = retainWhile(val.trim(), ...NUMERIC_CHAR);
    const next = stripChars(val.trim().replace(first, "").trim(), "-");
    return first.length === 5 && next.length === 4 && isNumberLike(next);
  }
  return false;
};
var isZipCode = (val) => {
  return isZipCode5(val) || isZipPlus4(val);
};
US_STATE_LOOKUP.map((i) => i.abbrev);
US_STATE_LOOKUP.map((i) => i.name);
var separate = (s2) => {
  return stripWhile(s2.toLowerCase(), ...NUMERIC_CHAR).trim();
};
var isAreaMetric = (val) => {
  return isString$1(val) && AREA_METRICS_LOOKUP.map((i) => i.abbrev).includes(separate(val));
};
var isLuminosityMetric = (val) => {
  return isString$1(val) && LUMINOSITY_METRICS_LOOKUP.map((i) => i.abbrev).includes(separate(val));
};
var isCurrentMetric = (val) => {
  return isString$1(val) && CURRENT_METRICS_LOOKUP.map((i) => i.abbrev).includes(separate(val));
};
var isVoltageMetric = (val) => {
  return isString$1(val) && VOLTAGE_METRICS_LOOKUP.map((i) => i.abbrev).includes(separate(val));
};
var isFrequencyMetric = (val) => {
  return isString$1(val) && FREQUENCY_METRICS_LOOKUP.map((i) => i.abbrev).includes(separate(val));
};
var isPowerMetric = (val) => {
  return isString$1(val) && POWER_METRICS_LOOKUP.map((i) => i.abbrev).includes(separate(val));
};
var isTimeMetric = (val) => {
  return isString$1(val) && TIME_METRICS_LOOKUP.map((i) => i.abbrev).includes(separate(val));
};
var isEnergyMetric = (val) => {
  return isString$1(val) && ENERGY_METRICS_LOOKUP.map((i) => i.abbrev).includes(separate(val));
};
var isPressureMetric = (val) => {
  return isString$1(val) && PRESSURE_METRICS_LOOKUP.map((i) => i.abbrev).includes(separate(val));
};
var isTemperatureMetric = (val) => {
  return isString$1(val) && TEMPERATURE_METRICS_LOOKUP.map((i) => i.abbrev).includes(separate(val));
};
var isAccelerationMetric = (val) => {
  return isString$1(val) && ACCELERATION_METRICS_LOOKUP.map((i) => i.abbrev).includes(separate(val));
};
var isSpeedMetric = (val) => {
  const speed = SPEED_METRICS_LOOKUP.map((i) => i.abbrev);
  return isString$1(val) && speed.includes(separate(val));
};
var isMassMetric = (val) => {
  return isString$1(val) && MASS_METRICS_LOOKUP.map((i) => i.abbrev).includes(separate(val));
};
var isDistanceMetric = (val) => {
  return isString$1(val) && DISTANCE_METRICS_LOOKUP.map((i) => i.abbrev).includes(separate(val));
};
var isMetric = (val) => {
  return isDistanceMetric(val) || isMassMetric(val) || isSpeedMetric(val) || isAccelerationMetric(val) || isVoltageMetric(val) || isTemperatureMetric(val) || isPressureMetric(val) || isEnergyMetric(val) || isTimeMetric(val) || isPowerMetric(val) || isFrequencyMetric(val) || isVoltageMetric(val) || isCurrentMetric(val) || isLuminosityMetric(val) || isAreaMetric(val);
};
var URL$5 = SOCIAL_MEDIA.flatMap((i) => i.baseUrls);
SOCIAL_MEDIA.map((i) => i.profileUrl);
var isSocialMediaUrl = (val) => {
  return isString$1(val) && URL$5.some((i) => val.startsWith(i));
};
var isGithubUrl = (val) => {
  const valid = [
    "https://github.com",
    "https://www.github.com",
    "https://github.io"
  ];
  return isString$1(val) && valid.some(
    (i) => val === i || val.startsWith(`${i}/`) || val.startsWith(`${i}?`)
  );
};
var stripper = (s2) => {
  return stripTrailing(
    stripLeading(s2, "https://github.com/"),
    "/"
  );
};
var isGithubRepoUrl = (val) => {
  return isString$1(val) && (val.startsWith("https://github.com/") && stripper(val).split("/").length === 2) ? true : false;
};
var isBitbucketUrl = (val) => {
  const valid = REPO_SOURCE_LOOKUP["bitbucket"];
  return isString$1(val) && valid.some(
    (i) => val === i || val.startsWith(`${i}/`) || val.startsWith(`${i}?`)
  );
};
var isCodeCommitUrl = (val) => {
  const valid = REPO_SOURCE_LOOKUP["codecommit"];
  return isString$1(val) && valid.some(
    (i) => val === i || val.startsWith(`${i}/`) || val.startsWith(`${i}?`)
  );
};
var isRepoUrl = (val) => {
  return isGithubUrl(val) || isBitbucketUrl(val) || isCodeCommitUrl(val);
};
var isWholeFoodsUrl = (val) => {
  return isString$1(val) && WHOLE_FOODS_DNS.some((i) => val.startsWith(`https://${i}`));
};
var isCvsUrl = (val) => {
  return isString$1(val) && CVS_DNS.some((i) => val.startsWith(`https://${i}`));
};
var isWalgreensUrl = (val) => {
  return isString$1(val) && WALGREENS_DNS.some((i) => val.startsWith(`https://${i}`));
};
var isKrogersUrl = (val) => {
  return isString$1(val) && KROGER_DNS.some((i) => val.startsWith(`https://${i}`));
};
var isZaraUrl = (val) => {
  return isString$1(val) && ZARA_DNS.some((i) => val.startsWith(`https://${i}`));
};
var isHmUrl = (val) => {
  return isString$1(val) && HM_DNS.some((i) => val.startsWith(`https://${i}`));
};
var isDellUrl = (val) => {
  return isString$1(val) && DELL_DNS.some((i) => val.startsWith(`https://${i}`));
};
var isIkeaUrl = (val) => {
  return isString$1(val) && KROGER_DNS.some((i) => val.startsWith(`https://${i}`));
};
var isLowesUrl = (val) => {
  return isString$1(val) && KROGER_DNS.some((i) => val.startsWith(`https://${i}`));
};
var isNikeUrl = (val) => {
  return isString$1(val) && NIKE_DNS.some((i) => val.startsWith(`https://${i}`));
};
var isWayfairUrl = (val) => {
  return isString$1(val) && WAYFAIR_DNS.some((i) => val.startsWith(`https://${i}`));
};
var isBestBuyUrl = (val) => {
  return isString$1(val) && BEST_BUY_DNS.some((i) => val.startsWith(`https://${i}`));
};
var isCostCoUrl = (val) => {
  return isString$1(val) && COSTCO_DNS.some((i) => val.startsWith(`https://${i}`));
};
var isEtsyUrl = (val) => {
  return isString$1(val) && ETSY_DNS.some((i) => val.startsWith(`https://${i}`));
};
var isTargetUrl = (val) => {
  return isString$1(val) && TARGET_DNS.some((i) => val.startsWith(`https://${i}`));
};
var isEbayUrl = (val) => {
  return isString$1(val) && EBAY_DNS.some((i) => val.startsWith(`https://${i}`));
};
var isHomeDepotUrl = (val) => {
  return isString$1(val) && HOME_DEPOT_DNS.some((i) => val.startsWith(`https://${i}`));
};
var isMacysUrl = (val) => {
  return isString$1(val) && MACYS_DNS.some((i) => val.startsWith(`https://${i}`));
};
var isAppleUrl = (val) => {
  return isString$1(val) && APPLE_DNS.some((i) => val.startsWith(`https://${i}`));
};
var isAmazonUrl = (val) => {
  return isString$1(val) && AMAZON_DNS.some((i) => val.startsWith(`https://${i}`));
};
var isRetailUrl = (val) => {
  return isAmazonUrl(val) || isWalgreensUrl(val) || isAppleUrl(val) || isMacysUrl(val) || isEbayUrl(val) || isHomeDepotUrl(val) || isTargetUrl(val) || isEtsyUrl(val) || isCostCoUrl(val) || isBestBuyUrl(val) || isWayfairUrl(val) || isNikeUrl(val) || isLowesUrl(val) || isIkeaUrl(val) || isDellUrl(val) || isHmUrl(val) || isZaraUrl(val) || isKrogersUrl(val) || isWalgreensUrl(val) || isCvsUrl(val) || isWholeFoodsUrl(val);
};
var isYouTubeUrl = (val) => {
  return isString$1(val) && (val.startsWith("https://www.youtube.com") || val.startsWith("https://youtube.com") || val.startsWith("https://youtu.be"));
};
var isYouTubeShareUrl = (val) => {
  return isString$1(val) && val.startsWith(`https://youtu.be`);
};
var isYouTubeVideoUrl = (val) => {
  return isString$1(val) && (val.startsWith("https://www.youtube.com") || val.startsWith("https://youtube.com") || val.startsWith("https://youtu.be"));
};
var feed_map = (type) => {
  return isUndefined(type) ? `/feed` : type === "liked" ? `/playlist?list=LL` : ["history", "playlists", "trending", "subscriptions"].includes(type) ? `/feed/${type}` : `/feed/`;
};
var isYouTubeFeedUrl = (val, type) => {
  return isString$1(val) && (val.startsWith(`https://www.youtube.com${feed_map(type)}`) || val.startsWith(`https://youtube.com${feed_map(type)}`));
};
var isYouTubeCreatorUrl = (url) => {
  return isString$1(url) && (url.startsWith(`https://www.youtube.com/@`) || url.startsWith(`https://youtube.com/@`) || url.startsWith(`https://www.youtube.com/channel/`));
};
var URL2 = AUSTRALIAN_NEWS.flatMap((i) => i.baseUrls);
var isAustralianNewsUrl = (val) => {
  return isString$1(val) && val.startsWith("https://") && (URL2.includes(val) || URL2.some((i) => i.startsWith(`${i}/`)));
};
var URL3 = BELGIUM_NEWS.flatMap((i) => i.baseUrls);
var isBelgiumNewsUrl = (val) => {
  return isString$1(val) && val.startsWith("https://") && (URL3.includes(val) || URL3.some((i) => i.startsWith(`${i}/`)));
};
var URL4 = CANADIAN_NEWS.flatMap((i) => i.baseUrls);
var isCanadianNewsUrl = (val) => {
  return isString$1(val) && val.startsWith("https://") && (URL4.includes(val) || URL4.some((i) => i.startsWith(`${i}/`)));
};
var URL5 = DANISH_NEWS.flatMap((i) => i.baseUrls);
var isDanishNewsUrl = (val) => {
  return isString$1(val) && val.startsWith("https://") && (URL5.includes(val) || URL5.some((i) => i.startsWith(`${i}/`)));
};
var URL6 = DUTCH_NEWS.flatMap((i) => i.baseUrls);
var isDutchNewsUrl = (val) => {
  return isString$1(val) && val.startsWith("https://") && (URL6.includes(val) || URL6.some((i) => i.startsWith(`${i}/`)));
};
var URL7 = FRENCH_NEWS.flatMap((i) => i.baseUrls);
var isFrenchNewsUrl = (val) => {
  return isString$1(val) && val.startsWith("https://") && (URL7.includes(val) || URL7.some((i) => i.startsWith(`${i}/`)));
};
var URL8 = GERMAN_NEWS.flatMap((i) => i.baseUrls);
var isGermanNewsUrl = (val) => {
  return isString$1(val) && val.startsWith("https://") && (URL8.includes(val) || URL8.some((i) => i.startsWith(`${i}/`)));
};
var URL9 = INDIAN_NEWS.flatMap((i) => i.baseUrls);
var isIndianNewsUrl = (val) => {
  return isString$1(val) && val.startsWith("https://") && (URL9.includes(val) || URL9.some((i) => i.startsWith(`${i}/`)));
};
var URL10 = ITALIAN_NEWS.flatMap((i) => i.baseUrls);
var isItalianNewsUrl = (val) => {
  return isString$1(val) && val.startsWith("https://") && (URL10.includes(val) || URL10.some((i) => i.startsWith(`${i}/`)));
};
var URL11 = JAPANESE_NEWS.flatMap((i) => i.baseUrls);
var isJapaneseNewsUrl = (val) => {
  return isString$1(val) && val.startsWith("https://") && (URL11.includes(val) || URL11.some((i) => i.startsWith(`${i}/`)));
};
var URL12 = MEXICAN_NEWS.flatMap((i) => i.baseUrls);
var isMexicanNewsUrl = (val) => {
  return isString$1(val) && val.startsWith("https://") && (URL12.includes(val) || URL12.some((i) => i.startsWith(`${i}/`)));
};
var URL13 = NORWEGIAN_NEWS.flatMap((i) => i.baseUrls);
var isNorwegianNewsUrl = (val) => {
  return isString$1(val) && val.startsWith("https://") && (URL13.includes(val) || URL13.some((i) => i.startsWith(`${i}/`)));
};
var URL14 = SOUTH_KOREAN_NEWS.flatMap((i) => i.baseUrls);
var isSouthKoreanNewsUrl = (val) => {
  return isString$1(val) && val.startsWith("https://") && (URL14.includes(val) || URL14.some((i) => i.startsWith(`${i}/`)));
};
var URL15 = SPANISH_NEWS.flatMap((i) => i.baseUrls);
var isSpanishNewsUrl = (val) => {
  return isString$1(val) && val.startsWith("https://") && (URL15.includes(val) || URL15.some((i) => i.startsWith(`${i}/`)));
};
var URL16 = SWISS_NEWS.flatMap((i) => i.baseUrls);
var isSwissNewsUrl = (val) => {
  return isString$1(val) && val.startsWith("https://") && (URL16.includes(val) || URL16.some((i) => i.startsWith(`${i}/`)));
};
var URL17 = TURKISH_NEWS.flatMap((i) => i.baseUrls);
var isTurkishNewsUrl = (val) => {
  return isString$1(val) && val.startsWith("https://") && (URL17.includes(val) || URL17.some((i) => i.startsWith(`${i}/`)));
};
var URL18 = UK_NEWS.flatMap((i) => i.baseUrls);
var isUkNewsUrl = (val) => {
  return isString$1(val) && val.startsWith("https://") && (URL18.includes(val) || URL18.some((i) => i.startsWith(`${i}/`)));
};
var URL19 = US_NEWS.flatMap((i) => i.baseUrls);
var isUsNewsUrl = (val) => {
  return isString$1(val) && val.startsWith("https://") && (URL19.includes(val) || URL19.some((i) => i.startsWith(`${i}/`)));
};
CHINESE_NEWS.flatMap((i) => i.baseUrls);
var isNewsUrl = (val) => {
  return isAustralianNewsUrl(val) || isBelgiumNewsUrl(val) || isCanadianNewsUrl(val) || isDanishNewsUrl(val) || isDutchNewsUrl(val) || isFrenchNewsUrl(val) || isGermanNewsUrl(val) || isIndianNewsUrl(val) || isItalianNewsUrl(val) || isJapaneseNewsUrl(val) || isMexicanNewsUrl(val) || isNorwegianNewsUrl(val) || isSouthKoreanNewsUrl(val) || isSpanishNewsUrl(val) || isSwissNewsUrl(val) || isTurkishNewsUrl(val) || isUkNewsUrl(val) || isUsNewsUrl(val);
};
var isIsoDateTime = (val) => {
  if (isString$1(val)) {
    return val.includes(":") && val.includes("-") && val.split("-").length === 3 && val.split(":").length > 1 && (!val.includes("Z") || isNumberLike(val.slice(-1)) || val.endsWith("Z")) && (!val.includes("Z") || ["+", "-"].includes(stripUntil(val, "Z").slice(1, 2)) || val.endsWith("Z"));
  }
  return false;
};
var isIsoExplicitTime = (val) => {
  if (isString$1(val)) {
    const parts = stripLeading(stripAfter(val, "Z"), "T").split(/[:.]/).map((i) => Number(i));
    return val.startsWith("T") && val.includes(":") && val.split(":").length === 3 && parts[0] >= 0 && parts[0] <= 23 && parts[1] >= 0 && parts[1] <= 59;
  } else {
    return false;
  }
};
var isIsoImplicitTime = (val) => {
  if (isString$1(val)) {
    const parts = stripAfter(val, "Z").split(/[:.]/).map((i) => Number(i));
    return val.includes(":") && val.split(":").length === 3 && parts[0] >= 0 && parts[0] <= 23 && parts[1] >= 0 && parts[1] <= 59;
  } else {
    return false;
  }
};
var isIsoTime = (val) => {
  return isIsoExplicitTime(val) || isIsoImplicitTime(val);
};
var isIsoExplicitDate = (val) => {
  if (isString$1(val)) {
    const parts = val.split("-").map((i) => Number(i));
    return val.includes("-") ? val.split("-").every((i) => isNumberLike(i)) ? parts[0] >= 0 && parts[0] <= 9999 && parts[1] >= 1 && parts[1] <= 12 && parts[2] >= 1 && parts[2] <= 31 : false : false;
  } else {
    return false;
  }
};
var isIsoImplicitDate = (val) => {
  if (isString$1(val) && val.length === 8 && isNumberLike(val)) {
    const year = Number(val.slice(0, 4));
    const month = Number(val.slice(4, 6));
    const date = Number(val.slice(6, 8));
    return year >= 0 && year <= 9999 && month >= 1 && month <= 12 && date >= 1 && date <= 31;
  } else {
    return false;
  }
};
var isIsoDate = (val) => {
  if (isString$1(val)) {
    return val.includes("-") ? isIsoExplicitDate(val) : isIsoImplicitDate(val);
  } else {
    return false;
  }
};
function stripTrailing(content2, ...strip) {
  let output = String(content2);
  for (const s2 of strip) {
    if (output.endsWith(String(s2))) {
      output = output.slice(0, -1 * String(s2).length);
    }
  }
  return isNumber$1(content2) ? Number(output) : output;
}
function stripLeading(content2, ...strip) {
  let output = String(content2);
  for (const s2 of strip) {
    if (output.startsWith(String(s2))) {
      output = output.slice(String(s2).length);
    }
  }
  return isNumber$1(content2) ? Number(output) : output;
}
function ensureTrailing(content2, ensure) {
  return (
    //
    content2.endsWith(ensure) ? content2 : `${content2}${ensure}`
  );
}
function ensureLeading(content2, ensure) {
  let output = String(content2);
  return output.startsWith(String(ensure)) ? content2 : isString$1(content2) ? `${ensure}${content2}` : Number(`${ensure}${content2}`);
}
function capitalize(str) {
  return `${str == null ? void 0 : str.slice(0, 1).toUpperCase()}${str == null ? void 0 : str.slice(1)}`;
}
function toKebabCase(input, _preserveWhitespace = false) {
  const [_, preWhite, focus, postWhite] = /^(\s*)(.*?)(\s*)$/.exec(input);
  const replaceWhitespace = (i) => i.replace(/\s/gs, "-");
  const replaceUppercase = (i) => i.replace(/[A-Z]/g, (c) => `-${c[0].toLowerCase()}`);
  const replaceLeadingDash = (i) => i.replace(/^-/s, "");
  const replaceTrailingDash = (i) => i.replace(/-$/s, "");
  const replaceUnderscore = (i) => i.replace(/_/g, "-");
  const removeDupDashes = (i) => i.replace(/-+/g, "-");
  return removeDupDashes(`${preWhite}${replaceUnderscore(
    replaceTrailingDash(
      replaceLeadingDash(removeDupDashes(replaceWhitespace(replaceUppercase(focus))))
    )
  )}${postWhite}`);
}
function retainAfter(content2, ...find2) {
  const idx = Math.min(
    ...find2.map((i) => content2.indexOf(i)).filter((i) => i > -1)
  );
  const min2 = Math.min(...find2.map((i) => i.length));
  let len = Math.max(...find2.map((i) => i.length));
  if (min2 !== len) {
    if (!find2.includes(content2.slice(idx, len))) {
      len = min2;
    }
  }
  return idx && idx > 0 ? content2.slice(idx + len) : "";
}
function stripAfter(content2, find2) {
  return content2.split(find2).shift();
}
function stripBefore(content2, find2) {
  return content2.split(find2).slice(1).join(find2);
}
var stripUntil = (content2, ...until) => {
  const stopIdx = asChars(content2).findIndex((c) => until.includes(c));
  return content2.slice(stopIdx);
};
function toPascalCase(input, preserveWhitespace = void 0) {
  const [_, preWhite, focus, postWhite] = /^(\s*)(.*?)(\s*)$/.exec(
    input
  );
  const convertInteriorToCap = (i) => i.replace(/[ |_|-]+([0-9]*?[a-z|A-Z]{1})/gs, (_2, p1) => p1.toUpperCase());
  const startingToCap = (i) => i.replace(/^[_|-]*?([0-9]*?[a-z]{1})/gs, (_2, p1) => p1.toUpperCase());
  const replaceLeadingTrash = (i) => i.replace(/^[-_]/s, "");
  const replaceTrailingTrash = (i) => i.replace(/[-_]$/s, "");
  const pascal = `${preserveWhitespace ? preWhite : ""}${capitalize(
    replaceTrailingTrash(replaceLeadingTrash(convertInteriorToCap(startingToCap(focus))))
  )}${preserveWhitespace ? postWhite : ""}`;
  return pascal;
}
var retainChars = (content2, ...retain2) => {
  let chars = asChars(content2);
  return chars.filter((c) => retain2.includes(c)).join("");
};
var stripChars = (content2, ...strip) => {
  let chars = asChars(content2);
  return chars.filter((c) => !strip.includes(c)).join("");
};
var retainWhile = (content2, ...retain2) => {
  const stopIdx = asChars(content2).findIndex((c) => !retain2.includes(c));
  return content2.slice(0, stopIdx);
};
function retainUntil(content2, ...find2) {
  const chars = asChars(content2);
  let idx = 0;
  while (!find2.includes(chars[idx]) && idx <= chars.length) {
    idx = idx + 1;
  }
  return idx === 0 ? "" : content2.slice(0, idx);
}
var stripWhile = (content2, ...match2) => {
  const stopIdx = asChars(content2).findIndex((c) => !match2.includes(c));
  return content2.slice(stopIdx);
};
var IGNORABLES = [
  "@vitest/runner",
  "node:"
];
function kindError(kind, baseContext = {}) {
  return (msg2, context = {}) => {
    const err = new Error(msg2);
    const stackTrace = parse$1(err).filter((i) => !IGNORABLES.some((has) => i.file && i.file.includes(has))).map((i) => ({
      ...i,
      file: i.file ? relative(process.cwd(), i.file) : void 0
    }));
    err.name = toPascalCase(kind);
    err.kind = toKebabCase(stripChars(kind, "<", ">", "[", "]", "(", ")"));
    err.file = stackTrace[0].file;
    err.line = stackTrace[0].line;
    err.col = stackTrace[0].col;
    err.stackTrace = stackTrace;
    err.__kind = "KindError";
    err.context = {
      ...baseContext,
      ...context
    };
    return err;
  };
}
var createFnWithProps = (fn2, props, narrowing = false) => {
  let fnWithProps = fn2;
  for (let prop of Object.keys(props)) {
    fnWithProps[prop] = props[prop];
  }
  return isTrue(narrowing) ? fnWithProps : fnWithProps;
};
var youtubeEmbed = (url) => {
  if (hasUrlQueryParameter(url, "v")) {
    const id = getUrlQueryParams(url, "v");
    return `https://www.youtube.com/embed/${id}`;
  } else if (isYouTubeShareUrl(url)) {
    const id = url.split("/").pop();
    if (id) {
      return `https://www.youtube.com/embed/${id}`;
    } else {
      throw new Error(`Unexpected problem parsing share URL -- "${url}" -- into a YouTube embed URL`);
    }
  } else {
    throw new Error(`Unexpected URL structure; unable to convert "${url}" to a YouTube embed URL`);
  }
};
Object.values(NETWORK_PROTOCOL_LOOKUP).flat().filter((i) => i !== "");
var getUrlQueryParams = (url, specific = void 0) => {
  const qp = stripBefore(url, "?");
  if (specific) {
    return qp.includes(`${specific}=`) ? decodeURIComponent(
      stripAfter(
        stripBefore(qp, `${specific}=`),
        "&"
      ).replace(/\+/g, "%20")
    ) : void 0;
  }
  return qp === "" ? qp : `?${qp}`;
};
identity({
  string: "<<string>>",
  number: "<<number>>",
  boolean: "<<boolean>>",
  true: "<<true>>",
  false: "<<false>>",
  null: "<<null>>",
  undefined: "<<undefined>>",
  unknown: "<<unknown>>",
  any: "<<any>>",
  never: "<<never>>"
});
const find_in = (tg) => (...values) => {
  const found = values.find((v2) => tg(v2));
  return found;
};
const isDateTime = (val) => {
  return isObject(val) && "toFormat" in val;
};
const isDvPage = (val) => {
  return isObject(val) && "file" in val && isObject(val.file) && "link" in val.file && "name" in val.file && "path" in val.file;
};
const isError = (val) => {
  return isObject(val) && val instanceof Error;
};
const isFileLink = (val) => {
  return isLink(val) && "type" in val && val.type === "file";
};
const isLink = (val) => {
  return isObject(val) && "path" in val && isString$1(val.path) && "embed" in val && typeof val.embed === "boolean";
};
const isPageInfo = (val) => {
  return isObject(val) && "current" in val && "categories" in val && "type" in val && isDvPage(val.current);
};
const isTAbstractFile = (v2) => {
  return isObject(v2) && "basename" in v2 && "path" in v2;
};
const isTFile = (v2) => {
  return isObject(v2) && "name" in v2 && "extension" in v2 && "path" in v2;
};
const isWikipediaUrl = (val) => {
  return isString$1(val) && val.startsWith("https://") && val.includes("wikipedia.org/");
};
const isValidPath = (val) => {
  return isString$1(val) && !val.startsWith("/") && !val.startsWith(".") && val.length > 2;
};
const isMoment = (val) => {
  return isObject(val) && "toISOString" in val && "calendar" in val && "dayOfYear" in val;
};
const isPageReference = (v2) => {
  return isDvPage(v2) || isFileLink(v2) || isPageInfo(v2) || isTFile(v2) || isTAbstractFile(v2) || isString$1(v2);
};
const isFrontmatter = (v2) => {
  return isObject(v2) && !isFunction$2(v2);
};
const isTagKindDefinition = (val) => {
  return isObject(val) && "tag" in val && typeof val.tag === "string";
};
const isKindDefinition = (val) => {
  return isObject(val) && "path" in val && typeof val.tag === "string" && "hash" in val && typeof val.hash === "number";
};
const getPath = (pg) => {
  var _a2, _b2;
  return isTFile(pg) || isTAbstractFile(pg) || isLink(pg) ? pg.path : isDvPage(pg) ? pg.file.path : isString$1(pg) ? stripAfter(pg, "|") : isPageInfo(pg) ? (_b2 = (_a2 = pg.current) == null ? void 0 : _a2.file) == null ? void 0 : _b2.path : void 0;
};
const getPage = (p2) => (pg) => {
  if (isDvPage(pg)) {
    return pg;
  }
  if (isPageInfo(pg)) {
    return pg.current;
  }
  const path = getPath(pg);
  const page = path ? p2.dv.page(path) : void 0;
  return page;
};
var __create = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target2) => __defProp2(target2, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target2, all) => {
  __markAsModule(target2);
  for (var name2 in all)
    __defProp2(target2, name2, { get: all[name2], enumerable: true });
};
var __reExport = (target2, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target2, key) && key !== "default")
        __defProp2(target2, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target2;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp2(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};
var require_tag = __commonJS({
  "src/grammar/tag.js"(exports, module) {
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location2) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location2;
      this.name = "SyntaxError";
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }
    peg$subclass(peg$SyntaxError, Error);
    peg$SyntaxError.buildMessage = function(expected, found, location2) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        },
        not: function(expectation) {
          return "not " + describeExpectation(expectation.expected);
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s2) {
        return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s2) {
        return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options2) {
      options2 = options2 !== void 0 ? options2 : {};
      var peg$FAILED = {};
      var peg$startRuleFunctions = { Top: peg$parseTop };
      var peg$startRuleFunction = peg$parseTop;
      var peg$c0 = "/";
      var peg$c1 = ".";
      var peg$c2 = "#";
      var peg$c3 = "=";
      var peg$c4 = "(";
      var peg$c5 = ")";
      var peg$c6 = ",";
      var peg$c7 = "[";
      var peg$c8 = "]";
      var peg$c9 = "null";
      var peg$c10 = "true";
      var peg$c11 = "false";
      var peg$c12 = "{";
      var peg$c13 = "}";
      var peg$c14 = ":";
      var peg$c16 = '"';
      var peg$c17 = "\\";
      var peg$c18 = "n";
      var peg$c19 = "r";
      var peg$c20 = "t";
      var peg$r0 = /^[$@]/;
      var peg$r1 = /^[0-9]/;
      var peg$r2 = /^[^\0-\x1F"\\]/;
      var peg$r3 = /^[a-zA-Z0-9_\-]/;
      var peg$r4 = /^[ \n\t]/;
      var peg$e0 = peg$literalExpectation("/", false);
      var peg$e1 = peg$otherExpectation("tag name");
      var peg$e2 = peg$otherExpectation("class");
      var peg$e3 = peg$otherExpectation("id");
      var peg$e4 = peg$literalExpectation("=", false);
      var peg$e5 = peg$literalExpectation("(", false);
      var peg$e6 = peg$literalExpectation(")", false);
      var peg$e7 = peg$literalExpectation(",", false);
      var peg$e8 = peg$otherExpectation("variable");
      var peg$e9 = peg$otherExpectation("null");
      var peg$e10 = peg$otherExpectation("boolean");
      var peg$e11 = peg$literalExpectation("[", false);
      var peg$e12 = peg$literalExpectation("]", false);
      var peg$e13 = peg$literalExpectation("{", false);
      var peg$e14 = peg$literalExpectation("}", false);
      var peg$e15 = peg$literalExpectation(":", false);
      var peg$e16 = peg$otherExpectation("number");
      var peg$e17 = peg$otherExpectation("string");
      var peg$e18 = peg$otherExpectation("identifier");
      var peg$e19 = peg$otherExpectation("whitespace");
      var peg$f0 = function(variable) {
        return { type: "variable", meta: { variable } };
      };
      var peg$f1 = function(attributes2) {
        return { type: "annotation", meta: { attributes: attributes2 } };
      };
      var peg$f2 = function(tag, value2) {
        return value2;
      };
      var peg$f3 = function(tag, primary, attributes2, close) {
        if (primary) {
          attributes2 = attributes2 || [];
          attributes2.unshift({
            type: "attribute",
            name: "primary",
            value: primary
          });
        }
        const [type, nesting] = close ? ["tag", 0] : ["tag_open", 1];
        return { type, nesting, meta: { tag, attributes: attributes2 } };
      };
      var peg$f4 = function(tag) {
        return { type: "tag_close", nesting: -1, meta: { tag } };
      };
      var peg$f5 = function(head, tail) {
        return !head ? [] : [head, ...tail];
      };
      var peg$f6 = function(item2) {
        return item2;
      };
      var peg$f7 = function(ids) {
        return ids;
      };
      var peg$f8 = function(classes) {
        return classes;
      };
      var peg$f9 = function(attribute) {
        return attribute;
      };
      var peg$f10 = function(name2) {
        return { type: "class", name: name2, value: true };
      };
      var peg$f11 = function(value2) {
        return { type: "attribute", name: "id", value: value2 };
      };
      var peg$f12 = function(name2, value2) {
        return { type: "attribute", name: name2, value: value2 };
      };
      var peg$f13 = function(name2, head, tail) {
        return head ? [head, ...tail] : [];
      };
      var peg$f14 = function(name2, params) {
        let parameters = {};
        for (let [index, { name: name22, value: value2 }] of params.entries())
          parameters[name22 || index] = value2;
        return new Function3(name2, parameters);
      };
      var peg$f15 = function(name2) {
        return name2;
      };
      var peg$f16 = function(name2, value2) {
        return { name: name2, value: value2 };
      };
      var peg$f17 = function(value2) {
        return value2;
      };
      var peg$f18 = function(prefix2, head, tail) {
        if (prefix2 === "@")
          return [head, ...tail];
        return new Variable2([head, ...tail]);
      };
      var peg$f19 = function() {
        return null;
      };
      var peg$f20 = function() {
        return true;
      };
      var peg$f21 = function() {
        return false;
      };
      var peg$f22 = function(head, tail) {
        return [head, ...tail];
      };
      var peg$f23 = function(value2) {
        return value2 || [];
      };
      var peg$f24 = function(head, tail) {
        return Object.assign(head, ...tail);
      };
      var peg$f25 = function(value2) {
        return value2 || {};
      };
      var peg$f26 = function(key, value2) {
        return key === "$$mdtype" ? {} : { [key]: value2 };
      };
      var peg$f27 = function() {
        return parseFloat(text2());
      };
      var peg$f28 = function(value2) {
        return value2.join("");
      };
      var peg$f29 = function() {
        return "\n";
      };
      var peg$f30 = function() {
        return "\r";
      };
      var peg$f31 = function() {
        return "	";
      };
      var peg$f32 = function(sequence) {
        return sequence;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$expected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options2) {
        if (!(options2.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
      }
      function text2() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function peg$literalExpectation(text3, ignoreCase) {
        return { type: "literal", text: text3, ignoreCase };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p2;
        if (details) {
          return details;
        } else {
          p2 = pos - 1;
          while (!peg$posDetailsCache[p2]) {
            p2--;
          }
          details = peg$posDetailsCache[p2];
          details = {
            line: details.line,
            column: details.column
          };
          while (p2 < pos) {
            if (input.charCodeAt(p2) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p2++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      var peg$VALIDFILENAME = typeof options2.filename === "string" && options2.filename.length > 0;
      function peg$computeLocation(startPos, endPos) {
        var loc = {};
        if (peg$VALIDFILENAME)
          loc.filename = options2.filename;
        var startPosDetails = peg$computePosDetails(startPos);
        loc.start = {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        };
        var endPosDetails = peg$computePosDetails(endPos);
        loc.end = {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        };
        return loc;
      }
      function peg$begin() {
        peg$expected.push({ pos: peg$currPos, variants: [] });
      }
      function peg$expect(expected2) {
        var top2 = peg$expected[peg$expected.length - 1];
        if (peg$currPos < top2.pos) {
          return;
        }
        if (peg$currPos > top2.pos) {
          top2.pos = peg$currPos;
          top2.variants = [];
        }
        top2.variants.push(expected2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found, location2), expected2, found, location2);
      }
      function peg$buildError() {
        var expected2 = peg$expected[0];
        var failPos = expected2.pos;
        return peg$buildStructuredError(expected2.variants, failPos < input.length ? input.charAt(failPos) : null, failPos < input.length ? peg$computeLocation(failPos, failPos + 1) : peg$computeLocation(failPos, failPos));
      }
      function peg$parseTop() {
        var s0;
        s0 = peg$parseTopLevelValue();
        if (s0 === peg$FAILED) {
          s0 = peg$parseAnnotation();
          if (s0 === peg$FAILED) {
            s0 = peg$parseTagOpen();
            if (s0 === peg$FAILED) {
              s0 = peg$parseTagClose();
            }
          }
        }
        return s0;
      }
      function peg$parseTopLevelValue() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseVariable();
        if (s1 === peg$FAILED) {
          s1 = peg$parseFunction();
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f0(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseAnnotation() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parseTagAttributes();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f1(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagOpen() {
        var s0, s1, s2, s3, s4, s5, s6;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseTagName();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_();
          }
          s3 = peg$currPos;
          s4 = peg$parseValue();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            peg$savedPos = s3;
            s3 = peg$f2(s1, s4);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          s4 = peg$parseTagAttributes();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          s5 = [];
          s6 = peg$parse_();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parse_();
          }
          rule$expects(peg$e0);
          if (input.charCodeAt(peg$currPos) === 47) {
            s6 = peg$c0;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
          }
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s3, s4, s6);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagClose() {
        var s0, s1, s2;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        rule$expects(peg$e0);
        if (input.charCodeAt(peg$currPos) === 47) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseTagName();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f4(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagName() {
        var s0;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e1);
        peg$silentFails++;
        s0 = peg$parseIdentifier();
        peg$silentFails--;
        return s0;
      }
      function peg$parseTagAttributes() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parseTagAttributesItem();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseTagAttributesTail();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseTagAttributesTail();
          }
          peg$savedPos = s0;
          s0 = peg$f5(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagAttributesTail() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseTagAttributesItem();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagAttributesItem() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseTagShortcutId();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f7(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseTagShortcutClass();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f8(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseTagAttribute();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f9(s1);
            }
            s0 = s1;
          }
        }
        return s0;
      }
      function peg$parseTagShortcutClass() {
        var s0, s1, s2;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e2);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f10(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseTagShortcutId() {
        var s0, s1, s2;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e3);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c2;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f11(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseTagAttribute() {
        var s0, s1, s2, s3;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseIdentifier();
        if (s1 !== peg$FAILED) {
          rule$expects(peg$e4);
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c3;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseValue();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f12(s1, s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseFunction() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseIdentifier();
        if (s1 !== peg$FAILED) {
          rule$expects(peg$e5);
          if (input.charCodeAt(peg$currPos) === 40) {
            s2 = peg$c4;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_();
            }
            s4 = peg$currPos;
            s5 = peg$parseFunctionParameter();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            s6 = [];
            s7 = peg$parseFunctionParameterTail();
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$parseFunctionParameterTail();
            }
            peg$savedPos = s4;
            s4 = peg$f13(s1, s5, s6);
            rule$expects(peg$e6);
            if (input.charCodeAt(peg$currPos) === 41) {
              s5 = peg$c5;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f14(s1, s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseFunctionParameter() {
        var s0, s1, s2, s3;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseIdentifier();
        if (s2 !== peg$FAILED) {
          rule$expects(peg$e4);
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c3;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s1;
            s1 = peg$f15(s2);
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s2 = peg$parseValue();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f16(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseFunctionParameterTail() {
        var s0, s1, s2, s3, s4;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c6;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parse_();
          }
          s4 = peg$parseFunctionParameter();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTrailingComma() {
        var s0, s1, s2;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c6;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = null;
        }
        return s0;
      }
      function peg$parseVariable() {
        var s0, s1, s2, s3, s4;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e8);
        peg$silentFails++;
        s0 = peg$currPos;
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseVariableTail();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseVariableTail();
            }
            peg$savedPos = s0;
            s0 = peg$f18(s1, s2, s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseVariableTail() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseValueNumber();
            if (s2 === peg$FAILED) {
              s2 = peg$parseValueString();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s3 = peg$c8;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f17(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseValue() {
        var s0;
        s0 = peg$parseValueNull();
        if (s0 === peg$FAILED) {
          s0 = peg$parseValueBoolean();
          if (s0 === peg$FAILED) {
            s0 = peg$parseValueString();
            if (s0 === peg$FAILED) {
              s0 = peg$parseValueNumber();
              if (s0 === peg$FAILED) {
                s0 = peg$parseValueArray();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseValueHash();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseFunction();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseVariable();
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parseValueNull() {
        var s0, s1;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e9);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c9) {
          s1 = peg$c9;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f19();
        }
        s0 = s1;
        peg$silentFails--;
        return s0;
      }
      function peg$parseValueBoolean() {
        var s0, s1;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e10);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c10) {
          s1 = peg$c10;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f20();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c11) {
            s1 = peg$c11;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f21();
          }
          s0 = s1;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseValueArray() {
        var s0, s1, s2, s3, s4, s5, s6;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        rule$expects(peg$e11);
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_();
          }
          s3 = peg$currPos;
          s4 = peg$parseValue();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseValueArrayTail();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseValueArrayTail();
            }
            s6 = peg$parseTrailingComma();
            peg$savedPos = s3;
            s3 = peg$f22(s4, s5);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          rule$expects(peg$e12);
          if (input.charCodeAt(peg$currPos) === 93) {
            s5 = peg$c8;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f23(s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueArrayTail() {
        var s0, s1, s2, s3, s4;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c6;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parse_();
          }
          s4 = peg$parseValue();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueHash() {
        var s0, s1, s2, s3, s4, s5, s6;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        rule$expects(peg$e13);
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c12;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_();
          }
          s3 = peg$currPos;
          s4 = peg$parseValueHashItem();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseValueHashTail();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseValueHashTail();
            }
            s6 = peg$parseTrailingComma();
            peg$savedPos = s3;
            s3 = peg$f24(s4, s5);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          rule$expects(peg$e14);
          if (input.charCodeAt(peg$currPos) === 125) {
            s5 = peg$c13;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueHashTail() {
        var s0, s1, s2, s3, s4;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c6;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parse_();
          }
          s4 = peg$parseValueHashItem();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueHashItem() {
        var s0, s1, s2, s3, s4;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseIdentifier();
        if (s1 === peg$FAILED) {
          s1 = peg$parseValueString();
        }
        if (s1 !== peg$FAILED) {
          rule$expects(peg$e15);
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c14;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_();
            }
            s4 = peg$parseValue();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f26(s1, s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueNumber() {
        var s0, s2, s3, s4, s5, s6;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e16);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          peg$currPos++;
        }
        s2 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
            }
          }
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s4 = peg$c1;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                }
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f27();
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseValueString() {
        var s0, s1, s2, s3;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e17);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c16;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseValueStringChars();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseValueStringChars();
          }
          if (input.charCodeAt(peg$currPos) === 34) {
            s3 = peg$c16;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f28(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseValueStringChars() {
        var s0;
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseValueStringEscapes();
        }
        return s0;
      }
      function peg$parseValueStringEscapes() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c17;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c16;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 92) {
              s2 = peg$c17;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 110) {
                s3 = peg$c18;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$f29();
              }
              s2 = s3;
              if (s2 === peg$FAILED) {
                s2 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 114) {
                  s3 = peg$c19;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$f30();
                }
                s2 = s3;
                if (s2 === peg$FAILED) {
                  s2 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 116) {
                    s3 = peg$c20;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                  }
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$f31();
                  }
                  s2 = s3;
                }
              }
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f32(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseIdentifier() {
        var s0, s1, s2;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e18);
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (peg$r3.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$r3.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parse_() {
        var s0;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e19);
        peg$silentFails++;
        if (peg$r4.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      const { Variable: Variable2, Function: Function3 } = options2;
      peg$begin();
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$expect(peg$endExpectation());
        }
        throw peg$buildError();
      }
    }
    module.exports = {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }
});
var require_entities = __commonJS({
  "node_modules/entities/lib/maps/entities.json"(exports, module) {
    module.exports = { Aacute: "", aacute: "", Abreve: "", abreve: "", ac: "", acd: "", acE: "", Acirc: "", acirc: "", acute: "", Acy: "", acy: "", AElig: "", aelig: "", af: "", Afr: "", afr: "", Agrave: "", agrave: "", alefsym: "", aleph: "", Alpha: "", alpha: "", Amacr: "", amacr: "", amalg: "", amp: "&", AMP: "&", andand: "", And: "", and: "", andd: "", andslope: "", andv: "", ang: "", ange: "", angle: "", angmsdaa: "", angmsdab: "", angmsdac: "", angmsdad: "", angmsdae: "", angmsdaf: "", angmsdag: "", angmsdah: "", angmsd: "", angrt: "", angrtvb: "", angrtvbd: "", angsph: "", angst: "", angzarr: "", Aogon: "", aogon: "", Aopf: "", aopf: "", apacir: "", ap: "", apE: "", ape: "", apid: "", apos: "'", ApplyFunction: "", approx: "", approxeq: "", Aring: "", aring: "", Ascr: "", ascr: "", Assign: "", ast: "*", asymp: "", asympeq: "", Atilde: "", atilde: "", Auml: "", auml: "", awconint: "", awint: "", backcong: "", backepsilon: "", backprime: "", backsim: "", backsimeq: "", Backslash: "", Barv: "", barvee: "", barwed: "", Barwed: "", barwedge: "", bbrk: "", bbrktbrk: "", bcong: "", Bcy: "", bcy: "", bdquo: "", becaus: "", because: "", Because: "", bemptyv: "", bepsi: "", bernou: "", Bernoullis: "", Beta: "", beta: "", beth: "", between: "", Bfr: "", bfr: "", bigcap: "", bigcirc: "", bigcup: "", bigodot: "", bigoplus: "", bigotimes: "", bigsqcup: "", bigstar: "", bigtriangledown: "", bigtriangleup: "", biguplus: "", bigvee: "", bigwedge: "", bkarow: "", blacklozenge: "", blacksquare: "", blacktriangle: "", blacktriangledown: "", blacktriangleleft: "", blacktriangleright: "", blank: "", blk12: "", blk14: "", blk34: "", block: "", bne: "=", bnequiv: "", bNot: "", bnot: "", Bopf: "", bopf: "", bot: "", bottom: "", bowtie: "", boxbox: "", boxdl: "", boxdL: "", boxDl: "", boxDL: "", boxdr: "", boxdR: "", boxDr: "", boxDR: "", boxh: "", boxH: "", boxhd: "", boxHd: "", boxhD: "", boxHD: "", boxhu: "", boxHu: "", boxhU: "", boxHU: "", boxminus: "", boxplus: "", boxtimes: "", boxul: "", boxuL: "", boxUl: "", boxUL: "", boxur: "", boxuR: "", boxUr: "", boxUR: "", boxv: "", boxV: "", boxvh: "", boxvH: "", boxVh: "", boxVH: "", boxvl: "", boxvL: "", boxVl: "", boxVL: "", boxvr: "", boxvR: "", boxVr: "", boxVR: "", bprime: "", breve: "", Breve: "", brvbar: "", bscr: "", Bscr: "", bsemi: "", bsim: "", bsime: "", bsolb: "", bsol: "\\", bsolhsub: "", bull: "", bullet: "", bump: "", bumpE: "", bumpe: "", Bumpeq: "", bumpeq: "", Cacute: "", cacute: "", capand: "", capbrcup: "", capcap: "", cap: "", Cap: "", capcup: "", capdot: "", CapitalDifferentialD: "", caps: "", caret: "", caron: "", Cayleys: "", ccaps: "", Ccaron: "", ccaron: "", Ccedil: "", ccedil: "", Ccirc: "", ccirc: "", Cconint: "", ccups: "", ccupssm: "", Cdot: "", cdot: "", cedil: "", Cedilla: "", cemptyv: "", cent: "", centerdot: "", CenterDot: "", cfr: "", Cfr: "", CHcy: "", chcy: "", check: "", checkmark: "", Chi: "", chi: "", circ: "", circeq: "", circlearrowleft: "", circlearrowright: "", circledast: "", circledcirc: "", circleddash: "", CircleDot: "", circledR: "", circledS: "", CircleMinus: "", CirclePlus: "", CircleTimes: "", cir: "", cirE: "", cire: "", cirfnint: "", cirmid: "", cirscir: "", ClockwiseContourIntegral: "", CloseCurlyDoubleQuote: "", CloseCurlyQuote: "", clubs: "", clubsuit: "", colon: ":", Colon: "", Colone: "", colone: "", coloneq: "", comma: ",", commat: "@", comp: "", compfn: "", complement: "", complexes: "", cong: "", congdot: "", Congruent: "", conint: "", Conint: "", ContourIntegral: "", copf: "", Copf: "", coprod: "", Coproduct: "", copy: "", COPY: "", copysr: "", CounterClockwiseContourIntegral: "", crarr: "", cross: "", Cross: "", Cscr: "", cscr: "", csub: "", csube: "", csup: "", csupe: "", ctdot: "", cudarrl: "", cudarrr: "", cuepr: "", cuesc: "", cularr: "", cularrp: "", cupbrcap: "", cupcap: "", CupCap: "", cup: "", Cup: "", cupcup: "", cupdot: "", cupor: "", cups: "", curarr: "", curarrm: "", curlyeqprec: "", curlyeqsucc: "", curlyvee: "", curlywedge: "", curren: "", curvearrowleft: "", curvearrowright: "", cuvee: "", cuwed: "", cwconint: "", cwint: "", cylcty: "", dagger: "", Dagger: "", daleth: "", darr: "", Darr: "", dArr: "", dash: "", Dashv: "", dashv: "", dbkarow: "", dblac: "", Dcaron: "", dcaron: "", Dcy: "", dcy: "", ddagger: "", ddarr: "", DD: "", dd: "", DDotrahd: "", ddotseq: "", deg: "", Del: "", Delta: "", delta: "", demptyv: "", dfisht: "", Dfr: "", dfr: "", dHar: "", dharl: "", dharr: "", DiacriticalAcute: "", DiacriticalDot: "", DiacriticalDoubleAcute: "", DiacriticalGrave: "`", DiacriticalTilde: "", diam: "", diamond: "", Diamond: "", diamondsuit: "", diams: "", die: "", DifferentialD: "", digamma: "", disin: "", div: "", divide: "", divideontimes: "", divonx: "", DJcy: "", djcy: "", dlcorn: "", dlcrop: "", dollar: "$", Dopf: "", dopf: "", Dot: "", dot: "", DotDot: "", doteq: "", doteqdot: "", DotEqual: "", dotminus: "", dotplus: "", dotsquare: "", doublebarwedge: "", DoubleContourIntegral: "", DoubleDot: "", DoubleDownArrow: "", DoubleLeftArrow: "", DoubleLeftRightArrow: "", DoubleLeftTee: "", DoubleLongLeftArrow: "", DoubleLongLeftRightArrow: "", DoubleLongRightArrow: "", DoubleRightArrow: "", DoubleRightTee: "", DoubleUpArrow: "", DoubleUpDownArrow: "", DoubleVerticalBar: "", DownArrowBar: "", downarrow: "", DownArrow: "", Downarrow: "", DownArrowUpArrow: "", DownBreve: "", downdownarrows: "", downharpoonleft: "", downharpoonright: "", DownLeftRightVector: "", DownLeftTeeVector: "", DownLeftVectorBar: "", DownLeftVector: "", DownRightTeeVector: "", DownRightVectorBar: "", DownRightVector: "", DownTeeArrow: "", DownTee: "", drbkarow: "", drcorn: "", drcrop: "", Dscr: "", dscr: "", DScy: "", dscy: "", dsol: "", Dstrok: "", dstrok: "", dtdot: "", dtri: "", dtrif: "", duarr: "", duhar: "", dwangle: "", DZcy: "", dzcy: "", dzigrarr: "", Eacute: "", eacute: "", easter: "", Ecaron: "", ecaron: "", Ecirc: "", ecirc: "", ecir: "", ecolon: "", Ecy: "", ecy: "", eDDot: "", Edot: "", edot: "", eDot: "", ee: "", efDot: "", Efr: "", efr: "", eg: "", Egrave: "", egrave: "", egs: "", egsdot: "", el: "", Element: "", elinters: "", ell: "", els: "", elsdot: "", Emacr: "", emacr: "", empty: "", emptyset: "", EmptySmallSquare: "", emptyv: "", EmptyVerySmallSquare: "", emsp13: "", emsp14: "", emsp: "", ENG: "", eng: "", ensp: "", Eogon: "", eogon: "", Eopf: "", eopf: "", epar: "", eparsl: "", eplus: "", epsi: "", Epsilon: "", epsilon: "", epsiv: "", eqcirc: "", eqcolon: "", eqsim: "", eqslantgtr: "", eqslantless: "", Equal: "", equals: "=", EqualTilde: "", equest: "", Equilibrium: "", equiv: "", equivDD: "", eqvparsl: "", erarr: "", erDot: "", escr: "", Escr: "", esdot: "", Esim: "", esim: "", Eta: "", eta: "", ETH: "", eth: "", Euml: "", euml: "", euro: "", excl: "!", exist: "", Exists: "", expectation: "", exponentiale: "", ExponentialE: "", fallingdotseq: "", Fcy: "", fcy: "", female: "", ffilig: "", fflig: "", ffllig: "", Ffr: "", ffr: "", filig: "", FilledSmallSquare: "", FilledVerySmallSquare: "", fjlig: "fj", flat: "", fllig: "", fltns: "", fnof: "", Fopf: "", fopf: "", forall: "", ForAll: "", fork: "", forkv: "", Fouriertrf: "", fpartint: "", frac12: "", frac13: "", frac14: "", frac15: "", frac16: "", frac18: "", frac23: "", frac25: "", frac34: "", frac35: "", frac38: "", frac45: "", frac56: "", frac58: "", frac78: "", frasl: "", frown: "", fscr: "", Fscr: "", gacute: "", Gamma: "", gamma: "", Gammad: "", gammad: "", gap: "", Gbreve: "", gbreve: "", Gcedil: "", Gcirc: "", gcirc: "", Gcy: "", gcy: "", Gdot: "", gdot: "", ge: "", gE: "", gEl: "", gel: "", geq: "", geqq: "", geqslant: "", gescc: "", ges: "", gesdot: "", gesdoto: "", gesdotol: "", gesl: "", gesles: "", Gfr: "", gfr: "", gg: "", Gg: "", ggg: "", gimel: "", GJcy: "", gjcy: "", gla: "", gl: "", glE: "", glj: "", gnap: "", gnapprox: "", gne: "", gnE: "", gneq: "", gneqq: "", gnsim: "", Gopf: "", gopf: "", grave: "`", GreaterEqual: "", GreaterEqualLess: "", GreaterFullEqual: "", GreaterGreater: "", GreaterLess: "", GreaterSlantEqual: "", GreaterTilde: "", Gscr: "", gscr: "", gsim: "", gsime: "", gsiml: "", gtcc: "", gtcir: "", gt: ">", GT: ">", Gt: "", gtdot: "", gtlPar: "", gtquest: "", gtrapprox: "", gtrarr: "", gtrdot: "", gtreqless: "", gtreqqless: "", gtrless: "", gtrsim: "", gvertneqq: "", gvnE: "", Hacek: "", hairsp: "", half: "", hamilt: "", HARDcy: "", hardcy: "", harrcir: "", harr: "", hArr: "", harrw: "", Hat: "^", hbar: "", Hcirc: "", hcirc: "", hearts: "", heartsuit: "", hellip: "", hercon: "", hfr: "", Hfr: "", HilbertSpace: "", hksearow: "", hkswarow: "", hoarr: "", homtht: "", hookleftarrow: "", hookrightarrow: "", hopf: "", Hopf: "", horbar: "", HorizontalLine: "", hscr: "", Hscr: "", hslash: "", Hstrok: "", hstrok: "", HumpDownHump: "", HumpEqual: "", hybull: "", hyphen: "", Iacute: "", iacute: "", ic: "", Icirc: "", icirc: "", Icy: "", icy: "", Idot: "", IEcy: "", iecy: "", iexcl: "", iff: "", ifr: "", Ifr: "", Igrave: "", igrave: "", ii: "", iiiint: "", iiint: "", iinfin: "", iiota: "", IJlig: "", ijlig: "", Imacr: "", imacr: "", image: "", ImaginaryI: "", imagline: "", imagpart: "", imath: "", Im: "", imof: "", imped: "", Implies: "", incare: "", in: "", infin: "", infintie: "", inodot: "", intcal: "", int: "", Int: "", integers: "", Integral: "", intercal: "", Intersection: "", intlarhk: "", intprod: "", InvisibleComma: "", InvisibleTimes: "", IOcy: "", iocy: "", Iogon: "", iogon: "", Iopf: "", iopf: "", Iota: "", iota: "", iprod: "", iquest: "", iscr: "", Iscr: "", isin: "", isindot: "", isinE: "", isins: "", isinsv: "", isinv: "", it: "", Itilde: "", itilde: "", Iukcy: "", iukcy: "", Iuml: "", iuml: "", Jcirc: "", jcirc: "", Jcy: "", jcy: "", Jfr: "", jfr: "", jmath: "", Jopf: "", jopf: "", Jscr: "", jscr: "", Jsercy: "", jsercy: "", Jukcy: "", jukcy: "", Kappa: "", kappa: "", kappav: "", Kcedil: "", kcedil: "", Kcy: "", kcy: "", Kfr: "", kfr: "", kgreen: "", KHcy: "", khcy: "", KJcy: "", kjcy: "", Kopf: "", kopf: "", Kscr: "", kscr: "", lAarr: "", Lacute: "", lacute: "", laemptyv: "", lagran: "", Lambda: "", lambda: "", lang: "", Lang: "", langd: "", langle: "", lap: "", Laplacetrf: "", laquo: "", larrb: "", larrbfs: "", larr: "", Larr: "", lArr: "", larrfs: "", larrhk: "", larrlp: "", larrpl: "", larrsim: "", larrtl: "", latail: "", lAtail: "", lat: "", late: "", lates: "", lbarr: "", lBarr: "", lbbrk: "", lbrace: "{", lbrack: "[", lbrke: "", lbrksld: "", lbrkslu: "", Lcaron: "", lcaron: "", Lcedil: "", lcedil: "", lceil: "", lcub: "{", Lcy: "", lcy: "", ldca: "", ldquo: "", ldquor: "", ldrdhar: "", ldrushar: "", ldsh: "", le: "", lE: "", LeftAngleBracket: "", LeftArrowBar: "", leftarrow: "", LeftArrow: "", Leftarrow: "", LeftArrowRightArrow: "", leftarrowtail: "", LeftCeiling: "", LeftDoubleBracket: "", LeftDownTeeVector: "", LeftDownVectorBar: "", LeftDownVector: "", LeftFloor: "", leftharpoondown: "", leftharpoonup: "", leftleftarrows: "", leftrightarrow: "", LeftRightArrow: "", Leftrightarrow: "", leftrightarrows: "", leftrightharpoons: "", leftrightsquigarrow: "", LeftRightVector: "", LeftTeeArrow: "", LeftTee: "", LeftTeeVector: "", leftthreetimes: "", LeftTriangleBar: "", LeftTriangle: "", LeftTriangleEqual: "", LeftUpDownVector: "", LeftUpTeeVector: "", LeftUpVectorBar: "", LeftUpVector: "", LeftVectorBar: "", LeftVector: "", lEg: "", leg: "", leq: "", leqq: "", leqslant: "", lescc: "", les: "", lesdot: "", lesdoto: "", lesdotor: "", lesg: "", lesges: "", lessapprox: "", lessdot: "", lesseqgtr: "", lesseqqgtr: "", LessEqualGreater: "", LessFullEqual: "", LessGreater: "", lessgtr: "", LessLess: "", lesssim: "", LessSlantEqual: "", LessTilde: "", lfisht: "", lfloor: "", Lfr: "", lfr: "", lg: "", lgE: "", lHar: "", lhard: "", lharu: "", lharul: "", lhblk: "", LJcy: "", ljcy: "", llarr: "", ll: "", Ll: "", llcorner: "", Lleftarrow: "", llhard: "", lltri: "", Lmidot: "", lmidot: "", lmoustache: "", lmoust: "", lnap: "", lnapprox: "", lne: "", lnE: "", lneq: "", lneqq: "", lnsim: "", loang: "", loarr: "", lobrk: "", longleftarrow: "", LongLeftArrow: "", Longleftarrow: "", longleftrightarrow: "", LongLeftRightArrow: "", Longleftrightarrow: "", longmapsto: "", longrightarrow: "", LongRightArrow: "", Longrightarrow: "", looparrowleft: "", looparrowright: "", lopar: "", Lopf: "", lopf: "", loplus: "", lotimes: "", lowast: "", lowbar: "_", LowerLeftArrow: "", LowerRightArrow: "", loz: "", lozenge: "", lozf: "", lpar: "(", lparlt: "", lrarr: "", lrcorner: "", lrhar: "", lrhard: "", lrm: "", lrtri: "", lsaquo: "", lscr: "", Lscr: "", lsh: "", Lsh: "", lsim: "", lsime: "", lsimg: "", lsqb: "[", lsquo: "", lsquor: "", Lstrok: "", lstrok: "", ltcc: "", ltcir: "", lt: "<", LT: "<", Lt: "", ltdot: "", lthree: "", ltimes: "", ltlarr: "", ltquest: "", ltri: "", ltrie: "", ltrif: "", ltrPar: "", lurdshar: "", luruhar: "", lvertneqq: "", lvnE: "", macr: "", male: "", malt: "", maltese: "", Map: "", map: "", mapsto: "", mapstodown: "", mapstoleft: "", mapstoup: "", marker: "", mcomma: "", Mcy: "", mcy: "", mdash: "", mDDot: "", measuredangle: "", MediumSpace: "", Mellintrf: "", Mfr: "", mfr: "", mho: "", micro: "", midast: "*", midcir: "", mid: "", middot: "", minusb: "", minus: "", minusd: "", minusdu: "", MinusPlus: "", mlcp: "", mldr: "", mnplus: "", models: "", Mopf: "", mopf: "", mp: "", mscr: "", Mscr: "", mstpos: "", Mu: "", mu: "", multimap: "", mumap: "", nabla: "", Nacute: "", nacute: "", nang: "", nap: "", napE: "", napid: "", napos: "", napprox: "", natural: "", naturals: "", natur: "", nbsp: "", nbump: "", nbumpe: "", ncap: "", Ncaron: "", ncaron: "", Ncedil: "", ncedil: "", ncong: "", ncongdot: "", ncup: "", Ncy: "", ncy: "", ndash: "", nearhk: "", nearr: "", neArr: "", nearrow: "", ne: "", nedot: "", NegativeMediumSpace: "", NegativeThickSpace: "", NegativeThinSpace: "", NegativeVeryThinSpace: "", nequiv: "", nesear: "", nesim: "", NestedGreaterGreater: "", NestedLessLess: "", NewLine: "\n", nexist: "", nexists: "", Nfr: "", nfr: "", ngE: "", nge: "", ngeq: "", ngeqq: "", ngeqslant: "", nges: "", nGg: "", ngsim: "", nGt: "", ngt: "", ngtr: "", nGtv: "", nharr: "", nhArr: "", nhpar: "", ni: "", nis: "", nisd: "", niv: "", NJcy: "", njcy: "", nlarr: "", nlArr: "", nldr: "", nlE: "", nle: "", nleftarrow: "", nLeftarrow: "", nleftrightarrow: "", nLeftrightarrow: "", nleq: "", nleqq: "", nleqslant: "", nles: "", nless: "", nLl: "", nlsim: "", nLt: "", nlt: "", nltri: "", nltrie: "", nLtv: "", nmid: "", NoBreak: "", NonBreakingSpace: "", nopf: "", Nopf: "", Not: "", not: "", NotCongruent: "", NotCupCap: "", NotDoubleVerticalBar: "", NotElement: "", NotEqual: "", NotEqualTilde: "", NotExists: "", NotGreater: "", NotGreaterEqual: "", NotGreaterFullEqual: "", NotGreaterGreater: "", NotGreaterLess: "", NotGreaterSlantEqual: "", NotGreaterTilde: "", NotHumpDownHump: "", NotHumpEqual: "", notin: "", notindot: "", notinE: "", notinva: "", notinvb: "", notinvc: "", NotLeftTriangleBar: "", NotLeftTriangle: "", NotLeftTriangleEqual: "", NotLess: "", NotLessEqual: "", NotLessGreater: "", NotLessLess: "", NotLessSlantEqual: "", NotLessTilde: "", NotNestedGreaterGreater: "", NotNestedLessLess: "", notni: "", notniva: "", notnivb: "", notnivc: "", NotPrecedes: "", NotPrecedesEqual: "", NotPrecedesSlantEqual: "", NotReverseElement: "", NotRightTriangleBar: "", NotRightTriangle: "", NotRightTriangleEqual: "", NotSquareSubset: "", NotSquareSubsetEqual: "", NotSquareSuperset: "", NotSquareSupersetEqual: "", NotSubset: "", NotSubsetEqual: "", NotSucceeds: "", NotSucceedsEqual: "", NotSucceedsSlantEqual: "", NotSucceedsTilde: "", NotSuperset: "", NotSupersetEqual: "", NotTilde: "", NotTildeEqual: "", NotTildeFullEqual: "", NotTildeTilde: "", NotVerticalBar: "", nparallel: "", npar: "", nparsl: "", npart: "", npolint: "", npr: "", nprcue: "", nprec: "", npreceq: "", npre: "", nrarrc: "", nrarr: "", nrArr: "", nrarrw: "", nrightarrow: "", nRightarrow: "", nrtri: "", nrtrie: "", nsc: "", nsccue: "", nsce: "", Nscr: "", nscr: "", nshortmid: "", nshortparallel: "", nsim: "", nsime: "", nsimeq: "", nsmid: "", nspar: "", nsqsube: "", nsqsupe: "", nsub: "", nsubE: "", nsube: "", nsubset: "", nsubseteq: "", nsubseteqq: "", nsucc: "", nsucceq: "", nsup: "", nsupE: "", nsupe: "", nsupset: "", nsupseteq: "", nsupseteqq: "", ntgl: "", Ntilde: "", ntilde: "", ntlg: "", ntriangleleft: "", ntrianglelefteq: "", ntriangleright: "", ntrianglerighteq: "", Nu: "", nu: "", num: "#", numero: "", numsp: "", nvap: "", nvdash: "", nvDash: "", nVdash: "", nVDash: "", nvge: "", nvgt: ">", nvHarr: "", nvinfin: "", nvlArr: "", nvle: "", nvlt: "<", nvltrie: "", nvrArr: "", nvrtrie: "", nvsim: "", nwarhk: "", nwarr: "", nwArr: "", nwarrow: "", nwnear: "", Oacute: "", oacute: "", oast: "", Ocirc: "", ocirc: "", ocir: "", Ocy: "", ocy: "", odash: "", Odblac: "", odblac: "", odiv: "", odot: "", odsold: "", OElig: "", oelig: "", ofcir: "", Ofr: "", ofr: "", ogon: "", Ograve: "", ograve: "", ogt: "", ohbar: "", ohm: "", oint: "", olarr: "", olcir: "", olcross: "", oline: "", olt: "", Omacr: "", omacr: "", Omega: "", omega: "", Omicron: "", omicron: "", omid: "", ominus: "", Oopf: "", oopf: "", opar: "", OpenCurlyDoubleQuote: "", OpenCurlyQuote: "", operp: "", oplus: "", orarr: "", Or: "", or: "", ord: "", order: "", orderof: "", ordf: "", ordm: "", origof: "", oror: "", orslope: "", orv: "", oS: "", Oscr: "", oscr: "", Oslash: "", oslash: "", osol: "", Otilde: "", otilde: "", otimesas: "", Otimes: "", otimes: "", Ouml: "", ouml: "", ovbar: "", OverBar: "", OverBrace: "", OverBracket: "", OverParenthesis: "", para: "", parallel: "", par: "", parsim: "", parsl: "", part: "", PartialD: "", Pcy: "", pcy: "", percnt: "%", period: ".", permil: "", perp: "", pertenk: "", Pfr: "", pfr: "", Phi: "", phi: "", phiv: "", phmmat: "", phone: "", Pi: "", pi: "", pitchfork: "", piv: "", planck: "", planckh: "", plankv: "", plusacir: "", plusb: "", pluscir: "", plus: "+", plusdo: "", plusdu: "", pluse: "", PlusMinus: "", plusmn: "", plussim: "", plustwo: "", pm: "", Poincareplane: "", pointint: "", popf: "", Popf: "", pound: "", prap: "", Pr: "", pr: "", prcue: "", precapprox: "", prec: "", preccurlyeq: "", Precedes: "", PrecedesEqual: "", PrecedesSlantEqual: "", PrecedesTilde: "", preceq: "", precnapprox: "", precneqq: "", precnsim: "", pre: "", prE: "", precsim: "", prime: "", Prime: "", primes: "", prnap: "", prnE: "", prnsim: "", prod: "", Product: "", profalar: "", profline: "", profsurf: "", prop: "", Proportional: "", Proportion: "", propto: "", prsim: "", prurel: "", Pscr: "", pscr: "", Psi: "", psi: "", puncsp: "", Qfr: "", qfr: "", qint: "", qopf: "", Qopf: "", qprime: "", Qscr: "", qscr: "", quaternions: "", quatint: "", quest: "?", questeq: "", quot: '"', QUOT: '"', rAarr: "", race: "", Racute: "", racute: "", radic: "", raemptyv: "", rang: "", Rang: "", rangd: "", range: "", rangle: "", raquo: "", rarrap: "", rarrb: "", rarrbfs: "", rarrc: "", rarr: "", Rarr: "", rArr: "", rarrfs: "", rarrhk: "", rarrlp: "", rarrpl: "", rarrsim: "", Rarrtl: "", rarrtl: "", rarrw: "", ratail: "", rAtail: "", ratio: "", rationals: "", rbarr: "", rBarr: "", RBarr: "", rbbrk: "", rbrace: "}", rbrack: "]", rbrke: "", rbrksld: "", rbrkslu: "", Rcaron: "", rcaron: "", Rcedil: "", rcedil: "", rceil: "", rcub: "}", Rcy: "", rcy: "", rdca: "", rdldhar: "", rdquo: "", rdquor: "", rdsh: "", real: "", realine: "", realpart: "", reals: "", Re: "", rect: "", reg: "", REG: "", ReverseElement: "", ReverseEquilibrium: "", ReverseUpEquilibrium: "", rfisht: "", rfloor: "", rfr: "", Rfr: "", rHar: "", rhard: "", rharu: "", rharul: "", Rho: "", rho: "", rhov: "", RightAngleBracket: "", RightArrowBar: "", rightarrow: "", RightArrow: "", Rightarrow: "", RightArrowLeftArrow: "", rightarrowtail: "", RightCeiling: "", RightDoubleBracket: "", RightDownTeeVector: "", RightDownVectorBar: "", RightDownVector: "", RightFloor: "", rightharpoondown: "", rightharpoonup: "", rightleftarrows: "", rightleftharpoons: "", rightrightarrows: "", rightsquigarrow: "", RightTeeArrow: "", RightTee: "", RightTeeVector: "", rightthreetimes: "", RightTriangleBar: "", RightTriangle: "", RightTriangleEqual: "", RightUpDownVector: "", RightUpTeeVector: "", RightUpVectorBar: "", RightUpVector: "", RightVectorBar: "", RightVector: "", ring: "", risingdotseq: "", rlarr: "", rlhar: "", rlm: "", rmoustache: "", rmoust: "", rnmid: "", roang: "", roarr: "", robrk: "", ropar: "", ropf: "", Ropf: "", roplus: "", rotimes: "", RoundImplies: "", rpar: ")", rpargt: "", rppolint: "", rrarr: "", Rrightarrow: "", rsaquo: "", rscr: "", Rscr: "", rsh: "", Rsh: "", rsqb: "]", rsquo: "", rsquor: "", rthree: "", rtimes: "", rtri: "", rtrie: "", rtrif: "", rtriltri: "", RuleDelayed: "", ruluhar: "", rx: "", Sacute: "", sacute: "", sbquo: "", scap: "", Scaron: "", scaron: "", Sc: "", sc: "", sccue: "", sce: "", scE: "", Scedil: "", scedil: "", Scirc: "", scirc: "", scnap: "", scnE: "", scnsim: "", scpolint: "", scsim: "", Scy: "", scy: "", sdotb: "", sdot: "", sdote: "", searhk: "", searr: "", seArr: "", searrow: "", sect: "", semi: ";", seswar: "", setminus: "", setmn: "", sext: "", Sfr: "", sfr: "", sfrown: "", sharp: "", SHCHcy: "", shchcy: "", SHcy: "", shcy: "", ShortDownArrow: "", ShortLeftArrow: "", shortmid: "", shortparallel: "", ShortRightArrow: "", ShortUpArrow: "", shy: "", Sigma: "", sigma: "", sigmaf: "", sigmav: "", sim: "", simdot: "", sime: "", simeq: "", simg: "", simgE: "", siml: "", simlE: "", simne: "", simplus: "", simrarr: "", slarr: "", SmallCircle: "", smallsetminus: "", smashp: "", smeparsl: "", smid: "", smile: "", smt: "", smte: "", smtes: "", SOFTcy: "", softcy: "", solbar: "", solb: "", sol: "/", Sopf: "", sopf: "", spades: "", spadesuit: "", spar: "", sqcap: "", sqcaps: "", sqcup: "", sqcups: "", Sqrt: "", sqsub: "", sqsube: "", sqsubset: "", sqsubseteq: "", sqsup: "", sqsupe: "", sqsupset: "", sqsupseteq: "", square: "", Square: "", SquareIntersection: "", SquareSubset: "", SquareSubsetEqual: "", SquareSuperset: "", SquareSupersetEqual: "", SquareUnion: "", squarf: "", squ: "", squf: "", srarr: "", Sscr: "", sscr: "", ssetmn: "", ssmile: "", sstarf: "", Star: "", star: "", starf: "", straightepsilon: "", straightphi: "", strns: "", sub: "", Sub: "", subdot: "", subE: "", sube: "", subedot: "", submult: "", subnE: "", subne: "", subplus: "", subrarr: "", subset: "", Subset: "", subseteq: "", subseteqq: "", SubsetEqual: "", subsetneq: "", subsetneqq: "", subsim: "", subsub: "", subsup: "", succapprox: "", succ: "", succcurlyeq: "", Succeeds: "", SucceedsEqual: "", SucceedsSlantEqual: "", SucceedsTilde: "", succeq: "", succnapprox: "", succneqq: "", succnsim: "", succsim: "", SuchThat: "", sum: "", Sum: "", sung: "", sup1: "", sup2: "", sup3: "", sup: "", Sup: "", supdot: "", supdsub: "", supE: "", supe: "", supedot: "", Superset: "", SupersetEqual: "", suphsol: "", suphsub: "", suplarr: "", supmult: "", supnE: "", supne: "", supplus: "", supset: "", Supset: "", supseteq: "", supseteqq: "", supsetneq: "", supsetneqq: "", supsim: "", supsub: "", supsup: "", swarhk: "", swarr: "", swArr: "", swarrow: "", swnwar: "", szlig: "", Tab: "	", target: "", Tau: "", tau: "", tbrk: "", Tcaron: "", tcaron: "", Tcedil: "", tcedil: "", Tcy: "", tcy: "", tdot: "", telrec: "", Tfr: "", tfr: "", there4: "", therefore: "", Therefore: "", Theta: "", theta: "", thetasym: "", thetav: "", thickapprox: "", thicksim: "", ThickSpace: "", ThinSpace: "", thinsp: "", thkap: "", thksim: "", THORN: "", thorn: "", tilde: "", Tilde: "", TildeEqual: "", TildeFullEqual: "", TildeTilde: "", timesbar: "", timesb: "", times: "", timesd: "", tint: "", toea: "", topbot: "", topcir: "", top: "", Topf: "", topf: "", topfork: "", tosa: "", tprime: "", trade: "", TRADE: "", triangle: "", triangledown: "", triangleleft: "", trianglelefteq: "", triangleq: "", triangleright: "", trianglerighteq: "", tridot: "", trie: "", triminus: "", TripleDot: "", triplus: "", trisb: "", tritime: "", trpezium: "", Tscr: "", tscr: "", TScy: "", tscy: "", TSHcy: "", tshcy: "", Tstrok: "", tstrok: "", twixt: "", twoheadleftarrow: "", twoheadrightarrow: "", Uacute: "", uacute: "", uarr: "", Uarr: "", uArr: "", Uarrocir: "", Ubrcy: "", ubrcy: "", Ubreve: "", ubreve: "", Ucirc: "", ucirc: "", Ucy: "", ucy: "", udarr: "", Udblac: "", udblac: "", udhar: "", ufisht: "", Ufr: "", ufr: "", Ugrave: "", ugrave: "", uHar: "", uharl: "", uharr: "", uhblk: "", ulcorn: "", ulcorner: "", ulcrop: "", ultri: "", Umacr: "", umacr: "", uml: "", UnderBar: "_", UnderBrace: "", UnderBracket: "", UnderParenthesis: "", Union: "", UnionPlus: "", Uogon: "", uogon: "", Uopf: "", uopf: "", UpArrowBar: "", uparrow: "", UpArrow: "", Uparrow: "", UpArrowDownArrow: "", updownarrow: "", UpDownArrow: "", Updownarrow: "", UpEquilibrium: "", upharpoonleft: "", upharpoonright: "", uplus: "", UpperLeftArrow: "", UpperRightArrow: "", upsi: "", Upsi: "", upsih: "", Upsilon: "", upsilon: "", UpTeeArrow: "", UpTee: "", upuparrows: "", urcorn: "", urcorner: "", urcrop: "", Uring: "", uring: "", urtri: "", Uscr: "", uscr: "", utdot: "", Utilde: "", utilde: "", utri: "", utrif: "", uuarr: "", Uuml: "", uuml: "", uwangle: "", vangrt: "", varepsilon: "", varkappa: "", varnothing: "", varphi: "", varpi: "", varpropto: "", varr: "", vArr: "", varrho: "", varsigma: "", varsubsetneq: "", varsubsetneqq: "", varsupsetneq: "", varsupsetneqq: "", vartheta: "", vartriangleleft: "", vartriangleright: "", vBar: "", Vbar: "", vBarv: "", Vcy: "", vcy: "", vdash: "", vDash: "", Vdash: "", VDash: "", Vdashl: "", veebar: "", vee: "", Vee: "", veeeq: "", vellip: "", verbar: "|", Verbar: "", vert: "|", Vert: "", VerticalBar: "", VerticalLine: "|", VerticalSeparator: "", VerticalTilde: "", VeryThinSpace: "", Vfr: "", vfr: "", vltri: "", vnsub: "", vnsup: "", Vopf: "", vopf: "", vprop: "", vrtri: "", Vscr: "", vscr: "", vsubnE: "", vsubne: "", vsupnE: "", vsupne: "", Vvdash: "", vzigzag: "", Wcirc: "", wcirc: "", wedbar: "", wedge: "", Wedge: "", wedgeq: "", weierp: "", Wfr: "", wfr: "", Wopf: "", wopf: "", wp: "", wr: "", wreath: "", Wscr: "", wscr: "", xcap: "", xcirc: "", xcup: "", xdtri: "", Xfr: "", xfr: "", xharr: "", xhArr: "", Xi: "", xi: "", xlarr: "", xlArr: "", xmap: "", xnis: "", xodot: "", Xopf: "", xopf: "", xoplus: "", xotime: "", xrarr: "", xrArr: "", Xscr: "", xscr: "", xsqcup: "", xuplus: "", xutri: "", xvee: "", xwedge: "", Yacute: "", yacute: "", YAcy: "", yacy: "", Ycirc: "", ycirc: "", Ycy: "", ycy: "", yen: "", Yfr: "", yfr: "", YIcy: "", yicy: "", Yopf: "", yopf: "", Yscr: "", yscr: "", YUcy: "", yucy: "", yuml: "", Yuml: "", Zacute: "", zacute: "", Zcaron: "", zcaron: "", Zcy: "", zcy: "", Zdot: "", zdot: "", zeetrf: "", ZeroWidthSpace: "", Zeta: "", zeta: "", zfr: "", Zfr: "", ZHcy: "", zhcy: "", zigrarr: "", zopf: "", Zopf: "", Zscr: "", zscr: "", zwj: "", zwnj: "" };
  }
});
var require_entities2 = __commonJS({
  "node_modules/markdown-it/lib/common/entities.js"(exports, module) {
    module.exports = require_entities();
  }
});
var require_regex = __commonJS({
  "node_modules/uc.micro/categories/P/regex.js"(exports, module) {
    module.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
  }
});
var require_encode = __commonJS({
  "node_modules/mdurl/encode.js"(exports, module) {
    var encodeCache = {};
    function getEncodeCache(exclude) {
      var i, ch, cache = encodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = encodeCache[exclude] = [];
      for (i = 0; i < 128; i++) {
        ch = String.fromCharCode(i);
        if (/^[0-9a-z]$/i.test(ch)) {
          cache.push(ch);
        } else {
          cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
        }
      }
      for (i = 0; i < exclude.length; i++) {
        cache[exclude.charCodeAt(i)] = exclude[i];
      }
      return cache;
    }
    function encode2(string, exclude, keepEscaped) {
      var i, l2, code2, nextCode, cache, result = "";
      if (typeof exclude !== "string") {
        keepEscaped = exclude;
        exclude = encode2.defaultChars;
      }
      if (typeof keepEscaped === "undefined") {
        keepEscaped = true;
      }
      cache = getEncodeCache(exclude);
      for (i = 0, l2 = string.length; i < l2; i++) {
        code2 = string.charCodeAt(i);
        if (keepEscaped && code2 === 37 && i + 2 < l2) {
          if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
            result += string.slice(i, i + 3);
            i += 2;
            continue;
          }
        }
        if (code2 < 128) {
          result += cache[code2];
          continue;
        }
        if (code2 >= 55296 && code2 <= 57343) {
          if (code2 >= 55296 && code2 <= 56319 && i + 1 < l2) {
            nextCode = string.charCodeAt(i + 1);
            if (nextCode >= 56320 && nextCode <= 57343) {
              result += encodeURIComponent(string[i] + string[i + 1]);
              i++;
              continue;
            }
          }
          result += "%EF%BF%BD";
          continue;
        }
        result += encodeURIComponent(string[i]);
      }
      return result;
    }
    encode2.defaultChars = ";/?:@&=+$,-_.!~*'()#";
    encode2.componentChars = "-_.!~*'()";
    module.exports = encode2;
  }
});
var require_decode = __commonJS({
  "node_modules/mdurl/decode.js"(exports, module) {
    var decodeCache = {};
    function getDecodeCache(exclude) {
      var i, ch, cache = decodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = decodeCache[exclude] = [];
      for (i = 0; i < 128; i++) {
        ch = String.fromCharCode(i);
        cache.push(ch);
      }
      for (i = 0; i < exclude.length; i++) {
        ch = exclude.charCodeAt(i);
        cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
      }
      return cache;
    }
    function decode2(string, exclude) {
      var cache;
      if (typeof exclude !== "string") {
        exclude = decode2.defaultChars;
      }
      cache = getDecodeCache(exclude);
      return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
        var i, l2, b1, b2, b3, b4, chr, result = "";
        for (i = 0, l2 = seq.length; i < l2; i += 3) {
          b1 = parseInt(seq.slice(i + 1, i + 3), 16);
          if (b1 < 128) {
            result += cache[b1];
            continue;
          }
          if ((b1 & 224) === 192 && i + 3 < l2) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            if ((b2 & 192) === 128) {
              chr = b1 << 6 & 1984 | b2 & 63;
              if (chr < 128) {
                result += "";
              } else {
                result += String.fromCharCode(chr);
              }
              i += 3;
              continue;
            }
          }
          if ((b1 & 240) === 224 && i + 6 < l2) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            b3 = parseInt(seq.slice(i + 7, i + 9), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128) {
              chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
              if (chr < 2048 || chr >= 55296 && chr <= 57343) {
                result += "";
              } else {
                result += String.fromCharCode(chr);
              }
              i += 6;
              continue;
            }
          }
          if ((b1 & 248) === 240 && i + 9 < l2) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            b3 = parseInt(seq.slice(i + 7, i + 9), 16);
            b4 = parseInt(seq.slice(i + 10, i + 12), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
              chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
              if (chr < 65536 || chr > 1114111) {
                result += "";
              } else {
                chr -= 65536;
                result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
              }
              i += 9;
              continue;
            }
          }
          result += "";
        }
        return result;
      });
    }
    decode2.defaultChars = ";/?:@&=+$,#";
    decode2.componentChars = "";
    module.exports = decode2;
  }
});
var require_format = __commonJS({
  "node_modules/mdurl/format.js"(exports, module) {
    module.exports = function format2(url) {
      var result = "";
      result += url.protocol || "";
      result += url.slashes ? "//" : "";
      result += url.auth ? url.auth + "@" : "";
      if (url.hostname && url.hostname.indexOf(":") !== -1) {
        result += "[" + url.hostname + "]";
      } else {
        result += url.hostname || "";
      }
      result += url.port ? ":" + url.port : "";
      result += url.pathname || "";
      result += url.search || "";
      result += url.hash || "";
      return result;
    };
  }
});
var require_parse = __commonJS({
  "node_modules/mdurl/parse.js"(exports, module) {
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.pathname = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    var hostEndingChars = ["/", "?", "#"];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    var slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    function urlParse(url, slashesDenoteHost) {
      if (url && url instanceof Url) {
        return url;
      }
      var u = new Url();
      u.parse(url, slashesDenoteHost);
      return u;
    }
    Url.prototype.parse = function(url, slashesDenoteHost) {
      var i, l2, lowerProto, hec, slashes, rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        lowerProto = proto.toLowerCase();
        this.protocol = proto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (i = 0; i < hostEndingChars.length; i++) {
          hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = auth;
        }
        hostEnd = -1;
        for (i = 0; i < nonHostChars.length; i++) {
          hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        if (rest[hostEnd - 1] === ":") {
          hostEnd--;
        }
        var host2 = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost(host2);
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (i = 0, l2 = hostparts.length; i < l2; i++) {
            var part = hostparts[i];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        }
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        }
      }
      var hash2 = rest.indexOf("#");
      if (hash2 !== -1) {
        this.hash = rest.substr(hash2);
        rest = rest.slice(0, hash2);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        rest = rest.slice(0, qm);
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "";
      }
      return this;
    };
    Url.prototype.parseHost = function(host2) {
      var port = portPattern.exec(host2);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host2 = host2.substr(0, host2.length - port.length);
      }
      if (host2) {
        this.hostname = host2;
      }
    };
    module.exports = urlParse;
  }
});
var require_mdurl = __commonJS({
  "node_modules/mdurl/index.js"(exports, module) {
    module.exports.encode = require_encode();
    module.exports.decode = require_decode();
    module.exports.format = require_format();
    module.exports.parse = require_parse();
  }
});
var require_regex2 = __commonJS({
  "node_modules/uc.micro/properties/Any/regex.js"(exports, module) {
    module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  }
});
var require_regex3 = __commonJS({
  "node_modules/uc.micro/categories/Cc/regex.js"(exports, module) {
    module.exports = /[\0-\x1F\x7F-\x9F]/;
  }
});
var require_regex4 = __commonJS({
  "node_modules/uc.micro/categories/Cf/regex.js"(exports, module) {
    module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
  }
});
var require_regex5 = __commonJS({
  "node_modules/uc.micro/categories/Z/regex.js"(exports, module) {
    module.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  }
});
var require_uc = __commonJS({
  "node_modules/uc.micro/index.js"(exports) {
    exports.Any = require_regex2();
    exports.Cc = require_regex3();
    exports.Cf = require_regex4();
    exports.P = require_regex();
    exports.Z = require_regex5();
  }
});
var require_utils = __commonJS({
  "node_modules/markdown-it/lib/common/utils.js"(exports) {
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString2(obj) {
      return _class(obj) === "[object String]";
    }
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function has(object, key) {
      return _hasOwnProperty.call(object, key);
    }
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be object");
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function arrayReplaceAt(src, pos, newElements) {
      return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
    }
    function isValidEntityCode(c) {
      if (c >= 55296 && c <= 57343) {
        return false;
      }
      if (c >= 64976 && c <= 65007) {
        return false;
      }
      if ((c & 65535) === 65535 || (c & 65535) === 65534) {
        return false;
      }
      if (c >= 0 && c <= 8) {
        return false;
      }
      if (c === 11) {
        return false;
      }
      if (c >= 14 && c <= 31) {
        return false;
      }
      if (c >= 127 && c <= 159) {
        return false;
      }
      if (c > 1114111) {
        return false;
      }
      return true;
    }
    function fromCodePoint2(c) {
      if (c > 65535) {
        c -= 65536;
        var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      }
      return String.fromCharCode(c);
    }
    var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
    var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
    var entities = require_entities2();
    function replaceEntityPattern(match2, name2) {
      var code2 = 0;
      if (has(entities, name2)) {
        return entities[name2];
      }
      if (name2.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name2)) {
        code2 = name2[1].toLowerCase() === "x" ? parseInt(name2.slice(2), 16) : parseInt(name2.slice(1), 10);
        if (isValidEntityCode(code2)) {
          return fromCodePoint2(code2);
        }
      }
      return match2;
    }
    function unescapeMd(str) {
      if (str.indexOf("\\") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_MD_RE, "$1");
    }
    function unescapeAll(str) {
      if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_ALL_RE, function(match2, escaped, entity) {
        if (escaped) {
          return escaped;
        }
        return replaceEntityPattern(match2, entity);
      });
    }
    var HTML_ESCAPE_TEST_RE = /[&<>"]/;
    var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
    var HTML_REPLACEMENTS = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    function replaceUnsafeChar(ch) {
      return HTML_REPLACEMENTS[ch];
    }
    function escapeHtml2(str) {
      if (HTML_ESCAPE_TEST_RE.test(str)) {
        return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
      }
      return str;
    }
    var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
    function escapeRE(str) {
      return str.replace(REGEXP_ESCAPE_RE, "\\$&");
    }
    function isSpace(code2) {
      switch (code2) {
        case 9:
        case 32:
          return true;
      }
      return false;
    }
    function isWhiteSpace(code2) {
      if (code2 >= 8192 && code2 <= 8202) {
        return true;
      }
      switch (code2) {
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 32:
        case 160:
        case 5760:
        case 8239:
        case 8287:
        case 12288:
          return true;
      }
      return false;
    }
    var UNICODE_PUNCT_RE = require_regex();
    function isPunctChar(ch) {
      return UNICODE_PUNCT_RE.test(ch);
    }
    function isMdAsciiPunct(ch) {
      switch (ch) {
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 124:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    function normalizeReference(str) {
      str = str.trim().replace(/\s+/g, " ");
      if ("".toLowerCase() === "") {
        str = str.replace(//g, "");
      }
      return str.toLowerCase().toUpperCase();
    }
    exports.lib = {};
    exports.lib.mdurl = require_mdurl();
    exports.lib.ucmicro = require_uc();
    exports.assign = assign;
    exports.isString = isString2;
    exports.has = has;
    exports.unescapeMd = unescapeMd;
    exports.unescapeAll = unescapeAll;
    exports.isValidEntityCode = isValidEntityCode;
    exports.fromCodePoint = fromCodePoint2;
    exports.escapeHtml = escapeHtml2;
    exports.arrayReplaceAt = arrayReplaceAt;
    exports.isSpace = isSpace;
    exports.isWhiteSpace = isWhiteSpace;
    exports.isMdAsciiPunct = isMdAsciiPunct;
    exports.isPunctChar = isPunctChar;
    exports.escapeRE = escapeRE;
    exports.normalizeReference = normalizeReference;
  }
});
var require_parse_link_label = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_label.js"(exports, module) {
    module.exports = function parseLinkLabel(state, start2, disableNested) {
      var level, found, marker, prevPos, labelEnd = -1, max2 = state.posMax, oldPos = state.pos;
      state.pos = start2 + 1;
      level = 1;
      while (state.pos < max2) {
        marker = state.src.charCodeAt(state.pos);
        if (marker === 93) {
          level--;
          if (level === 0) {
            found = true;
            break;
          }
        }
        prevPos = state.pos;
        state.md.inline.skipToken(state);
        if (marker === 91) {
          if (prevPos === state.pos - 1) {
            level++;
          } else if (disableNested) {
            state.pos = oldPos;
            return -1;
          }
        }
      }
      if (found) {
        labelEnd = state.pos;
      }
      state.pos = oldPos;
      return labelEnd;
    };
  }
});
var require_parse_link_destination = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_destination.js"(exports, module) {
    var unescapeAll = require_utils().unescapeAll;
    module.exports = function parseLinkDestination(str, pos, max2) {
      var code2, level, lines = 0, start2 = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (str.charCodeAt(pos) === 60) {
        pos++;
        while (pos < max2) {
          code2 = str.charCodeAt(pos);
          if (code2 === 10) {
            return result;
          }
          if (code2 === 60) {
            return result;
          }
          if (code2 === 62) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start2 + 1, pos));
            result.ok = true;
            return result;
          }
          if (code2 === 92 && pos + 1 < max2) {
            pos += 2;
            continue;
          }
          pos++;
        }
        return result;
      }
      level = 0;
      while (pos < max2) {
        code2 = str.charCodeAt(pos);
        if (code2 === 32) {
          break;
        }
        if (code2 < 32 || code2 === 127) {
          break;
        }
        if (code2 === 92 && pos + 1 < max2) {
          if (str.charCodeAt(pos + 1) === 32) {
            break;
          }
          pos += 2;
          continue;
        }
        if (code2 === 40) {
          level++;
          if (level > 32) {
            return result;
          }
        }
        if (code2 === 41) {
          if (level === 0) {
            break;
          }
          level--;
        }
        pos++;
      }
      if (start2 === pos) {
        return result;
      }
      if (level !== 0) {
        return result;
      }
      result.str = unescapeAll(str.slice(start2, pos));
      result.lines = lines;
      result.pos = pos;
      result.ok = true;
      return result;
    };
  }
});
var require_parse_link_title = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_title.js"(exports, module) {
    var unescapeAll = require_utils().unescapeAll;
    module.exports = function parseLinkTitle(str, pos, max2) {
      var code2, marker, lines = 0, start2 = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (pos >= max2) {
        return result;
      }
      marker = str.charCodeAt(pos);
      if (marker !== 34 && marker !== 39 && marker !== 40) {
        return result;
      }
      pos++;
      if (marker === 40) {
        marker = 41;
      }
      while (pos < max2) {
        code2 = str.charCodeAt(pos);
        if (code2 === marker) {
          result.pos = pos + 1;
          result.lines = lines;
          result.str = unescapeAll(str.slice(start2 + 1, pos));
          result.ok = true;
          return result;
        } else if (code2 === 40 && marker === 41) {
          return result;
        } else if (code2 === 10) {
          lines++;
        } else if (code2 === 92 && pos + 1 < max2) {
          pos++;
          if (str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
        pos++;
      }
      return result;
    };
  }
});
var require_helpers = __commonJS({
  "node_modules/markdown-it/lib/helpers/index.js"(exports) {
    exports.parseLinkLabel = require_parse_link_label();
    exports.parseLinkDestination = require_parse_link_destination();
    exports.parseLinkTitle = require_parse_link_title();
  }
});
var require_renderer = __commonJS({
  "node_modules/markdown-it/lib/renderer.js"(exports, module) {
    var assign = require_utils().assign;
    var unescapeAll = require_utils().unescapeAll;
    var escapeHtml2 = require_utils().escapeHtml;
    var default_rules = {};
    default_rules.code_inline = function(tokens2, idx, options2, env, slf) {
      var token = tokens2[idx];
      return "<code" + slf.renderAttrs(token) + ">" + escapeHtml2(tokens2[idx].content) + "</code>";
    };
    default_rules.code_block = function(tokens2, idx, options2, env, slf) {
      var token = tokens2[idx];
      return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml2(tokens2[idx].content) + "</code></pre>\n";
    };
    default_rules.fence = function(tokens2, idx, options2, env, slf) {
      var token = tokens2[idx], info2 = token.info ? unescapeAll(token.info).trim() : "", langName = "", langAttrs = "", highlighted, i, arr, tmpAttrs, tmpToken;
      if (info2) {
        arr = info2.split(/(\s+)/g);
        langName = arr[0];
        langAttrs = arr.slice(2).join("");
      }
      if (options2.highlight) {
        highlighted = options2.highlight(token.content, langName, langAttrs) || escapeHtml2(token.content);
      } else {
        highlighted = escapeHtml2(token.content);
      }
      if (highlighted.indexOf("<pre") === 0) {
        return highlighted + "\n";
      }
      if (info2) {
        i = token.attrIndex("class");
        tmpAttrs = token.attrs ? token.attrs.slice() : [];
        if (i < 0) {
          tmpAttrs.push(["class", options2.langPrefix + langName]);
        } else {
          tmpAttrs[i] = tmpAttrs[i].slice();
          tmpAttrs[i][1] += " " + options2.langPrefix + langName;
        }
        tmpToken = {
          attrs: tmpAttrs
        };
        return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
      }
      return "<pre><code" + slf.renderAttrs(token) + ">" + highlighted + "</code></pre>\n";
    };
    default_rules.image = function(tokens2, idx, options2, env, slf) {
      var token = tokens2[idx];
      token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options2, env);
      return slf.renderToken(tokens2, idx, options2);
    };
    default_rules.hardbreak = function(tokens2, idx, options2) {
      return options2.xhtmlOut ? "<br />\n" : "<br>\n";
    };
    default_rules.softbreak = function(tokens2, idx, options2) {
      return options2.breaks ? options2.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
    };
    default_rules.text = function(tokens2, idx) {
      return escapeHtml2(tokens2[idx].content);
    };
    default_rules.html_block = function(tokens2, idx) {
      return tokens2[idx].content;
    };
    default_rules.html_inline = function(tokens2, idx) {
      return tokens2[idx].content;
    };
    function Renderer() {
      this.rules = assign({}, default_rules);
    }
    Renderer.prototype.renderAttrs = function renderAttrs(token) {
      var i, l2, result;
      if (!token.attrs) {
        return "";
      }
      result = "";
      for (i = 0, l2 = token.attrs.length; i < l2; i++) {
        result += " " + escapeHtml2(token.attrs[i][0]) + '="' + escapeHtml2(token.attrs[i][1]) + '"';
      }
      return result;
    };
    Renderer.prototype.renderToken = function renderToken(tokens2, idx, options2) {
      var nextToken, result = "", needLf = false, token = tokens2[idx];
      if (token.hidden) {
        return "";
      }
      if (token.block && token.nesting !== -1 && idx && tokens2[idx - 1].hidden) {
        result += "\n";
      }
      result += (token.nesting === -1 ? "</" : "<") + token.tag;
      result += this.renderAttrs(token);
      if (token.nesting === 0 && options2.xhtmlOut) {
        result += " /";
      }
      if (token.block) {
        needLf = true;
        if (token.nesting === 1) {
          if (idx + 1 < tokens2.length) {
            nextToken = tokens2[idx + 1];
            if (nextToken.type === "inline" || nextToken.hidden) {
              needLf = false;
            } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
              needLf = false;
            }
          }
        }
      }
      result += needLf ? ">\n" : ">";
      return result;
    };
    Renderer.prototype.renderInline = function(tokens2, options2, env) {
      var type, result = "", rules = this.rules;
      for (var i = 0, len = tokens2.length; i < len; i++) {
        type = tokens2[i].type;
        if (typeof rules[type] !== "undefined") {
          result += rules[type](tokens2, i, options2, env, this);
        } else {
          result += this.renderToken(tokens2, i, options2);
        }
      }
      return result;
    };
    Renderer.prototype.renderInlineAsText = function(tokens2, options2, env) {
      var result = "";
      for (var i = 0, len = tokens2.length; i < len; i++) {
        if (tokens2[i].type === "text") {
          result += tokens2[i].content;
        } else if (tokens2[i].type === "image") {
          result += this.renderInlineAsText(tokens2[i].children, options2, env);
        } else if (tokens2[i].type === "softbreak") {
          result += "\n";
        }
      }
      return result;
    };
    Renderer.prototype.render = function(tokens2, options2, env) {
      var i, len, type, result = "", rules = this.rules;
      for (i = 0, len = tokens2.length; i < len; i++) {
        type = tokens2[i].type;
        if (type === "inline") {
          result += this.renderInline(tokens2[i].children, options2, env);
        } else if (typeof rules[type] !== "undefined") {
          result += rules[tokens2[i].type](tokens2, i, options2, env, this);
        } else {
          result += this.renderToken(tokens2, i, options2, env);
        }
      }
      return result;
    };
    module.exports = Renderer;
  }
});
var require_ruler = __commonJS({
  "node_modules/markdown-it/lib/ruler.js"(exports, module) {
    function Ruler() {
      this.__rules__ = [];
      this.__cache__ = null;
    }
    Ruler.prototype.__find__ = function(name2) {
      for (var i = 0; i < this.__rules__.length; i++) {
        if (this.__rules__[i].name === name2) {
          return i;
        }
      }
      return -1;
    };
    Ruler.prototype.__compile__ = function() {
      var self2 = this;
      var chains = [""];
      self2.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
          return;
        }
        rule.alt.forEach(function(altName) {
          if (chains.indexOf(altName) < 0) {
            chains.push(altName);
          }
        });
      });
      self2.__cache__ = {};
      chains.forEach(function(chain) {
        self2.__cache__[chain] = [];
        self2.__rules__.forEach(function(rule) {
          if (!rule.enabled) {
            return;
          }
          if (chain && rule.alt.indexOf(chain) < 0) {
            return;
          }
          self2.__cache__[chain].push(rule.fn);
        });
      });
    };
    Ruler.prototype.at = function(name2, fn2, options2) {
      var index = this.__find__(name2);
      var opt = options2 || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + name2);
      }
      this.__rules__[index].fn = fn2;
      this.__rules__[index].alt = opt.alt || [];
      this.__cache__ = null;
    };
    Ruler.prototype.before = function(beforeName, ruleName, fn2, options2) {
      var index = this.__find__(beforeName);
      var opt = options2 || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + beforeName);
      }
      this.__rules__.splice(index, 0, {
        name: ruleName,
        enabled: true,
        fn: fn2,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.after = function(afterName, ruleName, fn2, options2) {
      var index = this.__find__(afterName);
      var opt = options2 || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + afterName);
      }
      this.__rules__.splice(index + 1, 0, {
        name: ruleName,
        enabled: true,
        fn: fn2,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.push = function(ruleName, fn2, options2) {
      var opt = options2 || {};
      this.__rules__.push({
        name: ruleName,
        enabled: true,
        fn: fn2,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.enable = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      var result = [];
      list2.forEach(function(name2) {
        var idx = this.__find__(name2);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name2);
        }
        this.__rules__[idx].enabled = true;
        result.push(name2);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.enableOnly = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      this.__rules__.forEach(function(rule) {
        rule.enabled = false;
      });
      this.enable(list2, ignoreInvalid);
    };
    Ruler.prototype.disable = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      var result = [];
      list2.forEach(function(name2) {
        var idx = this.__find__(name2);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name2);
        }
        this.__rules__[idx].enabled = false;
        result.push(name2);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.getRules = function(chainName) {
      if (this.__cache__ === null) {
        this.__compile__();
      }
      return this.__cache__[chainName] || [];
    };
    module.exports = Ruler;
  }
});
var require_normalize = __commonJS({
  "node_modules/markdown-it/lib/rules_core/normalize.js"(exports, module) {
    var NEWLINES_RE = /\r\n?|\n/g;
    var NULL_RE = /\0/g;
    module.exports = function normalize(state) {
      var str;
      str = state.src.replace(NEWLINES_RE, "\n");
      str = str.replace(NULL_RE, "");
      state.src = str;
    };
  }
});
var require_block = __commonJS({
  "node_modules/markdown-it/lib/rules_core/block.js"(exports, module) {
    module.exports = function block4(state) {
      var token;
      if (state.inlineMode) {
        token = new state.Token("inline", "", 0);
        token.content = state.src;
        token.map = [0, 1];
        token.children = [];
        state.tokens.push(token);
      } else {
        state.md.block.parse(state.src, state.md, state.env, state.tokens);
      }
    };
  }
});
var require_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_core/inline.js"(exports, module) {
    module.exports = function inline4(state) {
      var tokens2 = state.tokens, tok, i, l2;
      for (i = 0, l2 = tokens2.length; i < l2; i++) {
        tok = tokens2[i];
        if (tok.type === "inline") {
          state.md.inline.parse(tok.content, state.md, state.env, tok.children);
        }
      }
    };
  }
});
var require_linkify = __commonJS({
  "node_modules/markdown-it/lib/rules_core/linkify.js"(exports, module) {
    var arrayReplaceAt = require_utils().arrayReplaceAt;
    function isLinkOpen(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose(str) {
      return /^<\/a\s*>/i.test(str);
    }
    module.exports = function linkify(state) {
      var i, j, l2, tokens2, token, currentToken, nodes, ln, text2, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
      if (!state.md.options.linkify) {
        return;
      }
      for (j = 0, l2 = blockTokens.length; j < l2; j++) {
        if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
          continue;
        }
        tokens2 = blockTokens[j].children;
        htmlLinkLevel = 0;
        for (i = tokens2.length - 1; i >= 0; i--) {
          currentToken = tokens2[i];
          if (currentToken.type === "link_close") {
            i--;
            while (tokens2[i].level !== currentToken.level && tokens2[i].type !== "link_open") {
              i--;
            }
            continue;
          }
          if (currentToken.type === "html_inline") {
            if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
              htmlLinkLevel--;
            }
            if (isLinkClose(currentToken.content)) {
              htmlLinkLevel++;
            }
          }
          if (htmlLinkLevel > 0) {
            continue;
          }
          if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
            text2 = currentToken.content;
            links = state.md.linkify.match(text2);
            nodes = [];
            level = currentToken.level;
            lastPos = 0;
            for (ln = 0; ln < links.length; ln++) {
              url = links[ln].url;
              fullUrl = state.md.normalizeLink(url);
              if (!state.md.validateLink(fullUrl)) {
                continue;
              }
              urlText = links[ln].text;
              if (!links[ln].schema) {
                urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
              } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
              } else {
                urlText = state.md.normalizeLinkText(urlText);
              }
              pos = links[ln].index;
              if (pos > lastPos) {
                token = new state.Token("text", "", 0);
                token.content = text2.slice(lastPos, pos);
                token.level = level;
                nodes.push(token);
              }
              token = new state.Token("link_open", "a", 1);
              token.attrs = [["href", fullUrl]];
              token.level = level++;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              token = new state.Token("text", "", 0);
              token.content = urlText;
              token.level = level;
              nodes.push(token);
              token = new state.Token("link_close", "a", -1);
              token.level = --level;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              lastPos = links[ln].lastIndex;
            }
            if (lastPos < text2.length) {
              token = new state.Token("text", "", 0);
              token.content = text2.slice(lastPos);
              token.level = level;
              nodes.push(token);
            }
            blockTokens[j].children = tokens2 = arrayReplaceAt(tokens2, i, nodes);
          }
        }
      }
    };
  }
});
var require_replacements = __commonJS({
  "node_modules/markdown-it/lib/rules_core/replacements.js"(exports, module) {
    var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
    var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;
    var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
    var SCOPED_ABBR = {
      c: "",
      r: "",
      p: "",
      tm: ""
    };
    function replaceFn(match2, name2) {
      return SCOPED_ABBR[name2.toLowerCase()];
    }
    function replace_scoped(inlineTokens) {
      var i, token, inside_autolink = 0;
      for (i = inlineTokens.length - 1; i >= 0; i--) {
        token = inlineTokens[i];
        if (token.type === "text" && !inside_autolink) {
          token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    function replace_rare(inlineTokens) {
      var i, token, inside_autolink = 0;
      for (i = inlineTokens.length - 1; i >= 0; i--) {
        token = inlineTokens[i];
        if (token.type === "text" && !inside_autolink) {
          if (RARE_RE.test(token.content)) {
            token.content = token.content.replace(/\+-/g, "").replace(/\.{2,}/g, "").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1").replace(/(^|\s)--(?=\s|$)/mg, "$1").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1");
          }
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    module.exports = function replace(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline") {
          continue;
        }
        if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
          replace_scoped(state.tokens[blkIdx].children);
        }
        if (RARE_RE.test(state.tokens[blkIdx].content)) {
          replace_rare(state.tokens[blkIdx].children);
        }
      }
    };
  }
});
var require_smartquotes = __commonJS({
  "node_modules/markdown-it/lib/rules_core/smartquotes.js"(exports, module) {
    var isWhiteSpace = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    var QUOTE_TEST_RE = /['"]/;
    var QUOTE_RE = /['"]/g;
    var APOSTROPHE = "";
    function replaceAt(str, index, ch) {
      return str.substr(0, index) + ch + str.substr(index + 1);
    }
    function process_inlines(tokens2, state) {
      var i, token, text2, t2, pos, max2, thisLevel, item2, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
      stack = [];
      for (i = 0; i < tokens2.length; i++) {
        token = tokens2[i];
        thisLevel = tokens2[i].level;
        for (j = stack.length - 1; j >= 0; j--) {
          if (stack[j].level <= thisLevel) {
            break;
          }
        }
        stack.length = j + 1;
        if (token.type !== "text") {
          continue;
        }
        text2 = token.content;
        pos = 0;
        max2 = text2.length;
        OUTER:
          while (pos < max2) {
            QUOTE_RE.lastIndex = pos;
            t2 = QUOTE_RE.exec(text2);
            if (!t2) {
              break;
            }
            canOpen = canClose = true;
            pos = t2.index + 1;
            isSingle = t2[0] === "'";
            lastChar = 32;
            if (t2.index - 1 >= 0) {
              lastChar = text2.charCodeAt(t2.index - 1);
            } else {
              for (j = i - 1; j >= 0; j--) {
                if (tokens2[j].type === "softbreak" || tokens2[j].type === "hardbreak")
                  break;
                if (!tokens2[j].content)
                  continue;
                lastChar = tokens2[j].content.charCodeAt(tokens2[j].content.length - 1);
                break;
              }
            }
            nextChar = 32;
            if (pos < max2) {
              nextChar = text2.charCodeAt(pos);
            } else {
              for (j = i + 1; j < tokens2.length; j++) {
                if (tokens2[j].type === "softbreak" || tokens2[j].type === "hardbreak")
                  break;
                if (!tokens2[j].content)
                  continue;
                nextChar = tokens2[j].content.charCodeAt(0);
                break;
              }
            }
            isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
            isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
            isLastWhiteSpace = isWhiteSpace(lastChar);
            isNextWhiteSpace = isWhiteSpace(nextChar);
            if (isNextWhiteSpace) {
              canOpen = false;
            } else if (isNextPunctChar) {
              if (!(isLastWhiteSpace || isLastPunctChar)) {
                canOpen = false;
              }
            }
            if (isLastWhiteSpace) {
              canClose = false;
            } else if (isLastPunctChar) {
              if (!(isNextWhiteSpace || isNextPunctChar)) {
                canClose = false;
              }
            }
            if (nextChar === 34 && t2[0] === '"') {
              if (lastChar >= 48 && lastChar <= 57) {
                canClose = canOpen = false;
              }
            }
            if (canOpen && canClose) {
              canOpen = isLastPunctChar;
              canClose = isNextPunctChar;
            }
            if (!canOpen && !canClose) {
              if (isSingle) {
                token.content = replaceAt(token.content, t2.index, APOSTROPHE);
              }
              continue;
            }
            if (canClose) {
              for (j = stack.length - 1; j >= 0; j--) {
                item2 = stack[j];
                if (stack[j].level < thisLevel) {
                  break;
                }
                if (item2.single === isSingle && stack[j].level === thisLevel) {
                  item2 = stack[j];
                  if (isSingle) {
                    openQuote = state.md.options.quotes[2];
                    closeQuote = state.md.options.quotes[3];
                  } else {
                    openQuote = state.md.options.quotes[0];
                    closeQuote = state.md.options.quotes[1];
                  }
                  token.content = replaceAt(token.content, t2.index, closeQuote);
                  tokens2[item2.token].content = replaceAt(tokens2[item2.token].content, item2.pos, openQuote);
                  pos += closeQuote.length - 1;
                  if (item2.token === i) {
                    pos += openQuote.length - 1;
                  }
                  text2 = token.content;
                  max2 = text2.length;
                  stack.length = j;
                  continue OUTER;
                }
              }
            }
            if (canOpen) {
              stack.push({
                token: i,
                pos: t2.index,
                single: isSingle,
                level: thisLevel
              });
            } else if (canClose && isSingle) {
              token.content = replaceAt(token.content, t2.index, APOSTROPHE);
            }
          }
      }
    }
    module.exports = function smartquotes(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
          continue;
        }
        process_inlines(state.tokens[blkIdx].children, state);
      }
    };
  }
});
var require_token = __commonJS({
  "node_modules/markdown-it/lib/token.js"(exports, module) {
    function Token(type, tag, nesting) {
      this.type = type;
      this.tag = tag;
      this.attrs = null;
      this.map = null;
      this.nesting = nesting;
      this.level = 0;
      this.children = null;
      this.content = "";
      this.markup = "";
      this.info = "";
      this.meta = null;
      this.block = false;
      this.hidden = false;
    }
    Token.prototype.attrIndex = function attrIndex(name2) {
      var attrs, i, len;
      if (!this.attrs) {
        return -1;
      }
      attrs = this.attrs;
      for (i = 0, len = attrs.length; i < len; i++) {
        if (attrs[i][0] === name2) {
          return i;
        }
      }
      return -1;
    };
    Token.prototype.attrPush = function attrPush(attrData) {
      if (this.attrs) {
        this.attrs.push(attrData);
      } else {
        this.attrs = [attrData];
      }
    };
    Token.prototype.attrSet = function attrSet(name2, value2) {
      var idx = this.attrIndex(name2), attrData = [name2, value2];
      if (idx < 0) {
        this.attrPush(attrData);
      } else {
        this.attrs[idx] = attrData;
      }
    };
    Token.prototype.attrGet = function attrGet(name2) {
      var idx = this.attrIndex(name2), value2 = null;
      if (idx >= 0) {
        value2 = this.attrs[idx][1];
      }
      return value2;
    };
    Token.prototype.attrJoin = function attrJoin(name2, value2) {
      var idx = this.attrIndex(name2);
      if (idx < 0) {
        this.attrPush([name2, value2]);
      } else {
        this.attrs[idx][1] = this.attrs[idx][1] + " " + value2;
      }
    };
    module.exports = Token;
  }
});
var require_state_core = __commonJS({
  "node_modules/markdown-it/lib/rules_core/state_core.js"(exports, module) {
    var Token = require_token();
    function StateCore(src, md, env) {
      this.src = src;
      this.env = env;
      this.tokens = [];
      this.inlineMode = false;
      this.md = md;
    }
    StateCore.prototype.Token = Token;
    module.exports = StateCore;
  }
});
var require_parser_core = __commonJS({
  "node_modules/markdown-it/lib/parser_core.js"(exports, module) {
    var Ruler = require_ruler();
    var _rules = [
      ["normalize", require_normalize()],
      ["block", require_block()],
      ["inline", require_inline()],
      ["linkify", require_linkify()],
      ["replacements", require_replacements()],
      ["smartquotes", require_smartquotes()]
    ];
    function Core() {
      this.ruler = new Ruler();
      for (var i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1]);
      }
    }
    Core.prototype.process = function(state) {
      var i, l2, rules;
      rules = this.ruler.getRules("");
      for (i = 0, l2 = rules.length; i < l2; i++) {
        rules[i](state);
      }
    };
    Core.prototype.State = require_state_core();
    module.exports = Core;
  }
});
var require_table = __commonJS({
  "node_modules/markdown-it/lib/rules_block/table.js"(exports, module) {
    var isSpace = require_utils().isSpace;
    function getLine2(state, line) {
      var pos = state.bMarks[line] + state.tShift[line], max2 = state.eMarks[line];
      return state.src.substr(pos, max2 - pos);
    }
    function escapedSplit(str) {
      var result = [], pos = 0, max2 = str.length, ch, isEscaped = false, lastPos = 0, current = "";
      ch = str.charCodeAt(pos);
      while (pos < max2) {
        if (ch === 124) {
          if (!isEscaped) {
            result.push(current + str.substring(lastPos, pos));
            current = "";
            lastPos = pos + 1;
          } else {
            current += str.substring(lastPos, pos - 1);
            lastPos = pos;
          }
        }
        isEscaped = ch === 92;
        pos++;
        ch = str.charCodeAt(pos);
      }
      result.push(current + str.substring(lastPos));
      return result;
    }
    module.exports = function table3(state, startLine, endLine, silent) {
      var ch, lineText, pos, i, l2, nextLine, columns, columnCount, token, aligns, t2, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
      if (startLine + 2 > endLine) {
        return false;
      }
      nextLine = startLine + 1;
      if (state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      firstCh = state.src.charCodeAt(pos++);
      if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
        return false;
      }
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      secondCh = state.src.charCodeAt(pos++);
      if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
        return false;
      }
      if (firstCh === 45 && isSpace(secondCh)) {
        return false;
      }
      while (pos < state.eMarks[nextLine]) {
        ch = state.src.charCodeAt(pos);
        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
          return false;
        }
        pos++;
      }
      lineText = getLine2(state, startLine + 1);
      columns = lineText.split("|");
      aligns = [];
      for (i = 0; i < columns.length; i++) {
        t2 = columns[i].trim();
        if (!t2) {
          if (i === 0 || i === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }
        if (!/^:?-+:?$/.test(t2)) {
          return false;
        }
        if (t2.charCodeAt(t2.length - 1) === 58) {
          aligns.push(t2.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t2.charCodeAt(0) === 58) {
          aligns.push("left");
        } else {
          aligns.push("");
        }
      }
      lineText = getLine2(state, startLine).trim();
      if (lineText.indexOf("|") === -1) {
        return false;
      }
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "")
        columns.shift();
      if (columns.length && columns[columns.length - 1] === "")
        columns.pop();
      columnCount = columns.length;
      if (columnCount === 0 || columnCount !== aligns.length) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldParentType = state.parentType;
      state.parentType = "table";
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      token = state.push("table_open", "table", 1);
      token.map = tableLines = [startLine, 0];
      token = state.push("thead_open", "thead", 1);
      token.map = [startLine, startLine + 1];
      token = state.push("tr_open", "tr", 1);
      token.map = [startLine, startLine + 1];
      for (i = 0; i < columns.length; i++) {
        token = state.push("th_open", "th", 1);
        if (aligns[i]) {
          token.attrs = [["style", "text-align:" + aligns[i]]];
        }
        token = state.push("inline", "", 0);
        token.content = columns[i].trim();
        token.children = [];
        token = state.push("th_close", "th", -1);
      }
      token = state.push("tr_close", "tr", -1);
      token = state.push("thead_close", "thead", -1);
      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        terminate = false;
        for (i = 0, l2 = terminatorRules.length; i < l2; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        lineText = getLine2(state, nextLine).trim();
        if (!lineText) {
          break;
        }
        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        columns = escapedSplit(lineText);
        if (columns.length && columns[0] === "")
          columns.shift();
        if (columns.length && columns[columns.length - 1] === "")
          columns.pop();
        if (nextLine === startLine + 2) {
          token = state.push("tbody_open", "tbody", 1);
          token.map = tbodyLines = [startLine + 2, 0];
        }
        token = state.push("tr_open", "tr", 1);
        token.map = [nextLine, nextLine + 1];
        for (i = 0; i < columnCount; i++) {
          token = state.push("td_open", "td", 1);
          if (aligns[i]) {
            token.attrs = [["style", "text-align:" + aligns[i]]];
          }
          token = state.push("inline", "", 0);
          token.content = columns[i] ? columns[i].trim() : "";
          token.children = [];
          token = state.push("td_close", "td", -1);
        }
        token = state.push("tr_close", "tr", -1);
      }
      if (tbodyLines) {
        token = state.push("tbody_close", "tbody", -1);
        tbodyLines[1] = nextLine;
      }
      token = state.push("table_close", "table", -1);
      tableLines[1] = nextLine;
      state.parentType = oldParentType;
      state.line = nextLine;
      return true;
    };
  }
});
var require_code = __commonJS({
  "node_modules/markdown-it/lib/rules_block/code.js"(exports, module) {
    module.exports = function code2(state, startLine, endLine) {
      if (state.md.options.allowIndentation) {
        return false;
      }
      var nextLine, last, token;
      if (state.sCount[startLine] - state.blkIndent < 4) {
        return false;
      }
      last = nextLine = startLine + 1;
      while (nextLine < endLine) {
        if (state.isEmpty(nextLine)) {
          nextLine++;
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          nextLine++;
          last = nextLine;
          continue;
        }
        break;
      }
      state.line = last;
      token = state.push("code_block", "code", 0);
      token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
      token.map = [startLine, state.line];
      return true;
    };
  }
});
var require_fence = __commonJS({
  "node_modules/markdown-it/lib/rules_block/fence.js"(exports, module) {
    module.exports = function fence3(state, startLine, endLine, silent) {
      var marker, len, params, nextLine, mem, token, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (pos + 3 > max2) {
        return false;
      }
      marker = state.src.charCodeAt(pos);
      if (marker !== 126 && marker !== 96) {
        return false;
      }
      mem = pos;
      pos = state.skipChars(pos, marker);
      len = pos - mem;
      if (len < 3) {
        return false;
      }
      markup = state.src.slice(mem, pos);
      params = state.src.slice(pos, max2);
      if (marker === 96) {
        if (params.indexOf(String.fromCharCode(marker)) >= 0) {
          return false;
        }
      }
      if (silent) {
        return true;
      }
      nextLine = startLine;
      for (; ; ) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
        max2 = state.eMarks[nextLine];
        if (pos < max2 && state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.src.charCodeAt(pos) !== marker) {
          continue;
        }
        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {
          continue;
        }
        pos = state.skipChars(pos, marker);
        if (pos - mem < len) {
          continue;
        }
        pos = state.skipSpaces(pos);
        if (pos < max2) {
          continue;
        }
        haveEndMarker = true;
        break;
      }
      len = state.sCount[startLine];
      state.line = nextLine + (haveEndMarker ? 1 : 0);
      token = state.push("fence", "code", 0);
      token.info = params;
      token.content = state.getLines(startLine + 1, nextLine, len, true);
      token.markup = markup;
      token.map = [startLine, state.line];
      return true;
    };
  }
});
var require_blockquote = __commonJS({
  "node_modules/markdown-it/lib/rules_block/blockquote.js"(exports, module) {
    var isSpace = require_utils().isSpace;
    module.exports = function blockquote2(state, startLine, endLine, silent) {
      var adjustTab, ch, i, initial, l2, lastLineEmpty, lines, nextLine, offset2, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos++) !== 62) {
        return false;
      }
      if (silent) {
        return true;
      }
      initial = offset2 = state.sCount[startLine] + 1;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        offset2++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[startLine] + offset2) % 4 === 3) {
          pos++;
          initial++;
          offset2++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      oldBMarks = [state.bMarks[startLine]];
      state.bMarks[startLine] = pos;
      while (pos < max2) {
        ch = state.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset2 += 4 - (offset2 + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset2++;
          }
        } else {
          break;
        }
        pos++;
      }
      oldBSCount = [state.bsCount[startLine]];
      state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
      lastLineEmpty = pos >= max2;
      oldSCount = [state.sCount[startLine]];
      state.sCount[startLine] = offset2 - initial;
      oldTShift = [state.tShift[startLine]];
      state.tShift[startLine] = pos - state.bMarks[startLine];
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      oldParentType = state.parentType;
      state.parentType = "blockquote";
      for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
        isOutdented = state.sCount[nextLine] < state.blkIndent;
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max2 = state.eMarks[nextLine];
        if (pos >= max2) {
          break;
        }
        if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
          initial = offset2 = state.sCount[nextLine] + 1;
          if (state.src.charCodeAt(pos) === 32) {
            pos++;
            initial++;
            offset2++;
            adjustTab = false;
            spaceAfterMarker = true;
          } else if (state.src.charCodeAt(pos) === 9) {
            spaceAfterMarker = true;
            if ((state.bsCount[nextLine] + offset2) % 4 === 3) {
              pos++;
              initial++;
              offset2++;
              adjustTab = false;
            } else {
              adjustTab = true;
            }
          } else {
            spaceAfterMarker = false;
          }
          oldBMarks.push(state.bMarks[nextLine]);
          state.bMarks[nextLine] = pos;
          while (pos < max2) {
            ch = state.src.charCodeAt(pos);
            if (isSpace(ch)) {
              if (ch === 9) {
                offset2 += 4 - (offset2 + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
              } else {
                offset2++;
              }
            } else {
              break;
            }
            pos++;
          }
          lastLineEmpty = pos >= max2;
          oldBSCount.push(state.bsCount[nextLine]);
          state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] = offset2 - initial;
          oldTShift.push(state.tShift[nextLine]);
          state.tShift[nextLine] = pos - state.bMarks[nextLine];
          continue;
        }
        if (lastLineEmpty) {
          break;
        }
        terminate = false;
        for (i = 0, l2 = terminatorRules.length; i < l2; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          state.lineMax = nextLine;
          if (state.blkIndent !== 0) {
            oldBMarks.push(state.bMarks[nextLine]);
            oldBSCount.push(state.bsCount[nextLine]);
            oldTShift.push(state.tShift[nextLine]);
            oldSCount.push(state.sCount[nextLine]);
            state.sCount[nextLine] -= state.blkIndent;
          }
          break;
        }
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = -1;
      }
      oldIndent = state.blkIndent;
      state.blkIndent = 0;
      token = state.push("blockquote_open", "blockquote", 1);
      token.markup = ">";
      token.map = lines = [startLine, 0];
      state.md.block.tokenize(state, startLine, nextLine);
      token = state.push("blockquote_close", "blockquote", -1);
      token.markup = ">";
      state.lineMax = oldLineMax;
      state.parentType = oldParentType;
      lines[1] = state.line;
      for (i = 0; i < oldTShift.length; i++) {
        state.bMarks[i + startLine] = oldBMarks[i];
        state.tShift[i + startLine] = oldTShift[i];
        state.sCount[i + startLine] = oldSCount[i];
        state.bsCount[i + startLine] = oldBSCount[i];
      }
      state.blkIndent = oldIndent;
      return true;
    };
  }
});
var require_hr = __commonJS({
  "node_modules/markdown-it/lib/rules_block/hr.js"(exports, module) {
    var isSpace = require_utils().isSpace;
    module.exports = function hr2(state, startLine, endLine, silent) {
      var marker, cnt, ch, token, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 95) {
        return false;
      }
      cnt = 1;
      while (pos < max2) {
        ch = state.src.charCodeAt(pos++);
        if (ch !== marker && !isSpace(ch)) {
          return false;
        }
        if (ch === marker) {
          cnt++;
        }
      }
      if (cnt < 3) {
        return false;
      }
      if (silent) {
        return true;
      }
      state.line = startLine + 1;
      token = state.push("hr", "hr", 0);
      token.map = [startLine, state.line];
      token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
      return true;
    };
  }
});
var require_list = __commonJS({
  "node_modules/markdown-it/lib/rules_block/list.js"(exports, module) {
    var isSpace = require_utils().isSpace;
    function skipBulletListMarker(state, startLine) {
      var marker, pos, max2, ch;
      pos = state.bMarks[startLine] + state.tShift[startLine];
      max2 = state.eMarks[startLine];
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 43) {
        return -1;
      }
      if (pos < max2) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function skipOrderedListMarker(state, startLine) {
      var ch, start2 = state.bMarks[startLine] + state.tShift[startLine], pos = start2, max2 = state.eMarks[startLine];
      if (pos + 1 >= max2) {
        return -1;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch < 48 || ch > 57) {
        return -1;
      }
      for (; ; ) {
        if (pos >= max2) {
          return -1;
        }
        ch = state.src.charCodeAt(pos++);
        if (ch >= 48 && ch <= 57) {
          if (pos - start2 >= 10) {
            return -1;
          }
          continue;
        }
        if (ch === 41 || ch === 46) {
          break;
        }
        return -1;
      }
      if (pos < max2) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function markTightParagraphs(state, idx) {
      var i, l2, level = state.level + 2;
      for (i = idx + 2, l2 = state.tokens.length - 2; i < l2; i++) {
        if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
          state.tokens[i + 2].hidden = true;
          state.tokens[i].hidden = true;
          i += 2;
        }
      }
    }
    module.exports = function list2(state, startLine, endLine, silent) {
      var ch, contentStart, i, indent, indentAfterMarker, initial, isOrdered, itemLines, l2, listLines, listTokIdx, markerCharCode, markerValue, max2, nextLine, offset2, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start2, terminate, terminatorRules, token, isTerminatingParagraph = false, tight = true;
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.allowIndentation && state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {
        return false;
      }
      if (silent && state.parentType === "paragraph") {
        if (state.sCount[startLine] >= state.blkIndent) {
          isTerminatingParagraph = true;
        }
      }
      if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
        isOrdered = true;
        start2 = state.bMarks[startLine] + state.tShift[startLine];
        markerValue = Number(state.src.slice(start2, posAfterMarker - 1));
        if (isTerminatingParagraph && markerValue !== 1)
          return false;
      } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
        isOrdered = false;
      } else {
        return false;
      }
      if (isTerminatingParagraph) {
        if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine])
          return false;
      }
      markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
      if (silent) {
        return true;
      }
      listTokIdx = state.tokens.length;
      if (isOrdered) {
        token = state.push("ordered_list_open", "ol", 1);
        if (markerValue !== 1) {
          token.attrs = [["start", markerValue]];
        }
      } else {
        token = state.push("bullet_list_open", "ul", 1);
      }
      token.map = listLines = [startLine, 0];
      token.markup = String.fromCharCode(markerCharCode);
      nextLine = startLine;
      prevEmptyEnd = false;
      terminatorRules = state.md.block.ruler.getRules("list");
      oldParentType = state.parentType;
      state.parentType = "list";
      while (nextLine < endLine) {
        pos = posAfterMarker;
        max2 = state.eMarks[nextLine];
        initial = offset2 = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);
        while (pos < max2) {
          ch = state.src.charCodeAt(pos);
          if (ch === 9) {
            offset2 += 4 - (offset2 + state.bsCount[nextLine]) % 4;
          } else if (ch === 32) {
            offset2++;
          } else {
            break;
          }
          pos++;
        }
        contentStart = pos;
        if (contentStart >= max2) {
          indentAfterMarker = 1;
        } else {
          indentAfterMarker = offset2 - initial;
        }
        if (!state.md.options.allowIndentation && indentAfterMarker > 4) {
          indentAfterMarker = 1;
        }
        indent = initial + indentAfterMarker;
        token = state.push("list_item_open", "li", 1);
        token.markup = String.fromCharCode(markerCharCode);
        token.map = itemLines = [startLine, 0];
        if (isOrdered) {
          token.info = state.src.slice(start2, posAfterMarker - 1);
        }
        oldTight = state.tight;
        oldTShift = state.tShift[startLine];
        oldSCount = state.sCount[startLine];
        oldListIndent = state.listIndent;
        state.listIndent = state.blkIndent;
        state.blkIndent = indent;
        state.tight = true;
        state.tShift[startLine] = contentStart - state.bMarks[startLine];
        state.sCount[startLine] = offset2;
        if (contentStart >= max2 && state.isEmpty(startLine + 1)) {
          state.line = Math.min(state.line + 2, endLine);
        } else {
          state.md.block.tokenize(state, startLine, endLine, true);
        }
        if (!state.tight || prevEmptyEnd) {
          tight = false;
        }
        prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
        state.blkIndent = state.listIndent;
        state.listIndent = oldListIndent;
        state.tShift[startLine] = oldTShift;
        state.sCount[startLine] = oldSCount;
        state.tight = oldTight;
        token = state.push("list_item_close", "li", -1);
        token.markup = String.fromCharCode(markerCharCode);
        nextLine = startLine = state.line;
        itemLines[1] = nextLine;
        contentStart = state.bMarks[startLine];
        if (nextLine >= endLine) {
          break;
        }
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
          break;
        }
        terminate = false;
        for (i = 0, l2 = terminatorRules.length; i < l2; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        if (isOrdered) {
          posAfterMarker = skipOrderedListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
          start2 = state.bMarks[nextLine] + state.tShift[nextLine];
        } else {
          posAfterMarker = skipBulletListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
        }
        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
          break;
        }
      }
      if (isOrdered) {
        token = state.push("ordered_list_close", "ol", -1);
      } else {
        token = state.push("bullet_list_close", "ul", -1);
      }
      token.markup = String.fromCharCode(markerCharCode);
      listLines[1] = nextLine;
      state.line = nextLine;
      state.parentType = oldParentType;
      if (tight) {
        markTightParagraphs(state, listTokIdx);
      }
      return true;
    };
  }
});
var require_reference = __commonJS({
  "node_modules/markdown-it/lib/rules_block/reference.js"(exports, module) {
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module.exports = function reference2(state, startLine, _endLine, silent) {
      var ch, destEndPos, destEndLineNo, endLine, href, i, l2, label, labelEnd, oldParentType, res, start2, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine], nextLine = startLine + 1;
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 91) {
        return false;
      }
      while (++pos < max2) {
        if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
          if (pos + 1 === max2) {
            return false;
          }
          if (state.src.charCodeAt(pos + 1) !== 58) {
            return false;
          }
          break;
        }
      }
      endLine = state.lineMax;
      terminatorRules = state.md.block.ruler.getRules("reference");
      oldParentType = state.parentType;
      state.parentType = "reference";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l2 = terminatorRules.length; i < l2; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      max2 = str.length;
      for (pos = 1; pos < max2; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 91) {
          return false;
        } else if (ch === 93) {
          labelEnd = pos;
          break;
        } else if (ch === 10) {
          lines++;
        } else if (ch === 92) {
          pos++;
          if (pos < max2 && str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
      }
      if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
        return false;
      }
      for (pos = labelEnd + 2; pos < max2; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) ;
        else {
          break;
        }
      }
      res = state.md.helpers.parseLinkDestination(str, pos, max2);
      if (!res.ok) {
        return false;
      }
      href = state.md.normalizeLink(res.str);
      if (!state.md.validateLink(href)) {
        return false;
      }
      pos = res.pos;
      lines += res.lines;
      destEndPos = pos;
      destEndLineNo = lines;
      start2 = pos;
      for (; pos < max2; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) ;
        else {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(str, pos, max2);
      if (pos < max2 && start2 !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        lines += res.lines;
      } else {
        title = "";
        pos = destEndPos;
        lines = destEndLineNo;
      }
      while (pos < max2) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
      if (pos < max2 && str.charCodeAt(pos) !== 10) {
        if (title) {
          title = "";
          pos = destEndPos;
          lines = destEndLineNo;
          while (pos < max2) {
            ch = str.charCodeAt(pos);
            if (!isSpace(ch)) {
              break;
            }
            pos++;
          }
        }
      }
      if (pos < max2 && str.charCodeAt(pos) !== 10) {
        return false;
      }
      label = normalizeReference(str.slice(1, labelEnd));
      if (!label) {
        return false;
      }
      if (silent) {
        return true;
      }
      if (typeof state.env.references === "undefined") {
        state.env.references = {};
      }
      if (typeof state.env.references[label] === "undefined") {
        state.env.references[label] = { title, href };
      }
      state.parentType = oldParentType;
      state.line = startLine + lines + 1;
      return true;
    };
  }
});
var require_html_blocks = __commonJS({
  "node_modules/markdown-it/lib/common/html_blocks.js"(exports, module) {
    module.exports = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
  }
});
var require_html_re = __commonJS({
  "node_modules/markdown-it/lib/common/html_re.js"(exports, module) {
    var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
    var unquoted = "[^\"'=<>`\\x00-\\x20]+";
    var single_quoted = "'[^']*'";
    var double_quoted = '"[^"]*"';
    var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
    var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
    var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
    var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    var comment2 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
    var processing2 = "<[?][\\s\\S]*?[?]>";
    var declaration = "<![A-Z]+\\s+[^>]*>";
    var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
    var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment2 + "|" + processing2 + "|" + declaration + "|" + cdata + ")");
    var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
    module.exports.HTML_TAG_RE = HTML_TAG_RE;
    module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;
  }
});
var require_html_block = __commonJS({
  "node_modules/markdown-it/lib/rules_block/html_block.js"(exports, module) {
    var block_names = require_html_blocks();
    var HTML_OPEN_CLOSE_TAG_RE = require_html_re().HTML_OPEN_CLOSE_TAG_RE;
    var HTML_SEQUENCES = [
      [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
      [/^<!--/, /-->/, true],
      [/^<\?/, /\?>/, true],
      [/^<![A-Z]/, />/, true],
      [/^<!\[CDATA\[/, /\]\]>/, true],
      [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
      [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
    ];
    module.exports = function html_block(state, startLine, endLine, silent) {
      var i, nextLine, token, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.html) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      lineText = state.src.slice(pos, max2);
      for (i = 0; i < HTML_SEQUENCES.length; i++) {
        if (HTML_SEQUENCES[i][0].test(lineText)) {
          break;
        }
      }
      if (i === HTML_SEQUENCES.length) {
        return false;
      }
      if (silent) {
        return HTML_SEQUENCES[i][2];
      }
      nextLine = startLine + 1;
      if (!HTML_SEQUENCES[i][1].test(lineText)) {
        for (; nextLine < endLine; nextLine++) {
          if (state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max2 = state.eMarks[nextLine];
          lineText = state.src.slice(pos, max2);
          if (HTML_SEQUENCES[i][1].test(lineText)) {
            if (lineText.length !== 0) {
              nextLine++;
            }
            break;
          }
        }
      }
      state.line = nextLine;
      token = state.push("html_block", "", 0);
      token.map = [startLine, nextLine];
      token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
      return true;
    };
  }
});
var require_heading = __commonJS({
  "node_modules/markdown-it/lib/rules_block/heading.js"(exports, module) {
    var isSpace = require_utils().isSpace;
    module.exports = function heading2(state, startLine, endLine, silent) {
      var ch, level, tmp, token, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      ch = state.src.charCodeAt(pos);
      if (ch !== 35 || pos >= max2) {
        return false;
      }
      level = 1;
      ch = state.src.charCodeAt(++pos);
      while (ch === 35 && pos < max2 && level <= 6) {
        level++;
        ch = state.src.charCodeAt(++pos);
      }
      if (level > 6 || pos < max2 && !isSpace(ch)) {
        return false;
      }
      if (silent) {
        return true;
      }
      max2 = state.skipSpacesBack(max2, pos);
      tmp = state.skipCharsBack(max2, 35, pos);
      if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
        max2 = tmp;
      }
      state.line = startLine + 1;
      token = state.push("heading_open", "h" + String(level), 1);
      token.markup = "########".slice(0, level);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = state.src.slice(pos, max2).trim();
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("heading_close", "h" + String(level), -1);
      token.markup = "########".slice(0, level);
      return true;
    };
  }
});
var require_lheading = __commonJS({
  "node_modules/markdown-it/lib/rules_block/lheading.js"(exports, module) {
    module.exports = function lheading(state, startLine, endLine) {
      var content2, terminate, i, l2, token, pos, max2, level, marker, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] >= state.blkIndent) {
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max2 = state.eMarks[nextLine];
          if (pos < max2) {
            marker = state.src.charCodeAt(pos);
            if (marker === 45 || marker === 61) {
              pos = state.skipChars(pos, marker);
              pos = state.skipSpaces(pos);
              if (pos >= max2) {
                level = marker === 61 ? 1 : 2;
                break;
              }
            }
          }
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l2 = terminatorRules.length; i < l2; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      if (!level) {
        return false;
      }
      content2 = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine + 1;
      token = state.push("heading_open", "h" + String(level), 1);
      token.markup = String.fromCharCode(marker);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content2;
      token.map = [startLine, state.line - 1];
      token.children = [];
      token = state.push("heading_close", "h" + String(level), -1);
      token.markup = String.fromCharCode(marker);
      state.parentType = oldParentType;
      return true;
    };
  }
});
var require_paragraph = __commonJS({
  "node_modules/markdown-it/lib/rules_block/paragraph.js"(exports, module) {
    module.exports = function paragraph2(state, startLine) {
      var content2, terminate, i, l2, token, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph"), endLine = state.lineMax;
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l2 = terminatorRules.length; i < l2; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      content2 = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine;
      token = state.push("paragraph_open", "p", 1);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content2;
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("paragraph_close", "p", -1);
      state.parentType = oldParentType;
      return true;
    };
  }
});
var require_state_block = __commonJS({
  "node_modules/markdown-it/lib/rules_block/state_block.js"(exports, module) {
    var Token = require_token();
    var isSpace = require_utils().isSpace;
    function StateBlock(src, md, env, tokens2) {
      var ch, s2, start2, pos, len, indent, offset2, indent_found;
      this.src = src;
      this.md = md;
      this.env = env;
      this.tokens = tokens2;
      this.bMarks = [];
      this.eMarks = [];
      this.tShift = [];
      this.sCount = [];
      this.bsCount = [];
      this.blkIndent = 0;
      this.line = 0;
      this.lineMax = 0;
      this.tight = false;
      this.ddIndent = -1;
      this.listIndent = -1;
      this.parentType = "root";
      this.level = 0;
      this.result = "";
      s2 = this.src;
      indent_found = false;
      for (start2 = pos = indent = offset2 = 0, len = s2.length; pos < len; pos++) {
        ch = s2.charCodeAt(pos);
        if (!indent_found) {
          if (isSpace(ch)) {
            indent++;
            if (ch === 9) {
              offset2 += 4 - offset2 % 4;
            } else {
              offset2++;
            }
            continue;
          } else {
            indent_found = true;
          }
        }
        if (ch === 10 || pos === len - 1) {
          if (ch !== 10) {
            pos++;
          }
          this.bMarks.push(start2);
          this.eMarks.push(pos);
          this.tShift.push(indent);
          this.sCount.push(offset2);
          this.bsCount.push(0);
          indent_found = false;
          indent = 0;
          offset2 = 0;
          start2 = pos + 1;
        }
      }
      this.bMarks.push(s2.length);
      this.eMarks.push(s2.length);
      this.tShift.push(0);
      this.sCount.push(0);
      this.bsCount.push(0);
      this.lineMax = this.bMarks.length - 1;
    }
    StateBlock.prototype.push = function(type, tag, nesting) {
      var token = new Token(type, tag, nesting);
      token.block = true;
      if (nesting < 0)
        this.level--;
      token.level = this.level;
      if (nesting > 0)
        this.level++;
      this.tokens.push(token);
      return token;
    };
    StateBlock.prototype.isEmpty = function isEmpty(line) {
      return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
    };
    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
      for (var max2 = this.lineMax; from < max2; from++) {
        if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
          break;
        }
      }
      return from;
    };
    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
      var ch;
      for (var max2 = this.src.length; pos < max2; pos++) {
        ch = this.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min2) {
      if (pos <= min2) {
        return pos;
      }
      while (pos > min2) {
        if (!isSpace(this.src.charCodeAt(--pos))) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipChars = function skipChars(pos, code2) {
      for (var max2 = this.src.length; pos < max2; pos++) {
        if (this.src.charCodeAt(pos) !== code2) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min2) {
      if (pos <= min2) {
        return pos;
      }
      while (pos > min2) {
        if (code2 !== this.src.charCodeAt(--pos)) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.getLines = function getLines(begin, end2, indent, keepLastLF) {
      var i, lineIndent, ch, first, last, queue, lineStart, line = begin;
      if (begin >= end2) {
        return "";
      }
      queue = new Array(end2 - begin);
      for (i = 0; line < end2; line++, i++) {
        lineIndent = 0;
        lineStart = first = this.bMarks[line];
        if (line + 1 < end2 || keepLastLF) {
          last = this.eMarks[line] + 1;
        } else {
          last = this.eMarks[line];
        }
        while (first < last && lineIndent < indent) {
          ch = this.src.charCodeAt(first);
          if (isSpace(ch)) {
            if (ch === 9) {
              lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
            } else {
              lineIndent++;
            }
          } else if (first - lineStart < this.tShift[line]) {
            lineIndent++;
          } else {
            break;
          }
          first++;
        }
        if (lineIndent > indent) {
          queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
        } else {
          queue[i] = this.src.slice(first, last);
        }
      }
      return queue.join("");
    };
    StateBlock.prototype.Token = Token;
    module.exports = StateBlock;
  }
});
var require_parser_block = __commonJS({
  "node_modules/markdown-it/lib/parser_block.js"(exports, module) {
    var Ruler = require_ruler();
    var _rules = [
      ["table", require_table(), ["paragraph", "reference"]],
      ["code", require_code()],
      ["fence", require_fence(), ["paragraph", "reference", "blockquote", "list"]],
      ["blockquote", require_blockquote(), ["paragraph", "reference", "blockquote", "list"]],
      ["hr", require_hr(), ["paragraph", "reference", "blockquote", "list"]],
      ["list", require_list(), ["paragraph", "reference", "blockquote"]],
      ["reference", require_reference()],
      ["html_block", require_html_block(), ["paragraph", "reference", "blockquote"]],
      ["heading", require_heading(), ["paragraph", "reference", "blockquote"]],
      ["lheading", require_lheading()],
      ["paragraph", require_paragraph()]
    ];
    function ParserBlock() {
      this.ruler = new Ruler();
      for (var i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
      }
    }
    ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
      var ok, i, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
      while (line < endLine) {
        state.line = line = state.skipEmptyLines(line);
        if (line >= endLine) {
          break;
        }
        if (state.sCount[line] < state.blkIndent) {
          break;
        }
        if (state.level >= maxNesting) {
          state.line = endLine;
          break;
        }
        for (i = 0; i < len; i++) {
          ok = rules[i](state, line, endLine, false);
          if (ok) {
            break;
          }
        }
        state.tight = !hasEmptyLines;
        if (state.isEmpty(state.line - 1)) {
          hasEmptyLines = true;
        }
        line = state.line;
        if (line < endLine && state.isEmpty(line)) {
          hasEmptyLines = true;
          line++;
          state.line = line;
        }
      }
    };
    ParserBlock.prototype.parse = function(src, md, env, outTokens) {
      var state;
      if (!src) {
        return;
      }
      state = new this.State(src, md, env, outTokens);
      this.tokenize(state, state.line, state.lineMax);
    };
    ParserBlock.prototype.State = require_state_block();
    module.exports = ParserBlock;
  }
});
var require_text = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/text.js"(exports, module) {
    function isTerminatorChar(ch) {
      switch (ch) {
        case 10:
        case 33:
        case 35:
        case 36:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 58:
        case 60:
        case 61:
        case 62:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    module.exports = function text2(state, silent) {
      var pos = state.pos;
      while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
        pos++;
      }
      if (pos === state.pos) {
        return false;
      }
      if (!silent) {
        state.pending += state.src.slice(state.pos, pos);
      }
      state.pos = pos;
      return true;
    };
  }
});
var require_newline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/newline.js"(exports, module) {
    var isSpace = require_utils().isSpace;
    module.exports = function newline(state, silent) {
      var pmax, max2, ws, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 10) {
        return false;
      }
      pmax = state.pending.length - 1;
      max2 = state.posMax;
      if (!silent) {
        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
          if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
            ws = pmax - 1;
            while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
              ws--;
            state.pending = state.pending.slice(0, ws);
            state.push("hardbreak", "br", 0);
          } else {
            state.pending = state.pending.slice(0, -1);
            state.push("softbreak", "br", 0);
          }
        } else {
          state.push("softbreak", "br", 0);
        }
      }
      pos++;
      while (pos < max2 && isSpace(state.src.charCodeAt(pos))) {
        pos++;
      }
      state.pos = pos;
      return true;
    };
  }
});
var require_escape = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/escape.js"(exports, module) {
    var isSpace = require_utils().isSpace;
    var ESCAPED = [];
    for (i = 0; i < 256; i++) {
      ESCAPED.push(0);
    }
    var i;
    "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
      ESCAPED[ch.charCodeAt(0)] = 1;
    });
    module.exports = function escape(state, silent) {
      var ch, pos = state.pos, max2 = state.posMax;
      if (state.src.charCodeAt(pos) !== 92) {
        return false;
      }
      pos++;
      if (pos < max2) {
        ch = state.src.charCodeAt(pos);
        if (ch < 256 && ESCAPED[ch] !== 0) {
          if (!silent) {
            state.pending += state.src[pos];
          }
          state.pos += 2;
          return true;
        }
        if (ch === 10) {
          if (!silent) {
            state.push("hardbreak", "br", 0);
          }
          pos++;
          while (pos < max2) {
            ch = state.src.charCodeAt(pos);
            if (!isSpace(ch)) {
              break;
            }
            pos++;
          }
          state.pos = pos;
          return true;
        }
      }
      if (!silent) {
        state.pending += "\\";
      }
      state.pos++;
      return true;
    };
  }
});
var require_backticks = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/backticks.js"(exports, module) {
    module.exports = function backtick(state, silent) {
      var start2, max2, marker, token, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
      if (ch !== 96) {
        return false;
      }
      start2 = pos;
      pos++;
      max2 = state.posMax;
      while (pos < max2 && state.src.charCodeAt(pos) === 96) {
        pos++;
      }
      marker = state.src.slice(start2, pos);
      openerLength = marker.length;
      if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start2) {
        if (!silent)
          state.pending += marker;
        state.pos += openerLength;
        return true;
      }
      matchStart = matchEnd = pos;
      while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
        matchEnd = matchStart + 1;
        while (matchEnd < max2 && state.src.charCodeAt(matchEnd) === 96) {
          matchEnd++;
        }
        closerLength = matchEnd - matchStart;
        if (closerLength === openerLength) {
          if (!silent) {
            token = state.push("code_inline", "code", 0);
            token.markup = marker;
            token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
          }
          state.pos = matchEnd;
          return true;
        }
        state.backticks[closerLength] = matchStart;
      }
      state.backticksScanned = true;
      if (!silent)
        state.pending += marker;
      state.pos += openerLength;
      return true;
    };
  }
});
var require_strikethrough = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/strikethrough.js"(exports, module) {
    module.exports.tokenize = function strikethrough(state, silent) {
      var i, scanned, token, len, ch, start2 = state.pos, marker = state.src.charCodeAt(start2);
      if (silent) {
        return false;
      }
      if (marker !== 126) {
        return false;
      }
      scanned = state.scanDelims(state.pos, true);
      len = scanned.length;
      ch = String.fromCharCode(marker);
      if (len < 2) {
        return false;
      }
      if (len % 2) {
        token = state.push("text", "", 0);
        token.content = ch;
        len--;
      }
      for (i = 0; i < len; i += 2) {
        token = state.push("text", "", 0);
        token.content = ch + ch;
        state.delimiters.push({
          marker,
          length: 0,
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i, j, startDelim, endDelim, token, loneMarkers = [], max2 = delimiters.length;
      for (i = 0; i < max2; i++) {
        startDelim = delimiters[i];
        if (startDelim.marker !== 126) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        token = state.tokens[startDelim.token];
        token.type = "s_open";
        token.tag = "s";
        token.nesting = 1;
        token.markup = "~~";
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = "s_close";
        token.tag = "s";
        token.nesting = -1;
        token.markup = "~~";
        token.content = "";
        if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
          loneMarkers.push(endDelim.token - 1);
        }
      }
      while (loneMarkers.length) {
        i = loneMarkers.pop();
        j = i + 1;
        while (j < state.tokens.length && state.tokens[j].type === "s_close") {
          j++;
        }
        j--;
        if (i !== j) {
          token = state.tokens[j];
          state.tokens[j] = state.tokens[i];
          state.tokens[i] = token;
        }
      }
    }
    module.exports.postProcess = function strikethrough(state) {
      var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max2; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});
var require_emphasis = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/emphasis.js"(exports, module) {
    module.exports.tokenize = function emphasis(state, silent) {
      var i, scanned, token, start2 = state.pos, marker = state.src.charCodeAt(start2);
      if (silent) {
        return false;
      }
      if (marker !== 95 && marker !== 42) {
        return false;
      }
      scanned = state.scanDelims(state.pos, marker === 42);
      for (i = 0; i < scanned.length; i++) {
        token = state.push("text", "", 0);
        token.content = String.fromCharCode(marker);
        state.delimiters.push({
          marker,
          length: scanned.length,
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i, startDelim, endDelim, token, ch, isStrong, max2 = delimiters.length;
      for (i = max2 - 1; i >= 0; i--) {
        startDelim = delimiters[i];
        if (startDelim.marker !== 95 && startDelim.marker !== 42) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1;
        ch = String.fromCharCode(startDelim.marker);
        token = state.tokens[startDelim.token];
        token.type = isStrong ? "strong_open" : "em_open";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = 1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = isStrong ? "strong_close" : "em_close";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = -1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        if (isStrong) {
          state.tokens[delimiters[i - 1].token].content = "";
          state.tokens[delimiters[startDelim.end + 1].token].content = "";
          i--;
        }
      }
    }
    module.exports.postProcess = function emphasis(state) {
      var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max2; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});
var require_link = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/link.js"(exports, module) {
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module.exports = function link2(state, silent) {
      var attrs, code2, label, labelEnd, labelStart, pos, res, ref, token, href = "", title = "", oldPos = state.pos, max2 = state.posMax, start2 = state.pos, parseReference = true;
      if (state.src.charCodeAt(state.pos) !== 91) {
        return false;
      }
      labelStart = state.pos + 1;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max2 && state.src.charCodeAt(pos) === 40) {
        parseReference = false;
        pos++;
        for (; pos < max2; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        if (pos >= max2) {
          return false;
        }
        start2 = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
          start2 = pos;
          for (; pos < max2; pos++) {
            code2 = state.src.charCodeAt(pos);
            if (!isSpace(code2) && code2 !== 10) {
              break;
            }
          }
          res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
          if (pos < max2 && start2 !== pos && res.ok) {
            title = res.str;
            pos = res.pos;
            for (; pos < max2; pos++) {
              code2 = state.src.charCodeAt(pos);
              if (!isSpace(code2) && code2 !== 10) {
                break;
              }
            }
          }
        }
        if (pos >= max2 || state.src.charCodeAt(pos) !== 41) {
          parseReference = true;
        }
        pos++;
      }
      if (parseReference) {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max2 && state.src.charCodeAt(pos) === 91) {
          start2 = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start2, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd;
        token = state.push("link_open", "a", 1);
        token.attrs = attrs = [["href", href]];
        if (title) {
          attrs.push(["title", title]);
        }
        state.md.inline.tokenize(state);
        token = state.push("link_close", "a", -1);
      }
      state.pos = pos;
      state.posMax = max2;
      return true;
    };
  }
});
var require_image = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/image.js"(exports, module) {
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module.exports = function image2(state, silent) {
      var attrs, code2, content2, label, labelEnd, labelStart, pos, ref, res, title, token, tokens2, start2, href = "", oldPos = state.pos, max2 = state.posMax;
      if (state.src.charCodeAt(state.pos) !== 33) {
        return false;
      }
      if (state.src.charCodeAt(state.pos + 1) !== 91) {
        return false;
      }
      labelStart = state.pos + 2;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max2 && state.src.charCodeAt(pos) === 40) {
        pos++;
        for (; pos < max2; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        if (pos >= max2) {
          return false;
        }
        start2 = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start2 = pos;
        for (; pos < max2; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max2 && start2 !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max2; pos++) {
            code2 = state.src.charCodeAt(pos);
            if (!isSpace(code2) && code2 !== 10) {
              break;
            }
          }
        } else {
          title = "";
        }
        if (pos >= max2 || state.src.charCodeAt(pos) !== 41) {
          state.pos = oldPos;
          return false;
        }
        pos++;
      } else {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max2 && state.src.charCodeAt(pos) === 91) {
          start2 = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start2, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        content2 = state.src.slice(labelStart, labelEnd);
        state.md.inline.parse(content2, state.md, state.env, tokens2 = []);
        token = state.push("image", "img", 0);
        token.attrs = attrs = [["src", href], ["alt", ""]];
        token.children = tokens2;
        token.content = content2;
        if (title) {
          attrs.push(["title", title]);
        }
      }
      state.pos = pos;
      state.posMax = max2;
      return true;
    };
  }
});
var require_autolink = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/autolink.js"(exports, module) {
    var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
    var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
    module.exports = function autolink(state, silent) {
      var url, fullUrl, token, ch, start2, max2, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      start2 = state.pos;
      max2 = state.posMax;
      for (; ; ) {
        if (++pos >= max2)
          return false;
        ch = state.src.charCodeAt(pos);
        if (ch === 60)
          return false;
        if (ch === 62)
          break;
      }
      url = state.src.slice(start2 + 1, pos);
      if (AUTOLINK_RE.test(url)) {
        fullUrl = state.md.normalizeLink(url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      if (EMAIL_RE.test(url)) {
        fullUrl = state.md.normalizeLink("mailto:" + url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      return false;
    };
  }
});
var require_html_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/html_inline.js"(exports, module) {
    var HTML_TAG_RE = require_html_re().HTML_TAG_RE;
    function isLetter(ch) {
      var lc = ch | 32;
      return lc >= 97 && lc <= 122;
    }
    module.exports = function html_inline(state, silent) {
      var ch, match2, max2, token, pos = state.pos;
      if (!state.md.options.html) {
        return false;
      }
      max2 = state.posMax;
      if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max2) {
        return false;
      }
      ch = state.src.charCodeAt(pos + 1);
      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
        return false;
      }
      match2 = state.src.slice(pos).match(HTML_TAG_RE);
      if (!match2) {
        return false;
      }
      if (!silent) {
        token = state.push("html_inline", "", 0);
        token.content = state.src.slice(pos, pos + match2[0].length);
      }
      state.pos += match2[0].length;
      return true;
    };
  }
});
var require_entity = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/entity.js"(exports, module) {
    var entities = require_entities2();
    var has = require_utils().has;
    var isValidEntityCode = require_utils().isValidEntityCode;
    var fromCodePoint2 = require_utils().fromCodePoint;
    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
    var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
    module.exports = function entity(state, silent) {
      var ch, code2, match2, pos = state.pos, max2 = state.posMax;
      if (state.src.charCodeAt(pos) !== 38) {
        return false;
      }
      if (pos + 1 < max2) {
        ch = state.src.charCodeAt(pos + 1);
        if (ch === 35) {
          match2 = state.src.slice(pos).match(DIGITAL_RE);
          if (match2) {
            if (!silent) {
              code2 = match2[1][0].toLowerCase() === "x" ? parseInt(match2[1].slice(1), 16) : parseInt(match2[1], 10);
              state.pending += isValidEntityCode(code2) ? fromCodePoint2(code2) : fromCodePoint2(65533);
            }
            state.pos += match2[0].length;
            return true;
          }
        } else {
          match2 = state.src.slice(pos).match(NAMED_RE);
          if (match2) {
            if (has(entities, match2[1])) {
              if (!silent) {
                state.pending += entities[match2[1]];
              }
              state.pos += match2[0].length;
              return true;
            }
          }
        }
      }
      if (!silent) {
        state.pending += "&";
      }
      state.pos++;
      return true;
    };
  }
});
var require_balance_pairs = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/balance_pairs.js"(exports, module) {
    function processDelimiters(state, delimiters) {
      var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max2 = delimiters.length;
      if (!max2)
        return;
      var headerIdx = 0;
      var lastTokenIdx = -2;
      var jumps = [];
      for (closerIdx = 0; closerIdx < max2; closerIdx++) {
        closer = delimiters[closerIdx];
        jumps.push(0);
        if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
          headerIdx = closerIdx;
        }
        lastTokenIdx = closer.token;
        closer.length = closer.length || 0;
        if (!closer.close)
          continue;
        if (!openersBottom.hasOwnProperty(closer.marker)) {
          openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
        }
        minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
        openerIdx = headerIdx - jumps[headerIdx] - 1;
        newMinOpenerIdx = openerIdx;
        for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
          opener = delimiters[openerIdx];
          if (opener.marker !== closer.marker)
            continue;
          if (opener.open && opener.end < 0) {
            isOddMatch = false;
            if (opener.close || closer.open) {
              if ((opener.length + closer.length) % 3 === 0) {
                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                  isOddMatch = true;
                }
              }
            }
            if (!isOddMatch) {
              lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
              jumps[closerIdx] = closerIdx - openerIdx + lastJump;
              jumps[openerIdx] = lastJump;
              closer.open = false;
              opener.end = closerIdx;
              opener.close = false;
              newMinOpenerIdx = -1;
              lastTokenIdx = -2;
              break;
            }
          }
        }
        if (newMinOpenerIdx !== -1) {
          openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
        }
      }
    }
    module.exports = function link_pairs(state) {
      var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;
      processDelimiters(state, state.delimiters);
      for (curr = 0; curr < max2; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          processDelimiters(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});
var require_text_collapse = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/text_collapse.js"(exports, module) {
    module.exports = function text_collapse(state) {
      var curr, last, level = 0, tokens2 = state.tokens, max2 = state.tokens.length;
      for (curr = last = 0; curr < max2; curr++) {
        if (tokens2[curr].nesting < 0)
          level--;
        tokens2[curr].level = level;
        if (tokens2[curr].nesting > 0)
          level++;
        if (tokens2[curr].type === "text" && curr + 1 < max2 && tokens2[curr + 1].type === "text") {
          tokens2[curr + 1].content = tokens2[curr].content + tokens2[curr + 1].content;
        } else {
          if (curr !== last) {
            tokens2[last] = tokens2[curr];
          }
          last++;
        }
      }
      if (curr !== last) {
        tokens2.length = last;
      }
    };
  }
});
var require_state_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/state_inline.js"(exports, module) {
    var Token = require_token();
    var isWhiteSpace = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    function StateInline(src, md, env, outTokens) {
      this.src = src;
      this.env = env;
      this.md = md;
      this.tokens = outTokens;
      this.tokens_meta = Array(outTokens.length);
      this.pos = 0;
      this.posMax = this.src.length;
      this.level = 0;
      this.pending = "";
      this.pendingLevel = 0;
      this.cache = {};
      this.delimiters = [];
      this._prev_delimiters = [];
      this.backticks = {};
      this.backticksScanned = false;
    }
    StateInline.prototype.pushPending = function() {
      var token = new Token("text", "", 0);
      token.content = this.pending;
      token.level = this.pendingLevel;
      this.tokens.push(token);
      this.pending = "";
      return token;
    };
    StateInline.prototype.push = function(type, tag, nesting) {
      if (this.pending) {
        this.pushPending();
      }
      var token = new Token(type, tag, nesting);
      var token_meta = null;
      if (nesting < 0) {
        this.level--;
        this.delimiters = this._prev_delimiters.pop();
      }
      token.level = this.level;
      if (nesting > 0) {
        this.level++;
        this._prev_delimiters.push(this.delimiters);
        this.delimiters = [];
        token_meta = { delimiters: this.delimiters };
      }
      this.pendingLevel = this.level;
      this.tokens.push(token);
      this.tokens_meta.push(token_meta);
      return token;
    };
    StateInline.prototype.scanDelims = function(start2, canSplitWord) {
      var pos = start2, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max2 = this.posMax, marker = this.src.charCodeAt(start2);
      lastChar = start2 > 0 ? this.src.charCodeAt(start2 - 1) : 32;
      while (pos < max2 && this.src.charCodeAt(pos) === marker) {
        pos++;
      }
      count = pos - start2;
      nextChar = pos < max2 ? this.src.charCodeAt(pos) : 32;
      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);
      if (isNextWhiteSpace) {
        left_flanking = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          left_flanking = false;
        }
      }
      if (isLastWhiteSpace) {
        right_flanking = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          right_flanking = false;
        }
      }
      if (!canSplitWord) {
        can_open = left_flanking && (!right_flanking || isLastPunctChar);
        can_close = right_flanking && (!left_flanking || isNextPunctChar);
      } else {
        can_open = left_flanking;
        can_close = right_flanking;
      }
      return {
        can_open,
        can_close,
        length: count
      };
    };
    StateInline.prototype.Token = Token;
    module.exports = StateInline;
  }
});
var require_parser_inline = __commonJS({
  "node_modules/markdown-it/lib/parser_inline.js"(exports, module) {
    var Ruler = require_ruler();
    var _rules = [
      ["text", require_text()],
      ["newline", require_newline()],
      ["escape", require_escape()],
      ["backticks", require_backticks()],
      ["strikethrough", require_strikethrough().tokenize],
      ["emphasis", require_emphasis().tokenize],
      ["link", require_link()],
      ["image", require_image()],
      ["autolink", require_autolink()],
      ["html_inline", require_html_inline()],
      ["entity", require_entity()]
    ];
    var _rules2 = [
      ["balance_pairs", require_balance_pairs()],
      ["strikethrough", require_strikethrough().postProcess],
      ["emphasis", require_emphasis().postProcess],
      ["text_collapse", require_text_collapse()]
    ];
    function ParserInline() {
      var i;
      this.ruler = new Ruler();
      for (i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1]);
      }
      this.ruler2 = new Ruler();
      for (i = 0; i < _rules2.length; i++) {
        this.ruler2.push(_rules2[i][0], _rules2[i][1]);
      }
    }
    ParserInline.prototype.skipToken = function(state) {
      var ok, i, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;
      if (typeof cache[pos] !== "undefined") {
        state.pos = cache[pos];
        return;
      }
      if (state.level < maxNesting) {
        for (i = 0; i < len; i++) {
          state.level++;
          ok = rules[i](state, true);
          state.level--;
          if (ok) {
            break;
          }
        }
      } else {
        state.pos = state.posMax;
      }
      if (!ok) {
        state.pos++;
      }
      cache[pos] = state.pos;
    };
    ParserInline.prototype.tokenize = function(state) {
      var ok, i, rules = this.ruler.getRules(""), len = rules.length, end2 = state.posMax, maxNesting = state.md.options.maxNesting;
      while (state.pos < end2) {
        if (state.level < maxNesting) {
          for (i = 0; i < len; i++) {
            ok = rules[i](state, false);
            if (ok) {
              break;
            }
          }
        }
        if (ok) {
          if (state.pos >= end2) {
            break;
          }
          continue;
        }
        state.pending += state.src[state.pos++];
      }
      if (state.pending) {
        state.pushPending();
      }
    };
    ParserInline.prototype.parse = function(str, md, env, outTokens) {
      var i, rules, len;
      var state = new this.State(str, md, env, outTokens);
      this.tokenize(state);
      rules = this.ruler2.getRules("");
      len = rules.length;
      for (i = 0; i < len; i++) {
        rules[i](state);
      }
    };
    ParserInline.prototype.State = require_state_inline();
    module.exports = ParserInline;
  }
});
var require_re = __commonJS({
  "node_modules/linkify-it/lib/re.js"(exports, module) {
    module.exports = function(opts) {
      var re = {};
      re.src_Any = require_regex2().source;
      re.src_Cc = require_regex3().source;
      re.src_Z = require_regex5().source;
      re.src_P = require_regex().source;
      re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
      re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
      var text_separators = "[><]";
      re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
      re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
      re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
      re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
      re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
      re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-]).|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]).|" + (opts && opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re.src_ZCc + ").|;(?!" + re.src_ZCc + ").|\\!+(?!" + re.src_ZCc + "|[!]).|\\?(?!" + re.src_ZCc + "|[?]).)+|\\/)?";
      re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
      re.src_xn = "xn--[a-z0-9\\-]{1,59}";
      re.src_domain_root = "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
      re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
      re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
      re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
      re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
      re.src_host_strict = re.src_host + re.src_host_terminator;
      re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
      re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
      re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
      re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
      re.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + re.src_ZPCc + "))((?![$+<=>^`|])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
      re.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + re.src_ZPCc + "))((?![$+<=>^`|])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
      return re;
    };
  }
});
var require_linkify_it = __commonJS({
  "node_modules/linkify-it/index.js"(exports, module) {
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString2(obj) {
      return _class(obj) === "[object String]";
    }
    function isObject2(obj) {
      return _class(obj) === "[object Object]";
    }
    function isRegExp(obj) {
      return _class(obj) === "[object RegExp]";
    }
    function isFunction2(obj) {
      return _class(obj) === "[object Function]";
    }
    function escapeRE(str) {
      return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    var defaultOptions = {
      fuzzyLink: true,
      fuzzyEmail: true,
      fuzzyIP: false
    };
    function isOptionsObj(obj) {
      return Object.keys(obj || {}).reduce(function(acc, k) {
        return acc || defaultOptions.hasOwnProperty(k);
      }, false);
    }
    var defaultSchemas = {
      "http:": {
        validate: function(text2, pos, self2) {
          var tail = text2.slice(pos);
          if (!self2.re.http) {
            self2.re.http = new RegExp("^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path, "i");
          }
          if (self2.re.http.test(tail)) {
            return tail.match(self2.re.http)[0].length;
          }
          return 0;
        }
      },
      "https:": "http:",
      "ftp:": "http:",
      "//": {
        validate: function(text2, pos, self2) {
          var tail = text2.slice(pos);
          if (!self2.re.no_http) {
            self2.re.no_http = new RegExp("^" + self2.re.src_auth + "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path, "i");
          }
          if (self2.re.no_http.test(tail)) {
            if (pos >= 3 && text2[pos - 3] === ":") {
              return 0;
            }
            if (pos >= 3 && text2[pos - 3] === "/") {
              return 0;
            }
            return tail.match(self2.re.no_http)[0].length;
          }
          return 0;
        }
      },
      "mailto:": {
        validate: function(text2, pos, self2) {
          var tail = text2.slice(pos);
          if (!self2.re.mailto) {
            self2.re.mailto = new RegExp("^" + self2.re.src_email_name + "@" + self2.re.src_host_strict, "i");
          }
          if (self2.re.mailto.test(tail)) {
            return tail.match(self2.re.mailto)[0].length;
          }
          return 0;
        }
      }
    };
    var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
    var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|".split("|");
    function resetScanCache(self2) {
      self2.__index__ = -1;
      self2.__text_cache__ = "";
    }
    function createValidator(re) {
      return function(text2, pos) {
        var tail = text2.slice(pos);
        if (re.test(tail)) {
          return tail.match(re)[0].length;
        }
        return 0;
      };
    }
    function createNormalizer() {
      return function(match2, self2) {
        self2.normalize(match2);
      };
    }
    function compile(self2) {
      var re = self2.re = require_re()(self2.__opts__);
      var tlds = self2.__tlds__.slice();
      self2.onCompile();
      if (!self2.__tlds_replaced__) {
        tlds.push(tlds_2ch_src_re);
      }
      tlds.push(re.src_xn);
      re.src_tlds = tlds.join("|");
      function untpl(tpl) {
        return tpl.replace("%TLDS%", re.src_tlds);
      }
      re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
      re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
      re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
      re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
      var aliases = [];
      self2.__compiled__ = {};
      function schemaError(name2, val) {
        throw new Error('(LinkifyIt) Invalid schema "' + name2 + '": ' + val);
      }
      Object.keys(self2.__schemas__).forEach(function(name2) {
        var val = self2.__schemas__[name2];
        if (val === null) {
          return;
        }
        var compiled = { validate: null, link: null };
        self2.__compiled__[name2] = compiled;
        if (isObject2(val)) {
          if (isRegExp(val.validate)) {
            compiled.validate = createValidator(val.validate);
          } else if (isFunction2(val.validate)) {
            compiled.validate = val.validate;
          } else {
            schemaError(name2, val);
          }
          if (isFunction2(val.normalize)) {
            compiled.normalize = val.normalize;
          } else if (!val.normalize) {
            compiled.normalize = createNormalizer();
          } else {
            schemaError(name2, val);
          }
          return;
        }
        if (isString2(val)) {
          aliases.push(name2);
          return;
        }
        schemaError(name2, val);
      });
      aliases.forEach(function(alias) {
        if (!self2.__compiled__[self2.__schemas__[alias]]) {
          return;
        }
        self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
        self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
      });
      self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
      var slist = Object.keys(self2.__compiled__).filter(function(name2) {
        return name2.length > 0 && self2.__compiled__[name2];
      }).map(escapeRE).join("|");
      self2.re.schema_test = RegExp("(^|(?!_)(?:[><]|" + re.src_ZPCc + "))(" + slist + ")", "i");
      self2.re.schema_search = RegExp("(^|(?!_)(?:[><]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
      self2.re.pretest = RegExp("(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@", "i");
      resetScanCache(self2);
    }
    function Match(self2, shift) {
      var start2 = self2.__index__, end2 = self2.__last_index__, text2 = self2.__text_cache__.slice(start2, end2);
      this.schema = self2.__schema__.toLowerCase();
      this.index = start2 + shift;
      this.lastIndex = end2 + shift;
      this.raw = text2;
      this.text = text2;
      this.url = text2;
    }
    function createMatch(self2, shift) {
      var match2 = new Match(self2, shift);
      self2.__compiled__[match2.schema].normalize(match2, self2);
      return match2;
    }
    function LinkifyIt(schemas, options2) {
      if (!(this instanceof LinkifyIt)) {
        return new LinkifyIt(schemas, options2);
      }
      if (!options2) {
        if (isOptionsObj(schemas)) {
          options2 = schemas;
          schemas = {};
        }
      }
      this.__opts__ = assign({}, defaultOptions, options2);
      this.__index__ = -1;
      this.__last_index__ = -1;
      this.__schema__ = "";
      this.__text_cache__ = "";
      this.__schemas__ = assign({}, defaultSchemas, schemas);
      this.__compiled__ = {};
      this.__tlds__ = tlds_default;
      this.__tlds_replaced__ = false;
      this.re = {};
      compile(this);
    }
    LinkifyIt.prototype.add = function add(schema, definition) {
      this.__schemas__[schema] = definition;
      compile(this);
      return this;
    };
    LinkifyIt.prototype.set = function set(options2) {
      this.__opts__ = assign(this.__opts__, options2);
      return this;
    };
    LinkifyIt.prototype.test = function test(text2) {
      this.__text_cache__ = text2;
      this.__index__ = -1;
      if (!text2.length) {
        return false;
      }
      var m, ml, me, len, shift, next, re, tld_pos, at_pos;
      if (this.re.schema_test.test(text2)) {
        re = this.re.schema_search;
        re.lastIndex = 0;
        while ((m = re.exec(text2)) !== null) {
          len = this.testSchemaAt(text2, m[2], re.lastIndex);
          if (len) {
            this.__schema__ = m[2];
            this.__index__ = m.index + m[1].length;
            this.__last_index__ = m.index + m[0].length + len;
            break;
          }
        }
      }
      if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
        tld_pos = text2.search(this.re.host_fuzzy_test);
        if (tld_pos >= 0) {
          if (this.__index__ < 0 || tld_pos < this.__index__) {
            if ((ml = text2.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
              shift = ml.index + ml[1].length;
              if (this.__index__ < 0 || shift < this.__index__) {
                this.__schema__ = "";
                this.__index__ = shift;
                this.__last_index__ = ml.index + ml[0].length;
              }
            }
          }
        }
      }
      if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
        at_pos = text2.indexOf("@");
        if (at_pos >= 0) {
          if ((me = text2.match(this.re.email_fuzzy)) !== null) {
            shift = me.index + me[1].length;
            next = me.index + me[0].length;
            if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
              this.__schema__ = "mailto:";
              this.__index__ = shift;
              this.__last_index__ = next;
            }
          }
        }
      }
      return this.__index__ >= 0;
    };
    LinkifyIt.prototype.pretest = function pretest(text2) {
      return this.re.pretest.test(text2);
    };
    LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text2, schema, pos) {
      if (!this.__compiled__[schema.toLowerCase()]) {
        return 0;
      }
      return this.__compiled__[schema.toLowerCase()].validate(text2, pos, this);
    };
    LinkifyIt.prototype.match = function match2(text2) {
      var shift = 0, result = [];
      if (this.__index__ >= 0 && this.__text_cache__ === text2) {
        result.push(createMatch(this, shift));
        shift = this.__last_index__;
      }
      var tail = shift ? text2.slice(shift) : text2;
      while (this.test(tail)) {
        result.push(createMatch(this, shift));
        tail = tail.slice(this.__last_index__);
        shift += this.__last_index__;
      }
      if (result.length) {
        return result;
      }
      return null;
    };
    LinkifyIt.prototype.tlds = function tlds(list2, keepOld) {
      list2 = Array.isArray(list2) ? list2 : [list2];
      if (!keepOld) {
        this.__tlds__ = list2.slice();
        this.__tlds_replaced__ = true;
        compile(this);
        return this;
      }
      this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el, idx, arr) {
        return el !== arr[idx - 1];
      }).reverse();
      compile(this);
      return this;
    };
    LinkifyIt.prototype.normalize = function normalize(match2) {
      if (!match2.schema) {
        match2.url = "http://" + match2.url;
      }
      if (match2.schema === "mailto:" && !/^mailto:/i.test(match2.url)) {
        match2.url = "mailto:" + match2.url;
      }
    };
    LinkifyIt.prototype.onCompile = function onCompile() {
    };
    module.exports = LinkifyIt;
  }
});
var require_punycode = __commonJS({
  "node_modules/punycode/punycode.js"(exports, module) {
    var maxInt2 = 2147483647;
    var base2 = 36;
    var tMin2 = 1;
    var tMax2 = 26;
    var skew2 = 38;
    var damp2 = 700;
    var initialBias2 = 72;
    var initialN2 = 128;
    var delimiter2 = "-";
    var regexPunycode2 = /^xn--/;
    var regexNonASCII2 = /[^\0-\x7E]/;
    var regexSeparators2 = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors2 = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin2 = base2 - tMin2;
    var floor2 = Math.floor;
    var stringFromCharCode2 = String.fromCharCode;
    function error2(type) {
      throw new RangeError(errors2[type]);
    }
    function map2(array, fn2) {
      const result = [];
      let length2 = array.length;
      while (length2--) {
        result[length2] = fn2(array[length2]);
      }
      return result;
    }
    function mapDomain2(string, fn2) {
      const parts = string.split("@");
      let result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators2, ".");
      const labels = string.split(".");
      const encoded = map2(labels, fn2).join(".");
      return result + encoded;
    }
    function ucs2decode2(string) {
      const output = [];
      let counter = 0;
      const length2 = string.length;
      while (counter < length2) {
        const value2 = string.charCodeAt(counter++);
        if (value2 >= 55296 && value2 <= 56319 && counter < length2) {
          const extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value2 & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value2);
            counter--;
          }
        } else {
          output.push(value2);
        }
      }
      return output;
    }
    var ucs2encode2 = (array) => String.fromCodePoint(...array);
    var basicToDigit2 = function(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base2;
    };
    var digitToBasic2 = function(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt2 = function(delta, numPoints, firstTime) {
      let k = 0;
      delta = firstTime ? floor2(delta / damp2) : delta >> 1;
      delta += floor2(delta / numPoints);
      for (; delta > baseMinusTMin2 * tMax2 >> 1; k += base2) {
        delta = floor2(delta / baseMinusTMin2);
      }
      return floor2(k + (baseMinusTMin2 + 1) * delta / (delta + skew2));
    };
    var decode2 = function(input) {
      const output = [];
      const inputLength = input.length;
      let i = 0;
      let n2 = initialN2;
      let bias = initialBias2;
      let basic = input.lastIndexOf(delimiter2);
      if (basic < 0) {
        basic = 0;
      }
      for (let j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error2("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        let oldi = i;
        for (let w = 1, k = base2; ; k += base2) {
          if (index >= inputLength) {
            error2("invalid-input");
          }
          const digit = basicToDigit2(input.charCodeAt(index++));
          if (digit >= base2 || digit > floor2((maxInt2 - i) / w)) {
            error2("overflow");
          }
          i += digit * w;
          const t2 = k <= bias ? tMin2 : k >= bias + tMax2 ? tMax2 : k - bias;
          if (digit < t2) {
            break;
          }
          const baseMinusT = base2 - t2;
          if (w > floor2(maxInt2 / baseMinusT)) {
            error2("overflow");
          }
          w *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt2(i - oldi, out, oldi == 0);
        if (floor2(i / out) > maxInt2 - n2) {
          error2("overflow");
        }
        n2 += floor2(i / out);
        i %= out;
        output.splice(i++, 0, n2);
      }
      return String.fromCodePoint(...output);
    };
    var encode2 = function(input) {
      const output = [];
      input = ucs2decode2(input);
      let inputLength = input.length;
      let n2 = initialN2;
      let delta = 0;
      let bias = initialBias2;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(stringFromCharCode2(currentValue));
        }
      }
      let basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter2);
      }
      while (handledCPCount < inputLength) {
        let m = maxInt2;
        for (const currentValue of input) {
          if (currentValue >= n2 && currentValue < m) {
            m = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n2 > floor2((maxInt2 - delta) / handledCPCountPlusOne)) {
          error2("overflow");
        }
        delta += (m - n2) * handledCPCountPlusOne;
        n2 = m;
        for (const currentValue of input) {
          if (currentValue < n2 && ++delta > maxInt2) {
            error2("overflow");
          }
          if (currentValue == n2) {
            let q = delta;
            for (let k = base2; ; k += base2) {
              const t2 = k <= bias ? tMin2 : k >= bias + tMax2 ? tMax2 : k - bias;
              if (q < t2) {
                break;
              }
              const qMinusT = q - t2;
              const baseMinusT = base2 - t2;
              output.push(stringFromCharCode2(digitToBasic2(t2 + qMinusT % baseMinusT, 0)));
              q = floor2(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode2(digitToBasic2(q, 0)));
            bias = adapt2(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n2;
      }
      return output.join("");
    };
    var toUnicode2 = function(input) {
      return mapDomain2(input, function(string) {
        return regexPunycode2.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII2 = function(input) {
      return mapDomain2(input, function(string) {
        return regexNonASCII2.test(string) ? "xn--" + encode2(string) : string;
      });
    };
    var punycode2 = {
      "version": "2.1.0",
      "ucs2": {
        "decode": ucs2decode2,
        "encode": ucs2encode2
      },
      "decode": decode2,
      "encode": encode2,
      "toASCII": toASCII2,
      "toUnicode": toUnicode2
    };
    module.exports = punycode2;
  }
});
var require_default = __commonJS({
  "node_modules/markdown-it/lib/presets/default.js"(exports, module) {
    module.exports = {
      options: {
        html: false,
        xhtmlOut: false,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "",
        highlight: null,
        maxNesting: 100
      },
      components: {
        core: {},
        block: {},
        inline: {}
      }
    };
  }
});
var require_zero = __commonJS({
  "node_modules/markdown-it/lib/presets/zero.js"(exports, module) {
    module.exports = {
      options: {
        html: false,
        xhtmlOut: false,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "",
        highlight: null,
        maxNesting: 20
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline"
          ]
        },
        block: {
          rules: [
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "text"
          ],
          rules2: [
            "balance_pairs",
            "text_collapse"
          ]
        }
      }
    };
  }
});
var require_commonmark = __commonJS({
  "node_modules/markdown-it/lib/presets/commonmark.js"(exports, module) {
    module.exports = {
      options: {
        html: true,
        xhtmlOut: true,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "",
        highlight: null,
        maxNesting: 20
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline"
          ]
        },
        block: {
          rules: [
            "blockquote",
            "code",
            "fence",
            "heading",
            "hr",
            "html_block",
            "lheading",
            "list",
            "reference",
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "autolink",
            "backticks",
            "emphasis",
            "entity",
            "escape",
            "html_inline",
            "image",
            "link",
            "newline",
            "text"
          ],
          rules2: [
            "balance_pairs",
            "emphasis",
            "text_collapse"
          ]
        }
      }
    };
  }
});
var require_lib = __commonJS({
  "node_modules/markdown-it/lib/index.js"(exports, module) {
    var utils2 = require_utils();
    var helpers = require_helpers();
    var Renderer = require_renderer();
    var ParserCore = require_parser_core();
    var ParserBlock = require_parser_block();
    var ParserInline = require_parser_inline();
    var LinkifyIt = require_linkify_it();
    var mdurl = require_mdurl();
    var punycode2 = require_punycode();
    var config = {
      default: require_default(),
      zero: require_zero(),
      commonmark: require_commonmark()
    };
    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
    var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
    function validateLink(url) {
      var str = url.trim().toLowerCase();
      return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
    }
    var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
    function normalizeLink(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode2.toASCII(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.encode(mdurl.format(parsed));
    }
    function normalizeLinkText(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode2.toUnicode(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
    }
    function MarkdownIt3(presetName, options2) {
      if (!(this instanceof MarkdownIt3)) {
        return new MarkdownIt3(presetName, options2);
      }
      if (!options2) {
        if (!utils2.isString(presetName)) {
          options2 = presetName || {};
          presetName = "default";
        }
      }
      this.inline = new ParserInline();
      this.block = new ParserBlock();
      this.core = new ParserCore();
      this.renderer = new Renderer();
      this.linkify = new LinkifyIt();
      this.validateLink = validateLink;
      this.normalizeLink = normalizeLink;
      this.normalizeLinkText = normalizeLinkText;
      this.utils = utils2;
      this.helpers = utils2.assign({}, helpers);
      this.options = {};
      this.configure(presetName);
      if (options2) {
        this.set(options2);
      }
    }
    MarkdownIt3.prototype.set = function(options2) {
      utils2.assign(this.options, options2);
      return this;
    };
    MarkdownIt3.prototype.configure = function(presets) {
      var self2 = this, presetName;
      if (utils2.isString(presets)) {
        presetName = presets;
        presets = config[presetName];
        if (!presets) {
          throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
        }
      }
      if (!presets) {
        throw new Error("Wrong `markdown-it` preset, can't be empty");
      }
      if (presets.options) {
        self2.set(presets.options);
      }
      if (presets.components) {
        Object.keys(presets.components).forEach(function(name2) {
          if (presets.components[name2].rules) {
            self2[name2].ruler.enableOnly(presets.components[name2].rules);
          }
          if (presets.components[name2].rules2) {
            self2[name2].ruler2.enableOnly(presets.components[name2].rules2);
          }
        });
      }
      return this;
    };
    MarkdownIt3.prototype.enable = function(list2, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.enable(list2, true));
      }, this);
      result = result.concat(this.inline.ruler2.enable(list2, true));
      var missed = list2.filter(function(name2) {
        return result.indexOf(name2) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt3.prototype.disable = function(list2, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.disable(list2, true));
      }, this);
      result = result.concat(this.inline.ruler2.disable(list2, true));
      var missed = list2.filter(function(name2) {
        return result.indexOf(name2) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt3.prototype.use = function(plugin4) {
      var args = [this].concat(Array.prototype.slice.call(arguments, 1));
      plugin4.apply(plugin4, args);
      return this;
    };
    MarkdownIt3.prototype.parse = function(src, env) {
      if (typeof src !== "string") {
        throw new Error("Input data should be a String");
      }
      var state = new this.core.State(src, this, env);
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt3.prototype.render = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parse(src, env), this.options, env);
    };
    MarkdownIt3.prototype.parseInline = function(src, env) {
      var state = new this.core.State(src, this, env);
      state.inlineMode = true;
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt3.prototype.renderInline = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parseInline(src, env), this.options, env);
    };
    module.exports = MarkdownIt3;
  }
});
var require_markdown_it = __commonJS({
  "node_modules/markdown-it/index.js"(exports, module) {
    module.exports = require_lib();
  }
});
var base_exports = {};
__export(base_exports, {
  getAstValues: () => getAstValues,
  isAst: () => isAst,
  isFunction: () => isFunction$1,
  isVariable: () => isVariable,
  resolve: () => resolve
});
function isAst(value2) {
  return !!(value2 == null ? void 0 : value2.$$mdtype);
}
function isFunction$1(value2) {
  return !!((value2 == null ? void 0 : value2.$$mdtype) === "Function");
}
function isVariable(value2) {
  return !!((value2 == null ? void 0 : value2.$$mdtype) === "Variable");
}
function* getAstValues(value2) {
  if (value2 == null || typeof value2 !== "object")
    return;
  if (Array.isArray(value2))
    for (const v2 of value2)
      yield* getAstValues(v2);
  if (isAst(value2))
    yield value2;
  if (Object.getPrototypeOf(value2) !== Object.prototype)
    return;
  for (const v2 of Object.values(value2))
    yield* getAstValues(v2);
}
function resolve(value2, config = {}) {
  if (value2 == null || typeof value2 !== "object")
    return value2;
  if (Array.isArray(value2))
    return value2.map((item2) => resolve(item2, config));
  if (isAst(value2) && (value2 == null ? void 0 : value2.resolve) instanceof Function)
    return value2.resolve(config);
  if (Object.getPrototypeOf(value2) !== Object.prototype)
    return value2;
  const output = {};
  for (const [k, v2] of Object.entries(value2))
    output[k] = resolve(v2, config);
  return output;
}
var Tag = class {
  constructor(name2 = "div", attributes2 = {}, children2 = []) {
    this.$$mdtype = "Tag";
    this.name = name2;
    this.attributes = attributes2;
    this.children = children2;
  }
};
Tag.isTag = (tag) => {
  return !!((tag == null ? void 0 : tag.$$mdtype) === "Tag");
};
var Class = class {
  validate(value2, _config, key) {
    if (typeof value2 === "string" || typeof value2 === "object")
      return [];
    return [
      {
        id: "attribute-type-invalid",
        level: "error",
        message: `Attribute '${key}' must be type 'string | object'`
      }
    ];
  }
  transform(value2) {
    if (!value2 || typeof value2 === "string")
      return value2;
    const classes = [];
    for (const [k, v2] of Object.entries(value2 ?? {}))
      if (v2)
        classes.push(k);
    return classes.join(" ");
  }
};
var Id = class {
  validate(value2) {
    if (typeof value2 === "string" && value2.match(/^[a-zA-Z]/))
      return [];
    return [
      {
        id: "attribute-value-invalid",
        level: "error",
        message: "The 'id' attribute must start with a letter"
      }
    ];
  }
};
var import_tag = __toModule(require_tag());
var Variable = class {
  constructor(path = []) {
    this.$$mdtype = "Variable";
    this.path = path;
  }
  resolve({ variables } = {}) {
    return variables instanceof Function ? variables(this.path) : this.path.reduce((obj = {}, key) => obj[key], variables);
  }
};
var Function2 = class {
  constructor(name2, parameters) {
    this.$$mdtype = "Function";
    this.name = name2;
    this.parameters = parameters;
  }
  resolve(config = {}) {
    var _a2, _b2;
    const fn2 = (_a2 = config == null ? void 0 : config.functions) == null ? void 0 : _a2[this.name];
    if (!fn2)
      return null;
    const parameters = resolve(this.parameters, config);
    return (_b2 = fn2.transform) == null ? void 0 : _b2.call(fn2, parameters, config);
  }
};
var STATES;
(function(STATES2) {
  STATES2[STATES2["normal"] = 0] = "normal";
  STATES2[STATES2["string"] = 1] = "string";
  STATES2[STATES2["escape"] = 2] = "escape";
})(STATES || (STATES = {}));
var OPEN = "{%";
var CLOSE = "%}";
var IDENTIFIER_REGEX = /^[a-zA-Z0-9_-]+$/;
function isIdentifier(s2) {
  return typeof s2 === "string" && IDENTIFIER_REGEX.test(s2);
}
function isPromise(a) {
  return a && typeof a === "object" && typeof a.then === "function";
}
function findTagEnd(content2, start2 = 0) {
  let state = 0;
  for (let pos = start2; pos < content2.length; pos++) {
    const char = content2[pos];
    switch (state) {
      case 1:
        switch (char) {
          case '"':
            state = 0;
            break;
          case "\\":
            state = 2;
            break;
        }
        break;
      case 2:
        state = 1;
        break;
      case 0:
        if (char === '"')
          state = 1;
        else if (content2.startsWith(CLOSE, pos))
          return pos;
    }
  }
  return null;
}
function parseTag(content2, line, contentStart) {
  try {
    return (0, import_tag.parse)(content2, { Variable, Function: Function2 });
  } catch (error2) {
    if (!(error2 instanceof import_tag.SyntaxError))
      throw error2;
    const {
      message,
      location: { start: start2, end: end2 }
    } = error2;
    const location2 = {
      start: { line, character: start2.offset + contentStart },
      end: { line: line + 1, character: end2.offset + contentStart }
    };
    return { type: "error", meta: { error: { message, location: location2 } } };
  }
}
function parseTags(content2, firstLine = 0) {
  let line = firstLine + 1;
  const output = [];
  let start2 = 0;
  for (let pos = 0; pos < content2.length; pos++) {
    if (content2[pos] === "\n") {
      line++;
      continue;
    }
    if (!content2.startsWith(OPEN, pos))
      continue;
    const end2 = findTagEnd(content2, pos);
    if (end2 == null) {
      pos = pos + OPEN.length;
      continue;
    }
    const text2 = content2.slice(pos, end2 + CLOSE.length);
    const inner = content2.slice(pos + OPEN.length, end2);
    const lineStart = content2.lastIndexOf("\n", pos);
    const lineEnd = content2.indexOf("\n", end2);
    const lineContent = content2.slice(lineStart, lineEnd);
    const tag = parseTag(inner.trim(), line, pos - lineStart);
    const precedingTextEnd = lineContent.trim() === text2 ? lineStart : pos;
    const precedingText = content2.slice(start2, precedingTextEnd);
    output.push({
      type: "text",
      start: start2,
      end: pos - 1,
      content: precedingText
    });
    output.push({
      map: [line, line + 1],
      position: {
        start: pos - lineStart,
        end: pos - lineStart + text2.length
      },
      start: pos,
      end: pos + text2.length - 1,
      info: text2,
      ...tag
    });
    start2 = end2 + CLOSE.length;
    pos = start2 - 1;
  }
  output.push({
    type: "text",
    start: start2,
    end: content2.length - 1,
    content: content2.slice(start2)
  });
  return output;
}
var globalAttributes = {
  class: { type: Class, render: true },
  id: { type: Id, render: true }
};
var transformer_default = {
  findSchema(node2, { nodes = {}, tags = {} } = {}) {
    return node2.tag ? tags[node2.tag] : nodes[node2.type];
  },
  attributes(node2, config = {}) {
    const schema = this.findSchema(node2, config) ?? {};
    const output = {};
    const attrs = { ...globalAttributes, ...schema.attributes };
    for (const [key, attr] of Object.entries(attrs)) {
      if (attr.render == false)
        continue;
      const name2 = typeof attr.render === "string" ? attr.render : key;
      let value2 = node2.attributes[key];
      if (typeof attr.type === "function") {
        const instance = new attr.type();
        if (instance.transform) {
          value2 = instance.transform(value2, config);
        }
      }
      value2 = value2 === void 0 ? attr.default : value2;
      if (value2 === void 0)
        continue;
      output[name2] = value2;
    }
    if (schema.slots) {
      for (const [key, slot2] of Object.entries(schema.slots)) {
        if (slot2.render === false)
          continue;
        const name2 = typeof slot2.render === "string" ? slot2.render : key;
        if (node2.slots[key])
          output[name2] = this.node(node2.slots[key], config);
      }
    }
    return output;
  },
  children(node2, config = {}) {
    const children2 = node2.children.flatMap((child) => this.node(child, config));
    if (children2.some(isPromise)) {
      return Promise.all(children2);
    }
    return children2;
  },
  node(node2, config = {}) {
    const schema = this.findSchema(node2, config) ?? {};
    if (schema && schema.transform instanceof Function)
      return schema.transform(node2, config);
    const children2 = this.children(node2, config);
    if (!schema || !schema.render)
      return children2;
    const attributes2 = this.attributes(node2, config);
    if (isPromise(attributes2) || isPromise(children2)) {
      return Promise.all([attributes2, children2]).then((values) => new Tag(schema.render, ...values));
    }
    return new Tag(schema.render, attributes2, children2);
  }
};
var Node$1 = class Node {
  constructor(type = "node", attributes2 = {}, children2 = [], tag) {
    this.$$mdtype = "Node";
    this.errors = [];
    this.lines = [];
    this.inline = false;
    this.attributes = attributes2;
    this.children = children2;
    this.type = type;
    this.tag = tag;
    this.annotations = [];
    this.slots = {};
  }
  *walk() {
    for (const child of [...Object.values(this.slots), ...this.children]) {
      yield child;
      yield* child.walk();
    }
  }
  push(node2) {
    this.children.push(node2);
  }
  resolve(config = {}) {
    return Object.assign(new Node$1(), this, {
      children: this.children.map((child) => child.resolve(config)),
      attributes: resolve(this.attributes, config),
      slots: Object.fromEntries(Object.entries(this.slots).map(([name2, slot2]) => [
        name2,
        slot2.resolve(config)
      ]))
    });
  }
  findSchema(config = {}) {
    return transformer_default.findSchema(this, config);
  }
  transformAttributes(config = {}) {
    return transformer_default.attributes(this, config);
  }
  transformChildren(config) {
    return transformer_default.children(this, config);
  }
  transform(config) {
    return transformer_default.node(this, config);
  }
};
var AstTypes = {
  Function: Function2,
  Node: Node$1,
  Variable
};
function reviver(_, value2) {
  if (!value2)
    return value2;
  const klass = AstTypes[value2.$$mdtype];
  return klass ? Object.assign(new klass(), value2) : value2;
}
function fromJSON(text2) {
  return JSON.parse(text2, reviver);
}
var ast_default = {
  ...AstTypes,
  ...base_exports,
  fromJSON
};
var SPACE = " ";
var SEP = ", ";
var NL = "\n";
var OL = ".";
var UL = "-";
var MAX_TAG_OPENING_WIDTH = 80;
var WRAPPING_TYPES = ["strong", "em", "s"];
var max = (a, b) => Math.max(a, b);
var increment = (o, n2 = 2) => ({
  ...o,
  indent: (o.indent || 0) + n2
});
function* formatChildren(a, options2) {
  for (const child of a.children) {
    yield* formatValue(child, options2);
  }
}
function* formatInline(g) {
  yield [...g].join("").trim();
}
function* formatTableRow(items) {
  yield `| ${items.join(" | ")} |`;
}
function formatScalar(v2) {
  if (v2 === void 0) {
    return void 0;
  }
  if (ast_default.isAst(v2)) {
    return format(v2);
  }
  if (v2 === null) {
    return "null";
  }
  if (Array.isArray(v2)) {
    return "[" + v2.map(formatScalar).join(SEP) + "]";
  }
  if (typeof v2 === "object") {
    return "{" + Object.entries(v2).map(([key, value2]) => `${isIdentifier(key) ? key : `"${key}"`}: ${formatScalar(value2)}`).join(SEP) + "}";
  }
  return JSON.stringify(v2);
}
function formatAnnotationValue(a) {
  const formattedValue = formatScalar(a.value);
  if (formattedValue === void 0)
    return void 0;
  if (a.name === "primary")
    return formattedValue;
  if (a.name === "id" && typeof a.value === "string" && isIdentifier(a.value))
    return "#" + a.value;
  if (a.type === "class" && isIdentifier(a.name))
    return "." + a.name;
  return `${a.name}=${formattedValue}`;
}
function* formatAttributes(n2) {
  for (const [key, value2] of Object.entries(n2.attributes)) {
    if (key === "class" && typeof value2 === "object" && !ast_default.isAst(value2))
      for (const name2 of Object.keys(value2)) {
        yield formatAnnotationValue({ type: "class", name: name2, value: value2 });
      }
    else
      yield formatAnnotationValue({ type: "attribute", name: key, value: value2 });
  }
}
function* formatAnnotations(n2) {
  if (n2.annotations.length) {
    yield OPEN + SPACE;
    yield n2.annotations.map(formatAnnotationValue).join(SPACE);
    yield SPACE + CLOSE;
  }
}
function* formatVariable(v2) {
  yield "$";
  yield v2.path.map((p2, i) => {
    if (i === 0)
      return p2;
    if (isIdentifier(p2))
      return "." + p2;
    if (typeof p2 === "number")
      return `[${p2}]`;
    return `["${p2}"]`;
  }).join("");
}
function* formatFunction(f) {
  yield f.name;
  yield "(";
  yield Object.values(f.parameters).map(formatScalar).join(SEP);
  yield ")";
}
function* trimStart(g) {
  let n2;
  do {
    const { value: value2, done } = g.next();
    if (done)
      return;
    n2 = value2.trimStart();
  } while (!n2.length);
  yield n2;
  yield* g;
}
function* escapeMarkdownCharacters(s2, characters) {
  yield s2.replace(characters, "\\$&").replace(new RegExp("", "g"), "&nbsp;");
}
function* formatNode(n2, o = {}) {
  const no = { ...o, parent: n2 };
  const indent = SPACE.repeat(no.indent || 0);
  switch (n2.type) {
    case "document": {
      if (n2.attributes.frontmatter && n2.attributes.frontmatter.length) {
        yield "---" + NL + n2.attributes.frontmatter + NL + "---" + NL + NL;
      }
      yield* trimStart(formatChildren(n2, no));
      break;
    }
    case "heading": {
      yield NL;
      yield indent;
      yield "#".repeat(n2.attributes.level || 1);
      yield SPACE;
      yield* trimStart(formatChildren(n2, no));
      yield* formatAnnotations(n2);
      yield NL;
      break;
    }
    case "paragraph": {
      yield NL;
      yield* formatChildren(n2, no);
      yield* formatAnnotations(n2);
      yield NL;
      break;
    }
    case "inline": {
      yield indent;
      yield* formatChildren(n2, no);
      break;
    }
    case "image": {
      yield "!";
      yield "[";
      yield* formatValue(n2.attributes.alt, no);
      yield "]";
      yield "(";
      yield* typeof n2.attributes.src === "string" ? escapeMarkdownCharacters(n2.attributes.src, /[()]/) : formatValue(n2.attributes.src, no);
      if (n2.attributes.title) {
        yield SPACE + `"${n2.attributes.title}"`;
      }
      yield ")";
      break;
    }
    case "link": {
      yield "[";
      yield* formatChildren(n2, no);
      yield "]";
      yield "(";
      yield* typeof n2.attributes.href === "string" ? escapeMarkdownCharacters(n2.attributes.href, /[()]/g) : formatValue(n2.attributes.href, no);
      if (n2.attributes.title) {
        yield SPACE + `"${n2.attributes.title}"`;
      }
      yield ")";
      break;
    }
    case "text": {
      const { content: content2 } = n2.attributes;
      if (ast_default.isAst(content2)) {
        yield OPEN + SPACE;
        yield* formatValue(content2, no);
        yield SPACE + CLOSE;
      } else {
        if (o.parent && WRAPPING_TYPES.includes(o.parent.type)) {
          yield* escapeMarkdownCharacters(content2, /[*_~]/g);
        } else {
          yield* escapeMarkdownCharacters(content2, /^[*>#]/);
        }
      }
      break;
    }
    case "blockquote": {
      const prefix2 = ">" + SPACE;
      yield n2.children.map((child) => format(child, no).trimStart()).map((d) => NL + indent + prefix2 + d).join(indent + prefix2);
      break;
    }
    case "hr": {
      yield NL;
      yield indent;
      yield "---";
      yield NL;
      break;
    }
    case "fence": {
      yield NL;
      yield indent;
      const innerFence = n2.attributes.content.match(/`{3,}/g) || [];
      const innerFenceLength = innerFence.map((s2) => s2.length).reduce(max, 0);
      const boundary = "`".repeat(innerFenceLength ? innerFenceLength + 1 : 3);
      yield boundary;
      if (n2.attributes.language)
        yield n2.attributes.language;
      if (n2.annotations.length)
        yield SPACE;
      yield* formatAnnotations(n2);
      yield NL;
      yield indent;
      yield n2.attributes.content.split(NL).join(NL + indent);
      yield boundary;
      yield NL;
      break;
    }
    case "tag": {
      if (!n2.inline) {
        yield NL;
        yield indent;
      }
      const open = OPEN + SPACE;
      const attributes2 = [...formatAttributes(n2)].filter((v2) => v2 !== void 0);
      const tag = [open + n2.tag, ...attributes2];
      const inlineTag = tag.join(SPACE);
      const isLongTagOpening = inlineTag.length + open.length * 2 > (o.maxTagOpeningWidth || MAX_TAG_OPENING_WIDTH);
      yield (!n2.inline && isLongTagOpening ? tag.join(NL + SPACE.repeat(open.length) + indent) : inlineTag) + SPACE + (n2.children.length ? "" : "/") + CLOSE;
      if (n2.children.length) {
        yield* formatChildren(n2, no.allowIndentation ? increment(no) : no);
        if (!n2.inline) {
          yield indent;
        }
        yield OPEN + SPACE + "/" + n2.tag + SPACE + CLOSE;
      }
      if (!n2.inline) {
        yield NL;
      }
      break;
    }
    case "list": {
      const isLoose = n2.children.some((n22) => n22.children.some((c) => c.type === "paragraph"));
      for (let i = 0; i < n2.children.length; i++) {
        const prefix2 = n2.attributes.ordered ? `${i === 0 ? n2.attributes.start ?? "1" : "1"}${n2.attributes.marker ?? OL}` : n2.attributes.marker ?? UL;
        let d = format(n2.children[i], increment(no, prefix2.length + 1));
        if (!isLoose || i === n2.children.length - 1) {
          d = d.trim();
        }
        yield NL + indent + prefix2 + " " + d;
      }
      yield NL;
      break;
    }
    case "item": {
      for (let i = 0; i < n2.children.length; i++) {
        yield* formatValue(n2.children[i], no);
        if (i === 0)
          yield* formatAnnotations(n2);
      }
      break;
    }
    case "strong": {
      yield n2.attributes.marker ?? "**";
      yield* formatInline(formatChildren(n2, no));
      yield n2.attributes.marker ?? "**";
      break;
    }
    case "em": {
      yield n2.attributes.marker ?? "*";
      yield* formatInline(formatChildren(n2, no));
      yield n2.attributes.marker ?? "*";
      break;
    }
    case "code": {
      yield "`";
      yield* formatInline(formatValue(n2.attributes.content, no));
      yield "`";
      break;
    }
    case "s": {
      yield "~~";
      yield* formatInline(formatChildren(n2, no));
      yield "~~";
      break;
    }
    case "hardbreak": {
      yield "\\" + NL;
      yield indent;
      break;
    }
    case "softbreak": {
      yield NL;
      yield indent;
      break;
    }
    case "table": {
      const table3 = [...formatChildren(n2, increment(no))];
      if (o.parent && o.parent.type === "tag" && o.parent.tag === "table") {
        for (let i = 0; i < table3.length; i++) {
          const row = table3[i];
          if (typeof row === "string") {
            if (row.trim().length) {
              yield NL;
              yield row;
            }
          } else {
            if (i !== 0) {
              yield NL;
              yield indent + "---";
            }
            for (const d of row) {
              yield NL + indent + UL + " " + d;
            }
          }
        }
        yield NL;
      } else {
        const widths = [];
        for (const row of table3) {
          for (let i = 0; i < row.length; i++) {
            widths[i] = widths[i] ? Math.max(widths[i], row[i].length) : row[i].length;
          }
        }
        const [head, ...rows] = table3;
        yield NL;
        yield* formatTableRow(head.map((cell, i) => cell + SPACE.repeat(widths[i] - cell.length)));
        yield NL;
        yield* formatTableRow(head.map((cell, i) => "-".repeat(widths[i])));
        yield NL;
        for (const row of rows) {
          yield* formatTableRow(row.map((cell, i) => cell + SPACE.repeat(widths[i] - cell.length)));
          yield NL;
        }
      }
      break;
    }
    case "thead": {
      const [head] = [...formatChildren(n2, no)];
      yield head || [];
      break;
    }
    case "tr": {
      yield [...formatChildren(n2, no)];
      break;
    }
    case "td":
    case "th": {
      yield [...formatChildren(n2, no), ...formatAnnotations(n2)].join("").trim();
      break;
    }
    case "tbody": {
      yield* formatChildren(n2, no);
      break;
    }
    case "comment": {
      yield "<!-- " + n2.attributes.content + " -->\n";
      break;
    }
  }
}
function* formatValue(v2, o = {}) {
  switch (typeof v2) {
    case "undefined":
      break;
    case "boolean":
    case "number":
    case "string": {
      yield v2.toString();
      break;
    }
    case "object": {
      if (v2 === null)
        break;
      if (Array.isArray(v2)) {
        for (const n2 of v2)
          yield* formatValue(n2, o);
        break;
      }
      switch (v2.$$mdtype) {
        case "Function": {
          yield* formatFunction(v2);
          break;
        }
        case "Node":
          yield* formatNode(v2, o);
          break;
        case "Variable": {
          yield* formatVariable(v2);
          break;
        }
        default:
          throw new Error(`Unimplemented: "${v2.$$mdtype}"`);
      }
      break;
    }
  }
}
function format(v2, options2) {
  let doc = "";
  for (const s2 of formatValue(v2, options2))
    doc += s2;
  return doc.trimStart();
}
function truthy(value2) {
  return value2 !== false && value2 !== void 0 && value2 !== null;
}
function renderConditions(node2) {
  const conditions = [
    { condition: node2.attributes.primary, children: [] }
  ];
  for (const child of node2.children) {
    if (child.type === "tag" && child.tag === "else")
      conditions.push({
        condition: "primary" in child.attributes ? child.attributes.primary : true,
        children: []
      });
    else
      conditions[conditions.length - 1].children.push(child);
  }
  return conditions;
}
var tagIf = {
  attributes: {
    primary: { type: Object, render: false }
  },
  transform(node2, config) {
    const conditions = renderConditions(node2);
    for (const { condition, children: children2 } of conditions)
      if (truthy(condition)) {
        const nodes = children2.flatMap((child) => child.transform(config));
        if (nodes.some(isPromise)) {
          return Promise.all(nodes).then((nodes2) => nodes2.flat());
        }
        return nodes;
      }
    return [];
  }
};
var tagElse = {
  selfClosing: true,
  attributes: {
    primary: { type: Object, render: false }
  }
};
var and = {
  transform(parameters) {
    return Object.values(parameters).every((x2) => truthy(x2));
  }
};
var or = {
  transform(parameters) {
    return Object.values(parameters).find((x2) => truthy(x2)) !== void 0;
  }
};
var not = {
  parameters: {
    0: { required: true }
  },
  transform(parameters) {
    return !truthy(parameters[0]);
  }
};
var equals = {
  transform(parameters) {
    const values = Object.values(parameters);
    return values.every((v2) => v2 === values[0]);
  }
};
var debug = {
  transform(parameters) {
    return JSON.stringify(parameters[0], null, 2);
  }
};
var defaultFn = {
  transform(parameters) {
    return parameters[0] === void 0 ? parameters[1] : parameters[0];
  }
};
var functions_default = { and, or, not, equals, default: defaultFn, debug };
function convertToRow(node2, cellType = "td") {
  node2.type = "tr";
  node2.attributes = {};
  for (const cell of node2.children)
    cell.type = cellType;
  return node2;
}
function transform(document2) {
  for (const node2 of document2.walk()) {
    if (node2.type !== "tag" || node2.tag !== "table")
      continue;
    const [first, ...rest] = node2.children;
    if (!first || first.type === "table")
      continue;
    const table3 = new ast_default.Node("table", node2.attributes, [
      new ast_default.Node("thead"),
      new ast_default.Node("tbody")
    ]);
    const [thead2, tbody2] = table3.children;
    if (first.type === "list")
      thead2.push(convertToRow(first, "th"));
    for (const row of rest) {
      if (row.type === "list")
        convertToRow(row);
      else if (row.type === "tag" && row.tag === "if") {
        const children2 = [];
        for (const child of row.children) {
          if (child.type === "hr")
            continue;
          if (child.type === "list")
            convertToRow(child);
          children2.push(child);
        }
        row.children = children2;
      } else
        continue;
      tbody2.push(row);
    }
    node2.children = [table3];
  }
}
var transforms_default = [transform];
var mappings = {
  ordered_list: "list",
  bullet_list: "list",
  code_inline: "code",
  list_item: "item",
  variable: "text"
};
function annotate(node2, attributes2) {
  for (const attribute of attributes2) {
    node2.annotations.push(attribute);
    const { name: name2, value: value2, type } = attribute;
    if (type === "attribute") {
      if (node2.attributes[name2] !== void 0)
        node2.errors.push({
          id: "duplicate-attribute",
          level: "warning",
          message: `Attribute '${name2}' already set`
        });
      node2.attributes[name2] = value2;
    } else if (type === "class")
      if (node2.attributes.class)
        node2.attributes.class[name2] = value2;
      else
        node2.attributes.class = { [name2]: value2 };
  }
}
function handleAttrs(token, type) {
  switch (type) {
    case "heading":
      return { level: Number(token.tag.replace("h", "")) };
    case "list": {
      const attrs = token.attrs ? Object.fromEntries(token.attrs) : void 0;
      const ordered = token.type.startsWith("ordered");
      return ordered && (attrs == null ? void 0 : attrs.start) ? { ordered: true, start: attrs.start, marker: token.markup } : { ordered, marker: token.markup };
    }
    case "link": {
      const attrs = Object.fromEntries(token.attrs);
      return attrs.title ? { href: attrs.href, title: attrs.title } : { href: attrs.href };
    }
    case "image": {
      const attrs = Object.fromEntries(token.attrs);
      return attrs.title ? { alt: token.content, src: attrs.src, title: attrs.title } : { alt: token.content, src: attrs.src };
    }
    case "em":
    case "strong":
      return { marker: token.markup };
    case "text":
    case "code":
    case "comment":
      return { content: (token.meta || {}).variable || token.content };
    case "fence": {
      const [language] = token.info.split(" ", 1);
      return language === "" || language === OPEN ? { content: token.content } : { content: token.content, language };
    }
    case "td":
    case "th": {
      if (token.attrs) {
        const attrs = Object.fromEntries(token.attrs);
        let align;
        if (attrs.style) {
          if (attrs.style.includes("left")) {
            align = "left";
          } else if (attrs.style.includes("center")) {
            align = "center";
          } else if (attrs.style.includes("right")) {
            align = "right";
          }
        }
        if (align) {
          return { align };
        }
      }
      return {};
    }
    default:
      return {};
  }
}
function handleToken(token, nodes, file, handleSlots, addLocation, inlineParent) {
  if (token.type === "frontmatter") {
    nodes[0].attributes.frontmatter = token.content;
    return;
  }
  if (token.hidden || token.type === "text" && token.content === "")
    return;
  const errors2 = token.errors || [];
  const parent = nodes[nodes.length - 1];
  const { tag, attributes: attributes2, error: error2 } = token.meta || {};
  if (token.type === "annotation") {
    if (inlineParent)
      return annotate(inlineParent, attributes2);
    return parent.errors.push({
      id: "no-inline-annotations",
      level: "error",
      message: `Can't apply inline annotations to '${parent.type}'`
    });
  }
  let typeName = token.type.replace(/_(open|close)$/, "");
  if (mappings[typeName])
    typeName = mappings[typeName];
  if (typeName === "error") {
    const { message, location: location2 } = error2;
    errors2.push({ id: "parse-error", level: "critical", message, location: location2 });
  }
  if (token.nesting < 0) {
    if (parent.type === typeName && parent.tag === tag) {
      if (parent.lines && token.map)
        parent.lines.push(...token.map);
      return nodes.pop();
    }
    errors2.push({
      id: "missing-opening",
      level: "critical",
      message: `Node '${typeName}' is missing opening`
    });
  }
  const attrs = handleAttrs(token, typeName);
  const node2 = new Node$1(typeName, attrs, void 0, tag || void 0);
  const { position = {} } = token;
  node2.errors = errors2;
  if (addLocation !== false) {
    node2.lines = token.map || parent.lines || [];
    node2.location = {
      file,
      start: {
        line: node2.lines[0],
        character: position.start
      },
      end: {
        line: node2.lines[1],
        character: position.end
      }
    };
  }
  if (inlineParent)
    node2.inline = true;
  if (attributes2 && ["tag", "fence", "image"].includes(typeName))
    annotate(node2, attributes2);
  if (handleSlots && tag === "slot" && typeof node2.attributes.primary === "string")
    parent.slots[node2.attributes.primary] = node2;
  else
    parent.push(node2);
  if (token.nesting > 0)
    nodes.push(node2);
  if (!Array.isArray(token.children))
    return;
  if (node2.type === "inline")
    inlineParent = parent;
  nodes.push(node2);
  const isLeafNode = typeName === "image";
  if (!isLeafNode) {
    for (const child of token.children)
      handleToken(child, nodes, file, handleSlots, addLocation, inlineParent);
  }
  nodes.pop();
}
function parser$1(tokens2, args) {
  const doc = new Node$1("document");
  const nodes = [doc];
  if (typeof args === "string")
    args = { file: args };
  for (const token of tokens2)
    handleToken(token, nodes, args == null ? void 0 : args.file, args == null ? void 0 : args.slots, args == null ? void 0 : args.location);
  if (nodes.length > 1)
    for (const node2 of nodes.slice(1))
      node2.errors.push({
        id: "missing-closing",
        level: "critical",
        message: `Node '${node2.tag || node2.type}' is missing closing`
      });
  for (const transform3 of transforms_default)
    transform3(doc);
  return doc;
}
var schema_exports = {};
__export(schema_exports, {
  blockquote: () => blockquote$1,
  code: () => code,
  comment: () => comment,
  document: () => document,
  em: () => em,
  error: () => error$2,
  fence: () => fence,
  hardbreak: () => hardbreak,
  heading: () => heading,
  hr: () => hr,
  image: () => image,
  inline: () => inline,
  item: () => item,
  link: () => link$1,
  list: () => list,
  node: () => node,
  paragraph: () => paragraph,
  s: () => s,
  softbreak: () => softbreak,
  strong: () => strong,
  table: () => table,
  tbody: () => tbody,
  td: () => td,
  text: () => text,
  th: () => th,
  thead: () => thead,
  tr: () => tr
});
var document = {
  render: "article",
  children: [
    "heading",
    "paragraph",
    "image",
    "table",
    "tag",
    "fence",
    "blockquote",
    "comment",
    "list",
    "hr"
  ],
  attributes: {
    frontmatter: { render: false }
  }
};
var heading = {
  children: ["inline"],
  attributes: {
    level: { type: Number, render: false, required: true }
  },
  transform(node2, config) {
    return new Tag(`h${node2.attributes["level"]}`, node2.transformAttributes(config), node2.transformChildren(config));
  }
};
var paragraph = {
  render: "p",
  children: ["inline"]
};
var image = {
  render: "img",
  attributes: {
    src: { type: String, required: true },
    alt: { type: String },
    title: { type: String }
  }
};
var fence = {
  render: "pre",
  attributes: {
    content: { type: String, render: false, required: true },
    language: { type: String, render: "data-language" },
    process: { type: Boolean, render: false, default: true }
  },
  transform(node2, config) {
    const attributes2 = node2.transformAttributes(config);
    const children2 = node2.children.length ? node2.transformChildren(config) : [node2.attributes.content];
    return new Tag("pre", attributes2, children2);
  }
};
var blockquote$1 = {
  render: "blockquote",
  children: [
    "heading",
    "paragraph",
    "image",
    "table",
    "tag",
    "fence",
    "blockquote",
    "list",
    "hr"
  ]
};
var item = {
  render: "li",
  children: [
    "inline",
    "heading",
    "paragraph",
    "image",
    "table",
    "tag",
    "fence",
    "blockquote",
    "list",
    "hr"
  ]
};
var list = {
  children: ["item"],
  attributes: {
    ordered: { type: Boolean, render: false, required: true },
    start: { type: Number },
    marker: { type: String, render: false }
  },
  transform(node2, config) {
    return new Tag(node2.attributes.ordered ? "ol" : "ul", node2.transformAttributes(config), node2.transformChildren(config));
  }
};
var hr = {
  render: "hr"
};
var table = {
  render: "table"
};
var td = {
  render: "td",
  children: [
    "inline",
    "heading",
    "paragraph",
    "image",
    "table",
    "tag",
    "fence",
    "blockquote",
    "list",
    "hr"
  ],
  attributes: {
    align: { type: String },
    colspan: { type: Number, render: "colSpan" },
    rowspan: { type: Number, render: "rowSpan" }
  }
};
var th = {
  render: "th",
  attributes: {
    width: { type: String },
    align: { type: String },
    colspan: { type: Number, render: "colSpan" },
    rowspan: { type: Number, render: "rowSpan" }
  }
};
var tr = {
  render: "tr",
  children: ["th", "td"]
};
var tbody = {
  render: "tbody",
  children: ["tr", "tag"]
};
var thead = {
  render: "thead",
  children: ["tr"]
};
var strong = {
  render: "strong",
  children: ["em", "s", "link", "code", "text", "tag"],
  attributes: {
    marker: { type: String, render: false }
  }
};
var em = {
  render: "em",
  children: ["strong", "s", "link", "code", "text", "tag"],
  attributes: {
    marker: { type: String, render: false }
  }
};
var s = {
  render: "s",
  children: ["strong", "em", "link", "code", "text", "tag"]
};
var inline = {
  children: [
    "strong",
    "em",
    "s",
    "code",
    "text",
    "tag",
    "link",
    "image",
    "hardbreak",
    "softbreak",
    "comment"
  ]
};
var link$1 = {
  render: "a",
  children: ["strong", "em", "s", "code", "text", "tag"],
  attributes: {
    href: { type: String, required: true },
    title: { type: String }
  }
};
var code = {
  render: "code",
  attributes: {
    content: { type: String, render: false, required: true }
  },
  transform(node2, config) {
    const attributes2 = node2.transformAttributes(config);
    return new Tag("code", attributes2, [node2.attributes.content]);
  }
};
var text = {
  attributes: {
    content: { type: String, required: true }
  },
  transform(node2) {
    return node2.attributes.content;
  }
};
var hardbreak = {
  render: "br"
};
var softbreak = {
  transform() {
    return " ";
  }
};
var comment = {
  attributes: {
    content: { type: String, required: true }
  }
};
var error$2 = {};
var node = {};
var import_markdown_it = __toModule(require_markdown_it());
var { escapeHtml } = (0, import_markdown_it.default)().utils;
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node2) {
  if (typeof node2 === "string" || typeof node2 === "number")
    return escapeHtml(String(node2));
  if (Array.isArray(node2))
    return node2.map(render).join("");
  if (node2 === null || typeof node2 !== "object" || !Tag.isTag(node2))
    return "";
  const { name: name2, attributes: attributes2, children: children2 = [] } = node2;
  if (!name2)
    return render(children2);
  let output = `<${name2}`;
  for (const [k, v2] of Object.entries(attributes2 ?? {}))
    output += ` ${k.toLowerCase()}="${escapeHtml(String(v2))}"`;
  output += ">";
  if (voidElements.has(name2))
    return output;
  if (children2.length)
    output += render(children2);
  output += `</${name2}>`;
  return output;
}
function tagName$1(name2, components) {
  return typeof name2 !== "string" ? name2 : name2[0] !== name2[0].toUpperCase() ? name2 : components instanceof Function ? components(name2) : components[name2];
}
function dynamic(node2, React, { components = {} } = {}) {
  function deepRender2(value2) {
    if (value2 == null || typeof value2 !== "object")
      return value2;
    if (Array.isArray(value2))
      return value2.map((item2) => deepRender2(item2));
    if (value2.$$mdtype === "Tag")
      return render3(value2);
    if (typeof value2 !== "object")
      return value2;
    const output = {};
    for (const [k, v2] of Object.entries(value2))
      output[k] = deepRender2(v2);
    return output;
  }
  function render3(node3) {
    if (Array.isArray(node3))
      return React.createElement(React.Fragment, null, ...node3.map(render3));
    if (node3 === null || typeof node3 !== "object" || !Tag.isTag(node3))
      return node3;
    const {
      name: name2,
      attributes: { class: className, ...attrs } = {},
      children: children2 = []
    } = node3;
    if (className)
      attrs.className = className;
    return React.createElement(tagName$1(name2, components), Object.keys(attrs).length == 0 ? null : deepRender2(attrs), ...children2.map(render3));
  }
  return render3(node2);
}
function tagName2(name2, components) {
  return typeof name2 !== "string" ? "Fragment" : name2[0] !== name2[0].toUpperCase() ? name2 : components instanceof Function ? components(name2) : components[name2];
}
function renderArray(children2) {
  return children2.map(render2).join(", ");
}
function deepRender(value2) {
  if (value2 == null || typeof value2 !== "object")
    return JSON.stringify(value2);
  if (Array.isArray(value2))
    return `[${value2.map((item2) => deepRender(item2)).join(", ")}]`;
  if (value2.$$mdtype === "Tag")
    return render2(value2);
  if (typeof value2 !== "object")
    return JSON.stringify(value2);
  const object = Object.entries(value2).map(([k, v2]) => [JSON.stringify(k), deepRender(v2)].join(": ")).join(", ");
  return `{${object}}`;
}
function render2(node2) {
  if (Array.isArray(node2))
    return `React.createElement(React.Fragment, null, ${renderArray(node2)})`;
  if (node2 === null || typeof node2 !== "object" || !Tag.isTag(node2))
    return JSON.stringify(node2);
  const {
    name: name2,
    attributes: { class: className, ...attrs } = {},
    children: children2 = []
  } = node2;
  if (className)
    attrs.className = className;
  return `React.createElement(
    tagName(${JSON.stringify(name2)}, components),
    ${Object.keys(attrs).length == 0 ? "null" : deepRender(attrs)},
    ${renderArray(children2)})`;
}
function reactStatic(node2) {
  return `
  (({components = {}} = {}) => {
    ${tagName2}
    return ${render2(node2)};
  })
`;
}
var renderers_default = { html: render, react: dynamic, reactStatic };
var PartialFile = class {
  validate(file, config) {
    const { partials = {} } = config;
    const partial2 = partials[file];
    if (!partial2)
      return [
        {
          id: "attribute-value-invalid",
          level: "error",
          message: `Partial \`${file}\` not found. The 'file' attribute must be set in \`config.partials\``
        }
      ];
    return [];
  }
};
var partial = {
  inline: false,
  selfClosing: true,
  attributes: {
    file: { type: PartialFile, render: false, required: true },
    variables: { type: Object, render: false }
  },
  transform(node2, config) {
    const { partials = {} } = config;
    const { file, variables } = node2.attributes;
    const partial2 = partials[file];
    if (!partial2)
      return null;
    const scopedConfig = {
      ...config,
      variables: {
        ...config.variables,
        ...variables,
        ["$$partial:filename"]: file
      }
    };
    const transformChildren = (part) => part.resolve(scopedConfig).transformChildren(scopedConfig);
    return Array.isArray(partial2) ? partial2.flatMap(transformChildren) : transformChildren(partial2);
  }
};
var table2 = {
  children: ["table"],
  inline: false
};
var slot = {
  attributes: {
    primary: { type: String, required: true }
  }
};
var tags_default = {
  else: tagElse,
  if: tagIf,
  partial,
  slot,
  table: table2
};
var import_lib = __toModule(require_lib());
var import_tag7 = __toModule(require_tag());
function createToken(state, content2, contentStart) {
  try {
    const { type, meta, nesting = 0 } = (0, import_tag7.parse)(content2, { Variable, Function: Function2 });
    const token = state.push(type, "", nesting);
    token.info = content2;
    token.meta = meta;
    if (!state.delimiters) {
      state.delimiters = [];
    }
    return token;
  } catch (error2) {
    if (!(error2 instanceof import_tag7.SyntaxError))
      throw error2;
    const {
      message,
      location: { start: start2, end: end2 }
    } = error2;
    const location2 = contentStart ? {
      start: { offset: start2.offset + contentStart },
      end: { offset: end2.offset + contentStart }
    } : null;
    const token = state.push("error", "", 0);
    token.meta = { error: { message, location: location2 } };
    return token;
  }
}
function block(state, startLine, endLine, silent) {
  const start2 = state.bMarks[startLine] + state.tShift[startLine];
  const finish = state.eMarks[startLine];
  if (!state.src.startsWith(OPEN, start2))
    return false;
  const tagEnd = findTagEnd(state.src, start2);
  const lastPossible = state.src.slice(0, finish).trim().length;
  if (!tagEnd || tagEnd < lastPossible - CLOSE.length)
    return false;
  const contentStart = start2 + OPEN.length;
  const content2 = state.src.slice(contentStart, tagEnd).trim();
  const lines = state.src.slice(start2, tagEnd + CLOSE.length).split("\n").length;
  if (content2[0] === "$")
    return false;
  if (silent)
    return true;
  const token = createToken(state, content2, contentStart);
  token.map = [startLine, startLine + lines];
  state.line += lines;
  return true;
}
function inline2(state, silent) {
  if (!state.src.startsWith(OPEN, state.pos))
    return false;
  const tagEnd = findTagEnd(state.src, state.pos);
  if (!tagEnd)
    return false;
  const content2 = state.src.slice(state.pos + OPEN.length, tagEnd);
  if (!silent)
    createToken(state, content2.trim());
  state.pos = tagEnd + CLOSE.length;
  return true;
}
function core(state) {
  var _a2, _b2;
  let token;
  for (token of state.tokens) {
    if (token.type !== "fence")
      continue;
    if (token.info.includes(OPEN)) {
      const start2 = token.info.indexOf(OPEN);
      const end2 = findTagEnd(token.info, start2);
      const content2 = token.info.slice(start2 + OPEN.length, end2);
      try {
        const { meta } = (0, import_tag7.parse)(content2.trim(), { Variable, Function: Function2 });
        token.meta = meta;
      } catch (error2) {
        if (!(error2 instanceof import_tag7.SyntaxError))
          throw error2;
        if (!token.errors)
          token.errors = [];
        token.errors.push({
          id: "fence-tag-error",
          level: "error",
          message: `Syntax error in fence tag: ${error2.message}`
        });
      }
    }
    if ((_b2 = (_a2 = token == null ? void 0 : token.meta) == null ? void 0 : _a2.attributes) == null ? void 0 : _b2.find((attr) => attr.name === "process" && !attr.value))
      continue;
    token.children = parseTags(token.content, token.map[0]);
  }
}
function plugin(md) {
  md.block.ruler.before("paragraph", "annotations", block, {
    alt: ["paragraph", "blockquote"]
  });
  md.inline.ruler.push("containers", inline2);
  md.core.ruler.push("annotations", core);
}
var fence2 = "---";
function getLine(state, n2) {
  return state.src.slice(state.bMarks[n2], state.eMarks[n2]).trim();
}
function findClose(state, endLine) {
  for (let line = 1; line < endLine; line++)
    if (getLine(state, line) === fence2)
      return line;
}
function block2(state, startLine, endLine, silent) {
  if (startLine != 0 || getLine(state, 0) != fence2)
    return false;
  const close = findClose(state, endLine);
  if (!close)
    return false;
  if (silent)
    return true;
  const token = state.push("frontmatter", "", 0);
  token.content = state.src.slice(state.eMarks[0], state.bMarks[close]).trim();
  token.map = [0, close];
  token.hidden = true;
  state.line = close + 1;
  return true;
}
function plugin2(md) {
  md.block.ruler.before("hr", "frontmatter", block2);
}
var OPEN2 = "<!--";
var CLOSE2 = "-->";
function block3(state, startLine, endLine, silent) {
  const start2 = state.bMarks[startLine] + state.tShift[startLine];
  if (!state.src.startsWith(OPEN2, start2))
    return false;
  const close = state.src.indexOf(CLOSE2, start2);
  if (!close)
    return false;
  if (silent)
    return true;
  const content2 = state.src.slice(start2 + OPEN2.length, close);
  const lines = content2.split("\n").length;
  const token = state.push("comment", "", 0);
  token.content = content2.trim();
  token.map = [startLine, startLine + lines];
  state.line += lines;
  return true;
}
function inline3(state, silent) {
  if (!state.src.startsWith(OPEN2, state.pos))
    return false;
  const close = state.src.indexOf(CLOSE2, state.pos);
  if (!close)
    return false;
  if (silent)
    return true;
  const content2 = state.src.slice(state.pos + OPEN2.length, close);
  const token = state.push("comment", "", 0);
  token.content = content2.trim();
  state.pos = close + CLOSE2.length;
  return true;
}
function plugin3(md) {
  md.block.ruler.before("table", "comment", block3, { alt: ["paragraph"] });
  md.inline.ruler.push("comment", inline3);
}
var Tokenizer = class {
  constructor(config = {}) {
    this.parser = new import_lib.default(config);
    this.parser.use(plugin, "annotations", {});
    this.parser.use(plugin2, "frontmatter", {});
    this.parser.disable([
      "lheading",
      "code"
    ]);
    if (config.allowComments)
      this.parser.use(plugin3, "comments", {});
  }
  tokenize(content2) {
    return this.parser.parse(content2.toString(), {});
  }
};
var TypeMappings = {
  String,
  Number,
  Array,
  Object,
  Boolean
};
function validateType(type, value2, config, key) {
  var _a2, _b2;
  if (!type)
    return true;
  if (ast_default.isFunction(value2) && ((_a2 = config.validation) == null ? void 0 : _a2.validateFunctions)) {
    const schema = (_b2 = config.functions) == null ? void 0 : _b2[value2.name];
    return !(schema == null ? void 0 : schema.returns) ? true : Array.isArray(schema.returns) ? schema.returns.find((t2) => t2 === type) !== void 0 : schema.returns === type;
  }
  if (ast_default.isAst(value2))
    return true;
  if (Array.isArray(type))
    return type.some((t2) => validateType(t2, value2, config, key));
  if (typeof type === "string")
    type = TypeMappings[type];
  if (typeof type === "function") {
    const instance = new type();
    if (instance.validate) {
      return instance.validate(value2, config, key);
    }
  }
  return value2 != null && value2.constructor === type;
}
function typeToString(type) {
  if (typeof type === "string")
    return type;
  if (Array.isArray(type))
    return type.map(typeToString).join(" | ");
  return type.name;
}
function validateFunction(fn2, config) {
  var _a2, _b2;
  const schema = (_a2 = config.functions) == null ? void 0 : _a2[fn2.name];
  const errors2 = [];
  if (!schema)
    return [
      {
        id: "function-undefined",
        level: "critical",
        message: `Undefined function: '${fn2.name}'`
      }
    ];
  if (schema.validate)
    errors2.push(...schema.validate(fn2, config));
  if (schema.parameters) {
    for (const [key, value2] of Object.entries(fn2.parameters)) {
      const param = (_b2 = schema.parameters) == null ? void 0 : _b2[key];
      if (!param) {
        errors2.push({
          id: "parameter-undefined",
          level: "error",
          message: `Invalid parameter: '${key}'`
        });
        continue;
      }
      if (ast_default.isAst(value2) && !ast_default.isFunction(value2))
        continue;
      if (param.type) {
        const valid = validateType(param.type, value2, config, key);
        if (valid === false) {
          errors2.push({
            id: "parameter-type-invalid",
            level: "error",
            message: `Parameter '${key}' of '${fn2.name}' must be type of '${typeToString(param.type)}'`
          });
        } else if (Array.isArray(valid)) {
          errors2.push(...valid);
        }
      }
    }
  }
  for (const [key, { required }] of Object.entries(schema.parameters ?? {}))
    if (required && fn2.parameters[key] === void 0)
      errors2.push({
        id: "parameter-missing-required",
        level: "error",
        message: `Missing required parameter: '${key}'`
      });
  return errors2;
}
function displayMatches(matches, n2) {
  if (matches.length <= n2)
    return JSON.stringify(matches);
  const items = matches.slice(0, n2).map((item2) => JSON.stringify(item2));
  return `[${items.join(",")}, ... ${matches.length - n2} more]`;
}
function validator(node2, config) {
  var _a2, _b2;
  const schema = node2.findSchema(config);
  const errors2 = [...node2.errors || []];
  if (!schema) {
    errors2.push({
      id: node2.tag ? "tag-undefined" : "node-undefined",
      level: "critical",
      message: node2.tag ? `Undefined tag: '${node2.tag}'` : `Undefined node: '${node2.type}'`
    });
    return errors2;
  }
  if (schema.inline != void 0 && node2.inline !== schema.inline)
    errors2.push({
      id: "tag-placement-invalid",
      level: "critical",
      message: `'${node2.tag}' tag should be ${schema.inline ? "inline" : "block"}`
    });
  if (schema.selfClosing && node2.children.length > 0)
    errors2.push({
      id: "tag-selfclosing-has-children",
      level: "critical",
      message: `'${node2.tag}' tag should be self-closing`
    });
  const attributes2 = {
    ...globalAttributes,
    ...schema.attributes
  };
  for (const key of Object.keys(node2.slots)) {
    const slot2 = (_a2 = schema.slots) == null ? void 0 : _a2[key];
    if (!slot2)
      errors2.push({
        id: "slot-undefined",
        level: "error",
        message: `Invalid slot: '${key}'`
      });
  }
  for (let [key, value2] of Object.entries(node2.attributes)) {
    const attrib = attributes2[key];
    if (!attrib) {
      errors2.push({
        id: "attribute-undefined",
        level: "error",
        message: `Invalid attribute: '${key}'`
      });
      continue;
    }
    let { type, matches, errorLevel } = attrib;
    if (ast_default.isAst(value2)) {
      if (ast_default.isFunction(value2) && ((_b2 = config.validation) == null ? void 0 : _b2.validateFunctions))
        errors2.push(...validateFunction(value2, config));
      else if (ast_default.isVariable(value2) && config.variables) {
        let missing = false;
        let variables = config.variables;
        for (const key2 of value2.path) {
          if (!Object.prototype.hasOwnProperty.call(variables, key2)) {
            missing = true;
            break;
          }
          variables = variables[key2];
        }
        if (missing) {
          errors2.push({
            id: "variable-undefined",
            level: "error",
            message: `Undefined variable: '${value2.path.join(".")}'`
          });
        }
      } else
        continue;
    }
    value2 = value2;
    if (type) {
      const valid = validateType(type, value2, config, key);
      if (valid === false) {
        errors2.push({
          id: "attribute-type-invalid",
          level: errorLevel || "error",
          message: `Attribute '${key}' must be type of '${typeToString(type)}'`
        });
      }
      if (Array.isArray(valid)) {
        errors2.push(...valid);
      }
    }
    if (typeof matches === "function")
      matches = matches(config);
    if (Array.isArray(matches) && !matches.includes(value2))
      errors2.push({
        id: "attribute-value-invalid",
        level: errorLevel || "error",
        message: `Attribute '${key}' must match one of ${displayMatches(matches, 8)}. Got '${value2}' instead.`
      });
    if (matches instanceof RegExp && !matches.test(value2))
      errors2.push({
        id: "attribute-value-invalid",
        level: errorLevel || "error",
        message: `Attribute '${key}' must match ${matches}. Got '${value2}' instead.`
      });
    if (typeof attrib.validate === "function") {
      const attribErrors = attrib.validate(value2, config, key);
      if (Array.isArray(attribErrors))
        errors2.push(...attribErrors);
    }
  }
  for (const [key, { required }] of Object.entries(attributes2))
    if (required && node2.attributes[key] === void 0)
      errors2.push({
        id: "attribute-missing-required",
        level: "error",
        message: `Missing required attribute: '${key}'`
      });
  if (schema.slots) {
    for (const [key, { required }] of Object.entries(schema.slots))
      if (required && node2.slots[key] === void 0)
        errors2.push({
          id: "slot-missing-required",
          level: "error",
          message: `Missing required slot: '${key}'`
        });
  }
  for (const { type } of node2.children) {
    if (schema.children && type !== "error" && !schema.children.includes(type))
      errors2.push({
        id: "child-invalid",
        level: "warning",
        message: `Can't nest '${type}' in '${node2.tag || node2.type}'`
      });
  }
  if (schema.validate) {
    const schemaErrors = schema.validate(node2, config);
    if (isPromise(schemaErrors)) {
      return schemaErrors.then((e2) => errors2.concat(e2));
    }
    errors2.push(...schemaErrors);
  }
  return errors2;
}
function* walkWithParents(node2, parents = []) {
  yield [node2, parents];
  for (const child of [...Object.values(node2.slots), ...node2.children])
    yield* walkWithParents(child, [...parents, node2]);
}
function validateTree(content2, config) {
  const output = [...walkWithParents(content2)].map(([node2, parents]) => {
    const { type, lines, location: location2 } = node2;
    const updatedConfig = {
      ...config,
      validation: { ...config.validation, parents }
    };
    const errors2 = validator(node2, updatedConfig);
    if (isPromise(errors2)) {
      return errors2.then((e2) => e2.map((error2) => ({ type, lines, location: location2, error: error2 })));
    }
    return errors2.map((error2) => ({ type, lines, location: location2, error: error2 }));
  });
  if (output.some(isPromise)) {
    return Promise.all(output).then((o) => o.flat());
  }
  return output.flat();
}
var tokenizer = new Tokenizer();
function mergeConfig(config = {}) {
  return {
    ...config,
    tags: {
      ...tags_default,
      ...config.tags
    },
    nodes: {
      ...schema_exports,
      ...config.nodes
    },
    functions: {
      ...functions_default,
      ...config.functions
    }
  };
}
function parse3(content2, args) {
  if (typeof content2 === "string")
    content2 = tokenizer.tokenize(content2);
  return parser$1(content2, args);
}
function resolve2(content2, config) {
  if (Array.isArray(content2))
    return content2.flatMap((child) => child.resolve(config));
  return content2.resolve(config);
}
function transform2(nodes, options2) {
  const config = mergeConfig(options2);
  const content2 = resolve2(nodes, config);
  if (Array.isArray(content2))
    return content2.flatMap((child) => child.transform(config));
  return content2.transform(config);
}
function validate(content2, options2) {
  const config = mergeConfig(options2);
  return validateTree(content2, config);
}
function createElement$1(name2, attributes2 = {}, ...children2) {
  return { name: name2, attributes: attributes2, children: children2 };
}
var Markdoc = class {
  constructor(config) {
    this.parse = parse3;
    this.resolve = (content2) => resolve2(content2, this.config);
    this.transform = (content2) => transform2(content2, this.config);
    this.validate = (content2) => validate(content2, this.config);
    this.config = config;
  }
};
Markdoc.nodes = schema_exports;
Markdoc.tags = tags_default;
Markdoc.functions = functions_default;
Markdoc.globalAttributes = globalAttributes;
Markdoc.renderers = renderers_default;
Markdoc.transforms = transforms_default;
Markdoc.Ast = ast_default;
Markdoc.Tag = Tag;
Markdoc.Tokenizer = Tokenizer;
Markdoc.parseTags = parseTags;
Markdoc.transformer = transformer_default;
Markdoc.validator = validator;
Markdoc.parse = parse3;
Markdoc.transform = transform2;
Markdoc.validate = validate;
Markdoc.createElement = createElement$1;
Markdoc.truthy = truthy;
Markdoc.format = format;
const isTag = (v2) => {
  return typeof v2 === "object" ? true : false;
};
const getHeadingLevel = (file, content2, level, plugin4) => {
  const root = transform2(parse3(content2 || ""));
  let headings = [];
  if (isTag(root)) {
    const nodes = root.children;
    headings = nodes.filter((n2) => isTag(n2) && n2.name === `h${level}`).map((h) => {
      const content22 = h.children.join("\n");
      const name2 = content22.replaceAll(/<(.+)>/gs, "").trim();
      return {
        level,
        name: name2,
        content: content22,
        link: plugin4.dv.fileLink(`${file}#${content22}`, false, name2),
        attributes: h.attributes
      };
    });
    plugin4.debug(
      `H${level} tags`,
      () => `${nodes.length} total nodes, ${nodes.filter((i) => isTag(i)).length} are tags, the rest are scalar items.`,
      `Of these tags, ${headings.length} are H${level} tags.`,
      headings
    );
  } else {
    plugin4.error(`The page content passed in did not result in a renderable tag node!`);
  }
  return headings;
};
const splitContent = (c) => {
  const re = /^(---.*\n---\s*\n){0,1}(.*)$/s;
  const result = c.trimStart().match(re);
  if (!result) {
    throw new Error(`Invalid Content passed to splitContent(${c})`);
  }
  const [_, yaml, body] = Array.from(result);
  const [preH1, h1, postH1] = `
${body}`.includes("\n# ") ? [
    stripTrailing(stripAfter(`
${body}`, "\n# "), "\n#"),
    stripAfter(stripBefore(`
${body}`, "\n#"), "\n").trim(),
    stripBefore(stripBefore(`
${body}`, "\n#"), "\n")
  ] : [
    void 0,
    void 0,
    body
  ];
  const blocks = (h1 ? postH1 : body).replace(/\n## (.*)\n/g, "\n## $1:::\n").slice(1).split(/\n## /).map((blk) => {
    if (/.+:::/.test(blk)) {
      let [name2, ...rest] = blk.split("\n");
      name2 = name2.replace(/(.*):::/, "$1");
      let content2 = rest.join("\n").replace(/^\n(.*)/, "$1").trim();
      return { name: name2, content: content2 };
    } else {
      return { name: "anonymous", content: blk };
    }
  });
  return { yaml, body, blocks, preH1, postH1, h1 };
};
const getContentStructure = (p2) => (content2, path) => {
  const ast = Markdoc.parse(content2);
  const renderableTree = Markdoc.transform(ast);
  return {
    ast,
    renderableTree,
    h2_tags: getHeadingLevel(path, content2, 2, p2),
    ...splitContent(content2)
  };
};
const getViewMeta = (p2) => (view, info2) => {
  var _a2, _b2, _c2;
  const content2 = view.getViewData();
  const ast = Markdoc.parse(content2);
  Markdoc.transform(ast);
  return {
    iconAssigned: view.icon,
    mode: view.currentMode,
    leaf: view.leaf,
    leaf_height: (_a2 = view.leaf) == null ? void 0 : _a2.height,
    leaf_width: (_b2 = view.leaf) == null ? void 0 : _b2.width,
    leaf_id: ((_c2 = view.leaf) == null ? void 0 : _c2.id) || "",
    popover: view.hoverPopover,
    allowNoFile: view.allowNoFile,
    previewMode: view.previewMode,
    viewType: view.getViewType(),
    navigation: view.navigation,
    editor: view.editor,
    requestSave: view.requestSave,
    load: view.load,
    onLoadFile: view.onLoadFile,
    onUnloadFile: view.onUnloadFile,
    onResize: view.onResize,
    onRename: view.onRename,
    onPaneMenu: view.onPaneMenu,
    register: view.register,
    registerDomEvent: view.registerDomEvent,
    registerEvent: view.registerEvent,
    registerInterval: view.registerInterval,
    getEphemeralState: view.getEphemeralState,
    getState: view.getState,
    getViewData: view.getViewData,
    getViewType: view.getViewType,
    content: content2,
    showBackLinks: view == null ? void 0 : view.showBackLinks,
    contentStructure: getContentStructure(p2)(content2, info2.path)
  };
};
const getDomMeta = (view, info2) => ({
  container: view.containerEl,
  content: view.contentEl,
  icon: view == null ? void 0 : view.iconEl,
  backButton: view == null ? void 0 : view.backButtonEl,
  forwardButton: view == null ? void 0 : view.forwardButtonEl,
  title: view == null ? void 0 : view.titleEl,
  titleContainer: view == null ? void 0 : view.titleContainerEl,
  titleParent: view == null ? void 0 : view.titleParentEl,
  inlineTitle: view == null ? void 0 : view.inlineTitleEl,
  actions: view == null ? void 0 : view.actionsEl,
  modeButton: view == null ? void 0 : view.modeButtonEl,
  backlinks: view == null ? void 0 : view.backlinksEl
});
const createPageView = (p2) => (view) => {
  var _a2;
  if ((_a2 = view == null ? void 0 : view.file) == null ? void 0 : _a2.path) {
    const info2 = getPageInfo(p2)(view.file.path);
    if (info2) {
      const viewMeta = {
        view: getViewMeta(p2)(view, info2),
        dom: getDomMeta(view)
      };
      return {
        ...info2,
        ...viewMeta
      };
    }
  }
};
const style$1 = (opts) => {
  let fmt = [];
  if (opts == null ? void 0 : opts.pb) {
    fmt.push(`padding-bottom: ${opts.pb}`);
  }
  if (opts == null ? void 0 : opts.pt) {
    fmt.push(`padding-top: ${opts.pt}`);
  }
  if (opts == null ? void 0 : opts.py) {
    fmt.push(`padding-top: ${opts.py}`);
    fmt.push(`padding-bottom: ${opts.py}`);
  }
  if (opts == null ? void 0 : opts.px) {
    fmt.push(`padding-left: ${opts.px}`);
    fmt.push(`padding-right: ${opts.px}`);
  }
  if (opts == null ? void 0 : opts.pl) {
    fmt.push(`padding-left: ${opts.pl}`);
  }
  if (opts == null ? void 0 : opts.pr) {
    fmt.push(`padding-right: ${opts.pr}`);
  }
  if (opts == null ? void 0 : opts.p) {
    fmt.push(`padding: ${opts.p}`);
  }
  if (opts == null ? void 0 : opts.m) {
    fmt.push(`margin-top: ${opts.m}`);
    fmt.push(`margin-bottom: ${opts.m}`);
    fmt.push(`margin-left: ${opts.m}`);
    fmt.push(`margin-right: ${opts.m}`);
  }
  if (opts == null ? void 0 : opts.mb) {
    fmt.push(`margin-bottom: ${opts.mb}`);
  }
  if (opts == null ? void 0 : opts.mt) {
    fmt.push(`margin-top: ${opts.mt}`);
  }
  if (opts == null ? void 0 : opts.my) {
    fmt.push(`margin-top: ${opts.mx}`);
    fmt.push(`margin-bottom: ${opts.mx}`);
  }
  if (opts == null ? void 0 : opts.mx) {
    fmt.push(`margin-left: ${opts.mx}`);
    fmt.push(`margin-right: ${opts.mx}`);
  }
  if (opts == null ? void 0 : opts.ml) {
    fmt.push(`margin-left: ${opts.ml}`);
  }
  if (opts == null ? void 0 : opts.mr) {
    fmt.push(`margin-right: ${opts.mr}`);
  }
  if (opts == null ? void 0 : opts.bespoke) {
    fmt.push(...opts.bespoke);
  }
  if (opts == null ? void 0 : opts.w) {
    fmt.push(`weight: ${opts.w}`);
  }
  if (opts == null ? void 0 : opts.fw) {
    fmt.push(`font-weight: ${opts.fw}`);
  }
  if (opts == null ? void 0 : opts.fs) {
    fmt.push(`font-style: ${opts.fs}`);
  }
  if (opts == null ? void 0 : opts.ts) {
    switch (opts.ts) {
      case "xs":
        fmt.push(`font-size: 0.75rem`);
        fmt.push(`line-height: 1rem`);
        break;
      case "sm":
        fmt.push(`font-size: 0.875rem`);
        fmt.push(`line-height: 1.25rem`);
        break;
      case "base":
        fmt.push(`font-size: 1rem`);
        fmt.push(`line-height: 1.5rem`);
        break;
      case "lg":
        fmt.push(`font-size: 1.125rem`);
        fmt.push(`line-height: 1.75rem`);
        break;
      case "xl":
        fmt.push(`font-size: 1.25rem`);
        fmt.push(`line-height: 1.75rem`);
        break;
      case "2xl":
        fmt.push(`font-size: 1.5rem`);
        fmt.push(`line-height: 2rem`);
        break;
      default:
        fmt.push(`font-size: ${opts.ts}`);
        fmt.push(`line-height: auto`);
    }
  }
  if (opts == null ? void 0 : opts.flex) {
    fmt.push(`display: flex`);
  }
  if (opts == null ? void 0 : opts.direction) {
    fmt.push(`flex-direction: ${opts.direction}`);
  }
  if (opts == null ? void 0 : opts.grow) {
    fmt.push(`flex-grow: ${opts.grow}`);
  }
  if (opts == null ? void 0 : opts.gap) {
    fmt.push(`gap: ${opts.gap}`);
  }
  if (opts == null ? void 0 : opts.cursor) {
    fmt.push(`cursor: ${opts.cursor}`);
  }
  if (opts == null ? void 0 : opts.alignItems) {
    fmt.push(`align-items: ${opts.alignItems}`);
  }
  if (opts == null ? void 0 : opts.justifyItems) {
    fmt.push(`justify-items: ${opts.justifyItems}`);
  }
  if (opts == null ? void 0 : opts.justifyContent) {
    fmt.push(`justify-content: ${opts.justifyContent}`);
  }
  if (opts == null ? void 0 : opts.position) {
    fmt.push(`position: ${opts.position}`);
  }
  if (opts == null ? void 0 : opts.display) {
    fmt.push(`display: ${opts.display}`);
  }
  if (opts == null ? void 0 : opts.opacity) {
    fmt.push(`opacity: ${opts.opacity}`);
  }
  return fmt.length === 0 ? `style=""` : `style="${fmt.join("; ")}"`;
};
const listStyle = (opts = {}) => {
  let fmt = [];
  if ((opts == null ? void 0 : opts.indentation) && opts.indentation !== "default") {
    switch (opts.indentation) {
      case "24px":
        fmt.push(`padding-inline-start: 24px`);
        break;
      case "20px":
        fmt.push(`padding-inline-start: 20px`);
        break;
      case "16px":
        fmt.push(`padding-inline-start: 16px`);
        break;
      case "12px":
        fmt.push(`padding-inline-start: 12px`);
        break;
      case "none":
        fmt.push(`padding-inline-start: 0px`);
        break;
    }
  }
  if ((opts == null ? void 0 : opts.mt) && opts.mt !== "default") {
    fmt.push(`margin-block-start: ${opts.mt === "tight" ? "2px" : opts.mt === "none" ? "0px" : opts.mt === "spaced" ? "1.5rem" : opts.mt}`);
  }
  if ((opts == null ? void 0 : opts.mb) && opts.mb !== "default") {
    fmt.push(`margin-block-end: ${opts.mb === "tight" ? "2px" : opts.mb === "none" ? "0px" : opts.mb === "spaced" ? "1.5rem" : opts.mb}`);
  }
  if ((opts == null ? void 0 : opts.my) && opts.my !== "default") {
    fmt.push(`margin-block-start: ${opts.my === "tight" ? "2px" : opts.my === "none" ? "0px" : opts.my === "spaced" ? "1.5rem" : opts.my}`);
    fmt.push(`margin-block-end: ${opts.my === "tight" ? "2px" : opts.my === "none" ? "0px" : opts.my === "spaced" ? "1.5rem" : opts.my}`);
  }
  return fmt.length === 0 ? `style=""` : `style="${fmt.join("; ")}"`;
};
const defaultLinkIcons = {
  documentation: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="#a3a3a3" d="M8 13h8v-2H8Zm0 3h8v-2H8Zm0 3h5v-2H8Zm-2 3q-.825 0-1.412-.587Q4 20.825 4 20V4q0-.825.588-1.413Q5.175 2 6 2h8l6 6v12q0 .825-.587 1.413Q18.825 22 18 22Zm7-13h5l-5-5Z"/></svg>`,
  repo: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 16 16"><path fill="#a3a3a3" d="M14 4a2 2 0 1 0-2.47 1.94V7a.48.48 0 0 1-.27.44L8.49 8.88l-2.76-1.4A.49.49 0 0 1 5.46 7V5.94a2 2 0 1 0-1 0V7a1.51 1.51 0 0 0 .82 1.34L8 9.74v1.32a2 2 0 1 0 1 0V9.74l2.7-1.36A1.49 1.49 0 0 0 12.52 7V5.92A2 2 0 0 0 14 4zM4 4a1 1 0 1 1 2 0a1 1 0 0 1-2 0zm5.47 9a1 1 0 1 1-2 0a1 1 0 0 1 2 0zM12 5a1 1 0 1 1 0-2a1 1 0 0 1 0 2z"/></svg>`,
  review: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 14 14"><g fill="none" stroke="#a3a3a3" stroke-linecap="round" stroke-linejoin="round"><circle cx="6.87" cy="5" r="4.5"/><circle cx="6.87" cy="5" r="2"/><path d="m6 9.42l-.88 3.7a.51.51 0 0 1-.26.33a.54.54 0 0 1-.43 0L1.11 12a.51.51 0 0 1-.18-.78L3.5 8M8 9.37l.9 3.75a.5.5 0 0 0 .27.33a.51.51 0 0 0 .42 0l3.3-1.45a.5.5 0 0 0 .28-.35a.48.48 0 0 0-.1-.43l-2.68-3.41"/></g></svg>`,
  company: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="#a3a3a3" d="M11 15v-2h2v2h-2Zm-1-9h4V4h-4v2ZM4 21q-.825 0-1.413-.588T2 19v-4h7v1q0 .425.288.713T10 17h4q.425 0 .713-.288T15 16v-1h7v4q0 .825-.588 1.413T20 21H4Zm-2-8V8q0-.825.588-1.413T4 6h4V4q0-.825.588-1.413T10 2h4q.825 0 1.413.588T16 4v2h4q.825 0 1.413.588T22 8v5h-7v-1q0-.425-.288-.713T14 11h-4q-.425 0-.713.288T9 12v1H2Z"/></svg>`,
  link: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 256 256"><path fill="#a3a3a3" d="M134.71 189.19a4 4 0 0 1 0 5.66l-9.94 9.94a52 52 0 0 1-73.56-73.56l24.12-24.12a52 52 0 0 1 71.32-2.1a4 4 0 1 1-5.32 6A44 44 0 0 0 81 112.77l-24.13 24.12a44 44 0 0 0 62.24 62.24l9.94-9.94a4 4 0 0 1 5.66 0Zm70.08-138a52.07 52.07 0 0 0-73.56 0l-9.94 9.94a4 4 0 1 0 5.71 5.68l9.94-9.94a44 44 0 0 1 62.24 62.24L175 143.23a44 44 0 0 1-60.33 1.77a4 4 0 1 0-5.32 6a52 52 0 0 0 71.32-2.1l24.12-24.12a52.07 52.07 0 0 0 0-73.57Z"/></svg>`,
  link_broken: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="#a3a3a3" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"><path d="M14 11.998C14 9.506 11.683 7 8.857 7H7.143C4.303 7 2 9.238 2 11.998c0 2.378 1.71 4.368 4 4.873a5.3 5.3 0 0 0 1.143.124M16.857 7c.393 0 .775.043 1.143.124c2.29.505 4 2.495 4 4.874a4.92 4.92 0 0 1-1.634 3.653"/><path d="M10 11.998c0 2.491 2.317 4.997 5.143 4.997M18 22.243l2.121-2.122m0 0L22.243 18m-2.122 2.121L18 18m2.121 2.121l2.122 2.122"/></g></svg>`,
  api: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="#888888" d="M13.26 10.5h2v1h-2z"/><path fill="#888888" d="M20 4H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2M8.4 15L8 13.77H6.06L5.62 15H4l2.2-6h1.62L10 15Zm8.36-3.5a1.47 1.47 0 0 1-1.5 1.5h-2v2h-1.5V9h3.5a1.47 1.47 0 0 1 1.5 1.5ZM20 15h-1.5V9H20Z"/><path fill="#888888" d="M6.43 12.77h1.16l-.58-1.59z"/></svg>`,
  article: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 256 256"><path fill="#888888" d="M88 112a8 8 0 0 1 8-8h80a8 8 0 0 1 0 16H96a8 8 0 0 1-8-8m8 40h80a8 8 0 0 0 0-16H96a8 8 0 0 0 0 16m136-88v120a24 24 0 0 1-24 24H32a24 24 0 0 1-24-23.89V88a8 8 0 0 1 16 0v96a8 8 0 0 0 16 0V64a16 16 0 0 1 16-16h160a16 16 0 0 1 16 16m-16 0H56v120a23.84 23.84 0 0 1-1.37 8H208a8 8 0 0 0 8-8Z"/></svg>`,
  you_tube: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M0 0h24v24H0z"/><path fill="#888888" d="M18 3a5 5 0 0 1 5 5v8a5 5 0 0 1-5 5H6a5 5 0 0 1-5-5V8a5 5 0 0 1 5-5zM9 9v6a1 1 0 0 0 1.514.857l5-3a1 1 0 0 0 0-1.714l-5-3A1 1 0 0 0 9 9"/></g></svg>`,
  website: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="#a3a3a3"><path fill-rule="evenodd" d="M14 7a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1V8a1 1 0 0 0-1-1h-4Zm3 2h-2v6h2V9Z" clip-rule="evenodd"/><path d="M6 7a1 1 0 0 0 0 2h4a1 1 0 1 0 0-2H6Zm0 4a1 1 0 1 0 0 2h4a1 1 0 1 0 0-2H6Zm-1 5a1 1 0 0 1 1-1h4a1 1 0 1 1 0 2H6a1 1 0 0 1-1-1Z"/><path fill-rule="evenodd" d="M4 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h16a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3H4Zm16 2H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1Z" clip-rule="evenodd"/></g></svg>`,
  wikipedia: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="#888888" d="m14.97 18.95l-2.56-6.03c-1.02 1.99-2.14 4.08-3.1 6.03c-.01.01-.47 0-.47 0C7.37 15.5 5.85 12.1 4.37 8.68C4.03 7.84 2.83 6.5 2 6.5v-.45h5.06v.45c-.6 0-1.62.4-1.36 1.05c.72 1.54 3.24 7.51 3.93 9.03c.47-.94 1.8-3.42 2.37-4.47c-.45-.88-1.87-4.18-2.29-5c-.32-.54-1.13-.61-1.75-.61c0-.15.01-.25 0-.44l4.46.01v.4c-.61.03-1.18.24-.92.82c.6 1.24.95 2.13 1.5 3.28c.17-.34 1.07-2.19 1.5-3.16c.26-.65-.13-.91-1.21-.91c.01-.12.01-.33.01-.43c1.39-.01 3.48-.01 3.85-.02v.42c-.71.03-1.44.41-1.82.99L13.5 11.3c.18.51 1.96 4.46 2.15 4.9l3.85-8.83c-.3-.72-1.16-.87-1.5-.87v-.45l4 .03v.42c-.88 0-1.43.5-1.75 1.25c-.8 1.79-3.25 7.49-4.85 11.2z"/></svg>`,
  playground: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 50 50"><path fill="#888888" d="M7.206 31.141c2.885 0 5.219-2.399 5.219-5.368c0-2.953-2.334-5.353-5.219-5.353C4.333 20.42 2 22.82 2 25.773c0 2.968 2.333 5.368 5.206 5.368m29.23 9.216a.53.53 0 0 1 .741.117l.965 1.372a.578.578 0 0 1-.116.766l-7.08 5.287a.536.536 0 0 1-.743-.118l-.962-1.372a.575.575 0 0 1 .116-.764zm-8.003-6.817l-2.808-5.063l-1.474 1.107l2.808 5.09zm-6.551-11.827L10.962 2l-2.089.014l11.522 20.82zm10.281 10.43C32.78 31.682 34.192 31 35 31h10c1.974 0 3 1.986 3 4.004C48 37.034 46.974 38 45 38h-9l-10.836 8.502c-3.808 2.819-6.116-.278-6.116-.278l-8.483-8.729c-1.423-1.753-1.115-5.089.591-6.566l11.739-8.597c1.166-1 2.897-.843 3.885.343c.976 1.2.822 2.994-.346 3.996l-7.515 5.657l5.399 5.484z"/></svg>`,
  pin: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="#888888" d="M12 20.556q-.235 0-.47-.077t-.432-.25q-1.067-.98-2.163-2.185q-1.097-1.204-1.992-2.493t-1.467-2.633t-.572-2.622q0-3.173 2.066-5.234T12 3t5.03 2.062t2.066 5.234q0 1.279-.572 2.613q-.572 1.333-1.458 2.632q-.885 1.3-1.981 2.494T12.92 20.21q-.191.173-.434.26t-.487.086m.003-8.825q.668 0 1.14-.476t.472-1.143t-.475-1.14t-1.143-.472t-1.14.476t-.472 1.143t.475 1.14t1.143.472"/></svg>`,
  map: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="#888888" d="M14.485 19.737L9 17.823l-3.902 1.509q-.21.083-.401.053t-.354-.132t-.252-.274Q4 18.806 4 18.583V6.41q0-.282.13-.499t.378-.303l3.957-1.345q.124-.05.257-.075T9 4.163t.278.025t.257.075L15 6.177l3.902-1.509q.21-.083.401-.053t.354.132t.252.274q.091.173.091.396v12.259q0 .284-.159.495t-.426.298l-3.9 1.287q-.13.05-.256.065q-.125.016-.26.016t-.26-.025t-.254-.075m.015-1.033v-11.7l-5-1.746v11.7zm1 0L19 17.55V5.7l-3.5 1.304zM5 18.3l3.5-1.342v-11.7L5 6.45zM15.5 7.004v11.7zm-7-1.746v11.7z"/></svg>`,
  home: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="#888888" d="M6 19h3v-5q0-.425.288-.712T10 13h4q.425 0 .713.288T15 14v5h3v-9l-6-4.5L6 10zm-2 0v-9q0-.475.213-.9t.587-.7l6-4.5q.525-.4 1.2-.4t1.2.4l6 4.5q.375.275.588.7T20 10v9q0 .825-.588 1.413T18 21h-4q-.425 0-.712-.288T13 20v-5h-2v5q0 .425-.288.713T10 21H6q-.825 0-1.412-.587T4 19m8-6.75"/></svg>`,
  office: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 20 20"><path fill="#888888" fill-rule="evenodd" d="M1 2.75A.75.75 0 0 1 1.75 2h10.5a.75.75 0 0 1 0 1.5H12v13.75a.75.75 0 0 1-.75.75h-1.5a.75.75 0 0 1-.75-.75v-2.5a.75.75 0 0 0-.75-.75h-2.5a.75.75 0 0 0-.75.75v2.5a.75.75 0 0 1-.75.75h-2.5a.75.75 0 0 1 0-1.5H2v-13h-.25A.75.75 0 0 1 1 2.75M4 5.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5zM4.5 9a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5zM8 5.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5zM8.5 9a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5zm5.75-3a.75.75 0 0 0-.75.75V17a1 1 0 0 0 1 1h3.75a.75.75 0 0 0 0-1.5H18v-9h.25a.75.75 0 0 0 0-1.5zm.5 3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5zm.5 3.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5z" clip-rule="evenodd"/></svg>`
};
const iconApi = (p2) => {
  const linkIcons = getPage(p2)("Link Icons") || defaultLinkIcons;
  return {
    /**
     * The designated page for _link icons_ with a backup of core icons so
     * even if `Link Icons` page is missing we'll have a decent selection.
     */
    linkIcons,
    /**
     * Returns the current icon associated with a page.
     *
     * - returns `broken-link` if the page is not resolvable by the `PageReference` passed in
     */
    currentIcon: (pg) => {
      const page = getPage(p2)(pg);
      if (page) {
        const path = getPath(page);
        return getIcon(path);
      }
      return "broken-link";
    },
    /**
     * Returns all the properties which have inline SVG definitions
     */
    getIconProperties: (pg) => {
      const page = getPage(p2)(pg);
      if (page) {
        return getMetadata(p2)(page)["svg_inline"];
      }
      return [];
    }
  };
};
const MARKDOWN_PAGE_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 15 15"><path fill="currentColor" fill-rule="evenodd" d="M0 3.5A1.5 1.5 0 0 1 1.5 2h12A1.5 1.5 0 0 1 15 3.5v8a1.5 1.5 0 0 1-1.5 1.5h-12A1.5 1.5 0 0 1 0 11.5zM10 5v3.293L8.854 7.146l-.708.708l2 2a.5.5 0 0 0 .708 0l2-2l-.707-.708L11 8.293V5zm-7.146.146A.5.5 0 0 0 2 5.5V10h1V6.707l1.5 1.5l1.5-1.5V10h1V5.5a.5.5 0 0 0-.854-.354L4.5 6.793z" clip-rule="evenodd"/></svg>`;
const WARN_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-alert-triangle"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><path d="M12 9v4"></path><path d="M12 17h.01"></path></svg>`;
const QUOTE_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-quote"><path d="M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z"></path><path d="M15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z"></path></svg>`;
const INFO_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg>`;
const TIP_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-flame"><path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z"></path></svg>`;
const SUMMARY_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 256 256"><path fill="currentColor" d="M200.12 55.87A102 102 0 1 0 55.88 200.12A102 102 0 1 0 200.12 55.87M94 211.37V152a2 2 0 0 1 2-2h64a2 2 0 0 1 2 2v59.37a90.49 90.49 0 0 1-68 0M146 138h-36V99.71l36-18Zm45.64 53.64A90.93 90.93 0 0 1 174 205.39V152a14 14 0 0 0-14-14h-2V72a6 6 0 0 0-8.68-5.37l-48 24A6 6 0 0 0 98 96v42h-2a14 14 0 0 0-14 14v53.39a90.93 90.93 0 0 1-17.64-13.75a90 90 0 1 1 127.28 0"/></svg>`;
const BUG_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-bug"><path d="m8 2 1.88 1.88"></path><path d="M14.12 3.88 16 2"></path><path d="M9 7.13v-1a3.003 3.003 0 1 1 6 0v1"></path><path d="M12 20c-3.3 0-6-2.7-6-6v-3a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v3c0 3.3-2.7 6-6 6"></path><path d="M12 20v-9"></path><path d="M6.53 9C4.6 8.8 3 7.1 3 5"></path><path d="M6 13H2"></path><path d="M3 21c0-2.1 1.7-3.9 3.8-4"></path><path d="M20.97 5c0 2.1-1.6 3.8-3.5 4"></path><path d="M22 13h-4"></path><path d="M17.2 17c2.1.1 3.8 1.9 3.8 4"></path></svg>`;
const EXAMPLE_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-list"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg>`;
const QUESTION_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-help-circle"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><path d="M12 17h.01"></path></svg>`;
const SUCCESS_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-check"><path d="M20 6 9 17l-5-5"></path></svg>`;
const ERROR_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-zap"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg>`;
const NOTE_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path><path d="m15 5 4 4"></path></svg>`;
const BOOK_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M14 9.9V8.2q.825-.35 1.688-.525T17.5 7.5q.65 0 1.275.1T20 7.85v1.6q-.6-.225-1.213-.337T17.5 9q-.95 0-1.825.238T14 9.9m0 5.5v-1.7q.825-.35 1.688-.525T17.5 13q.65 0 1.275.1t1.225.25v1.6q-.6-.225-1.213-.338T17.5 14.5q-.95 0-1.825.225T14 15.4m0-2.75v-1.7q.825-.35 1.688-.525t1.812-.175q.65 0 1.275.1T20 10.6v1.6q-.6-.225-1.213-.338T17.5 11.75q-.95 0-1.825.238T14 12.65M6.5 16q1.175 0 2.288.263T11 17.05V7.2q-1.025-.6-2.175-.9T6.5 6q-.9 0-1.788.175T3 6.7v9.9q.875-.3 1.738-.45T6.5 16m6.5 1.05q1.1-.525 2.213-.787T17.5 16q.9 0 1.763.15T21 16.6V6.7q-.825-.35-1.713-.525T17.5 6q-1.175 0-2.325.3T13 7.2zM12 20q-1.2-.95-2.6-1.475T6.5 18q-1.05 0-2.062.275T2.5 19.05q-.525.275-1.012-.025T1 18.15V6.1q0-.275.138-.525T1.55 5.2q1.15-.6 2.4-.9T6.5 4q1.45 0 2.838.375T12 5.5q1.275-.75 2.663-1.125T17.5 4q1.3 0 2.55.3t2.4.9q.275.125.413.375T23 6.1v12.05q0 .575-.487.875t-1.013.025q-.925-.5-1.937-.775T17.5 18q-1.5 0-2.9.525T12 20m-5-8.35"/></svg>`;
const KINDLE_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 48 48"><circle cx="24" cy="24" r="21.5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"/><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6.944 37.03a56.3 56.3 0 0 1 9.696-.751c4.318 0 11.836 1.626 20.316 4.879"/><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M20.167 36.547c1.52-.212 3.833-2.679 3.833-2.679a15 15 0 0 0 2.237-1.57l2.179 2.124v1.24l1.29.885l3.589-2.96s-.379-1.293-1.262-1.64c-.042-.62-2.748-5.06-3-5.425m-6.589.533a15 15 0 0 0 2.44 1.542c.392.028 6.532-4.093 6.532-4.093a4.73 4.73 0 0 0 2.13-1.122a2.7 2.7 0 0 0 .225-1.15s.365-.476.365-.645s.28-1.01.28-1.093"/><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M24.855 24.504s.701.869.925.869s5.103-2.58 5.215-3.14m-10.828 6.532c.09-.084 2.644-1.444 2.644-1.444"/><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18.154 21.868c.477 1.907 3.673 5.453 3.673 5.453l3.365-3.294s-2.832-3.028-3.169-3.953s-.785-2.524-1.682-2.916s-4.458-2.243-4.458-2.243l-.673 1.233a11.73 11.73 0 0 0-5.13 9.673c0 6.561.756 8.804.756 8.804s4.85-1.037 6.589-2.888s2.742-2.972 2.742-2.972l.353-3.004"/><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M11.597 34.44a3.44 3.44 0 0 0 1.423 1.93m19.701-2.31a15.5 15.5 0 0 0 3.391 4.532a17 17 0 0 0 2.25 1.304M30.03 36.28c.573.756 2.396 2.817 2.956 3.448M20.167 17.079l.454-.426s2.047 1.402 2.664 1.01s.589-.842.589-.842s1.01-.617.981-.925a1.7 1.7 0 0 1 0-.449h.841s-.532-1.598-.196-2.186l.336-.59l.401.365a2.6 2.6 0 0 0 1.03-2.58c-.393-1.57-2.776-4.037-3.87-4.205s-.953.196-.953.196s-1.99-1.177-3.224-.084s-2.692 2.356-2.663 4.599s.056 2.887.224 3.112a2.6 2.6 0 0 0 .766.481l-.494.964m17.924.738l3.028.2l-5.284 5.663l-2.511-.308z"/></svg>`;
const SEARCH_BOOK = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M11.724 7.447a2.276 2.276 0 1 0 0 4.553a2.276 2.276 0 0 0 0-4.553M4 4.5A2.5 2.5 0 0 1 6.5 2H18a2.5 2.5 0 0 1 2.5 2.5v14.25a.75.75 0 0 1-.75.75H5.5a1 1 0 0 0 1 1h13.25a.75.75 0 0 1 0 1.5H6.5A2.5 2.5 0 0 1 4 19.5zm10.819 7.295a3.724 3.724 0 1 0-1.024 1.024l2.476 2.475l.067.058l.008.006a.724.724 0 0 0 .942-1.093z"/></svg>`;
const AMAZON = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path d="M15.93 17.09c-.18.16-.43.17-.63.06c-.89-.74-1.05-1.08-1.54-1.79c-1.47 1.5-2.51 1.95-4.42 1.95c-2.25 0-4.01-1.39-4.01-4.17c0-2.18 1.17-3.64 2.86-4.38c1.46-.64 3.49-.76 5.04-.93V7.5c0-.66.05-1.41-.33-1.96c-.32-.49-.95-.7-1.5-.7c-1.02 0-1.93.53-2.15 1.61c-.05.24-.25.48-.47.49l-2.6-.28c-.22-.05-.46-.22-.4-.56c.6-3.15 3.45-4.1 6-4.1c1.3 0 3 .35 4.03 1.33C17.11 4.55 17 6.18 17 7.95v4.17c0 1.25.5 1.81 1 2.48c.17.25.21.54 0 .71l-2.06 1.78h-.01m-2.7-6.53V10c-1.94 0-3.99.39-3.99 2.67c0 1.16.61 1.95 1.63 1.95c.76 0 1.43-.47 1.86-1.22c.52-.93.5-1.8.5-2.84m6.93 8.98C18 21.14 14.82 22 12.1 22c-3.81 0-7.25-1.41-9.85-3.76c-.2-.18-.02-.43.25-.29c2.78 1.63 6.25 2.61 9.83 2.61c2.41 0 5.07-.5 7.51-1.53c.37-.16.66.24.32.51m.91-1.04c-.28-.36-1.85-.17-2.57-.08c-.19.02-.22-.16-.03-.3c1.24-.88 3.29-.62 3.53-.33c.24.3-.07 2.35-1.24 3.32c-.18.16-.35.07-.26-.11c.26-.67.85-2.14.57-2.5z" fill="currentColor"/></svg>`;
const BOOK_CATALOG = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 48 48"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6.3 42.5h34.1m-34-2l7-.2l-.5-34.7l-6.3-.1Zm8.6-27l-.3 26.3l6.5-.2l.8-25.9Zm9-5.6l-1.4 32.2l8.7-.1L33 8.4Zm10 6.3l-1.5 26.3l7.8.1l1.4-26.3Zm1 0a8.5 8.5 0 0 1 5.7-3.7M12.9 5.6L14.8 9l.1 4.6m-1.5 26.7l1.3-.5"/></svg>`;
const CALENDAR_DATE = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="#a3a3a3" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M8 2v4m8-4v4"/><rect width="18" height="18" x="3" y="4" rx="2"/><path d="M3 10h18"/></g></svg>`;
const obsidian_blockquote = (kind, title, opts) => [
  `<div data-callout-metadata="" data-callout-fold="${(opts == null ? void 0 : opts.fold) || ""}" data-callout="${kind}" class="callout" ${style$1((opts == null ? void 0 : opts.style) || {})}>`,
  `<div class="callout-title" style="gap:15px; align-items: center">`,
  ...(opts == null ? void 0 : opts.icon) ? [`<div class="callout-icon">${opts == null ? void 0 : opts.icon}</div>`] : [],
  `<div class="callout-title-inner" style="display: flex; flex-direction: row;">${title}</div>`,
  ...(opts == null ? void 0 : opts.toRight) ? [
    `<div class="callout-title-right" style="display: flex; flex-grow: 1; justify-content: right">${opts.toRight}</div>`
  ] : [],
  `</div>`,
  ...(opts == null ? void 0 : opts.content) ? typeof opts.content === "string" ? [
    `<div class="callout-content" ${style$1(opts.contentStyle || {})}>`,
    `<p>${opts.content}</p>`,
    `</div>`
  ] : [
    `<div class="callout-content" style="display: flex; flex-direction: column; space-between: 4px;">`,
    ...opts.content.map((c) => `<div class="content-element" ${style$1({ flex: true, ...opts.contentStyle || {} })}>${c}</div>`),
    `</div>`
  ] : [],
  ...(opts == null ? void 0 : opts.belowTheFold) ? [`<div class="below-the-fold" ${style$1((opts == null ? void 0 : opts.belowTheFoldStyle) || {})}>${opts == null ? void 0 : opts.belowTheFold}</div>`] : [""],
  `</div>`
].filter((i) => i).join("\n");
const blockquote = (kind, title, opts) => {
  const iconLookup = {
    warning: WARN_ICON,
    quote: QUOTE_ICON,
    info: INFO_ICON,
    tip: TIP_ICON,
    summary: SUMMARY_ICON,
    bug: BUG_ICON,
    example: EXAMPLE_ICON,
    question: QUESTION_ICON,
    success: SUCCESS_ICON,
    error: ERROR_ICON,
    note: NOTE_ICON
  };
  return obsidian_blockquote(
    kind,
    title,
    (opts == null ? void 0 : opts.icon) && opts.icon in iconLookup ? { ...opts, icon: iconLookup[opts.icon] } : opts
  );
};
const badge = (text2, color = "gray", textColor = "white") => {
  return `<span class="badge" style="background-color: ${color}; padding: 0.25rem; font-size: 10px; border-radius: 8px; text-color: ${textColor}">${text2}</span>`;
};
const removePound$1 = (tag) => {
  return typeof tag === "string" && (tag == null ? void 0 : tag.startsWith("#")) ? tag.slice(1) : tag;
};
const list_items_api = (wrapper) => ({
  indent: (...items) => renderListItems(wrapper, items),
  done: createFnWithProps(() => "", { escape: true })
});
const wrap_ul = (items, opts) => `<ul ${listStyle(opts)}>${items}</ul>`;
const renderListItems = (wrapper, items, opts) => wrapper(
  items.filter((i) => i !== void 0).map((i) => isFunction$2(i) ? isFunction$2(i(list_items_api)) ? "" : i(list_items_api) : `<li ${style$1((opts == null ? void 0 : opts.li) ? isFunction$2(opts == null ? void 0 : opts.li) ? opts.li(i ? i : "") : opts.li : {})}>${i}</li>`).filter((i) => i !== "").join("\n"),
  opts
);
const span = (text2, fmt) => {
  return `<span ${style$1(fmt || { fw: "400" })}>${text2}</span>`;
};
const italics = (text2, fmt) => {
  return `<span ${style$1({ ...fmt || { fw: "400" }, fs: "italic" })}>${text2}</span>`;
};
const italic = (text2, fmt) => italics(text2, fmt);
const bold = (text2, fmt) => {
  return `<span ${style$1({ ...fmt || {}, fw: "700" })}>${text2}</span>`;
};
const light = (text2, fmt) => {
  return `<span ${style$1({ ...fmt || {}, fw: "300" })}>${text2}</span>`;
};
const thin = (text2, fmt) => {
  return `<span ${style$1({ ...fmt || {}, fw: "100" })}>${text2}</span>`;
};
const medium = (text2, fmt) => {
  return `<span ${style$1({ ...fmt || {}, fw: "500" })}>${text2}</span>`;
};
const normal = (text2, fmt) => {
  return `<span ${style$1({ ...fmt || {}, fw: "400" })}>${text2}</span>`;
};
const emptyCallout = (fmt) => [
  `<div class="callout" ${style$1(fmt)}>`,
  `<div class="callout-title">&nbsp;</div>`,
  `<div class="callout-content">&nbsp;</div>`,
  `</div>`
].join("\n");
const internalLink = (p2) => (ref, opt) => {
  const link2 = (href, title) => `<a data-tooltip-position="top" aria-label="${href}" data-href="${href}" class="internal-link data-link-icon data-link-text" _target="_blank" rel="noopener" data-link-path="${href}" style="">${title}</a>`;
  let page = getPage(p2)(ref);
  if (page) {
    link2(page.file.path, (opt == null ? void 0 : opt.title) || page.file.name);
  }
  return "";
};
const formattingApi = (p2) => {
  return {
    /** removes the pound symbol from a string */
    removePound: removePound$1,
    /**
     * returns the HTML for an unordered list
     */
    ul(items, opts) {
      return renderListItems(wrap_ul, items.filter((i) => i !== void 0), opts);
    },
    // /**
    //  * **renderToRight**`(text)`
    //  * 
    //  * Takes text/html and renders it to the right.
    //  * 
    //  * Note: use `toRight` just to wrap this text in the appropriate HTML
    //  * to move content to right.
    //  */
    // renderToRight: (text: string) => p.dv.renderValue(
    // 	`<span class="to-right" style="display: flex; flex-direction: row; width: auto;"><span class="spacer" style="display: flex; flex-grow: 1">&nbsp;</span><span class="right-text" style: "display: flex; flex-grow: 0>${text}</span></span>`, 
    // 	container,p, filePath, true
    // ),
    toRight: (content2, fmt) => {
      const html = [
        `<div class="wrapper-to-right" style="display: relative">`,
        `<span class="block-to-right" style="position: absolute; right: 0">`,
        `<span ${style$1({ ...fmt, position: "relative" })}>`,
        content2,
        `</span>`,
        `</div>`
      ].join("\n");
      return html;
    },
    /**
     * Adds an HTML link tag `<a></a>` to an internal resource in the vault.
     * 
     * Note: for external links use the `link` helper instead as the generated link
     * here provides the reference as meta-data other then the traditional `href` 
     * property.
     */
    internalLink: internalLink(p2),
    /**
     * Add a span element with optional formatting
     */
    span,
    italics,
    bold,
    light,
    thin,
    medium,
    normal,
    emptyCallout,
    /**
     * Wrap children items with DIV element; gain formatting control for block
     */
    wrap: (children2, fmt) => {
      return [
        `<div class="wrapped-content" ${style$1(fmt || {})}>`,
        ...children2.filter((i) => i !== void 0),
        `</div>`
      ].join("\n");
    },
    link: (title, url, opts) => {
      return [
        `<a href="${url}" >`,
        ...(opts == null ? void 0 : opts.iconUrl) || (opts == null ? void 0 : opts.svgInline) ? (opts == null ? void 0 : opts.titlePosition) === "top" ? [
          normal(title)
        ] : [
          `<span class="grouping" ${style$1((opts == null ? void 0 : opts.style) || { alignItems: "center", flex: true })}>`,
          (opts == null ? void 0 : opts.iconUrl) ? `<img src="${opts.iconUrl}" style="padding-right: 4px">` : opts == null ? void 0 : opts.svgInline,
          normal(title),
          `</span>`
        ] : [
          normal(title)
        ],
        `</a>`
      ].join("\n");
    },
    /**
     * **as_tag**`(text)`
     * 
     * Puts the provided text into a _code block_ and ensures that the
     * leading character is a `#` symbol.
     */
    as_tag: (text2) => text2 ? `<code class="tag-reference" style="background-color: transparent">${ensureLeading(text2, "#")}</code>` : "",
    inline_codeblock: (text2) => `<code class="inline-codeblock" style="display: flex; flex-direction: row;">${text2}</code>`,
    /**
     * **blockquote**`(kind, title, opts)`
     * 
     * Produces the HTML for a callout.
     * 
     * **Note:** use `callout` for same functionality but 
     * with HTML _rendered_ rather than _returned_.
     */
    blockquote: (kind, title, opts) => blockquote(kind, title, opts),
    list: (format2, ...blocks) => {
      const html = [
        `<div class="list-block" style="${style$1(format2)}">`,
        blocks.join("\n	"),
        `</div>`
      ].join("\n");
      return html;
    },
    /** draws a two column table using markdown rather than HTML */
    twoColumnTable: (leftHeading, rightHeading, ...data2) => {
      let lines = [];
      for (const datum of data2) {
        const [left2, right2] = datum;
        lines.push(`| ${left2} | ${right2}|`);
      }
      if (!leftHeading && !rightHeading) {
        return lines.join("\n") + "\n";
      } else {
        const preamble = `| ${leftHeading} | ${rightHeading} |
| --- | --- |
`;
        return preamble + lines.join("\n") + "\n";
      }
    }
  };
};
function removePound(tag) {
  return typeof tag === "string" && (tag == null ? void 0 : tag.startsWith("#")) ? tag.slice(1) : tag;
}
const get_internal_links = (p2) => (pg, ...props) => {
  let links = [];
  for (const prop of props) {
    const pgProp = pg[prop];
    if (!pgProp) {
      break;
    }
    if (Array.isArray(pgProp)) {
      links = [...links, ...pgProp.filter((i) => isLink(i))];
    } else if (isLink(pgProp)) {
      links.push(pgProp);
    } else if (isDvPage(pgProp)) {
      links.push(pgProp.file.link);
    }
  }
  return links;
};
const renderApi = (p2) => (el, filePath) => {
  const current = getPage(p2)(filePath);
  if (!current) {
    throw new Error(`Attempt to initialize dv_page() with an invalid sourcePath: ${filePath}!`);
  }
  return {
    /**
     * Uses the underlying `renderValue()` functionality exposed by
     * dataview to render data to the page.
     */
    async render(data2) {
      await p2.dv.renderValue(data2, el, p2, filePath, false);
    },
    /** the current page represented as a `DvPage` */
    current,
    /**
     * simply utility to ensure that a tag string has it's 
     * leading pound symbol removed.
     */
    removePound,
    /**
     * **get_classification**`(page)`
     * 
     * Gets a page's classification {`isCategory`,`isSubcategory`,`category`,`subcategory`}
     */
    getClassification: getClassification(p2),
    /**
     * **get_internal_links**
     * 
     * Gets any links to pages in the vault found across the various 
     * properties passed in.
     */
    get_internal_links: get_internal_links(),
    /**
     * **callout**`(kind, title, opts)`
     * 
     * Renders a callout to the current block.
     * 
     * **Note:** use `blockquote` for same functionality but 
     * with HTML returned rather than _rendered_.
     */
    callout: (kind, title, opts) => p2.dv.renderValue(
      blockquote(kind, title, opts),
      el,
      p2,
      filePath,
      false
    ),
    /**
     * **page**`(path, [originFile])`
     * 
     * Map a page path to the actual data contained within that page.
     */
    page(pg, originFile) {
      return p2.dv.page(pg, originFile);
    },
    pages(query2, originFile) {
      return p2.dv.pages(query2, originFile);
    },
    /**
     * **as_array**`(v)`
     * 
     * Utility function which ensures that the passed in value _is_ an array,
     * and that any DvArray[] proxy is converted to a normal JS array
     */
    as_array: (v2) => {
      return p2.dv.isDataArray(v2) ? Array.from(v2.values) : isArray(v2) ? v2.map((i) => p2.dv.isDataArray(i) ? i.values : i) : [v2];
    },
    /**
     * Return an array of paths (as strings) corresponding to pages 
     * which match the query.
     */
    pagePaths(query2, originFile) {
      return p2.dv.pagePaths(query2, originFile);
    },
    /**
     * **date**`(pathLike)`
     * 
     * Attempt to extract a date from a string, link or date.
     */
    date(pathLike) {
      return p2.dv.date(pathLike);
    },
    /**
     * **duration**`(pathLike)`
     * 
     * Attempt to extract a duration from a string or duration.
     */
    duration(str) {
      return p2.dv.duration(str);
    },
    /**
     * **fileLink**`(path, [embed],[display])`
     * 
     * Create a dataview file link to the given path.
     */
    fileLink(path, embed, displayAs) {
      return p2.dv.fileLink(path, embed, displayAs);
    },
    /**
     * **sectionLink**`(path, [embed],[display])`
     * 
     * Create a dataview section link to the given path.
     */
    sectionLink(path, embed, display) {
      return p2.dv.sectionLink(path, embed, display);
    },
    /**
     * **blockLink**`(path, [embed],[display])`
     * 
     * Create a dataview block link to the given path.
     */
    blockLink(path, embed, display) {
      return p2.dv.blockLink(path, embed, display);
    },
    /**
     * **table**`(headers,values,container,component,filePath)`
     * 
     * Render a dataview table with the given headers, and the 
     * 2D array of values.
     */
    async table(headers, values) {
      return p2.dv.table(headers, values, el, p2, filePath);
    },
    /**
     * **renderValue**`(value, [inline])`
     * 
     * Render an arbitrary value into a container.
     */
    async renderValue(value2, inline4 = false) {
      return p2.dv.renderValue(value2, el, p2, filePath, inline4);
    },
    /** 
     * **taskList**`(tasks,groupByFile)`
     * 
     * Render a dataview task view with the given tasks. 
     */
    async taskList(tasks, groupByFile) {
      return p2.dv.taskList(tasks, groupByFile, el, p2, filePath);
    },
    /**
     * **list**(values, container, component, filePath)
     * 
     * Render a dataview **list** of the given values by:
     * 
     * - adding a sub-container DIV to the passed in _container_
     * - using the `component`'s `addChild()` method to 
     * adding a child element which is given the sub-container
     * for rendering purposes
     */
    async list(values) {
      return p2.dv.list(values, el, p2, filePath);
    },
    async paragraph(text2) {
      return p2.dv.renderValue(text2, el, p2, filePath, false);
    },
    async ul(...items) {
      const wrap_ul2 = (items2) => `<ul>${items2}</ul>`;
      const render_items = (items2) => items2.map((i) => isFunction$2(i) ? isFunction$2(i(ul_api)) ? "" : i(ul_api) : `<li>${i}</li>`).filter((i) => i !== "").join("\n");
      const ul_api = {
        indent: (...items2) => wrap_ul2(render_items(items2)),
        done: createFnWithProps(() => "", { escape: true })
      };
      return p2.dv.renderValue(
        wrap_ul2(render_items(items)),
        el,
        p2,
        filePath,
        false
      );
    },
    async ol(...items) {
      return p2.dv.renderValue(
        renderListItems(wrap_ol, items),
        el,
        p2,
        filePath,
        false
      );
    },
    code: (code2) => p2.dv.renderValue(
      `<code>${code2}</code>`,
      el,
      p2,
      filePath,
      true
    )
  };
};
const removeFmKey = (p2) => (
  /**
   * A higher order function which interacts with **Obsidian** to remove
   * a property from a page's frontmatter.
   */
  (path) => (
    /**
     *  Removes the specified `key` from the current page.
     */
    async (key) => {
      const abstractFile = p2.app.vault.getAbstractFileByPath(path);
      if (abstractFile instanceof TFile) {
        const file = abstractFile;
        try {
          await p2.app.fileManager.processFrontMatter(file, (frontmatter) => {
            delete frontmatter[key];
          });
          p2.debug(`Frontmatter key '${key}' removed successfully from file: ${path}`);
        } catch (error2) {
          p2.error("Error removing frontmatter key:", error2);
        }
      } else {
        p2.error(`File "${path}" not found or is a folder.`);
      }
    }
  )
);
const setFmKey = (p2) => (path) => (
  /**
   * Sets the value of the specified **key** in the _frontmatter_ properties.
   */
  async (key, value2) => {
    const abstractFile = p2.app.vault.getAbstractFileByPath(path);
    if (abstractFile instanceof TFile) {
      const file = abstractFile;
      try {
        await p2.app.fileManager.processFrontMatter(file, (frontmatter) => {
          frontmatter[key] = value2;
        });
        p2.debug(`Frontmatter updated successfully for file: ${path}`);
      } catch (error2) {
        p2.error(`Error updating frontmatter [${key}] for file "${path}":`, error2);
      }
    } else {
      console.error(`File "${path}" not found or is a folder.`);
    }
  }
);
const fmApi = (p2, path) => path ? {
  /** set **key** on current page's _frontmatter_. */
  setFmKey: setFmKey(p2)(path),
  /** remove **key** from current page's _frontmatter_. */
  removeFmKey: removeFmKey(p2)(path)
} : {
  setFmKey: setFmKey(p2),
  removeFmKey: removeFmKey(p2)
};
const createKindDefinition = (p2) => (ref) => {
  const pg = getPage(p2)(ref);
  if (pg) {
    try {
      const tags = getKindTagsOfPage(p2)(pg);
      const defn = {
        path: pg.file.path,
        tag: tags ? tags[0] : void 0,
        requiredProps: isArray(pg._requiredProps) ? pg._requiredProps : isArray(pg.__requiredProps) ? pg.__requiredProps : void 0,
        metricProps: pg._metricProps || pg.__metricProps
      };
      const hash2 = p2.hasher(JSON.stringify(defn));
      p2.debug(`kind defn hash: ${hash2}`, { ref });
      return {
        ...defn,
        hash: hash2
      };
    } catch (e2) {
      const msg2 = (e2 == null ? void 0 : e2.msg) || (e2 == null ? void 0 : e2.message) || String(e2);
      p2.error(`Problem calling createKindDefinition(${String(ref)}): ${msg2}`);
    }
  } else {
    if (!ref) {
      p2.warn(`an empty reference was passed to createKindDefinition!`);
    } else {
      p2.warn("can not create KindDefinition", { ref, pg });
    }
  }
};
const updateKindDefinitionInCache = (p2) => async (payload) => {
  if (isPageReference(payload)) {
    const path = getPath(payload);
    const page = getPage(p2)(path);
    if (path && page) {
      const defn = createKindDefinition(p2)(page);
      if (isTagKindDefinition(defn)) {
        p2.cache.kindDefinitionsByTag.set(defn.tag, defn);
        p2.cache.kindDefinitionsByPath.set(path, defn);
      } else {
        p2.cache.kindDefinitionsByPath.set(path, defn);
      }
    } else {
      p2.warn(
        `when calling updateKindDefinitionInCache() the payload appeared to be a page reference but for some reason we couldn't bring up the page! ${JSON.stringify(payload)}`,
        { path, page }
      );
    }
  }
  if (isKindDefinition(payload)) {
    const page = getPage(p2)(payload.path);
    if (page) {
      const defn = createKindDefinition(p2)(payload.path);
      if ((defn == null ? void 0 : defn.hash) !== (payload == null ? void 0 : payload.hash)) {
        p2.cache.kindDefinitionsByPath.set(payload.path, defn);
        if (defn.tag) {
          p2.cache.kindDefinitionsByTag.set(defn.tag, defn);
        }
      } else {
        p2.debug(`no change to kind defn`, `path: ${page.file.path}`, `hash: ${defn.hash}`);
      }
    } else {
      p2.warn(`updateKindDefinitionInCache() got invalid payload`, "was not a page reference so kind have been a KindDefinition", { payload });
    }
  }
};
const updateTypeDefinitionInCache = (p2) => async (payload) => {
  if (isPageReference(payload)) {
    const path = getPath(payload);
    const page = getPage(p2)(path);
    if (path && page) {
      const defn = createKindDefinition(p2)(page);
      if (isTagKindDefinition(defn)) {
        p2.cache.typeDefinitionsByTag.set(defn.tag, defn);
        p2.cache.typeDefinitionsByPath.set(path, defn);
      } else {
        p2.cache.typeDefinitionsByPath.set(path, defn);
      }
    }
    if (isKindDefinition(payload)) {
      const page2 = getPage(p2)(payload.path);
      if (page2) {
        const defn = createKindDefinition(p2)(payload.path);
        if ((defn == null ? void 0 : defn.hash) !== (payload == null ? void 0 : payload.hash)) {
          p2.cache.typeDefinitionsByPath.set(payload.path, defn);
          if (defn.tag) {
            p2.cache.typeDefinitionsByTag.set(defn.tag, defn);
          }
        } else {
          p2.warn(`updateTypeDefinitionInCache() got invalid payload`, "was not a page reference so kind should have been a KindDefinition", { payload });
        }
      }
    }
  } else {
    const defn = createKindDefinition(p2)(payload.path);
    if (defn.hash !== payload.hash) {
      p2.cache.typeDefinitionsByPath.set(payload.path, defn);
      if (defn.tag) {
        p2.cache.typeDefinitionsByTag.set(defn.tag, defn);
      }
    }
  }
};
const wait = (delay) => {
  return new Promise((resolve3) => {
    setTimeout(() => {
      resolve3("wait delay expired");
    }, delay);
  });
};
const showQueryError = (p2) => (handler, page, content2) => {
  page.callout("error", `Query error in ${handler}`, {
    content: content2
  });
};
const isValidURL = (str) => {
  try {
    new URL(str);
    return true;
  } catch (_) {
    return false;
  }
};
const findStaleByTag = async (p2) => {
  const kinds = p2.dv.pages(`#kind`).where((k) => {
    var _a2, _b2;
    return (_b2 = (_a2 = k.file) == null ? void 0 : _a2.etags) == null ? void 0 : _b2.some((i) => i.startsWith(`#kind/`));
  });
  const types = p2.dv.pages(`#type`).where((k) => {
    var _a2, _b2;
    return (_b2 = (_a2 = k.file) == null ? void 0 : _a2.etags) == null ? void 0 : _b2.some((i) => i.startsWith(`#type/`));
  });
  let problems = [];
  for (const pg of kinds) {
    const kp = p2.dv.page(pg.file.path);
    if (kp) {
      updateKindDefinitionInCache(p2)(kp);
      p2.debug(`caching by file path ${kp.file.path}`);
    } else {
      p2.warn(`Page missing kind tag`, { pg });
    }
  }
  for (const pg of types) {
    const kp = p2.dv.page(pg.file.path);
    if (kp) {
      updateTypeDefinitionInCache(p2)(kp);
      p2.debug(`caching by file path ${kp.file.path}`);
    } else {
      p2.warn(`Page missing kind tag`, { pg });
    }
  }
  p2.settings.kinds = Array.from(
    p2.cache.kindDefinitionsByTag.values()
  );
  p2.settings.types = Array.from(
    p2.cache.typeDefinitionsByTag.values()
  );
  p2.saveSettings();
  if (problems.length > 0) {
    p2.warn(`${problems.length} problems loading cache`, "failed to insert the following elements into cache", problems);
  }
};
const initializeKindCaches = async (p2) => {
  var _a2, _b2, _c2, _d2;
  const kinds = Array.isArray((_a2 = p2.settings) == null ? void 0 : _a2.kinds) ? (_b2 = p2.settings) == null ? void 0 : _b2.kinds : [];
  const types = Array.isArray((_c2 = p2.settings) == null ? void 0 : _c2.types) ? (_d2 = p2.settings) == null ? void 0 : _d2.types : [];
  p2.info(
    `cache updated with user settings`,
    `${kinds.length} kinds defined in user settings`,
    `${types.length} types defined in user settings`
  );
  for (const kind of kinds) {
    if (isTagKindDefinition(kind)) {
      if (p2.cache.kindDefinitionsByTag.has(kind.tag)) {
        if (p2.cache.kindTagDuplicates.has(kind.tag)) {
          const current = p2.cache.kindTagDuplicates.get(kind.tag);
          current == null ? void 0 : current.add(kind);
          p2.cache.kindTagDuplicates.set(kind.tag, current);
        } else {
          p2.cache.kindTagDuplicates.set(
            kind.tag,
            /* @__PURE__ */ new Set(
              [
                kind,
                p2.cache.kindTagDuplicates.get(kind.tag)
              ]
            )
          );
        }
      }
      p2.cache.kindDefinitionsByTag.set(kind.tag, kind);
    }
    if (kind.path) {
      p2.cache.kindDefinitionsByPath.set(kind.path, kind);
    }
  }
  for (const t2 of types) {
    if (isTagKindDefinition(t2)) {
      if (p2.cache.kindDefinitionsByTag.has(t2.tag)) {
        if (p2.cache.kindTagDuplicates.has(t2.tag)) {
          const current = p2.cache.kindTagDuplicates.get(t2.tag);
          current == null ? void 0 : current.add(t2);
          p2.cache.kindTagDuplicates.set(t2.tag, current);
        } else {
          p2.cache.kindTagDuplicates.set(
            t2.tag,
            /* @__PURE__ */ new Set(
              [
                t2,
                p2.cache.kindTagDuplicates.get(t2.tag)
              ]
            )
          );
        }
      }
      p2.cache.kindDefinitionsByTag.set(t2.tag, t2);
    }
    if (t2.path) {
      p2.cache.kindDefinitionsByPath.set(t2.path, t2);
    }
  }
  p2.info(`Kind (${kinds.length}) and Type (${types.length}) Lookups cached`);
  await wait(100);
  return Promise.all([
    // findStaleByPath(p),
    findStaleByTag(p2).then(() => p2.info("Cache refreshed"))
  ]);
};
const lookupKindByTag = (p2) => (tag) => {
  const t2 = stripLeading(tag, "#");
  return p2.cache.kindDefinitionsByTag.get(t2);
};
const lookupKnownKindTags = (p2) => {
  const tags = Array.from(p2.cache.kindDefinitionsByTag.keys());
  return tags;
};
const moment = globalThis.moment;
const getWhenDate = (p2) => (ref) => {
  const page = getPageInfo(p2)(ref);
  if (page) {
    const { when, date } = page.current.file.frontmatter;
    const prop = when || date;
    if (prop && isIsoExplicitDate(prop)) {
      return prop;
    }
    if (page.name.includes("-")) {
      const pre = retainUntil(page.name, ...WHITESPACE_CHARS);
      if (isIsoExplicitDate(pre)) {
        return pre;
      }
    }
  }
  p2.info("when", { page, ref });
  return void 0;
};
const todaysYear = () => String(moment(Date.now()).year());
const todaysMonth = () => String(moment(Date.now()).month());
const todaysDate = () => String(moment(Date.now()).date());
const getToday = () => {
  const dt = moment(Date.now()).toISOString(true);
  return stripAfter(dt, "T");
};
const getYesterday = () => {
  const dt = moment(Date.now()).subtract("1", "day").toISOString(true);
  return stripAfter(dt, "T");
};
const getTomorrow = () => {
  const dt = moment(Date.now()).add("1", "day").toISOString(true);
  return stripAfter(dt, "T");
};
const isThisYear = (date) => {
  const year = isMoment(date) ? String(date.year()) : date.slice(0, 4);
  return year === todaysYear();
};
const getYear = (forDate) => {
  const date = stripAfter(forDate, "T");
  return isIsoExplicitDate(date) ? date.split("-")[0] : date.slice(0, 4);
};
const getMonth = (forDate) => {
  const date = stripAfter(forDate, "T");
  return isIsoExplicitDate(date) ? date.split("-")[1] : date.slice(4, 6);
};
const getDate = (forDate) => {
  const date = stripAfter(forDate, "T");
  return isIsoExplicitDate(date) ? date.split("-")[2] : date.slice(6, 8);
};
const isToday = (test) => {
  if (isString$1(test)) {
    const justDate = stripAfter(test, "T");
    return isIsoExplicitDate(justDate) && justDate === getToday();
  } else if (isMoment(test)) {
    return asExplicitIso8601Date(test.toISOString()) === getToday();
  }
  return false;
};
const isYesterday = (test) => {
  if (isString$1(test)) {
    const justDate = stripAfter(test, "T");
    return isIsoExplicitDate(justDate) && justDate === getYesterday();
  } else if (isMoment(test)) {
    return asExplicitIso8601Date(test.toISOString()) === getYesterday();
  }
  return false;
};
const isTomorrow = (test) => {
  if (isString$1(test)) {
    const justDate = stripAfter(test, "T");
    return isIsoExplicitDate(justDate) && justDate === getTomorrow();
  } else if (isMoment(test)) {
    return asExplicitIso8601Date(test.toISOString()) === getTomorrow();
  }
  return false;
};
const priorDay = (date) => {
  const prior = stripAfter(
    moment(date).subtract("1", "day").toISOString(true),
    "T"
  );
  return prior;
};
const nextDay = (date) => {
  const next = stripAfter(
    moment(date).add("1", "day").toISOString(true),
    "T"
  );
  return next;
};
const journalFile = (format2, dayOf = void 0) => {
  const [year, month, day] = dayOf ? [getYear(dayOf), getMonth(dayOf), getDate(dayOf)] : [todaysYear(), todaysMonth(), todaysDate()];
  if (!format2.includes("YYYY") && !format2.includes("MM") && !format2.includes("DD")) {
    throw new Error(
      `a journal file was passed in with a static format string: ${format2}; must have at least one dynamic segment!`
    );
  }
  const filepath = format2.replaceAll("YYYY", year).replaceAll("MM", month).replaceAll("DD", day);
  return filepath;
};
const asExplicitIso8601Date = (date) => {
  const d = stripAfter(date, "T");
  return isIsoExplicitDate(d) ? d : `${d.slice(0, 4)}-${d.slice(4, 6)}-${d.slice(6, 8)}`;
};
const describeDate = (date, offset2 = 0, sameYear = "MMM Do", diffYear = "MMM Do, YYYY") => {
  const d = moment(asExplicitIso8601Date(date)).add(offset2, "days");
  console.log("describe", {
    d,
    offset: offset2,
    isToday: isToday(d),
    isYesterday: isYesterday(d)
  });
  return isToday(d) ? "today" : isYesterday(d) ? "yesterday" : isTomorrow(d) ? "tomorrow" : isThisYear(d) ? d.format(sameYear) : d.format(diffYear);
};
const DEFAULT_LINK = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 256 256"><path fill="#a3a3a3" d="M134.71 189.19a4 4 0 0 1 0 5.66l-9.94 9.94a52 52 0 0 1-73.56-73.56l24.12-24.12a52 52 0 0 1 71.32-2.1a4 4 0 1 1-5.32 6A44 44 0 0 0 81 112.77l-24.13 24.12a44 44 0 0 0 62.24 62.24l9.94-9.94a4 4 0 0 1 5.66 0Zm70.08-138a52.07 52.07 0 0 0-73.56 0l-9.94 9.94a4 4 0 1 0 5.71 5.68l9.94-9.94a44 44 0 0 1 62.24 62.24L175 143.23a44 44 0 0 1-60.33 1.77a4 4 0 1 0-5.32 6a52 52 0 0 0 71.32-2.1l24.12-24.12a52.07 52.07 0 0 0 0-73.57Z"/></svg>`;
const showCreatedDate = (p2) => (pg, format2) => {
  const page = getPage(p2)(pg);
  if (page) {
    return format2 ? page.file.cday.toFormat(format2) : page.file.cday;
  }
  return "";
};
const showModifiedDate = (p2) => (pg, format2) => {
  const page = getPage(p2)(pg);
  if (page) {
    return format2 ? page.file.mday.toFormat(format2) : page.file.mday;
  }
  return "";
};
const showDueDate = (p2) => (page, prop = "due", format2) => {
  const pg = getPage(p2)(page);
  if (pg && pg[prop] !== void 0) {
    return typeof pg[prop] === "number" ? format2 ? DateTime$1.fromMillis(pg[prop]).toFormat(format2) : DateTime$1.fromMillis(pg[prop]) : typeof pg[prop] === "object" && pg[prop] instanceof DateTime$1 ? format2 ? pg[prop].toFormat(format2) : pg[prop] : typeof pg[prop] === "string" && DateTime$1.fromISO(pg[prop]) ? format2 ? DateTime$1.fromISO(pg[prop]).toFormat(format2) : DateTime$1.fromISO(pg[prop]) : "";
  } else {
    return "";
  }
};
const showDesc = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  if (page) {
    const desc = showProp(p2)(page, "about", "desc", "description");
    if (typeof desc == "string") {
      return `<span style="font-weight:200; font-size: 14px">${desc}</span>`;
    } else {
      return "";
    }
  }
  return "";
};
const showWhen = (p2) => (pg, format2 = "LLL yyyy") => {
  const page = getPage(p2)(pg);
  if (page) {
    const created = page.file.cday;
    const modified = page.file.mday;
    const deltaCreated = Math.abs(created.diffNow("days").days);
    const deltaModified = Math.abs(modified.diffNow("days").days);
    if (deltaCreated < 14) {
      const desc = created.toRelative();
      return `<span style="cursor: default"><i style="font-weight: 150">created</i> ${desc}</span>`;
    } else if (deltaModified < 14) {
      const desc = modified.toRelative();
      return `<span style="cursor: default"><i style="font-weight: 150">modified</i> ${desc}</span>`;
    } else {
      return `<span style="cursor: default">${modified.toFormat(format2)}</span>`;
    }
  } else {
    return "";
  }
};
const showTags = (p2) => (pg, ...exclude) => {
  return pg.file.etags.filter((t2) => !exclude.some((i) => t2.startsWith(i) ? true : false)).map((t2) => `\`${t2}\``).join(", ") || "";
};
const showLinks = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  if (page) {
    const [_, pageIcon] = getProp(p2)(pg, "icon", "svg_icon", "_icon", "_svg_icon");
    const link_props = {
      website: "website",
      wikipedia: "wikipedia",
      company: "company",
      retailer: "company",
      docs: "documentation",
      retail_urls: "retail",
      retail: "retail",
      url: "link",
      repo: "repo",
      review: "review",
      reviews: "review",
      blog: "blog",
      api: "api",
      map: "map",
      place: "pin",
      home: "home",
      office: "office",
      offices: "office",
      work: "office",
      employer: "office",
      playground: "playground",
      demo: "playground",
      support: "support",
      help: "support"
    };
    const create_lnk = (icon, url, prop) => {
      icon = prop === "website" && isString$1(pageIcon) ? pageIcon : /youtube.com/.test(url) ? "you_tube" : icon;
      p2.debug(prop, pageIcon);
      return `<a href="${url}" data-href="${url}" alt="${prop}" style="display: flex; align-items: baseline; padding-right: 2px" data-tooltip-position="top"><span class="link-icon" style="display: flex;width: auto; max-width: 24px; max-height: 24px; height: 24px">${icon}</span></a>`;
    };
    const links = [];
    for (const prop of keysOf(pg)) {
      if (prop in page && isString$1(page[prop])) {
        if (Array.isArray(page[prop])) {
          page[prop].forEach((p22) => {
            if (isString$1(p22) && /^http/.test(p22)) {
              links.push([prop, p22]);
            }
          });
        } else if (isString$1(page[prop]) && !prop.startsWith("_") && /^http/.test(page[prop])) {
          links.push([prop, page[prop]]);
        }
      }
    }
    const icons = p2.api.linkIcons;
    const prettify = (tuple) => {
      const [prop, url] = tuple;
      if (prop in link_props) {
        if (link_props[prop] in icons) {
          return create_lnk(icons[link_props[prop]], url, prop);
        } else {
          return create_lnk(DEFAULT_LINK, url, prop);
        }
      } else {
        return create_lnk(DEFAULT_LINK, url, prop);
      }
    };
    return `<span style='display: flex; flex-direction: row;'>${links.map(prettify).join(" ")}</span>`;
  }
  return "";
};
const showProp = (p2) => (pg, ...props) => {
  var _a2;
  const page = getPage(p2)(pg);
  if (page) {
    if (!((_a2 = page == null ? void 0 : page.file) == null ? void 0 : _a2.name)) {
      throw new Error(`Attempt to call showProp(page, ${props.join(", ")}) with an invalid page passed in!`);
    }
    const found = props.find((prop) => isKeyOf(page, prop) && page[prop] !== void 0);
    if (!found) {
      return "";
    }
    if (isKeyOf(page, found)) {
      const value2 = page[found];
      try {
        return isString$1(value2) ? value2 : isLink(value2) ? value2 : isDvPage(value2) ? value2 == null ? void 0 : value2.file.link : isArray(value2) ? value2.map((v2) => isLink(v2) ? v2 : isDvPage(v2) ? v2.file.link : "").filter((i) => i).join(", ") : "";
      } catch (e2) {
        p2.error(`Ran into problem displaying the "${found}" property on the page "${page.file.path}" passed in while calling show_prop().`, e2);
        return "";
      }
    }
  }
  return "";
};
const getProp = (p2) => (pg, ...props) => {
  const page = getPage(p2)(pg);
  if (page) {
    const found = props.find((prop) => isKeyOf(page, prop) && page[prop] !== void 0);
    if (!found) {
      return [void 0, void 0];
    } else {
      const value2 = page[found];
      return [
        found,
        isLink(value2) ? p2.api.getPage(value2) : Array.isArray(value2) ? value2.map((i) => isLink(i) ? p2.dv.page(i) : i) : value2
      ];
    }
  }
  p2.error(`Call to getProp(pg) passed in an invalid DvPage`, { pg, props });
  return [void 0, void 0];
};
const showAbout = (p2) => (pg) => {
  return [];
};
const showPeers = (p2) => (pg) => {
  return "";
};
const showKind = (p2) => (pg, withTag) => {
  const page = p2.api.getPage(pg);
  let links = [];
  withTag = isUndefined(withTag) ? true : withTag;
  if (page) {
    const classy = getClassification(p2)(page);
    for (const k of classy) {
      const fmt = p2.api.format;
      links.push(
        withTag ? `${links}${createMarkdownLink(p2)(k.kind, { post: fmt.as_tag(k.kindTag) })}` : `${links}${createMarkdownLink(p2)(k.kind)}`
      );
    }
  }
  return links.join(", ");
};
const link = (name2, path, display) => {
  return [
    `<a data-href="${name2}" href="${path}" `,
    `class="internal-link data-link-icon data-link-icon-after data-link-text" `,
    `target="_blank" rel="noopener">`,
    display,
    `</a>`
  ].join("");
};
const htmlLink = (p2) => (ref, opt) => {
  const page = getPage(p2)(ref);
  if (page) {
    const name2 = page.file.name;
    const path = stripTrailing(page.file.path, ".md");
    const display = (opt == null ? void 0 : opt.display) || page.file.name || page.file.path;
    return link(name2, path, display);
  } else {
    console.log(`invalid: ${ref}`);
  }
  if ((opt == null ? void 0 : opt.createPageWhereMissing) && isValidPath(ref)) {
    const parts = ref.split("/");
    const display = opt.display || parts.pop() || "";
    return link(
      stripTrailing(ref, ".md"),
      ref,
      isToday(display) ? "today" : isYesterday(display) ? "yesterday" : isTomorrow(display) ? "tomorrow" : display
    );
  }
  return isValidPath(ref) ? `<!-- no link [${String(ref)}] -->` : `<!-- no link [invalid path: ${String(ref)}] -->`;
};
const showCategories = (p2) => (pg, opt) => {
  const page = p2.api.getPage(pg);
  let links = [];
  isUndefined(opt == null ? void 0 : opt.withTag) ? true : opt.withTag;
  const currentPage = (opt == null ? void 0 : opt.currentPage) ? getPage(p2)(opt.currentPage) : {};
  if (page) {
    const cats = getCategories(p2)(page);
    const isMultiKind = new Set(cats.map((i) => i.kind)).size > 1;
    for (const cat of cats) {
      p2.api.format;
      ({
        pre: isMultiKind ? p2.api.format.light(cat.kind + "/") : ""
      });
      links.push(
        getPath(page) === getPath(currentPage) ? "(this)" : htmlLink(p2)(page, { display: cat.category })
      );
    }
  }
  return links.join(", ");
};
const showSubcategories = (p2) => (pg, opt) => {
  const page = p2.api.getPage(pg);
  let links = [];
  isUndefined(opt == null ? void 0 : opt.withTag) ? true : opt.withTag;
  if (page) {
    const cats = getSubcategories(p2)(page);
    const isMultiKind = new Set(cats.map((i) => i.kind)).size > 1;
    for (const cat of cats) {
      p2.api.format;
      ({
        pre: isMultiKind ? p2.api.format.light(cat.kind + "/") : ""
      });
      links.push(
        htmlLink(p2)(page, { display: cat.subcategory })
      );
    }
  }
  return links.join(", ");
};
const showMetrics = (p2) => (pg) => {
  return "";
};
const showSlider = (p2) => (pg) => {
  return "";
};
const showClassifications = (p2) => (pg) => {
  const classy = getClassification(p2)(pg);
  const opt = (pg2) => {
    const page = p2.api.getPage(pg2);
    if (page) {
      return {
        display: page.name
      };
    }
    return {};
  };
  const classification2 = classy.map(
    (i) => {
      var _a2;
      return [
        // KIND
        htmlLink(p2)(i.kind),
        // CATEGORY
        i.categories.length === 0 ? "" : i.categories && i.categories.length === 1 ? htmlLink(p2)(
          i.categories[0].category,
          opt(p2.api.format.as_tag(i.categories[0].category))
        ) : `<span style="opacity: 0.8">[ </span>` + i.categories.map(
          (ii) => htmlLink(p2)(
            ii.category,
            opt(p2.api.format.as_tag(ii.category))
          )
        ).join(",&nbsp;") + `<span style="opacity: 0.8"> ]</span>`,
        // SUBCATEGORY
        i.subcategory ? htmlLink(p2)((_a2 = i == null ? void 0 : i.subcategory) == null ? void 0 : _a2.subcategory) : ""
      ].filter((i2) => i2 && i2 !== "").join(`<span style="opacity: 0.8"> &gt; </span>`);
    }
  );
  return classification2.join("<br>");
};
function extractTitle(s2) {
  return s2 && typeof s2 === "string" ? s2.replace(/\d{0,4}-\d{2}-\d{2}\s*/, "") : s2;
}
const createFileLink = (p2) => (pathLike, embed, display) => {
  const page = p2.api.getPage(pathLike);
  if (page) {
    return p2.dv.fileLink(
      page.file.name,
      isUndefined(embed) ? false : embed,
      extractTitle(page.file.name)
    );
  }
  return "";
};
const createMarkdownLink = (p2) => (pathLike, opt) => {
  const page = p2.api.getPage(pathLike);
  if (page) {
    return (opt == null ? void 0 : opt.display) ? `${(opt == null ? void 0 : opt.pre) || ""}[[${page.file.path}|${opt.display}]]${(opt == null ? void 0 : opt.post) || ""}` : `${(opt == null ? void 0 : opt.pre) || ""}[[${page.file.path}|${page.file.name}]]${(opt == null ? void 0 : opt.post) || ""}`;
  }
  return "";
};
const showApi = (p2) => ({
  /** show the creation date */
  showCreatedDate,
  /** show last modified date */
  showModifiedDate,
  /** show _due_ date */
  showDueDate: showDueDate(p2),
  showWhen: showWhen(p2),
  showDesc: showDesc(p2),
  showTags: showTags(),
  showLinks: showLinks(p2),
  // showAbout: showAbout(p),
  showProp: showProp(p2),
  getProp: getProp(p2),
  showAbout: showAbout(),
  showPeers: showPeers(),
  showKind: showKind(p2),
  showCategories: showCategories(p2),
  showSubcategories: showSubcategories(p2),
  showClassifications: showClassifications(p2),
  showMetrics: showMetrics(),
  showSlider: showSlider(),
  createFileLink: createFileLink(p2),
  createMarkdownLink: createMarkdownLink(p2)
});
const createVaultLink = (p2) => (ref) => {
  const page = getPage(p2)(ref);
  if (page) {
    const alias = page.file.name;
    const path = page.file.path;
    const link2 = `[[${path}|${alias}]]`;
    return link2;
  }
  return void 0;
};
const getPageInfo = (p2) => (pg) => {
  if (isPageInfo(pg)) {
    return pg;
  }
  const path = getPath(pg);
  const page = getPage(p2)(pg);
  if (path && page) {
    const meta = {
      categories: getCategories(p2)(page),
      subcategories: getSubcategories(p2)(page),
      hasCategoryProp: hasCategoryProp(p2)(page),
      hasCategoriesProp: hasCategoriesProp(p2)(page),
      hasAnyCategoryProp: hasAnyCategoryProp(p2)(page),
      hasSubcategoryProp: hasSubcategoryProp(p2)(page),
      hasSubcategoriesProp: hasSubcategoriesProp(p2)(page),
      hasAnySubcategoryProp: hasAnySubcategoryProp(p2)(page),
      hasCategoryTag: hasCategoryTag(p2)(page),
      hasSubcategoryTag: hasSubcategoryTag(p2)(page),
      hasSubcategoryDefnTag: hasSubcategoryTagDefn(p2)(page),
      hasKindProp: hasKindProp(p2)(page),
      hasKindsProp: hasKindsProp(p2)(page),
      hasAnyKindProp: hasAnyKindProp(p2)(page),
      hasKindTag: hasKindTag(p2)(page),
      hasKindDefinitionTag: hasKindDefinitionTag(p2)(page),
      hasTypeDefinitionTag: hasTypeDefinitionTag(p2)(page),
      isCategoryPage: isCategoryPage(p2)(page),
      isSubcategoryPage: isSubcategoryPage(p2)(page),
      isKindDefnPage: isKindDefnPage(p2)(page),
      isTypeDefnPage: isTypeDefnPage(p2)(page),
      isKindedPage: isKindedPage(p2)(page),
      kindTags: getKindTagsOfPage(p2)(page),
      typeTags: []
    };
    const info2 = {
      current: page,
      path,
      name: page.file.name,
      ext: page.file.ext,
      classifications: getClassification(p2)(
        page,
        meta.categories,
        meta.subcategories
      ),
      hasMultipleKinds: meta.kindTags.length > 1,
      type: meta.isKindDefnPage ? "kind-defn" : meta.isTypeDefnPage ? "type-defn" : meta.isKindedPage && meta.isCategoryPage ? "kinded > category" : meta.isKindedPage && meta.isSubcategoryPage ? "kinded > subcategory" : meta.isKindedPage ? "kinded" : "none",
      fm: page.file.frontmatter,
      ...fmApi(p2, path),
      metadata: getMetadata(p2)(page),
      ...meta
    };
    return info2;
  }
};
const getPageInfoBlock = (p2) => (evt) => {
  const { source, el, ctx } = evt;
  const filePath = ctx.sourcePath;
  const page = getPageInfo(p2)(filePath);
  if (page) {
    const sectionInfo = ctx.getSectionInfo(el);
    return {
      ...page,
      content: source,
      container: el,
      component: ctx,
      sectionInfo,
      ...renderApi(p2)(el, filePath)
    };
  }
};
const getPropertyType = (p2) => (value2) => {
  if (isYouTubeUrl(value2)) {
    if (isYouTubeCreatorUrl(value2)) {
      return `youtube_creator_featured`;
    }
    if (isYouTubeFeedUrl(value2, "history")) {
      return `youtube_feed_history`;
    }
  }
  if (isString$1(value2)) {
    if (value2.startsWith("[[") && value2.endsWith("]]")) {
      const content2 = stripTrailing(stripLeading(value2, "[["), "]]");
      const page = getPage(p2)(content2);
      if (page) {
        if (page.file.ext === "png" || page.file.ext === "jpg" || page.file.ext === "jpeg" || page.file.ext === "gif" || page.file.ext === "avif" || page.file.ext === "wep") {
          return "image_vault";
        } else if (page.file.ext === "excalidraw") {
          return "link_drawing";
        } else if (page.file.ext === "md" || content2.includes(".md|")) {
          return "link_md";
        }
      }
      p2.info("undefined link", content2, value2);
      return "link_undefined";
    }
    if (isPhoneNumber(value2)) {
      return "phoneNumber";
    }
    if (isEmail(value2)) {
      return "email";
    }
    if (isInlineSvg(value2)) {
      return "svg_inline";
    }
    if (isMetric(value2)) {
      return "metric";
    }
    if (isDateTime(value2)) {
      return "datetime";
    }
    if (isIsoDate(value2)) {
      return "date";
    }
    if (isIsoTime(value2)) {
      return "time";
    }
    if (isZipCode(value2)) {
      return "geo_zip";
    }
    if (isIso3166CountryCode(value2) || isIso3166CountryName(value2)) {
      return "geo_country";
    }
    if (isUrl(value2)) {
      if (isSocialMediaUrl(value2)) {
        return "url_social";
      }
      if (isRepoUrl(value2)) {
        return "url_repo";
      }
      if (isRetailUrl(value2)) {
        return "url_retail";
      }
      if (isNewsUrl(value2)) {
        return "url_news";
      }
      if (isYouTubeUrl(value2)) {
        return "url_youtube";
      }
      if (isSocialMediaUrl(value2)) {
        return "url_social";
      }
      return "url";
    }
    return "string";
  }
  if (isNumber$1(value2)) {
    return "number";
  }
  if (isBoolean(value2)) {
    return "boolean";
  }
  if (isUndefined(value2)) {
    return "empty";
  } else if (isArray(value2) && value2.length > 0) {
    const variants = new Set(
      value2.map(getPropertyType(p2))
    );
    if (variants.size === 1) {
      return `list_${Array.from(variants)[0]}`;
    } else {
      return `list_mixed_${Array.from(variants).join(",")}`;
    }
  }
  return `other_${toPascalCase(String(typeof value2))}`;
};
const getKnownKindTags = (p2) => (tag) => {
  var _a2, _b2, _c2, _d2;
  return tag ? Array.from(((_b2 = (_a2 = p2.cache) == null ? void 0 : _a2.kindDefinitionsByTag) == null ? void 0 : _b2.keys()) || []).filter(
    (i) => i.includes(tag)
  ) : Array.from(((_d2 = (_c2 = p2.cache) == null ? void 0 : _c2.kindDefinitionsByTag) == null ? void 0 : _d2.keys()) || []);
};
const isKeyOf = (container, key) => {
  return isContainer$1(container) && (isString$1(key) || isNumber$1(key)) && key in container ? true : false;
};
const isKindTag = (p2) => (tag) => {
  const safeTag = stripLeading(stripLeading(tag, "#"), "kind/");
  const valid = getKnownKindTags(p2)();
  return valid.includes(safeTag);
};
const hasCategoryTagDefn = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  if (page) {
    const hasBareCategory = page.file.etags.find(
      (t2) => t2.startsWith(`#category/`)
    ) ? true : false;
    const hasKindCategory = page.file.etags.find(
      (t2) => t2.split("/")[1] === "category" && t2.split("/").length === 3
    );
    return hasBareCategory || hasKindCategory ? true : false;
  }
  return false;
};
const hasSubcategoryTagDefn = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  if (page) {
    const hasBareSubcategory = page.file.etags.find(
      (t2) => t2.startsWith(`#subcategory/`)
    ) ? true : false;
    const hasKindSubcategory = page.file.etags.find(
      (t2) => t2.split("/")[1] === "subcategory" && t2.split("/").length === 4
    );
    return hasBareSubcategory || hasKindSubcategory ? true : false;
  }
  return false;
};
const hasSubcategoryTag = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  const kinds = lookupKnownKindTags(p2);
  return page && page.file.etags.some(
    (i) => i.split("/").length === 3 && kinds.includes(stripLeading(i.split("/")[0], "#"))
  ) ? true : false;
};
const hasCategoryTag = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  if (page) {
    const kindTags = Array.from(page.file.tags).filter(
      (t2) => isKindTag(p2)(stripLeading(t2.split("/")[0], "#"))
    );
    const withCategory = kindTags.filter((t2) => t2.split("/").length > 1).map((t2) => t2.split("/")[1]);
    return withCategory.length > 0;
  }
  return false;
};
const hasCategoryProp = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  if (page) {
    const catType = getPropertyType(p2)(
      page.file.frontmatter["category"]
    );
    return page.category && catType.startsWith("link") ? true : false;
  }
  return false;
};
const hasSubcategoryProp = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  if (page) {
    const catType = getPropertyType(p2)(
      page.file.frontmatter["subcategory"]
    );
    return page.category && catType.startsWith("link") ? true : false;
  }
  return false;
};
const hasSubcategoriesProp = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  if (page) {
    const catType = getPropertyType(p2)(
      page.file.frontmatter["subcategory"]
    );
    return page.category && catType.startsWith("link") ? true : false;
  }
  return false;
};
const hasAnySubcategoryProp = (p2) => (pg) => hasSubcategoriesProp(p2)(pg) || hasSubcategoryProp(p2)(pg);
const hasCategoriesProp = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  if (page) {
    return page.categories && Array.isArray(page.categories) && page.categories.filter(isFileLink).length > 0 ? true : false;
  }
  return false;
};
const hasAnyCategoryProp = (p2) => (pg) => hasCategoriesProp(p2)(pg) || hasCategoryProp(p2)(pg);
const isCategoryPage = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  return page && page.file.etags.some(
    (i) => i.split("/").length === 3 && i.split("/")[1] === "category"
  ) ? true : false;
};
const isSubcategoryPage = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  if (page) {
    return page.file.etags.some(
      (i) => i.split("/").length === 4 && i.split("/")[1] === "subcategory"
    ) ? true : false;
  }
  return false;
};
const hasMultipleKinds = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  if (page) {
    const tags = page.file.tags;
    const kindTags = tags.filter(
      (t2) => isKindTag(p2)(stripLeading(t2.split("/")[0], "#"))
    );
    return kindTags.length > 1 ? true : false;
  }
  return false;
};
const hasKindTag = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  if (page) {
    const tags = page.file.etags;
    const kindTags = tags.filter(
      (t2) => isKindTag(p2)(stripLeading(t2.split("/")[0], "#")) || t2.split("/").length === 3 && t2.split("/")[1] === "category" || t2.split("/").length === 4 && t2.split("/")[1] === "subcategory"
    );
    return kindTags.length > 0 ? true : false;
  }
  return false;
};
const hasKindDefinitionTag = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  if (page) {
    const tags = page.file.tags.filter((t2) => t2.startsWith(`#kind/`));
    return tags.length > 0 ? true : false;
  }
  return false;
};
const hasTypeDefinitionTag = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  if (page) {
    const tags = page.file.tags.filter((t2) => t2.startsWith(`#type/`));
    return tags.length > 0 ? true : false;
  }
  return false;
};
const hasKindProp = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  return page && isDefined(page.kind) && isFileLink(page.kind) ? true : false;
};
const hasKindsProp = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  if (page) {
    return isDefined(page.kinds) && isArray(page.kinds) && page.kinds.some((p22) => isFileLink(p22));
  }
  return false;
};
const hasAnyKindProp = (p2) => (pg) => hasKindProp(p2)(pg) || hasKindsProp(p2)(pg);
const hasTypeProp = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  if (page) {
    return isDefined(page.type) && isFileLink(page.type);
  }
  return false;
};
const getFrontmatter = (p2) => (from) => {
  if (isDvPage(from)) {
    return from.file.frontmatter;
  }
  if (isPageInfo(from)) {
    return from.fm;
  }
  if (isFrontmatter(from)) {
    return from;
  }
  const page = getPage(p2)(from);
  if (page) {
    return page.file.frontmatter;
  } else {
    p2.debug(
      `call to getFrontmatter() was unable to load a valid page so returned an empty object.`,
      { from }
    );
    return {};
  }
};
const catTag = (kind, cat) => {
  return `${ensureLeading(kind, "#")}/${cat}`;
};
const getCategories = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  const categories = [];
  if (page) {
    const kindedCat = page.file.etags.filter(
      (t2) => t2.split("/").length === 3 && t2.split("/")[1] === "category"
    ).map((i) => catTag(i.split("/")[0], i.split("/")[2]));
    const kindedSubcat = page.file.etags.filter(
      (t2) => t2.split("/").length === 4 && t2.split("/")[1] === "subcategory"
    ).map((i) => catTag(i.split("/")[0], i.split("/")[2]));
    const kinded = page.file.etags.filter(
      (t2) => t2.split("/").length > 1 && !["category", "subcategory"].includes(
        t2.split("/")[1]
      ) && isKindTag(p2)(t2.split("/")[0])
    ).map((i) => catTag(i.split("/")[0], i.split("/")[1]));
    const tags = /* @__PURE__ */ new Set([
      ...kinded,
      ...kindedCat,
      ...kindedSubcat
    ]);
    const missing = [];
    const pages = Array.from(tags).map((t2) => {
      const [kind, cat] = t2.split("/");
      const pgs = p2.dv.pages(`${kind}/category/${cat}`);
      if (pgs.length > 0) {
        return [t2, pgs[0]];
      } else {
        missing.push(`${t2} on page "${page.file.path}"`);
        return void 0;
      }
    }).filter((i) => i);
    if (missing.length > 0) {
      p2.warn("Some category tags didn't not map to a page", missing);
    }
    return pages.map(([t2, pg2]) => {
      return {
        kind: stripLeading(t2.split("/")[0], "#"),
        page: pg2,
        category: t2.split("/")[1],
        kindedTag: ensureLeading(t2, "#"),
        defnTag: `${ensureLeading(t2.split("/")[0], "#")}/category/${t2.split("/")[1]}`
      };
    });
  }
  return categories;
};
const subCatTag = (kind, cat, sub) => {
  return `${ensureLeading(kind, "#")}/${cat}/${sub}`;
};
const getSubcategories = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  if (page) {
    const kindedSubcat = page.file.etags.filter(
      (t2) => t2.split("/").length === 4 && t2.split("/")[1] === "subcategory"
    ).map(
      (i) => subCatTag(
        i.split("/")[0],
        i.split("/")[2],
        i.split("/")[3]
      )
    );
    const kinded = page.file.etags.filter(
      (t2) => t2.split("/").length === 3 && !["category", "subcategory"].includes(
        t2.split("/")[1]
      ) && isKindTag(p2)(t2.split("/")[0])
    ).map(
      (i) => subCatTag(
        i.split("/")[0],
        i.split("/")[1],
        i.split("/")[2]
      )
    );
    const tags = /* @__PURE__ */ new Set([...kinded, ...kindedSubcat]);
    const missing = [];
    const pages = Array.from(tags).map((t2) => {
      const [kind, cat, subcat] = t2.split("/");
      const pgs = p2.dv.pages(
        `${kind}/subcategory/${cat}/${subcat}`
      );
      if (pgs.length > 0) {
        return [t2, pgs[0]];
      } else {
        missing.push(`${t2} on page "${page.file.path}"`);
        return void 0;
      }
    }).filter((i) => i);
    if (missing.length > 0) {
      p2.warn(
        "Some subcategory tags didn't not map to a page",
        missing
      );
    }
    return pages.map(([t2, pg2]) => {
      const parts = t2.split("/");
      return {
        kind: stripLeading(parts[0], "#"),
        page: pg2,
        category: parts[1],
        subcategory: parts[2],
        kindedTag: ensureLeading(t2, "#"),
        defnTag: `${ensureLeading(parts[0], "#")}/subcategories/${parts[1]}/${parts[2]}`
      };
    });
  }
  return [];
};
const isKindedPage = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  if (page) {
    return hasKindProp(p2)(page) && !hasKindDefinitionTag(p2)(page) ? true : hasKindTag(p2)(page) ? true : false;
  }
  return false;
};
const isKindDefnPage = (p2) => (ref) => {
  const page = getPage(p2)(ref);
  return page && page.file.etags.some((i) => i.startsWith("#kind/")) ? true : false;
};
const isTypeDefnPage = (p2) => (ref) => {
  const page = getPage(p2)(ref);
  return page && page.file.etags.some((i) => i.startsWith("#type/")) ? true : false;
};
const getKindTagsOfPage = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  if (page) {
    const kindedCat = page.file.etags.filter(
      (t2) => t2.split("/").length === 3 && t2.split("/")[1] === "category"
    ).map((i) => i.split("/")[0]);
    const kindedSubcat = page.file.etags.filter(
      (t2) => t2.split("/").length === 4 && t2.split("/")[1] === "subcategory"
    ).map((i) => i.split("/")[0]);
    const kinded = page.file.etags.filter(
      (t2) => isKindTag(p2)(t2.split("/")[0]) && !["category", "subcategory"].includes(t2.split("/")[1])
    ).map((i) => i.split("/")[0]);
    const kindDefn = page.file.etags.filter((t2) => t2.startsWith("#kind/")).map((i) => i.split("/")[1]);
    const tags = /* @__PURE__ */ new Set([
      ...kinded,
      ...kindedCat,
      ...kindedSubcat,
      ...kindDefn
    ]);
    return Array.from(tags).map((i) => stripLeading(i, "#"));
  }
  return [];
};
const getKindPages = (p2) => (pg) => {
  const page = getPage(p2)(pg);
  if (page) {
    const pages = getKindTagsOfPage(p2)(page).map((i) => lookupKindByTag(p2)(i)).map((i) => i ? getPage(p2)(i.path) : void 0).filter((i) => i);
    return pages;
  }
  return [];
};
const getMetadata = (p2) => (pg) => {
  const fm = pg ? getFrontmatter(p2)(pg) : void 0;
  if (fm) {
    let meta = {};
    for (const key of Object.keys(fm)) {
      const type = getPropertyType(p2)(fm[key]);
      if (type && !type.startsWith("other")) {
        meta[type] = meta[type] ? [...meta[type], key] : [key];
        [fm[key], type];
      } else {
        meta["other"] = meta.other ? [...meta.other, key] : [key];
        [fm[key], type];
      }
    }
    meta.hasLinks = () => {
      return Object.keys(meta).includes("link") || Object.keys(meta).includes("link_image") || Object.keys(meta).includes("link_md") || Object.keys(meta).includes("link_drawing") || Object.keys(meta).includes("link_vector") || Object.keys(meta).includes("link_unknown");
    };
    meta.hasUrls = () => {
      return Object.keys(meta).includes("url") || Object.keys(meta).includes("url_social") || Object.keys(meta).includes("url_book") || Object.keys(meta).includes("url_retail") || Object.keys(meta).includes("url_profile") || Object.keys(meta).includes("url_repo") || Object.keys(meta).includes("url_news") || Object.keys(meta).includes("url_youtube");
    };
    meta.getFirstDateFrom = (...props) => {
      const sources = [
        ...meta["date"] || [],
        ...meta["list_date"] || [],
        ...meta["datetime"] || [],
        ...meta["list_datetime"] || []
      ];
      const targets = props.filter((i) => sources.includes(i));
      let found = void 0;
      let idx = 0;
      while (idx <= targets.length || isIsoExplicitDate(found)) {
        const prop = targets[idx];
        if (isStringArray(prop)) {
          const candidate = prop.find(
            (i) => isIsoDate(i) || isIsoDateTime(i)
          );
          if (candidate) {
            found = asExplicitIso8601Date(candidate);
          }
        }
        idx++;
      }
      return found;
    };
    meta.hasGeoInfo = () => {
      return Object.keys(meta).includes("geo") || Object.keys(meta).includes("geo_country") || Object.keys(meta).includes("geo_zip") || Object.keys(meta).includes("geo_state") || Object.keys(meta).includes("geo_city");
    };
    meta.getYouTubeVideoLinks = () => {
      if (!(Object.keys(meta).includes("url_youtube") || Object.keys(meta).includes("list_url_youtube"))) {
        return [];
      }
      const unitLinks = (meta["url_youtube"] || []).map(
        (i) => meta[i]
      );
      const listLinks = (meta["list_url_youtube"] || []).flatMap(
        (i) => meta[i]
      );
      const links = [...unitLinks, ...listLinks].filter(
        (i) => isYouTubeVideoUrl(i)
      );
      return links;
    };
    return meta;
  } else {
    p2.debug(`no metadata found on page ${pg ? pg : "unknown"}`);
  }
  return {};
};
const getClassification = (p2) => (pg, cats, subCats) => {
  const page = pg ? getPage(p2)(pg) : void 0;
  const classification2 = [];
  if (page) {
    const pgCats = cats ? cats : getCategories(p2)(page);
    const pgSubCats = subCats ? subCats : getSubcategories(p2)(page);
    const kindTags = getKindTagsOfPage(p2)(page);
    for (let tag of kindTags) {
      tag = stripLeading(tag, "#");
      p2.debug(`tag ${tag}`);
      const kd = lookupKindByTag(p2)(tag);
      const kp = kd ? getPage(p2)(kd.path) : void 0;
      if (kd && kp) {
        classification2.push({
          kind: kp,
          kindTag: tag,
          categories: pgCats.filter(
            (c) => c.kind === stripLeading(tag, "#")
          ),
          subcategory: pgSubCats.find(
            (c) => c.kind === stripLeading(tag, "#")
          )
        });
      } else {
        const defn = p2.dv.pages(`#kind/${tag}`);
        if (defn.length > 0) {
          p2.debug(
            `tag lookup of ${tag} failed but found kind definition with dataview query`
          );
          const kindPage = Array.from(defn)[0];
          if (kindPage && kindPage.file.etags.some(
            (i) => i.startsWith("#kind/")
          )) {
            classification2.push({
              kind: kindPage,
              kindTag: tag,
              categories: pgCats.filter(
                (c) => c.kind === stripLeading(tag, "#")
              ),
              subcategory: pgSubCats.find(
                (c) => c.kind === stripLeading(tag, "#")
              )
            });
            return classification2;
          }
        }
        p2.warn(
          `no 'kind' could be identified for the page ${page.file.path}`,
          {
            categories: pgCats,
            subcategories: pgSubCats,
            etags: Array.from(page.file.etags),
            kindTags,
            tag,
            kd,
            kp
          }
        );
      }
    }
  }
  p2.debug("classification", classification2);
  return classification2;
};
const buildingBlocks = (plugin4) => ({
  isKeyOf,
  hasCategoryProp: hasCategoryProp(plugin4),
  hasCategoriesProp: hasCategoriesProp(plugin4),
  hasTypeDefinitionTag: hasTypeDefinitionTag(plugin4),
  hasKindDefinitionTag: hasKindDefinitionTag(plugin4),
  hasKindProp: hasKindProp(plugin4),
  hasKindsProp: hasKindsProp(plugin4),
  hasTypeProp: hasTypeProp(plugin4),
  hasMultipleKinds: hasMultipleKinds(plugin4),
  hasCategoryTagDefn: hasCategoryTagDefn(plugin4),
  hasCategoryTag: hasCategoryTag(plugin4),
  hasAnyCategoryProp: hasAnyCategoryProp(plugin4),
  hasAnySubcategoryProp: hasAnySubcategoryProp(plugin4),
  getCategories: getCategories(plugin4),
  hasSubcategoryTagDefn: hasSubcategoryTagDefn(plugin4),
  isCategoryPage: isCategoryPage(plugin4),
  isSubcategoryPage: isSubcategoryPage(plugin4),
  isKindedPage: isKindedPage(plugin4),
  isKindDefnPage: isKindDefnPage(plugin4),
  getClassification: getClassification(plugin4),
  getKnownKindTags: getKnownKindTags(plugin4),
  getKindPages: getKindPages(plugin4),
  getMetadata: getMetadata(plugin4),
  getKindTagsOfPage: getKindTagsOfPage(plugin4),
  isKindTag: isKindTag(plugin4)
});
const obsidianApi = (p2) => {
  return {
    /**
     * the full Obsidian API surface exposed on global
     */
    app: p2.app,
    /**
     * A dictionary of commands configured for the active vault
     */
    commands: globalThis.app.commands.commands,
    /**
     * Atomically read, modify, and save the frontmatter of a note. The frontmatter is passed in as a JS object, and should be mutated directly to achieve the desired result.
     Remember to handle errors thrown by this method.
     * @param file  the file to be modified. Must be a Markdown file.
     * @param fn  a callback function which mutates the frontmatter object synchronously.
     * @param options  write options.
     * @throws  YAMLParseError if the YAML parsing fails
     * @throws  any errors that your callback function throws
     * 
     * ```ts
     * app.fileManager.processFrontMatter(file, (frontmatter) => {
     *     frontmatter['key1'] = value;
     *     delete frontmatter['key2'];
     * });
     * ```
     */
    processFrontmatter: p2.app.fileManager.processFrontMatter,
    /**
     * Resolves a unique path for the attachment file being saved.
     * Ensures that the parent directory exists and dedupes the
     * filename if the destination filename already exists.
     *
     * @param filename Name of the attachment being saved
     * @param sourcePath The path to the note associated with this attachment, defaults to the workspace's active file.
     * @returns Full path for where the attachment should be saved, according to the user's settings
     */
    getAvailablePathForAttachment: p2.app.fileManager.getAvailablePathForAttachment,
    /**
     * A dictionary of files:
     * 
     * - _keys_ are the full file path
     * - _values_ are 
     */
    fileCache: globalThis.app.metadataCache.fileCache,
    /**
     * A dictionary which can be used to lookup metadata using
     * the `fileCache`'s hash value.
     */
    metaData: globalThis.app.metadataCache.metadataCache
  };
};
const parseQueryParams = (p2) => (name2, raw, scalar, options2) => {
  const requiredScalar = scalar.filter((i) => !i.contains("opt(")).length;
  const invalid = kindError(`InvalidQuery<${name2}>`, {
    raw,
    scalar,
    options: options2,
    requiredScalar
  });
  const parsingErr = kindError(`ParsingError<${name2}>`, {
    raw,
    scalar,
    options: options2,
    requiredScalar
  });
  const scalarOrder = scalar.map((s2) => {
    return [retainUntil(s2, " "), retainAfter(s2, "AS ")];
  });
  if (!raw || raw.trim() === "") {
    if (requiredScalar > 0) {
      return invalid(`The ${name2} handler expects at least ${requiredScalar} scalar parameters and no parameters were passed into the handler and none were provided!`);
    }
    return [
      {},
      {}
    ];
  }
  try {
    const parsed = JSON.parse(`[ ${raw} ]`);
    const optionsPosition = parsed.findIndex((i) => isObject(i));
    const hasOptionsHash = optionsPosition !== -1;
    const optionsHash = hasOptionsHash ? parsed[optionsPosition] : {};
    const optionsInTerminalPosition = optionsPosition === -1 ? true : optionsPosition === length - 1;
    const scalarParams = optionsPosition === -1 ? parsed : parsed.slice(0, optionsPosition);
    const notEnoughScalarParams = requiredScalar > 0 && scalarParams.length < requiredScalar ? true : false;
    if (!optionsInTerminalPosition) {
      return invalid(`Kind Model query syntax requires that any options hash parameter provided be provided as the LAST parameter but the ${optionsPosition + 1} element was the options hash on a parameter array which had ${parsed.length} parameters.`);
    }
    if (notEnoughScalarParams) {
      return invalid(`the ${name2} query handler expects at least ${requiredScalar} scalar parameters to be passed in when using it!`);
    }
    if (optionsPosition !== -1) {
      const requiredOpts = Object.keys(options2).filter((i) => !i.includes("opt("));
      const opts = parsed[optionsPosition];
      for (const key of requiredOpts) {
        if (!(key in opts)) {
          return invalid(`The "${name2}" query parser received an options hash but did not provide all of the required properties!`);
        }
      }
    }
    const scalar2 = {};
    let idx = 0;
    for (const [key, typeOf] of scalarOrder) {
      if (typeOf.startsWith("string") && !isString$1(scalarParams[idx])) {
        return invalid(`the scalar property "${key}" is required and expected to be a string; type was ${typeof scalarParams[idx]}`);
      }
      scalar2[key] = scalarParams[idx];
      idx++;
    }
    return [
      scalar2,
      optionsHash
    ];
  } catch (e2) {
    return parsingErr(`Problem parsing query parameters passed in: ${raw}!`, { underlying: e2 });
  }
};
const clientHandler = (p2) => (handler, handlerFn, scalarParams, optionParams, evt) => createFnWithProps(
  async () => {
    const page = getPageInfoBlock(p2)(evt);
    const re = new RegExp(`${handler}((.*))`);
    const err = kindError(`InvalidQuery<${handler}>`, { evt, page });
    if (page) {
      if (re.test(evt.source)) {
        const raw = evt.source.match(re) ? stripParenthesis(Array.from(
          evt.source.match(re)
        )[1]) : "";
        const result = parseQueryParams()(
          handler,
          raw,
          scalarParams,
          optionParams
        );
        if (isError(result)) {
          return result;
        } else {
          const [scalar, options2] = result;
          const event2 = {
            plugin: p2,
            page,
            source: evt.source,
            ctx: evt.ctx,
            re,
            raw,
            scalar,
            options: options2
          };
          await handlerFn(event2);
          p2.debug(
            `Code Block event processed by ${handler}.`,
            { page, scalar, options: options2 }
          );
          return true;
        }
      } else {
        return false;
      }
    } else {
      return err(`Unable to create a PageInfoBlock from the page in which the code block being parsed was found!`, { sourcePath: evt.ctx.sourcePath });
    }
  },
  // properties
  {
    handlerName: handler
  }
);
const addParams = (handler) => ({
  /**
   * Define the _scalar_ parameters this handler expects.
   * 
   * ```ts
   * const Example = createHandler("Example")
   * 		.scalar({
   * 			"Foo as string",
   * 			"Bar as opt(number)"
   * 		});
   * ```
   */
  scalar: (...scalarParams) => ({
    /**
     * Define the _options_ hash this handler expects.
     */
    options: (optionParams = {}) => ({
      /**
       * Provide the actual handler function; remember that
       * the handler should be an async function.
       */
      handler: (handlerFn) => (p2) => {
        return (evt) => clientHandler(p2)(
          handler,
          handlerFn,
          scalarParams,
          optionParams,
          evt
        );
      }
    })
  })
});
const createHandler = (handler) => addParams(toPascalCase(handler));
createHandler("Kind").scalar(
  "Foo AS string",
  "Bar AS number"
).options({
  foo: "string",
  bar: "opt(bool)"
});
const BackLinks = createHandler("BackLinks").scalar().options().handler(async (evt) => {
  const { plugin: p2, page } = evt;
  const current = page.current;
  const {
    table: table3,
    renderValue
  } = page;
  const links = current.file.inlinks.sort((p22) => p22 == null ? void 0 : p22.path).where((p22) => p22.path !== current.file.path);
  p2.info("backlinks", links.map((i) => [
    createFileLink(p2)(i),
    showClassifications(p2)(i),
    showDesc(p2)(i),
    showLinks(p2)(i)
  ]));
  if (links.length > 0) {
    table3(
      ["Backlink", "Classification(s)", "Desc", "Links"],
      links.map((i) => [
        createFileLink(p2)(i),
        showClassifications(p2)(i),
        showDesc(p2)(i),
        showLinks(p2)(i)
      ])
    );
  }
  if (links.length === 0) {
    renderValue(`- no back links found to this page`);
  }
});
var _function = {};
(function(exports) {
  var __spreadArray = commonjsGlobal$1 && commonjsGlobal$1.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dual = exports.getEndomorphismMonoid = exports.SK = exports.hole = exports.constVoid = exports.constUndefined = exports.constNull = exports.constFalse = exports.constTrue = exports.unsafeCoerce = exports.apply = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBooleanAlgebra = void 0;
  exports.identity = identity2;
  exports.constant = constant;
  exports.flip = flip2;
  exports.flow = flow;
  exports.tuple = tuple;
  exports.increment = increment2;
  exports.decrement = decrement;
  exports.absurd = absurd;
  exports.tupled = tupled;
  exports.untupled = untupled;
  exports.pipe = pipe;
  exports.not = not2;
  var getBooleanAlgebra = function(B) {
    return function() {
      return {
        meet: function(x2, y2) {
          return function(a) {
            return B.meet(x2(a), y2(a));
          };
        },
        join: function(x2, y2) {
          return function(a) {
            return B.join(x2(a), y2(a));
          };
        },
        zero: function() {
          return B.zero;
        },
        one: function() {
          return B.one;
        },
        implies: function(x2, y2) {
          return function(a) {
            return B.implies(x2(a), y2(a));
          };
        },
        not: function(x2) {
          return function(a) {
            return B.not(x2(a));
          };
        }
      };
    };
  };
  exports.getBooleanAlgebra = getBooleanAlgebra;
  var getSemigroup = function(S) {
    return function() {
      return {
        concat: function(f, g) {
          return function(a) {
            return S.concat(f(a), g(a));
          };
        }
      };
    };
  };
  exports.getSemigroup = getSemigroup;
  var getMonoid = function(M) {
    var getSemigroupM = (0, exports.getSemigroup)(M);
    return function() {
      return {
        concat: getSemigroupM().concat,
        empty: function() {
          return M.empty;
        }
      };
    };
  };
  exports.getMonoid = getMonoid;
  var getSemiring = function(S) {
    return {
      add: function(f, g) {
        return function(x2) {
          return S.add(f(x2), g(x2));
        };
      },
      zero: function() {
        return S.zero;
      },
      mul: function(f, g) {
        return function(x2) {
          return S.mul(f(x2), g(x2));
        };
      },
      one: function() {
        return S.one;
      }
    };
  };
  exports.getSemiring = getSemiring;
  var getRing = function(R) {
    var S = (0, exports.getSemiring)(R);
    return {
      add: S.add,
      mul: S.mul,
      one: S.one,
      zero: S.zero,
      sub: function(f, g) {
        return function(x2) {
          return R.sub(f(x2), g(x2));
        };
      }
    };
  };
  exports.getRing = getRing;
  var apply = function(a) {
    return function(f) {
      return f(a);
    };
  };
  exports.apply = apply;
  function identity2(a) {
    return a;
  }
  exports.unsafeCoerce = identity2;
  function constant(a) {
    return function() {
      return a;
    };
  }
  exports.constTrue = constant(true);
  exports.constFalse = constant(false);
  exports.constNull = constant(null);
  exports.constUndefined = constant(void 0);
  exports.constVoid = exports.constUndefined;
  function flip2(f) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (args.length > 1) {
        return f(args[1], args[0]);
      }
      return function(a) {
        return f(a)(args[0]);
      };
    };
  }
  function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
    switch (arguments.length) {
      case 1:
        return ab;
      case 2:
        return function() {
          return bc(ab.apply(this, arguments));
        };
      case 3:
        return function() {
          return cd(bc(ab.apply(this, arguments)));
        };
      case 4:
        return function() {
          return de(cd(bc(ab.apply(this, arguments))));
        };
      case 5:
        return function() {
          return ef(de(cd(bc(ab.apply(this, arguments)))));
        };
      case 6:
        return function() {
          return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
        };
      case 7:
        return function() {
          return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
        };
      case 8:
        return function() {
          return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
        };
      case 9:
        return function() {
          return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
        };
    }
    return;
  }
  function tuple() {
    var t2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      t2[_i] = arguments[_i];
    }
    return t2;
  }
  function increment2(n2) {
    return n2 + 1;
  }
  function decrement(n2) {
    return n2 - 1;
  }
  function absurd(_) {
    throw new Error("Called `absurd` function which should be uncallable");
  }
  function tupled(f) {
    return function(a) {
      return f.apply(void 0, a);
    };
  }
  function untupled(f) {
    return function() {
      var a = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        a[_i] = arguments[_i];
      }
      return f(a);
    };
  }
  function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
    switch (arguments.length) {
      case 1:
        return a;
      case 2:
        return ab(a);
      case 3:
        return bc(ab(a));
      case 4:
        return cd(bc(ab(a)));
      case 5:
        return de(cd(bc(ab(a))));
      case 6:
        return ef(de(cd(bc(ab(a)))));
      case 7:
        return fg(ef(de(cd(bc(ab(a))))));
      case 8:
        return gh(fg(ef(de(cd(bc(ab(a)))))));
      case 9:
        return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
      default: {
        var ret = arguments[0];
        for (var i = 1; i < arguments.length; i++) {
          ret = arguments[i](ret);
        }
        return ret;
      }
    }
  }
  exports.hole = absurd;
  var SK = function(_, b) {
    return b;
  };
  exports.SK = SK;
  function not2(predicate) {
    return function(a) {
      return !predicate(a);
    };
  }
  var getEndomorphismMonoid = function() {
    return {
      concat: function(first, second) {
        return flow(first, second);
      },
      empty: identity2
    };
  };
  exports.getEndomorphismMonoid = getEndomorphismMonoid;
  var dual = function(arity, body) {
    var isDataFirst = typeof arity === "number" ? function(args) {
      return args.length >= arity;
    } : arity;
    return function() {
      var args = Array.from(arguments);
      if (isDataFirst(arguments)) {
        return body.apply(this, args);
      }
      return function(self2) {
        return body.apply(void 0, __spreadArray([self2], args, false));
      };
    };
  };
  exports.dual = dual;
})(_function);
var webidl2jsWrapper = {};
var URL$4 = {};
var lib = {};
(function(exports) {
  function makeException(ErrorType, message, options2) {
    if (options2.globals) {
      ErrorType = options2.globals[ErrorType.name];
    }
    return new ErrorType(`${options2.context ? options2.context : "Value"} ${message}.`);
  }
  function toNumber(value2, options2) {
    if (typeof value2 === "bigint") {
      throw makeException(TypeError, "is a BigInt which cannot be converted to a number", options2);
    }
    if (!options2.globals) {
      return Number(value2);
    }
    return options2.globals.Number(value2);
  }
  function evenRound(x2) {
    if (x2 > 0 && x2 % 1 === 0.5 && (x2 & 1) === 0 || x2 < 0 && x2 % 1 === -0.5 && (x2 & 1) === 1) {
      return censorNegativeZero(Math.floor(x2));
    }
    return censorNegativeZero(Math.round(x2));
  }
  function integerPart(n2) {
    return censorNegativeZero(Math.trunc(n2));
  }
  function sign(x2) {
    return x2 < 0 ? -1 : 1;
  }
  function modulo(x2, y2) {
    const signMightNotMatch = x2 % y2;
    if (sign(y2) !== sign(signMightNotMatch)) {
      return signMightNotMatch + y2;
    }
    return signMightNotMatch;
  }
  function censorNegativeZero(x2) {
    return x2 === 0 ? 0 : x2;
  }
  function createIntegerConversion(bitLength, { unsigned }) {
    let lowerBound, upperBound;
    if (unsigned) {
      lowerBound = 0;
      upperBound = 2 ** bitLength - 1;
    } else {
      lowerBound = -(2 ** (bitLength - 1));
      upperBound = 2 ** (bitLength - 1) - 1;
    }
    const twoToTheBitLength = 2 ** bitLength;
    const twoToOneLessThanTheBitLength = 2 ** (bitLength - 1);
    return (value2, options2 = {}) => {
      let x2 = toNumber(value2, options2);
      x2 = censorNegativeZero(x2);
      if (options2.enforceRange) {
        if (!Number.isFinite(x2)) {
          throw makeException(TypeError, "is not a finite number", options2);
        }
        x2 = integerPart(x2);
        if (x2 < lowerBound || x2 > upperBound) {
          throw makeException(
            TypeError,
            `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`,
            options2
          );
        }
        return x2;
      }
      if (!Number.isNaN(x2) && options2.clamp) {
        x2 = Math.min(Math.max(x2, lowerBound), upperBound);
        x2 = evenRound(x2);
        return x2;
      }
      if (!Number.isFinite(x2) || x2 === 0) {
        return 0;
      }
      x2 = integerPart(x2);
      if (x2 >= lowerBound && x2 <= upperBound) {
        return x2;
      }
      x2 = modulo(x2, twoToTheBitLength);
      if (!unsigned && x2 >= twoToOneLessThanTheBitLength) {
        return x2 - twoToTheBitLength;
      }
      return x2;
    };
  }
  function createLongLongConversion(bitLength, { unsigned }) {
    const upperBound = Number.MAX_SAFE_INTEGER;
    const lowerBound = unsigned ? 0 : Number.MIN_SAFE_INTEGER;
    const asBigIntN = unsigned ? BigInt.asUintN : BigInt.asIntN;
    return (value2, options2 = {}) => {
      let x2 = toNumber(value2, options2);
      x2 = censorNegativeZero(x2);
      if (options2.enforceRange) {
        if (!Number.isFinite(x2)) {
          throw makeException(TypeError, "is not a finite number", options2);
        }
        x2 = integerPart(x2);
        if (x2 < lowerBound || x2 > upperBound) {
          throw makeException(
            TypeError,
            `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`,
            options2
          );
        }
        return x2;
      }
      if (!Number.isNaN(x2) && options2.clamp) {
        x2 = Math.min(Math.max(x2, lowerBound), upperBound);
        x2 = evenRound(x2);
        return x2;
      }
      if (!Number.isFinite(x2) || x2 === 0) {
        return 0;
      }
      let xBigInt = BigInt(integerPart(x2));
      xBigInt = asBigIntN(bitLength, xBigInt);
      return Number(xBigInt);
    };
  }
  exports.any = (value2) => {
    return value2;
  };
  exports.undefined = () => {
    return void 0;
  };
  exports.boolean = (value2) => {
    return Boolean(value2);
  };
  exports.byte = createIntegerConversion(8, { unsigned: false });
  exports.octet = createIntegerConversion(8, { unsigned: true });
  exports.short = createIntegerConversion(16, { unsigned: false });
  exports["unsigned short"] = createIntegerConversion(16, { unsigned: true });
  exports.long = createIntegerConversion(32, { unsigned: false });
  exports["unsigned long"] = createIntegerConversion(32, { unsigned: true });
  exports["long long"] = createLongLongConversion(64, { unsigned: false });
  exports["unsigned long long"] = createLongLongConversion(64, { unsigned: true });
  exports.double = (value2, options2 = {}) => {
    const x2 = toNumber(value2, options2);
    if (!Number.isFinite(x2)) {
      throw makeException(TypeError, "is not a finite floating-point value", options2);
    }
    return x2;
  };
  exports["unrestricted double"] = (value2, options2 = {}) => {
    const x2 = toNumber(value2, options2);
    return x2;
  };
  exports.float = (value2, options2 = {}) => {
    const x2 = toNumber(value2, options2);
    if (!Number.isFinite(x2)) {
      throw makeException(TypeError, "is not a finite floating-point value", options2);
    }
    if (Object.is(x2, -0)) {
      return x2;
    }
    const y2 = Math.fround(x2);
    if (!Number.isFinite(y2)) {
      throw makeException(TypeError, "is outside the range of a single-precision floating-point value", options2);
    }
    return y2;
  };
  exports["unrestricted float"] = (value2, options2 = {}) => {
    const x2 = toNumber(value2, options2);
    if (isNaN(x2)) {
      return x2;
    }
    if (Object.is(x2, -0)) {
      return x2;
    }
    return Math.fround(x2);
  };
  exports.DOMString = (value2, options2 = {}) => {
    if (options2.treatNullAsEmptyString && value2 === null) {
      return "";
    }
    if (typeof value2 === "symbol") {
      throw makeException(TypeError, "is a symbol, which cannot be converted to a string", options2);
    }
    const StringCtor = options2.globals ? options2.globals.String : String;
    return StringCtor(value2);
  };
  exports.ByteString = (value2, options2 = {}) => {
    const x2 = exports.DOMString(value2, options2);
    let c;
    for (let i = 0; (c = x2.codePointAt(i)) !== void 0; ++i) {
      if (c > 255) {
        throw makeException(TypeError, "is not a valid ByteString", options2);
      }
    }
    return x2;
  };
  exports.USVString = (value2, options2 = {}) => {
    const S = exports.DOMString(value2, options2);
    const n2 = S.length;
    const U = [];
    for (let i = 0; i < n2; ++i) {
      const c = S.charCodeAt(i);
      if (c < 55296 || c > 57343) {
        U.push(String.fromCodePoint(c));
      } else if (56320 <= c && c <= 57343) {
        U.push(String.fromCodePoint(65533));
      } else if (i === n2 - 1) {
        U.push(String.fromCodePoint(65533));
      } else {
        const d = S.charCodeAt(i + 1);
        if (56320 <= d && d <= 57343) {
          const a = c & 1023;
          const b = d & 1023;
          U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
          ++i;
        } else {
          U.push(String.fromCodePoint(65533));
        }
      }
    }
    return U.join("");
  };
  exports.object = (value2, options2 = {}) => {
    if (value2 === null || typeof value2 !== "object" && typeof value2 !== "function") {
      throw makeException(TypeError, "is not an object", options2);
    }
    return value2;
  };
  const abByteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
  const sabByteLengthGetter = typeof SharedArrayBuffer === "function" ? Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, "byteLength").get : null;
  function isNonSharedArrayBuffer(value2) {
    try {
      abByteLengthGetter.call(value2);
      return true;
    } catch {
      return false;
    }
  }
  function isSharedArrayBuffer(value2) {
    try {
      sabByteLengthGetter.call(value2);
      return true;
    } catch {
      return false;
    }
  }
  function isArrayBufferDetached(value2) {
    try {
      new Uint8Array(value2);
      return false;
    } catch {
      return true;
    }
  }
  exports.ArrayBuffer = (value2, options2 = {}) => {
    if (!isNonSharedArrayBuffer(value2)) {
      if (options2.allowShared && !isSharedArrayBuffer(value2)) {
        throw makeException(TypeError, "is not an ArrayBuffer or SharedArrayBuffer", options2);
      }
      throw makeException(TypeError, "is not an ArrayBuffer", options2);
    }
    if (isArrayBufferDetached(value2)) {
      throw makeException(TypeError, "is a detached ArrayBuffer", options2);
    }
    return value2;
  };
  const dvByteLengthGetter = Object.getOwnPropertyDescriptor(DataView.prototype, "byteLength").get;
  exports.DataView = (value2, options2 = {}) => {
    try {
      dvByteLengthGetter.call(value2);
    } catch (e2) {
      throw makeException(TypeError, "is not a DataView", options2);
    }
    if (!options2.allowShared && isSharedArrayBuffer(value2.buffer)) {
      throw makeException(TypeError, "is backed by a SharedArrayBuffer, which is not allowed", options2);
    }
    if (isArrayBufferDetached(value2.buffer)) {
      throw makeException(TypeError, "is backed by a detached ArrayBuffer", options2);
    }
    return value2;
  };
  const typedArrayNameGetter = Object.getOwnPropertyDescriptor(
    Object.getPrototypeOf(Uint8Array).prototype,
    Symbol.toStringTag
  ).get;
  [
    Int8Array,
    Int16Array,
    Int32Array,
    Uint8Array,
    Uint16Array,
    Uint32Array,
    Uint8ClampedArray,
    Float32Array,
    Float64Array
  ].forEach((func) => {
    const { name: name2 } = func;
    const article = /^[AEIOU]/u.test(name2) ? "an" : "a";
    exports[name2] = (value2, options2 = {}) => {
      if (!ArrayBuffer.isView(value2) || typedArrayNameGetter.call(value2) !== name2) {
        throw makeException(TypeError, `is not ${article} ${name2} object`, options2);
      }
      if (!options2.allowShared && isSharedArrayBuffer(value2.buffer)) {
        throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options2);
      }
      if (isArrayBufferDetached(value2.buffer)) {
        throw makeException(TypeError, "is a view on a detached ArrayBuffer", options2);
      }
      return value2;
    };
  });
  exports.ArrayBufferView = (value2, options2 = {}) => {
    if (!ArrayBuffer.isView(value2)) {
      throw makeException(TypeError, "is not a view on an ArrayBuffer or SharedArrayBuffer", options2);
    }
    if (!options2.allowShared && isSharedArrayBuffer(value2.buffer)) {
      throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options2);
    }
    if (isArrayBufferDetached(value2.buffer)) {
      throw makeException(TypeError, "is a view on a detached ArrayBuffer", options2);
    }
    return value2;
  };
  exports.BufferSource = (value2, options2 = {}) => {
    if (ArrayBuffer.isView(value2)) {
      if (!options2.allowShared && isSharedArrayBuffer(value2.buffer)) {
        throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options2);
      }
      if (isArrayBufferDetached(value2.buffer)) {
        throw makeException(TypeError, "is a view on a detached ArrayBuffer", options2);
      }
      return value2;
    }
    if (!options2.allowShared && !isNonSharedArrayBuffer(value2)) {
      throw makeException(TypeError, "is not an ArrayBuffer or a view on one", options2);
    }
    if (options2.allowShared && !isSharedArrayBuffer(value2) && !isNonSharedArrayBuffer(value2)) {
      throw makeException(TypeError, "is not an ArrayBuffer, SharedArrayBuffer, or a view on one", options2);
    }
    if (isArrayBufferDetached(value2)) {
      throw makeException(TypeError, "is a detached ArrayBuffer", options2);
    }
    return value2;
  };
  exports.DOMTimeStamp = exports["unsigned long long"];
})(lib);
var utils$2 = { exports: {} };
(function(module, exports) {
  function isObject2(value2) {
    return typeof value2 === "object" && value2 !== null || typeof value2 === "function";
  }
  const hasOwn = Function.prototype.call.bind(Object.prototype.hasOwnProperty);
  function define(target2, source) {
    for (const key of Reflect.ownKeys(source)) {
      const descriptor = Reflect.getOwnPropertyDescriptor(source, key);
      if (descriptor && !Reflect.defineProperty(target2, key, descriptor)) {
        throw new TypeError(`Cannot redefine property: ${String(key)}`);
      }
    }
  }
  function newObjectInRealm(globalObject, object) {
    const ctorRegistry = initCtorRegistry(globalObject);
    return Object.defineProperties(
      Object.create(ctorRegistry["%Object.prototype%"]),
      Object.getOwnPropertyDescriptors(object)
    );
  }
  const wrapperSymbol = Symbol("wrapper");
  const implSymbol = Symbol("impl");
  const sameObjectCaches = Symbol("SameObject caches");
  const ctorRegistrySymbol = Symbol.for("[webidl2js] constructor registry");
  const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
  }).prototype);
  function initCtorRegistry(globalObject) {
    if (hasOwn(globalObject, ctorRegistrySymbol)) {
      return globalObject[ctorRegistrySymbol];
    }
    const ctorRegistry = /* @__PURE__ */ Object.create(null);
    ctorRegistry["%Object.prototype%"] = globalObject.Object.prototype;
    ctorRegistry["%IteratorPrototype%"] = Object.getPrototypeOf(
      Object.getPrototypeOf(new globalObject.Array()[Symbol.iterator]())
    );
    try {
      ctorRegistry["%AsyncIteratorPrototype%"] = Object.getPrototypeOf(
        Object.getPrototypeOf(
          globalObject.eval("(async function* () {})").prototype
        )
      );
    } catch {
      ctorRegistry["%AsyncIteratorPrototype%"] = AsyncIteratorPrototype;
    }
    globalObject[ctorRegistrySymbol] = ctorRegistry;
    return ctorRegistry;
  }
  function getSameObject(wrapper, prop, creator) {
    if (!wrapper[sameObjectCaches]) {
      wrapper[sameObjectCaches] = /* @__PURE__ */ Object.create(null);
    }
    if (prop in wrapper[sameObjectCaches]) {
      return wrapper[sameObjectCaches][prop];
    }
    wrapper[sameObjectCaches][prop] = creator();
    return wrapper[sameObjectCaches][prop];
  }
  function wrapperForImpl(impl) {
    return impl ? impl[wrapperSymbol] : null;
  }
  function implForWrapper(wrapper) {
    return wrapper ? wrapper[implSymbol] : null;
  }
  function tryWrapperForImpl(impl) {
    const wrapper = wrapperForImpl(impl);
    return wrapper ? wrapper : impl;
  }
  function tryImplForWrapper(wrapper) {
    const impl = implForWrapper(wrapper);
    return impl ? impl : wrapper;
  }
  const iterInternalSymbol = Symbol("internal");
  function isArrayIndexPropName(P) {
    if (typeof P !== "string") {
      return false;
    }
    const i = P >>> 0;
    if (i === 2 ** 32 - 1) {
      return false;
    }
    const s2 = `${i}`;
    if (P !== s2) {
      return false;
    }
    return true;
  }
  const byteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
  function isArrayBuffer(value2) {
    try {
      byteLengthGetter.call(value2);
      return true;
    } catch (e2) {
      return false;
    }
  }
  function iteratorResult([key, value2], kind) {
    let result;
    switch (kind) {
      case "key":
        result = key;
        break;
      case "value":
        result = value2;
        break;
      case "key+value":
        result = [key, value2];
        break;
    }
    return { value: result, done: false };
  }
  const supportsPropertyIndex = Symbol("supports property index");
  const supportedPropertyIndices = Symbol("supported property indices");
  const supportsPropertyName = Symbol("supports property name");
  const supportedPropertyNames = Symbol("supported property names");
  const indexedGet = Symbol("indexed property get");
  const indexedSetNew = Symbol("indexed property set new");
  const indexedSetExisting = Symbol("indexed property set existing");
  const namedGet = Symbol("named property get");
  const namedSetNew = Symbol("named property set new");
  const namedSetExisting = Symbol("named property set existing");
  const namedDelete = Symbol("named property delete");
  const asyncIteratorNext = Symbol("async iterator get the next iteration result");
  const asyncIteratorReturn = Symbol("async iterator return steps");
  const asyncIteratorInit = Symbol("async iterator initialization steps");
  const asyncIteratorEOI = Symbol("async iterator end of iteration");
  module.exports = {
    isObject: isObject2,
    hasOwn,
    define,
    newObjectInRealm,
    wrapperSymbol,
    implSymbol,
    getSameObject,
    ctorRegistrySymbol,
    initCtorRegistry,
    wrapperForImpl,
    implForWrapper,
    tryWrapperForImpl,
    tryImplForWrapper,
    iterInternalSymbol,
    isArrayBuffer,
    isArrayIndexPropName,
    supportsPropertyIndex,
    supportedPropertyIndices,
    supportsPropertyName,
    supportedPropertyNames,
    indexedGet,
    indexedSetNew,
    indexedSetExisting,
    namedGet,
    namedSetNew,
    namedSetExisting,
    namedDelete,
    asyncIteratorNext,
    asyncIteratorReturn,
    asyncIteratorInit,
    asyncIteratorEOI,
    iteratorResult
  };
})(utils$2);
var utilsExports = utils$2.exports;
var URLImpl = {};
var urlStateMachine$1 = { exports: {} };
const maxInt = 2147483647;
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128;
const delimiter = "-";
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7F]/;
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
const errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;
function error$1(type) {
  throw new RangeError(errors[type]);
}
function map(array, callback) {
  const result = [];
  let length2 = array.length;
  while (length2--) {
    result[length2] = callback(array[length2]);
  }
  return result;
}
function mapDomain(domain, callback) {
  const parts = domain.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    domain = parts[1];
  }
  domain = domain.replace(regexSeparators, ".");
  const labels = domain.split(".");
  const encoded = map(labels, callback).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length2 = string.length;
  while (counter < length2) {
    const value2 = string.charCodeAt(counter++);
    if (value2 >= 55296 && value2 <= 56319 && counter < length2) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value2 & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value2);
        counter--;
      }
    } else {
      output.push(value2);
    }
  }
  return output;
}
const ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
const basicToDigit = function(codePoint) {
  if (codePoint >= 48 && codePoint < 58) {
    return 26 + (codePoint - 48);
  }
  if (codePoint >= 65 && codePoint < 91) {
    return codePoint - 65;
  }
  if (codePoint >= 97 && codePoint < 123) {
    return codePoint - 97;
  }
  return base;
};
const digitToBasic = function(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};
const adapt = function(delta, numPoints, firstTime) {
  let k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};
const decode = function(input) {
  const output = [];
  const inputLength = input.length;
  let i = 0;
  let n2 = initialN;
  let bias = initialBias;
  let basic = input.lastIndexOf(delimiter);
  if (basic < 0) {
    basic = 0;
  }
  for (let j = 0; j < basic; ++j) {
    if (input.charCodeAt(j) >= 128) {
      error$1("not-basic");
    }
    output.push(input.charCodeAt(j));
  }
  for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
    const oldi = i;
    for (let w = 1, k = base; ; k += base) {
      if (index >= inputLength) {
        error$1("invalid-input");
      }
      const digit = basicToDigit(input.charCodeAt(index++));
      if (digit >= base) {
        error$1("invalid-input");
      }
      if (digit > floor((maxInt - i) / w)) {
        error$1("overflow");
      }
      i += digit * w;
      const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
      if (digit < t2) {
        break;
      }
      const baseMinusT = base - t2;
      if (w > floor(maxInt / baseMinusT)) {
        error$1("overflow");
      }
      w *= baseMinusT;
    }
    const out = output.length + 1;
    bias = adapt(i - oldi, out, oldi == 0);
    if (floor(i / out) > maxInt - n2) {
      error$1("overflow");
    }
    n2 += floor(i / out);
    i %= out;
    output.splice(i++, 0, n2);
  }
  return String.fromCodePoint(...output);
};
const encode = function(input) {
  const output = [];
  input = ucs2decode(input);
  const inputLength = input.length;
  let n2 = initialN;
  let delta = 0;
  let bias = initialBias;
  for (const currentValue of input) {
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  const basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    let m = maxInt;
    for (const currentValue of input) {
      if (currentValue >= n2 && currentValue < m) {
        m = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error$1("overflow");
    }
    delta += (m - n2) * handledCPCountPlusOne;
    n2 = m;
    for (const currentValue of input) {
      if (currentValue < n2 && ++delta > maxInt) {
        error$1("overflow");
      }
      if (currentValue === n2) {
        let q = delta;
        for (let k = base; ; k += base) {
          const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q < t2) {
            break;
          }
          const qMinusT = q - t2;
          const baseMinusT = base - t2;
          output.push(
            stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
          );
          q = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n2;
  }
  return output.join("");
};
const toUnicode$1 = function(input) {
  return mapDomain(input, function(string) {
    return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
  });
};
const toASCII$1 = function(input) {
  return mapDomain(input, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
  });
};
const punycode$1 = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  "version": "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  "ucs2": {
    "decode": ucs2decode,
    "encode": ucs2encode
  },
  "decode": decode,
  "encode": encode,
  "toASCII": toASCII$1,
  "toUnicode": toUnicode$1
};
const punycode_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode,
  default: punycode$1,
  encode,
  toASCII: toASCII$1,
  toUnicode: toUnicode$1,
  ucs2decode,
  ucs2encode
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(punycode_es6);
const combiningMarks = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{11002}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11082}\u{110B0}-\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{11134}\u{11145}\u{11146}\u{11173}\u{11180}-\u{11182}\u{111B3}-\u{111C0}\u{111C9}-\u{111CC}\u{111CE}\u{111CF}\u{1122C}-\u{11237}\u{1123E}\u{11241}\u{112DF}-\u{112EA}\u{11300}-\u{11303}\u{1133B}\u{1133C}\u{1133E}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11357}\u{11362}\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11435}-\u{11446}\u{1145E}\u{114B0}-\u{114C3}\u{115AF}-\u{115B5}\u{115B8}-\u{115C0}\u{115DC}\u{115DD}\u{11630}-\u{11640}\u{116AB}-\u{116B7}\u{1171D}-\u{1172B}\u{1182C}-\u{1183A}\u{11930}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{1193E}\u{11940}\u{11942}\u{11943}\u{119D1}-\u{119D7}\u{119DA}-\u{119E0}\u{119E4}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A39}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A5B}\u{11A8A}-\u{11A99}\u{11C2F}-\u{11C36}\u{11C38}-\u{11C3F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D8A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D97}\u{11EF3}-\u{11EF6}\u{11F00}\u{11F01}\u{11F03}\u{11F34}-\u{11F3A}\u{11F3E}-\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F51}-\u{16F87}\u{16F8F}-\u{16F92}\u{16FE4}\u{16FF0}\u{16FF1}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D165}-\u{1D169}\u{1D16D}-\u{1D172}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]/u;
const combiningClassVirama = /[\u094D\u09CD\u0A4D\u0ACD\u0B4D\u0BCD\u0C4D\u0CCD\u0D3B\u0D3C\u0D4D\u0DCA\u0E3A\u0EBA\u0F84\u1039\u103A\u1714\u1715\u1734\u17D2\u1A60\u1B44\u1BAA\u1BAB\u1BF2\u1BF3\u2D7F\uA806\uA82C\uA8C4\uA953\uA9C0\uAAF6\uABED\u{10A3F}\u{11046}\u{11070}\u{1107F}\u{110B9}\u{11133}\u{11134}\u{111C0}\u{11235}\u{112EA}\u{1134D}\u{11442}\u{114C2}\u{115BF}\u{1163F}\u{116B6}\u{1172B}\u{11839}\u{1193D}\u{1193E}\u{119E0}\u{11A34}\u{11A47}\u{11A99}\u{11C3F}\u{11D44}\u{11D45}\u{11D97}\u{11F41}\u{11F42}]/u;
const validZWNJ = /[\u0620\u0626\u0628\u062A-\u062E\u0633-\u063F\u0641-\u0647\u0649\u064A\u066E\u066F\u0678-\u0687\u069A-\u06BF\u06C1\u06C2\u06CC\u06CE\u06D0\u06D1\u06FA-\u06FC\u06FF\u0712-\u0714\u071A-\u071D\u071F-\u0727\u0729\u072B\u072D\u072E\u074E-\u0758\u075C-\u076A\u076D-\u0770\u0772\u0775-\u0777\u077A-\u077F\u07CA-\u07EA\u0841-\u0845\u0848\u084A-\u0853\u0855\u0860\u0862-\u0865\u0868\u0886\u0889-\u088D\u08A0-\u08A9\u08AF\u08B0\u08B3-\u08B8\u08BA-\u08C8\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA872\u{10AC0}-\u{10AC4}\u{10ACD}\u{10AD3}-\u{10ADC}\u{10ADE}-\u{10AE0}\u{10AEB}-\u{10AEE}\u{10B80}\u{10B82}\u{10B86}-\u{10B88}\u{10B8A}\u{10B8B}\u{10B8D}\u{10B90}\u{10BAD}\u{10BAE}\u{10D00}-\u{10D21}\u{10D23}\u{10F30}-\u{10F32}\u{10F34}-\u{10F44}\u{10F51}-\u{10F53}\u{10F70}-\u{10F73}\u{10F76}-\u{10F81}\u{10FB0}\u{10FB2}\u{10FB3}\u{10FB8}\u{10FBB}\u{10FBC}\u{10FBE}\u{10FBF}\u{10FC1}\u{10FC4}\u{10FCA}\u{10FCB}\u{1E900}-\u{1E943}][\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{13430}-\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*\u200C[\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{13430}-\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*[\u0620\u0622-\u063F\u0641-\u064A\u066E\u066F\u0671-\u0673\u0675-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u077F\u07CA-\u07EA\u0840-\u0858\u0860\u0862-\u0865\u0867-\u086A\u0870-\u0882\u0886\u0889-\u088E\u08A0-\u08AC\u08AE-\u08C8\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA871\u{10AC0}-\u{10AC5}\u{10AC7}\u{10AC9}\u{10ACA}\u{10ACE}-\u{10AD6}\u{10AD8}-\u{10AE1}\u{10AE4}\u{10AEB}-\u{10AEF}\u{10B80}-\u{10B91}\u{10BA9}-\u{10BAE}\u{10D01}-\u{10D23}\u{10F30}-\u{10F44}\u{10F51}-\u{10F54}\u{10F70}-\u{10F81}\u{10FB0}\u{10FB2}-\u{10FB6}\u{10FB8}-\u{10FBF}\u{10FC1}-\u{10FC4}\u{10FC9}\u{10FCA}\u{1E900}-\u{1E943}]/u;
const bidiDomain = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
const bidiS1LTR = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B50-\u1B6A\u1B74-\u1B7E\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u249C-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11F02}-\u{11F10}\u{11F12}-\u{11F35}\u{11F3E}\u{11F3F}\u{11F41}\u{11F43}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1343F}\u{13441}-\u{13446}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6DA}\u{1D6DC}-\u{1D714}\u{1D716}-\u{1D74E}\u{1D750}-\u{1D788}\u{1D78A}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D800}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E4D0}-\u{1E4EB}\u{1E4F0}-\u{1E4F9}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]/u;
const bidiS1RTL = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
const bidiS2 = /^[\0-\x08\x0E-\x1B!-@\[-`\{-\x84\x86-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02B9\u02BA\u02C2-\u02CF\u02D2-\u02DF\u02E5-\u02ED\u02EF-\u036F\u0374\u0375\u037E\u0384\u0385\u0387\u03F6\u0483-\u0489\u058A\u058D-\u058F\u0591-\u05C7\u05D0-\u05EA\u05EF-\u05F4\u0600-\u070D\u070F-\u074A\u074D-\u07B1\u07C0-\u07FA\u07FD-\u082D\u0830-\u083E\u0840-\u085B\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u0898-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09F2\u09F3\u09FB\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AF1\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0BF3-\u0BFA\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C78-\u0C7E\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E3F\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39-\u0F3D\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1390-\u1399\u1400\u169B\u169C\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DB\u17DD\u17F0-\u17F9\u1800-\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1940\u1944\u1945\u19DE-\u19FF\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u200B-\u200D\u200F-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20C0\u20D0-\u20F0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u2150-\u215F\u2189-\u218B\u2190-\u2335\u237B-\u2394\u2396-\u2426\u2440-\u244A\u2460-\u249B\u24EA-\u26AB\u26AD-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2CEF-\u2CF1\u2CF9-\u2CFF\u2D7F\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3001-\u3004\u3008-\u3020\u302A-\u302D\u3030\u3036\u3037\u303D-\u303F\u3099-\u309C\u30A0\u30FB\u31C0-\u31E3\u31EF\u321D\u321E\u3250-\u325F\u327C-\u327E\u32B1-\u32BF\u32CC-\u32CF\u3377-\u337A\u33DE\u33DF\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA60D-\uA60F\uA66F-\uA67F\uA69E\uA69F\uA6F0\uA6F1\uA700-\uA721\uA788\uA802\uA806\uA80B\uA825\uA826\uA828-\uA82C\uA838\uA839\uA874-\uA877\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uAB6A\uAB6B\uABE5\uABE8\uABED\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD8F\uFD92-\uFDC7\uFDCF\uFDF0-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFE70-\uFE74\uFE76-\uFEFC\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10101}\u{10140}-\u{1018C}\u{10190}-\u{1019C}\u{101A0}\u{101FD}\u{102E0}-\u{102FB}\u{10376}-\u{1037A}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{1091F}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A38}-\u{10A3A}\u{10A3F}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE6}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B39}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D27}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAB}-\u{10EAD}\u{10EB0}\u{10EB1}\u{10EFD}-\u{10F27}\u{10F30}-\u{10F59}\u{10F70}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{11001}\u{11038}-\u{11046}\u{11052}-\u{11065}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{11660}-\u{1166C}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11FD5}-\u{11FF1}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE2}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D1E9}\u{1D1EA}\u{1D200}-\u{1D245}\u{1D300}-\u{1D356}\u{1D6DB}\u{1D715}\u{1D74F}\u{1D789}\u{1D7C3}\u{1D7CE}-\u{1D7FF}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E2FF}\u{1E4EC}-\u{1E4EF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8D6}\u{1E900}-\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F10F}\u{1F12F}\u{1F16A}-\u{1F16F}\u{1F1AD}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DC}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F776}\u{1F77B}-\u{1F7D9}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}\u{1F8B1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA7C}\u{1FA80}-\u{1FA88}\u{1FA90}-\u{1FABD}\u{1FABF}-\u{1FAC5}\u{1FACE}-\u{1FADB}\u{1FAE0}-\u{1FAE8}\u{1FAF0}-\u{1FAF8}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBCA}\u{1FBF0}-\u{1FBF9}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*$/u;
const bidiS3 = /[0-9\xB2\xB3\xB9\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\u{102E1}-\u{102FB}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1D7CE}-\u{1D7FF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
const bidiS4EN = /[0-9\xB2\xB3\xB9\u06F0-\u06F9\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFF10-\uFF19\u{102E1}-\u{102FB}\u{1D7CE}-\u{1D7FF}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}]/u;
const bidiS4AN = /[\u0600-\u0605\u0660-\u0669\u066B\u066C\u06DD\u0890\u0891\u08E2\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}]/u;
const bidiS5 = /^[\0-\x08\x0E-\x1B!-\x84\x86-\u0377\u037A-\u037F\u0384-\u038A\u038C\u038E-\u03A1\u03A3-\u052F\u0531-\u0556\u0559-\u058A\u058D-\u058F\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0606\u0607\u0609\u060A\u060C\u060E-\u061A\u064B-\u065F\u066A\u0670\u06D6-\u06DC\u06DE-\u06E4\u06E7-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07F6-\u07F9\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A76\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3C-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C77-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4F\u0D54-\u0D63\u0D66-\u0D7F\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E3A\u0E3F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECE\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FDA\u1000-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u13A0-\u13F5\u13F8-\u13FD\u1400-\u167F\u1681-\u169C\u16A0-\u16F8\u1700-\u1715\u171F-\u1736\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u1800-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE-\u1A1B\u1A1E-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1AB0-\u1ACE\u1B00-\u1B4C\u1B50-\u1B7E\u1B80-\u1BF3\u1BFC-\u1C37\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD0-\u1CFA\u1D00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u200B-\u200E\u2010-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2071\u2074-\u208E\u2090-\u209C\u20A0-\u20C0\u20D0-\u20F0\u2100-\u218B\u2190-\u2426\u2440-\u244A\u2460-\u2B73\u2B76-\u2B95\u2B97-\u2CF3\u2CF9-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3001-\u303F\u3041-\u3096\u3099-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31E3\u31EF-\u321E\u3220-\uA48C\uA490-\uA4C6\uA4D0-\uA62B\uA640-\uA6F7\uA700-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA82C\uA830-\uA839\uA840-\uA877\uA880-\uA8C5\uA8CE-\uA8D9\uA8E0-\uA953\uA95F-\uA97C\uA980-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAAC2\uAADB-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB6B\uAB70-\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1E\uFB29\uFD3E-\uFD4F\uFDCF\uFDFD-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}-\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1018E}\u{10190}-\u{1019C}\u{101A0}\u{101D0}-\u{101FD}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E0}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{1037A}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{1091F}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10B39}-\u{10B3F}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{1104D}\u{11052}-\u{11075}\u{1107F}-\u{110C2}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11100}-\u{11134}\u{11136}-\u{11147}\u{11150}-\u{11176}\u{11180}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{11241}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112EA}\u{112F0}-\u{112F9}\u{11300}-\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133B}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11400}-\u{1145B}\u{1145D}-\u{11461}\u{11480}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B5}\u{115B8}-\u{115DD}\u{11600}-\u{11644}\u{11650}-\u{11659}\u{11660}-\u{1166C}\u{11680}-\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{1171D}-\u{1172B}\u{11730}-\u{11746}\u{11800}-\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D7}\u{119DA}-\u{119E4}\u{11A00}-\u{11A47}\u{11A50}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C36}\u{11C38}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D47}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF8}\u{11F00}-\u{11F10}\u{11F12}-\u{11F3A}\u{11F3E}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FF1}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{13455}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF0}-\u{16AF5}\u{16B00}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F4F}-\u{16F87}\u{16F8F}-\u{16F9F}\u{16FE0}-\u{16FE4}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D1EA}\u{1D200}-\u{1D245}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D300}-\u{1D356}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D7CB}\u{1D7CE}-\u{1DA8B}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E030}-\u{1E06D}\u{1E08F}\u{1E100}-\u{1E12C}\u{1E130}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AE}\u{1E2C0}-\u{1E2F9}\u{1E2FF}\u{1E4D0}-\u{1E4F9}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F1AD}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DC}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F776}\u{1F77B}-\u{1F7D9}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}\u{1F8B1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA7C}\u{1FA80}-\u{1FA88}\u{1FA90}-\u{1FABD}\u{1FABF}-\u{1FAC5}\u{1FACE}-\u{1FADB}\u{1FAE0}-\u{1FAE8}\u{1FAF0}-\u{1FAF8}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBCA}\u{1FBF0}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]*$/u;
const bidiS6 = /[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u06F0-\u06F9\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B50-\u1B6A\u1B74-\u1B7E\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u2488-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E1}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11F02}-\u{11F10}\u{11F12}-\u{11F35}\u{11F3E}\u{11F3F}\u{11F41}\u{11F43}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1343F}\u{13441}-\u{13446}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6DA}\u{1D6DC}-\u{1D714}\u{1D716}-\u{1D74E}\u{1D750}-\u{1D788}\u{1D78A}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D7CE}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E4D0}-\u{1E4EB}\u{1E4F0}-\u{1E4F9}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F100}-\u{1F10A}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1FBF0}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
var regexes$1 = {
  combiningMarks,
  combiningClassVirama,
  validZWNJ,
  bidiDomain,
  bidiS1LTR,
  bidiS1RTL,
  bidiS2,
  bidiS3,
  bidiS4EN,
  bidiS4AN,
  bidiS5,
  bidiS6
};
const require$$2 = [
  [
    [
      0,
      44
    ],
    4
  ],
  [
    [
      45,
      46
    ],
    2
  ],
  [
    47,
    4
  ],
  [
    [
      48,
      57
    ],
    2
  ],
  [
    [
      58,
      64
    ],
    4
  ],
  [
    65,
    1,
    "a"
  ],
  [
    66,
    1,
    "b"
  ],
  [
    67,
    1,
    "c"
  ],
  [
    68,
    1,
    "d"
  ],
  [
    69,
    1,
    "e"
  ],
  [
    70,
    1,
    "f"
  ],
  [
    71,
    1,
    "g"
  ],
  [
    72,
    1,
    "h"
  ],
  [
    73,
    1,
    "i"
  ],
  [
    74,
    1,
    "j"
  ],
  [
    75,
    1,
    "k"
  ],
  [
    76,
    1,
    "l"
  ],
  [
    77,
    1,
    "m"
  ],
  [
    78,
    1,
    "n"
  ],
  [
    79,
    1,
    "o"
  ],
  [
    80,
    1,
    "p"
  ],
  [
    81,
    1,
    "q"
  ],
  [
    82,
    1,
    "r"
  ],
  [
    83,
    1,
    "s"
  ],
  [
    84,
    1,
    "t"
  ],
  [
    85,
    1,
    "u"
  ],
  [
    86,
    1,
    "v"
  ],
  [
    87,
    1,
    "w"
  ],
  [
    88,
    1,
    "x"
  ],
  [
    89,
    1,
    "y"
  ],
  [
    90,
    1,
    "z"
  ],
  [
    [
      91,
      96
    ],
    4
  ],
  [
    [
      97,
      122
    ],
    2
  ],
  [
    [
      123,
      127
    ],
    4
  ],
  [
    [
      128,
      159
    ],
    3
  ],
  [
    160,
    5,
    " "
  ],
  [
    [
      161,
      167
    ],
    2
  ],
  [
    168,
    5,
    " "
  ],
  [
    169,
    2
  ],
  [
    170,
    1,
    "a"
  ],
  [
    [
      171,
      172
    ],
    2
  ],
  [
    173,
    7
  ],
  [
    174,
    2
  ],
  [
    175,
    5,
    " "
  ],
  [
    [
      176,
      177
    ],
    2
  ],
  [
    178,
    1,
    "2"
  ],
  [
    179,
    1,
    "3"
  ],
  [
    180,
    5,
    " "
  ],
  [
    181,
    1,
    ""
  ],
  [
    182,
    2
  ],
  [
    183,
    2
  ],
  [
    184,
    5,
    " "
  ],
  [
    185,
    1,
    "1"
  ],
  [
    186,
    1,
    "o"
  ],
  [
    187,
    2
  ],
  [
    188,
    1,
    "14"
  ],
  [
    189,
    1,
    "12"
  ],
  [
    190,
    1,
    "34"
  ],
  [
    191,
    2
  ],
  [
    192,
    1,
    ""
  ],
  [
    193,
    1,
    ""
  ],
  [
    194,
    1,
    ""
  ],
  [
    195,
    1,
    ""
  ],
  [
    196,
    1,
    ""
  ],
  [
    197,
    1,
    ""
  ],
  [
    198,
    1,
    ""
  ],
  [
    199,
    1,
    ""
  ],
  [
    200,
    1,
    ""
  ],
  [
    201,
    1,
    ""
  ],
  [
    202,
    1,
    ""
  ],
  [
    203,
    1,
    ""
  ],
  [
    204,
    1,
    ""
  ],
  [
    205,
    1,
    ""
  ],
  [
    206,
    1,
    ""
  ],
  [
    207,
    1,
    ""
  ],
  [
    208,
    1,
    ""
  ],
  [
    209,
    1,
    ""
  ],
  [
    210,
    1,
    ""
  ],
  [
    211,
    1,
    ""
  ],
  [
    212,
    1,
    ""
  ],
  [
    213,
    1,
    ""
  ],
  [
    214,
    1,
    ""
  ],
  [
    215,
    2
  ],
  [
    216,
    1,
    ""
  ],
  [
    217,
    1,
    ""
  ],
  [
    218,
    1,
    ""
  ],
  [
    219,
    1,
    ""
  ],
  [
    220,
    1,
    ""
  ],
  [
    221,
    1,
    ""
  ],
  [
    222,
    1,
    ""
  ],
  [
    223,
    6,
    "ss"
  ],
  [
    [
      224,
      246
    ],
    2
  ],
  [
    247,
    2
  ],
  [
    [
      248,
      255
    ],
    2
  ],
  [
    256,
    1,
    ""
  ],
  [
    257,
    2
  ],
  [
    258,
    1,
    ""
  ],
  [
    259,
    2
  ],
  [
    260,
    1,
    ""
  ],
  [
    261,
    2
  ],
  [
    262,
    1,
    ""
  ],
  [
    263,
    2
  ],
  [
    264,
    1,
    ""
  ],
  [
    265,
    2
  ],
  [
    266,
    1,
    ""
  ],
  [
    267,
    2
  ],
  [
    268,
    1,
    ""
  ],
  [
    269,
    2
  ],
  [
    270,
    1,
    ""
  ],
  [
    271,
    2
  ],
  [
    272,
    1,
    ""
  ],
  [
    273,
    2
  ],
  [
    274,
    1,
    ""
  ],
  [
    275,
    2
  ],
  [
    276,
    1,
    ""
  ],
  [
    277,
    2
  ],
  [
    278,
    1,
    ""
  ],
  [
    279,
    2
  ],
  [
    280,
    1,
    ""
  ],
  [
    281,
    2
  ],
  [
    282,
    1,
    ""
  ],
  [
    283,
    2
  ],
  [
    284,
    1,
    ""
  ],
  [
    285,
    2
  ],
  [
    286,
    1,
    ""
  ],
  [
    287,
    2
  ],
  [
    288,
    1,
    ""
  ],
  [
    289,
    2
  ],
  [
    290,
    1,
    ""
  ],
  [
    291,
    2
  ],
  [
    292,
    1,
    ""
  ],
  [
    293,
    2
  ],
  [
    294,
    1,
    ""
  ],
  [
    295,
    2
  ],
  [
    296,
    1,
    ""
  ],
  [
    297,
    2
  ],
  [
    298,
    1,
    ""
  ],
  [
    299,
    2
  ],
  [
    300,
    1,
    ""
  ],
  [
    301,
    2
  ],
  [
    302,
    1,
    ""
  ],
  [
    303,
    2
  ],
  [
    304,
    1,
    "i"
  ],
  [
    305,
    2
  ],
  [
    [
      306,
      307
    ],
    1,
    "ij"
  ],
  [
    308,
    1,
    ""
  ],
  [
    309,
    2
  ],
  [
    310,
    1,
    ""
  ],
  [
    [
      311,
      312
    ],
    2
  ],
  [
    313,
    1,
    ""
  ],
  [
    314,
    2
  ],
  [
    315,
    1,
    ""
  ],
  [
    316,
    2
  ],
  [
    317,
    1,
    ""
  ],
  [
    318,
    2
  ],
  [
    [
      319,
      320
    ],
    1,
    "l"
  ],
  [
    321,
    1,
    ""
  ],
  [
    322,
    2
  ],
  [
    323,
    1,
    ""
  ],
  [
    324,
    2
  ],
  [
    325,
    1,
    ""
  ],
  [
    326,
    2
  ],
  [
    327,
    1,
    ""
  ],
  [
    328,
    2
  ],
  [
    329,
    1,
    "n"
  ],
  [
    330,
    1,
    ""
  ],
  [
    331,
    2
  ],
  [
    332,
    1,
    ""
  ],
  [
    333,
    2
  ],
  [
    334,
    1,
    ""
  ],
  [
    335,
    2
  ],
  [
    336,
    1,
    ""
  ],
  [
    337,
    2
  ],
  [
    338,
    1,
    ""
  ],
  [
    339,
    2
  ],
  [
    340,
    1,
    ""
  ],
  [
    341,
    2
  ],
  [
    342,
    1,
    ""
  ],
  [
    343,
    2
  ],
  [
    344,
    1,
    ""
  ],
  [
    345,
    2
  ],
  [
    346,
    1,
    ""
  ],
  [
    347,
    2
  ],
  [
    348,
    1,
    ""
  ],
  [
    349,
    2
  ],
  [
    350,
    1,
    ""
  ],
  [
    351,
    2
  ],
  [
    352,
    1,
    ""
  ],
  [
    353,
    2
  ],
  [
    354,
    1,
    ""
  ],
  [
    355,
    2
  ],
  [
    356,
    1,
    ""
  ],
  [
    357,
    2
  ],
  [
    358,
    1,
    ""
  ],
  [
    359,
    2
  ],
  [
    360,
    1,
    ""
  ],
  [
    361,
    2
  ],
  [
    362,
    1,
    ""
  ],
  [
    363,
    2
  ],
  [
    364,
    1,
    ""
  ],
  [
    365,
    2
  ],
  [
    366,
    1,
    ""
  ],
  [
    367,
    2
  ],
  [
    368,
    1,
    ""
  ],
  [
    369,
    2
  ],
  [
    370,
    1,
    ""
  ],
  [
    371,
    2
  ],
  [
    372,
    1,
    ""
  ],
  [
    373,
    2
  ],
  [
    374,
    1,
    ""
  ],
  [
    375,
    2
  ],
  [
    376,
    1,
    ""
  ],
  [
    377,
    1,
    ""
  ],
  [
    378,
    2
  ],
  [
    379,
    1,
    ""
  ],
  [
    380,
    2
  ],
  [
    381,
    1,
    ""
  ],
  [
    382,
    2
  ],
  [
    383,
    1,
    "s"
  ],
  [
    384,
    2
  ],
  [
    385,
    1,
    ""
  ],
  [
    386,
    1,
    ""
  ],
  [
    387,
    2
  ],
  [
    388,
    1,
    ""
  ],
  [
    389,
    2
  ],
  [
    390,
    1,
    ""
  ],
  [
    391,
    1,
    ""
  ],
  [
    392,
    2
  ],
  [
    393,
    1,
    ""
  ],
  [
    394,
    1,
    ""
  ],
  [
    395,
    1,
    ""
  ],
  [
    [
      396,
      397
    ],
    2
  ],
  [
    398,
    1,
    ""
  ],
  [
    399,
    1,
    ""
  ],
  [
    400,
    1,
    ""
  ],
  [
    401,
    1,
    ""
  ],
  [
    402,
    2
  ],
  [
    403,
    1,
    ""
  ],
  [
    404,
    1,
    ""
  ],
  [
    405,
    2
  ],
  [
    406,
    1,
    ""
  ],
  [
    407,
    1,
    ""
  ],
  [
    408,
    1,
    ""
  ],
  [
    [
      409,
      411
    ],
    2
  ],
  [
    412,
    1,
    ""
  ],
  [
    413,
    1,
    ""
  ],
  [
    414,
    2
  ],
  [
    415,
    1,
    ""
  ],
  [
    416,
    1,
    ""
  ],
  [
    417,
    2
  ],
  [
    418,
    1,
    ""
  ],
  [
    419,
    2
  ],
  [
    420,
    1,
    ""
  ],
  [
    421,
    2
  ],
  [
    422,
    1,
    ""
  ],
  [
    423,
    1,
    ""
  ],
  [
    424,
    2
  ],
  [
    425,
    1,
    ""
  ],
  [
    [
      426,
      427
    ],
    2
  ],
  [
    428,
    1,
    ""
  ],
  [
    429,
    2
  ],
  [
    430,
    1,
    ""
  ],
  [
    431,
    1,
    ""
  ],
  [
    432,
    2
  ],
  [
    433,
    1,
    ""
  ],
  [
    434,
    1,
    ""
  ],
  [
    435,
    1,
    ""
  ],
  [
    436,
    2
  ],
  [
    437,
    1,
    ""
  ],
  [
    438,
    2
  ],
  [
    439,
    1,
    ""
  ],
  [
    440,
    1,
    ""
  ],
  [
    [
      441,
      443
    ],
    2
  ],
  [
    444,
    1,
    ""
  ],
  [
    [
      445,
      451
    ],
    2
  ],
  [
    [
      452,
      454
    ],
    1,
    "d"
  ],
  [
    [
      455,
      457
    ],
    1,
    "lj"
  ],
  [
    [
      458,
      460
    ],
    1,
    "nj"
  ],
  [
    461,
    1,
    ""
  ],
  [
    462,
    2
  ],
  [
    463,
    1,
    ""
  ],
  [
    464,
    2
  ],
  [
    465,
    1,
    ""
  ],
  [
    466,
    2
  ],
  [
    467,
    1,
    ""
  ],
  [
    468,
    2
  ],
  [
    469,
    1,
    ""
  ],
  [
    470,
    2
  ],
  [
    471,
    1,
    ""
  ],
  [
    472,
    2
  ],
  [
    473,
    1,
    ""
  ],
  [
    474,
    2
  ],
  [
    475,
    1,
    ""
  ],
  [
    [
      476,
      477
    ],
    2
  ],
  [
    478,
    1,
    ""
  ],
  [
    479,
    2
  ],
  [
    480,
    1,
    ""
  ],
  [
    481,
    2
  ],
  [
    482,
    1,
    ""
  ],
  [
    483,
    2
  ],
  [
    484,
    1,
    ""
  ],
  [
    485,
    2
  ],
  [
    486,
    1,
    ""
  ],
  [
    487,
    2
  ],
  [
    488,
    1,
    ""
  ],
  [
    489,
    2
  ],
  [
    490,
    1,
    ""
  ],
  [
    491,
    2
  ],
  [
    492,
    1,
    ""
  ],
  [
    493,
    2
  ],
  [
    494,
    1,
    ""
  ],
  [
    [
      495,
      496
    ],
    2
  ],
  [
    [
      497,
      499
    ],
    1,
    "dz"
  ],
  [
    500,
    1,
    ""
  ],
  [
    501,
    2
  ],
  [
    502,
    1,
    ""
  ],
  [
    503,
    1,
    ""
  ],
  [
    504,
    1,
    ""
  ],
  [
    505,
    2
  ],
  [
    506,
    1,
    ""
  ],
  [
    507,
    2
  ],
  [
    508,
    1,
    ""
  ],
  [
    509,
    2
  ],
  [
    510,
    1,
    ""
  ],
  [
    511,
    2
  ],
  [
    512,
    1,
    ""
  ],
  [
    513,
    2
  ],
  [
    514,
    1,
    ""
  ],
  [
    515,
    2
  ],
  [
    516,
    1,
    ""
  ],
  [
    517,
    2
  ],
  [
    518,
    1,
    ""
  ],
  [
    519,
    2
  ],
  [
    520,
    1,
    ""
  ],
  [
    521,
    2
  ],
  [
    522,
    1,
    ""
  ],
  [
    523,
    2
  ],
  [
    524,
    1,
    ""
  ],
  [
    525,
    2
  ],
  [
    526,
    1,
    ""
  ],
  [
    527,
    2
  ],
  [
    528,
    1,
    ""
  ],
  [
    529,
    2
  ],
  [
    530,
    1,
    ""
  ],
  [
    531,
    2
  ],
  [
    532,
    1,
    ""
  ],
  [
    533,
    2
  ],
  [
    534,
    1,
    ""
  ],
  [
    535,
    2
  ],
  [
    536,
    1,
    ""
  ],
  [
    537,
    2
  ],
  [
    538,
    1,
    ""
  ],
  [
    539,
    2
  ],
  [
    540,
    1,
    ""
  ],
  [
    541,
    2
  ],
  [
    542,
    1,
    ""
  ],
  [
    543,
    2
  ],
  [
    544,
    1,
    ""
  ],
  [
    545,
    2
  ],
  [
    546,
    1,
    ""
  ],
  [
    547,
    2
  ],
  [
    548,
    1,
    ""
  ],
  [
    549,
    2
  ],
  [
    550,
    1,
    ""
  ],
  [
    551,
    2
  ],
  [
    552,
    1,
    ""
  ],
  [
    553,
    2
  ],
  [
    554,
    1,
    ""
  ],
  [
    555,
    2
  ],
  [
    556,
    1,
    ""
  ],
  [
    557,
    2
  ],
  [
    558,
    1,
    ""
  ],
  [
    559,
    2
  ],
  [
    560,
    1,
    ""
  ],
  [
    561,
    2
  ],
  [
    562,
    1,
    ""
  ],
  [
    563,
    2
  ],
  [
    [
      564,
      566
    ],
    2
  ],
  [
    [
      567,
      569
    ],
    2
  ],
  [
    570,
    1,
    ""
  ],
  [
    571,
    1,
    ""
  ],
  [
    572,
    2
  ],
  [
    573,
    1,
    ""
  ],
  [
    574,
    1,
    ""
  ],
  [
    [
      575,
      576
    ],
    2
  ],
  [
    577,
    1,
    ""
  ],
  [
    578,
    2
  ],
  [
    579,
    1,
    ""
  ],
  [
    580,
    1,
    ""
  ],
  [
    581,
    1,
    ""
  ],
  [
    582,
    1,
    ""
  ],
  [
    583,
    2
  ],
  [
    584,
    1,
    ""
  ],
  [
    585,
    2
  ],
  [
    586,
    1,
    ""
  ],
  [
    587,
    2
  ],
  [
    588,
    1,
    ""
  ],
  [
    589,
    2
  ],
  [
    590,
    1,
    ""
  ],
  [
    591,
    2
  ],
  [
    [
      592,
      680
    ],
    2
  ],
  [
    [
      681,
      685
    ],
    2
  ],
  [
    [
      686,
      687
    ],
    2
  ],
  [
    688,
    1,
    "h"
  ],
  [
    689,
    1,
    ""
  ],
  [
    690,
    1,
    "j"
  ],
  [
    691,
    1,
    "r"
  ],
  [
    692,
    1,
    ""
  ],
  [
    693,
    1,
    ""
  ],
  [
    694,
    1,
    ""
  ],
  [
    695,
    1,
    "w"
  ],
  [
    696,
    1,
    "y"
  ],
  [
    [
      697,
      705
    ],
    2
  ],
  [
    [
      706,
      709
    ],
    2
  ],
  [
    [
      710,
      721
    ],
    2
  ],
  [
    [
      722,
      727
    ],
    2
  ],
  [
    728,
    5,
    " "
  ],
  [
    729,
    5,
    " "
  ],
  [
    730,
    5,
    " "
  ],
  [
    731,
    5,
    " "
  ],
  [
    732,
    5,
    " "
  ],
  [
    733,
    5,
    " "
  ],
  [
    734,
    2
  ],
  [
    735,
    2
  ],
  [
    736,
    1,
    ""
  ],
  [
    737,
    1,
    "l"
  ],
  [
    738,
    1,
    "s"
  ],
  [
    739,
    1,
    "x"
  ],
  [
    740,
    1,
    ""
  ],
  [
    [
      741,
      745
    ],
    2
  ],
  [
    [
      746,
      747
    ],
    2
  ],
  [
    748,
    2
  ],
  [
    749,
    2
  ],
  [
    750,
    2
  ],
  [
    [
      751,
      767
    ],
    2
  ],
  [
    [
      768,
      831
    ],
    2
  ],
  [
    832,
    1,
    ""
  ],
  [
    833,
    1,
    ""
  ],
  [
    834,
    2
  ],
  [
    835,
    1,
    ""
  ],
  [
    836,
    1,
    ""
  ],
  [
    837,
    1,
    ""
  ],
  [
    [
      838,
      846
    ],
    2
  ],
  [
    847,
    7
  ],
  [
    [
      848,
      855
    ],
    2
  ],
  [
    [
      856,
      860
    ],
    2
  ],
  [
    [
      861,
      863
    ],
    2
  ],
  [
    [
      864,
      865
    ],
    2
  ],
  [
    866,
    2
  ],
  [
    [
      867,
      879
    ],
    2
  ],
  [
    880,
    1,
    ""
  ],
  [
    881,
    2
  ],
  [
    882,
    1,
    ""
  ],
  [
    883,
    2
  ],
  [
    884,
    1,
    ""
  ],
  [
    885,
    2
  ],
  [
    886,
    1,
    ""
  ],
  [
    887,
    2
  ],
  [
    [
      888,
      889
    ],
    3
  ],
  [
    890,
    5,
    " "
  ],
  [
    [
      891,
      893
    ],
    2
  ],
  [
    894,
    5,
    ";"
  ],
  [
    895,
    1,
    ""
  ],
  [
    [
      896,
      899
    ],
    3
  ],
  [
    900,
    5,
    " "
  ],
  [
    901,
    5,
    " "
  ],
  [
    902,
    1,
    ""
  ],
  [
    903,
    1,
    ""
  ],
  [
    904,
    1,
    ""
  ],
  [
    905,
    1,
    ""
  ],
  [
    906,
    1,
    ""
  ],
  [
    907,
    3
  ],
  [
    908,
    1,
    ""
  ],
  [
    909,
    3
  ],
  [
    910,
    1,
    ""
  ],
  [
    911,
    1,
    ""
  ],
  [
    912,
    2
  ],
  [
    913,
    1,
    ""
  ],
  [
    914,
    1,
    ""
  ],
  [
    915,
    1,
    ""
  ],
  [
    916,
    1,
    ""
  ],
  [
    917,
    1,
    ""
  ],
  [
    918,
    1,
    ""
  ],
  [
    919,
    1,
    ""
  ],
  [
    920,
    1,
    ""
  ],
  [
    921,
    1,
    ""
  ],
  [
    922,
    1,
    ""
  ],
  [
    923,
    1,
    ""
  ],
  [
    924,
    1,
    ""
  ],
  [
    925,
    1,
    ""
  ],
  [
    926,
    1,
    ""
  ],
  [
    927,
    1,
    ""
  ],
  [
    928,
    1,
    ""
  ],
  [
    929,
    1,
    ""
  ],
  [
    930,
    3
  ],
  [
    931,
    1,
    ""
  ],
  [
    932,
    1,
    ""
  ],
  [
    933,
    1,
    ""
  ],
  [
    934,
    1,
    ""
  ],
  [
    935,
    1,
    ""
  ],
  [
    936,
    1,
    ""
  ],
  [
    937,
    1,
    ""
  ],
  [
    938,
    1,
    ""
  ],
  [
    939,
    1,
    ""
  ],
  [
    [
      940,
      961
    ],
    2
  ],
  [
    962,
    6,
    ""
  ],
  [
    [
      963,
      974
    ],
    2
  ],
  [
    975,
    1,
    ""
  ],
  [
    976,
    1,
    ""
  ],
  [
    977,
    1,
    ""
  ],
  [
    978,
    1,
    ""
  ],
  [
    979,
    1,
    ""
  ],
  [
    980,
    1,
    ""
  ],
  [
    981,
    1,
    ""
  ],
  [
    982,
    1,
    ""
  ],
  [
    983,
    2
  ],
  [
    984,
    1,
    ""
  ],
  [
    985,
    2
  ],
  [
    986,
    1,
    ""
  ],
  [
    987,
    2
  ],
  [
    988,
    1,
    ""
  ],
  [
    989,
    2
  ],
  [
    990,
    1,
    ""
  ],
  [
    991,
    2
  ],
  [
    992,
    1,
    ""
  ],
  [
    993,
    2
  ],
  [
    994,
    1,
    ""
  ],
  [
    995,
    2
  ],
  [
    996,
    1,
    ""
  ],
  [
    997,
    2
  ],
  [
    998,
    1,
    ""
  ],
  [
    999,
    2
  ],
  [
    1e3,
    1,
    ""
  ],
  [
    1001,
    2
  ],
  [
    1002,
    1,
    ""
  ],
  [
    1003,
    2
  ],
  [
    1004,
    1,
    ""
  ],
  [
    1005,
    2
  ],
  [
    1006,
    1,
    ""
  ],
  [
    1007,
    2
  ],
  [
    1008,
    1,
    ""
  ],
  [
    1009,
    1,
    ""
  ],
  [
    1010,
    1,
    ""
  ],
  [
    1011,
    2
  ],
  [
    1012,
    1,
    ""
  ],
  [
    1013,
    1,
    ""
  ],
  [
    1014,
    2
  ],
  [
    1015,
    1,
    ""
  ],
  [
    1016,
    2
  ],
  [
    1017,
    1,
    ""
  ],
  [
    1018,
    1,
    ""
  ],
  [
    1019,
    2
  ],
  [
    1020,
    2
  ],
  [
    1021,
    1,
    ""
  ],
  [
    1022,
    1,
    ""
  ],
  [
    1023,
    1,
    ""
  ],
  [
    1024,
    1,
    ""
  ],
  [
    1025,
    1,
    ""
  ],
  [
    1026,
    1,
    ""
  ],
  [
    1027,
    1,
    ""
  ],
  [
    1028,
    1,
    ""
  ],
  [
    1029,
    1,
    ""
  ],
  [
    1030,
    1,
    ""
  ],
  [
    1031,
    1,
    ""
  ],
  [
    1032,
    1,
    ""
  ],
  [
    1033,
    1,
    ""
  ],
  [
    1034,
    1,
    ""
  ],
  [
    1035,
    1,
    ""
  ],
  [
    1036,
    1,
    ""
  ],
  [
    1037,
    1,
    ""
  ],
  [
    1038,
    1,
    ""
  ],
  [
    1039,
    1,
    ""
  ],
  [
    1040,
    1,
    ""
  ],
  [
    1041,
    1,
    ""
  ],
  [
    1042,
    1,
    ""
  ],
  [
    1043,
    1,
    ""
  ],
  [
    1044,
    1,
    ""
  ],
  [
    1045,
    1,
    ""
  ],
  [
    1046,
    1,
    ""
  ],
  [
    1047,
    1,
    ""
  ],
  [
    1048,
    1,
    ""
  ],
  [
    1049,
    1,
    ""
  ],
  [
    1050,
    1,
    ""
  ],
  [
    1051,
    1,
    ""
  ],
  [
    1052,
    1,
    ""
  ],
  [
    1053,
    1,
    ""
  ],
  [
    1054,
    1,
    ""
  ],
  [
    1055,
    1,
    ""
  ],
  [
    1056,
    1,
    ""
  ],
  [
    1057,
    1,
    ""
  ],
  [
    1058,
    1,
    ""
  ],
  [
    1059,
    1,
    ""
  ],
  [
    1060,
    1,
    ""
  ],
  [
    1061,
    1,
    ""
  ],
  [
    1062,
    1,
    ""
  ],
  [
    1063,
    1,
    ""
  ],
  [
    1064,
    1,
    ""
  ],
  [
    1065,
    1,
    ""
  ],
  [
    1066,
    1,
    ""
  ],
  [
    1067,
    1,
    ""
  ],
  [
    1068,
    1,
    ""
  ],
  [
    1069,
    1,
    ""
  ],
  [
    1070,
    1,
    ""
  ],
  [
    1071,
    1,
    ""
  ],
  [
    [
      1072,
      1103
    ],
    2
  ],
  [
    1104,
    2
  ],
  [
    [
      1105,
      1116
    ],
    2
  ],
  [
    1117,
    2
  ],
  [
    [
      1118,
      1119
    ],
    2
  ],
  [
    1120,
    1,
    ""
  ],
  [
    1121,
    2
  ],
  [
    1122,
    1,
    ""
  ],
  [
    1123,
    2
  ],
  [
    1124,
    1,
    ""
  ],
  [
    1125,
    2
  ],
  [
    1126,
    1,
    ""
  ],
  [
    1127,
    2
  ],
  [
    1128,
    1,
    ""
  ],
  [
    1129,
    2
  ],
  [
    1130,
    1,
    ""
  ],
  [
    1131,
    2
  ],
  [
    1132,
    1,
    ""
  ],
  [
    1133,
    2
  ],
  [
    1134,
    1,
    ""
  ],
  [
    1135,
    2
  ],
  [
    1136,
    1,
    ""
  ],
  [
    1137,
    2
  ],
  [
    1138,
    1,
    ""
  ],
  [
    1139,
    2
  ],
  [
    1140,
    1,
    ""
  ],
  [
    1141,
    2
  ],
  [
    1142,
    1,
    ""
  ],
  [
    1143,
    2
  ],
  [
    1144,
    1,
    ""
  ],
  [
    1145,
    2
  ],
  [
    1146,
    1,
    ""
  ],
  [
    1147,
    2
  ],
  [
    1148,
    1,
    ""
  ],
  [
    1149,
    2
  ],
  [
    1150,
    1,
    ""
  ],
  [
    1151,
    2
  ],
  [
    1152,
    1,
    ""
  ],
  [
    1153,
    2
  ],
  [
    1154,
    2
  ],
  [
    [
      1155,
      1158
    ],
    2
  ],
  [
    1159,
    2
  ],
  [
    [
      1160,
      1161
    ],
    2
  ],
  [
    1162,
    1,
    ""
  ],
  [
    1163,
    2
  ],
  [
    1164,
    1,
    ""
  ],
  [
    1165,
    2
  ],
  [
    1166,
    1,
    ""
  ],
  [
    1167,
    2
  ],
  [
    1168,
    1,
    ""
  ],
  [
    1169,
    2
  ],
  [
    1170,
    1,
    ""
  ],
  [
    1171,
    2
  ],
  [
    1172,
    1,
    ""
  ],
  [
    1173,
    2
  ],
  [
    1174,
    1,
    ""
  ],
  [
    1175,
    2
  ],
  [
    1176,
    1,
    ""
  ],
  [
    1177,
    2
  ],
  [
    1178,
    1,
    ""
  ],
  [
    1179,
    2
  ],
  [
    1180,
    1,
    ""
  ],
  [
    1181,
    2
  ],
  [
    1182,
    1,
    ""
  ],
  [
    1183,
    2
  ],
  [
    1184,
    1,
    ""
  ],
  [
    1185,
    2
  ],
  [
    1186,
    1,
    ""
  ],
  [
    1187,
    2
  ],
  [
    1188,
    1,
    ""
  ],
  [
    1189,
    2
  ],
  [
    1190,
    1,
    ""
  ],
  [
    1191,
    2
  ],
  [
    1192,
    1,
    ""
  ],
  [
    1193,
    2
  ],
  [
    1194,
    1,
    ""
  ],
  [
    1195,
    2
  ],
  [
    1196,
    1,
    ""
  ],
  [
    1197,
    2
  ],
  [
    1198,
    1,
    ""
  ],
  [
    1199,
    2
  ],
  [
    1200,
    1,
    ""
  ],
  [
    1201,
    2
  ],
  [
    1202,
    1,
    ""
  ],
  [
    1203,
    2
  ],
  [
    1204,
    1,
    ""
  ],
  [
    1205,
    2
  ],
  [
    1206,
    1,
    ""
  ],
  [
    1207,
    2
  ],
  [
    1208,
    1,
    ""
  ],
  [
    1209,
    2
  ],
  [
    1210,
    1,
    ""
  ],
  [
    1211,
    2
  ],
  [
    1212,
    1,
    ""
  ],
  [
    1213,
    2
  ],
  [
    1214,
    1,
    ""
  ],
  [
    1215,
    2
  ],
  [
    1216,
    3
  ],
  [
    1217,
    1,
    ""
  ],
  [
    1218,
    2
  ],
  [
    1219,
    1,
    ""
  ],
  [
    1220,
    2
  ],
  [
    1221,
    1,
    ""
  ],
  [
    1222,
    2
  ],
  [
    1223,
    1,
    ""
  ],
  [
    1224,
    2
  ],
  [
    1225,
    1,
    ""
  ],
  [
    1226,
    2
  ],
  [
    1227,
    1,
    ""
  ],
  [
    1228,
    2
  ],
  [
    1229,
    1,
    ""
  ],
  [
    1230,
    2
  ],
  [
    1231,
    2
  ],
  [
    1232,
    1,
    ""
  ],
  [
    1233,
    2
  ],
  [
    1234,
    1,
    ""
  ],
  [
    1235,
    2
  ],
  [
    1236,
    1,
    ""
  ],
  [
    1237,
    2
  ],
  [
    1238,
    1,
    ""
  ],
  [
    1239,
    2
  ],
  [
    1240,
    1,
    ""
  ],
  [
    1241,
    2
  ],
  [
    1242,
    1,
    ""
  ],
  [
    1243,
    2
  ],
  [
    1244,
    1,
    ""
  ],
  [
    1245,
    2
  ],
  [
    1246,
    1,
    ""
  ],
  [
    1247,
    2
  ],
  [
    1248,
    1,
    ""
  ],
  [
    1249,
    2
  ],
  [
    1250,
    1,
    ""
  ],
  [
    1251,
    2
  ],
  [
    1252,
    1,
    ""
  ],
  [
    1253,
    2
  ],
  [
    1254,
    1,
    ""
  ],
  [
    1255,
    2
  ],
  [
    1256,
    1,
    ""
  ],
  [
    1257,
    2
  ],
  [
    1258,
    1,
    ""
  ],
  [
    1259,
    2
  ],
  [
    1260,
    1,
    ""
  ],
  [
    1261,
    2
  ],
  [
    1262,
    1,
    ""
  ],
  [
    1263,
    2
  ],
  [
    1264,
    1,
    ""
  ],
  [
    1265,
    2
  ],
  [
    1266,
    1,
    ""
  ],
  [
    1267,
    2
  ],
  [
    1268,
    1,
    ""
  ],
  [
    1269,
    2
  ],
  [
    1270,
    1,
    ""
  ],
  [
    1271,
    2
  ],
  [
    1272,
    1,
    ""
  ],
  [
    1273,
    2
  ],
  [
    1274,
    1,
    ""
  ],
  [
    1275,
    2
  ],
  [
    1276,
    1,
    ""
  ],
  [
    1277,
    2
  ],
  [
    1278,
    1,
    ""
  ],
  [
    1279,
    2
  ],
  [
    1280,
    1,
    ""
  ],
  [
    1281,
    2
  ],
  [
    1282,
    1,
    ""
  ],
  [
    1283,
    2
  ],
  [
    1284,
    1,
    ""
  ],
  [
    1285,
    2
  ],
  [
    1286,
    1,
    ""
  ],
  [
    1287,
    2
  ],
  [
    1288,
    1,
    ""
  ],
  [
    1289,
    2
  ],
  [
    1290,
    1,
    ""
  ],
  [
    1291,
    2
  ],
  [
    1292,
    1,
    ""
  ],
  [
    1293,
    2
  ],
  [
    1294,
    1,
    ""
  ],
  [
    1295,
    2
  ],
  [
    1296,
    1,
    ""
  ],
  [
    1297,
    2
  ],
  [
    1298,
    1,
    ""
  ],
  [
    1299,
    2
  ],
  [
    1300,
    1,
    ""
  ],
  [
    1301,
    2
  ],
  [
    1302,
    1,
    ""
  ],
  [
    1303,
    2
  ],
  [
    1304,
    1,
    ""
  ],
  [
    1305,
    2
  ],
  [
    1306,
    1,
    ""
  ],
  [
    1307,
    2
  ],
  [
    1308,
    1,
    ""
  ],
  [
    1309,
    2
  ],
  [
    1310,
    1,
    ""
  ],
  [
    1311,
    2
  ],
  [
    1312,
    1,
    ""
  ],
  [
    1313,
    2
  ],
  [
    1314,
    1,
    ""
  ],
  [
    1315,
    2
  ],
  [
    1316,
    1,
    ""
  ],
  [
    1317,
    2
  ],
  [
    1318,
    1,
    ""
  ],
  [
    1319,
    2
  ],
  [
    1320,
    1,
    ""
  ],
  [
    1321,
    2
  ],
  [
    1322,
    1,
    ""
  ],
  [
    1323,
    2
  ],
  [
    1324,
    1,
    ""
  ],
  [
    1325,
    2
  ],
  [
    1326,
    1,
    ""
  ],
  [
    1327,
    2
  ],
  [
    1328,
    3
  ],
  [
    1329,
    1,
    ""
  ],
  [
    1330,
    1,
    ""
  ],
  [
    1331,
    1,
    ""
  ],
  [
    1332,
    1,
    ""
  ],
  [
    1333,
    1,
    ""
  ],
  [
    1334,
    1,
    ""
  ],
  [
    1335,
    1,
    ""
  ],
  [
    1336,
    1,
    ""
  ],
  [
    1337,
    1,
    ""
  ],
  [
    1338,
    1,
    ""
  ],
  [
    1339,
    1,
    ""
  ],
  [
    1340,
    1,
    ""
  ],
  [
    1341,
    1,
    ""
  ],
  [
    1342,
    1,
    ""
  ],
  [
    1343,
    1,
    ""
  ],
  [
    1344,
    1,
    ""
  ],
  [
    1345,
    1,
    ""
  ],
  [
    1346,
    1,
    ""
  ],
  [
    1347,
    1,
    ""
  ],
  [
    1348,
    1,
    ""
  ],
  [
    1349,
    1,
    ""
  ],
  [
    1350,
    1,
    ""
  ],
  [
    1351,
    1,
    ""
  ],
  [
    1352,
    1,
    ""
  ],
  [
    1353,
    1,
    ""
  ],
  [
    1354,
    1,
    ""
  ],
  [
    1355,
    1,
    ""
  ],
  [
    1356,
    1,
    ""
  ],
  [
    1357,
    1,
    ""
  ],
  [
    1358,
    1,
    ""
  ],
  [
    1359,
    1,
    ""
  ],
  [
    1360,
    1,
    ""
  ],
  [
    1361,
    1,
    ""
  ],
  [
    1362,
    1,
    ""
  ],
  [
    1363,
    1,
    ""
  ],
  [
    1364,
    1,
    ""
  ],
  [
    1365,
    1,
    ""
  ],
  [
    1366,
    1,
    ""
  ],
  [
    [
      1367,
      1368
    ],
    3
  ],
  [
    1369,
    2
  ],
  [
    [
      1370,
      1375
    ],
    2
  ],
  [
    1376,
    2
  ],
  [
    [
      1377,
      1414
    ],
    2
  ],
  [
    1415,
    1,
    ""
  ],
  [
    1416,
    2
  ],
  [
    1417,
    2
  ],
  [
    1418,
    2
  ],
  [
    [
      1419,
      1420
    ],
    3
  ],
  [
    [
      1421,
      1422
    ],
    2
  ],
  [
    1423,
    2
  ],
  [
    1424,
    3
  ],
  [
    [
      1425,
      1441
    ],
    2
  ],
  [
    1442,
    2
  ],
  [
    [
      1443,
      1455
    ],
    2
  ],
  [
    [
      1456,
      1465
    ],
    2
  ],
  [
    1466,
    2
  ],
  [
    [
      1467,
      1469
    ],
    2
  ],
  [
    1470,
    2
  ],
  [
    1471,
    2
  ],
  [
    1472,
    2
  ],
  [
    [
      1473,
      1474
    ],
    2
  ],
  [
    1475,
    2
  ],
  [
    1476,
    2
  ],
  [
    1477,
    2
  ],
  [
    1478,
    2
  ],
  [
    1479,
    2
  ],
  [
    [
      1480,
      1487
    ],
    3
  ],
  [
    [
      1488,
      1514
    ],
    2
  ],
  [
    [
      1515,
      1518
    ],
    3
  ],
  [
    1519,
    2
  ],
  [
    [
      1520,
      1524
    ],
    2
  ],
  [
    [
      1525,
      1535
    ],
    3
  ],
  [
    [
      1536,
      1539
    ],
    3
  ],
  [
    1540,
    3
  ],
  [
    1541,
    3
  ],
  [
    [
      1542,
      1546
    ],
    2
  ],
  [
    1547,
    2
  ],
  [
    1548,
    2
  ],
  [
    [
      1549,
      1551
    ],
    2
  ],
  [
    [
      1552,
      1557
    ],
    2
  ],
  [
    [
      1558,
      1562
    ],
    2
  ],
  [
    1563,
    2
  ],
  [
    1564,
    3
  ],
  [
    1565,
    2
  ],
  [
    1566,
    2
  ],
  [
    1567,
    2
  ],
  [
    1568,
    2
  ],
  [
    [
      1569,
      1594
    ],
    2
  ],
  [
    [
      1595,
      1599
    ],
    2
  ],
  [
    1600,
    2
  ],
  [
    [
      1601,
      1618
    ],
    2
  ],
  [
    [
      1619,
      1621
    ],
    2
  ],
  [
    [
      1622,
      1624
    ],
    2
  ],
  [
    [
      1625,
      1630
    ],
    2
  ],
  [
    1631,
    2
  ],
  [
    [
      1632,
      1641
    ],
    2
  ],
  [
    [
      1642,
      1645
    ],
    2
  ],
  [
    [
      1646,
      1647
    ],
    2
  ],
  [
    [
      1648,
      1652
    ],
    2
  ],
  [
    1653,
    1,
    ""
  ],
  [
    1654,
    1,
    ""
  ],
  [
    1655,
    1,
    ""
  ],
  [
    1656,
    1,
    ""
  ],
  [
    [
      1657,
      1719
    ],
    2
  ],
  [
    [
      1720,
      1721
    ],
    2
  ],
  [
    [
      1722,
      1726
    ],
    2
  ],
  [
    1727,
    2
  ],
  [
    [
      1728,
      1742
    ],
    2
  ],
  [
    1743,
    2
  ],
  [
    [
      1744,
      1747
    ],
    2
  ],
  [
    1748,
    2
  ],
  [
    [
      1749,
      1756
    ],
    2
  ],
  [
    1757,
    3
  ],
  [
    1758,
    2
  ],
  [
    [
      1759,
      1768
    ],
    2
  ],
  [
    1769,
    2
  ],
  [
    [
      1770,
      1773
    ],
    2
  ],
  [
    [
      1774,
      1775
    ],
    2
  ],
  [
    [
      1776,
      1785
    ],
    2
  ],
  [
    [
      1786,
      1790
    ],
    2
  ],
  [
    1791,
    2
  ],
  [
    [
      1792,
      1805
    ],
    2
  ],
  [
    1806,
    3
  ],
  [
    1807,
    3
  ],
  [
    [
      1808,
      1836
    ],
    2
  ],
  [
    [
      1837,
      1839
    ],
    2
  ],
  [
    [
      1840,
      1866
    ],
    2
  ],
  [
    [
      1867,
      1868
    ],
    3
  ],
  [
    [
      1869,
      1871
    ],
    2
  ],
  [
    [
      1872,
      1901
    ],
    2
  ],
  [
    [
      1902,
      1919
    ],
    2
  ],
  [
    [
      1920,
      1968
    ],
    2
  ],
  [
    1969,
    2
  ],
  [
    [
      1970,
      1983
    ],
    3
  ],
  [
    [
      1984,
      2037
    ],
    2
  ],
  [
    [
      2038,
      2042
    ],
    2
  ],
  [
    [
      2043,
      2044
    ],
    3
  ],
  [
    2045,
    2
  ],
  [
    [
      2046,
      2047
    ],
    2
  ],
  [
    [
      2048,
      2093
    ],
    2
  ],
  [
    [
      2094,
      2095
    ],
    3
  ],
  [
    [
      2096,
      2110
    ],
    2
  ],
  [
    2111,
    3
  ],
  [
    [
      2112,
      2139
    ],
    2
  ],
  [
    [
      2140,
      2141
    ],
    3
  ],
  [
    2142,
    2
  ],
  [
    2143,
    3
  ],
  [
    [
      2144,
      2154
    ],
    2
  ],
  [
    [
      2155,
      2159
    ],
    3
  ],
  [
    [
      2160,
      2183
    ],
    2
  ],
  [
    2184,
    2
  ],
  [
    [
      2185,
      2190
    ],
    2
  ],
  [
    2191,
    3
  ],
  [
    [
      2192,
      2193
    ],
    3
  ],
  [
    [
      2194,
      2199
    ],
    3
  ],
  [
    [
      2200,
      2207
    ],
    2
  ],
  [
    2208,
    2
  ],
  [
    2209,
    2
  ],
  [
    [
      2210,
      2220
    ],
    2
  ],
  [
    [
      2221,
      2226
    ],
    2
  ],
  [
    [
      2227,
      2228
    ],
    2
  ],
  [
    2229,
    2
  ],
  [
    [
      2230,
      2237
    ],
    2
  ],
  [
    [
      2238,
      2247
    ],
    2
  ],
  [
    [
      2248,
      2258
    ],
    2
  ],
  [
    2259,
    2
  ],
  [
    [
      2260,
      2273
    ],
    2
  ],
  [
    2274,
    3
  ],
  [
    2275,
    2
  ],
  [
    [
      2276,
      2302
    ],
    2
  ],
  [
    2303,
    2
  ],
  [
    2304,
    2
  ],
  [
    [
      2305,
      2307
    ],
    2
  ],
  [
    2308,
    2
  ],
  [
    [
      2309,
      2361
    ],
    2
  ],
  [
    [
      2362,
      2363
    ],
    2
  ],
  [
    [
      2364,
      2381
    ],
    2
  ],
  [
    2382,
    2
  ],
  [
    2383,
    2
  ],
  [
    [
      2384,
      2388
    ],
    2
  ],
  [
    2389,
    2
  ],
  [
    [
      2390,
      2391
    ],
    2
  ],
  [
    2392,
    1,
    ""
  ],
  [
    2393,
    1,
    ""
  ],
  [
    2394,
    1,
    ""
  ],
  [
    2395,
    1,
    ""
  ],
  [
    2396,
    1,
    ""
  ],
  [
    2397,
    1,
    ""
  ],
  [
    2398,
    1,
    ""
  ],
  [
    2399,
    1,
    ""
  ],
  [
    [
      2400,
      2403
    ],
    2
  ],
  [
    [
      2404,
      2405
    ],
    2
  ],
  [
    [
      2406,
      2415
    ],
    2
  ],
  [
    2416,
    2
  ],
  [
    [
      2417,
      2418
    ],
    2
  ],
  [
    [
      2419,
      2423
    ],
    2
  ],
  [
    2424,
    2
  ],
  [
    [
      2425,
      2426
    ],
    2
  ],
  [
    [
      2427,
      2428
    ],
    2
  ],
  [
    2429,
    2
  ],
  [
    [
      2430,
      2431
    ],
    2
  ],
  [
    2432,
    2
  ],
  [
    [
      2433,
      2435
    ],
    2
  ],
  [
    2436,
    3
  ],
  [
    [
      2437,
      2444
    ],
    2
  ],
  [
    [
      2445,
      2446
    ],
    3
  ],
  [
    [
      2447,
      2448
    ],
    2
  ],
  [
    [
      2449,
      2450
    ],
    3
  ],
  [
    [
      2451,
      2472
    ],
    2
  ],
  [
    2473,
    3
  ],
  [
    [
      2474,
      2480
    ],
    2
  ],
  [
    2481,
    3
  ],
  [
    2482,
    2
  ],
  [
    [
      2483,
      2485
    ],
    3
  ],
  [
    [
      2486,
      2489
    ],
    2
  ],
  [
    [
      2490,
      2491
    ],
    3
  ],
  [
    2492,
    2
  ],
  [
    2493,
    2
  ],
  [
    [
      2494,
      2500
    ],
    2
  ],
  [
    [
      2501,
      2502
    ],
    3
  ],
  [
    [
      2503,
      2504
    ],
    2
  ],
  [
    [
      2505,
      2506
    ],
    3
  ],
  [
    [
      2507,
      2509
    ],
    2
  ],
  [
    2510,
    2
  ],
  [
    [
      2511,
      2518
    ],
    3
  ],
  [
    2519,
    2
  ],
  [
    [
      2520,
      2523
    ],
    3
  ],
  [
    2524,
    1,
    ""
  ],
  [
    2525,
    1,
    ""
  ],
  [
    2526,
    3
  ],
  [
    2527,
    1,
    ""
  ],
  [
    [
      2528,
      2531
    ],
    2
  ],
  [
    [
      2532,
      2533
    ],
    3
  ],
  [
    [
      2534,
      2545
    ],
    2
  ],
  [
    [
      2546,
      2554
    ],
    2
  ],
  [
    2555,
    2
  ],
  [
    2556,
    2
  ],
  [
    2557,
    2
  ],
  [
    2558,
    2
  ],
  [
    [
      2559,
      2560
    ],
    3
  ],
  [
    2561,
    2
  ],
  [
    2562,
    2
  ],
  [
    2563,
    2
  ],
  [
    2564,
    3
  ],
  [
    [
      2565,
      2570
    ],
    2
  ],
  [
    [
      2571,
      2574
    ],
    3
  ],
  [
    [
      2575,
      2576
    ],
    2
  ],
  [
    [
      2577,
      2578
    ],
    3
  ],
  [
    [
      2579,
      2600
    ],
    2
  ],
  [
    2601,
    3
  ],
  [
    [
      2602,
      2608
    ],
    2
  ],
  [
    2609,
    3
  ],
  [
    2610,
    2
  ],
  [
    2611,
    1,
    ""
  ],
  [
    2612,
    3
  ],
  [
    2613,
    2
  ],
  [
    2614,
    1,
    ""
  ],
  [
    2615,
    3
  ],
  [
    [
      2616,
      2617
    ],
    2
  ],
  [
    [
      2618,
      2619
    ],
    3
  ],
  [
    2620,
    2
  ],
  [
    2621,
    3
  ],
  [
    [
      2622,
      2626
    ],
    2
  ],
  [
    [
      2627,
      2630
    ],
    3
  ],
  [
    [
      2631,
      2632
    ],
    2
  ],
  [
    [
      2633,
      2634
    ],
    3
  ],
  [
    [
      2635,
      2637
    ],
    2
  ],
  [
    [
      2638,
      2640
    ],
    3
  ],
  [
    2641,
    2
  ],
  [
    [
      2642,
      2648
    ],
    3
  ],
  [
    2649,
    1,
    ""
  ],
  [
    2650,
    1,
    ""
  ],
  [
    2651,
    1,
    ""
  ],
  [
    2652,
    2
  ],
  [
    2653,
    3
  ],
  [
    2654,
    1,
    ""
  ],
  [
    [
      2655,
      2661
    ],
    3
  ],
  [
    [
      2662,
      2676
    ],
    2
  ],
  [
    2677,
    2
  ],
  [
    2678,
    2
  ],
  [
    [
      2679,
      2688
    ],
    3
  ],
  [
    [
      2689,
      2691
    ],
    2
  ],
  [
    2692,
    3
  ],
  [
    [
      2693,
      2699
    ],
    2
  ],
  [
    2700,
    2
  ],
  [
    2701,
    2
  ],
  [
    2702,
    3
  ],
  [
    [
      2703,
      2705
    ],
    2
  ],
  [
    2706,
    3
  ],
  [
    [
      2707,
      2728
    ],
    2
  ],
  [
    2729,
    3
  ],
  [
    [
      2730,
      2736
    ],
    2
  ],
  [
    2737,
    3
  ],
  [
    [
      2738,
      2739
    ],
    2
  ],
  [
    2740,
    3
  ],
  [
    [
      2741,
      2745
    ],
    2
  ],
  [
    [
      2746,
      2747
    ],
    3
  ],
  [
    [
      2748,
      2757
    ],
    2
  ],
  [
    2758,
    3
  ],
  [
    [
      2759,
      2761
    ],
    2
  ],
  [
    2762,
    3
  ],
  [
    [
      2763,
      2765
    ],
    2
  ],
  [
    [
      2766,
      2767
    ],
    3
  ],
  [
    2768,
    2
  ],
  [
    [
      2769,
      2783
    ],
    3
  ],
  [
    2784,
    2
  ],
  [
    [
      2785,
      2787
    ],
    2
  ],
  [
    [
      2788,
      2789
    ],
    3
  ],
  [
    [
      2790,
      2799
    ],
    2
  ],
  [
    2800,
    2
  ],
  [
    2801,
    2
  ],
  [
    [
      2802,
      2808
    ],
    3
  ],
  [
    2809,
    2
  ],
  [
    [
      2810,
      2815
    ],
    2
  ],
  [
    2816,
    3
  ],
  [
    [
      2817,
      2819
    ],
    2
  ],
  [
    2820,
    3
  ],
  [
    [
      2821,
      2828
    ],
    2
  ],
  [
    [
      2829,
      2830
    ],
    3
  ],
  [
    [
      2831,
      2832
    ],
    2
  ],
  [
    [
      2833,
      2834
    ],
    3
  ],
  [
    [
      2835,
      2856
    ],
    2
  ],
  [
    2857,
    3
  ],
  [
    [
      2858,
      2864
    ],
    2
  ],
  [
    2865,
    3
  ],
  [
    [
      2866,
      2867
    ],
    2
  ],
  [
    2868,
    3
  ],
  [
    2869,
    2
  ],
  [
    [
      2870,
      2873
    ],
    2
  ],
  [
    [
      2874,
      2875
    ],
    3
  ],
  [
    [
      2876,
      2883
    ],
    2
  ],
  [
    2884,
    2
  ],
  [
    [
      2885,
      2886
    ],
    3
  ],
  [
    [
      2887,
      2888
    ],
    2
  ],
  [
    [
      2889,
      2890
    ],
    3
  ],
  [
    [
      2891,
      2893
    ],
    2
  ],
  [
    [
      2894,
      2900
    ],
    3
  ],
  [
    2901,
    2
  ],
  [
    [
      2902,
      2903
    ],
    2
  ],
  [
    [
      2904,
      2907
    ],
    3
  ],
  [
    2908,
    1,
    ""
  ],
  [
    2909,
    1,
    ""
  ],
  [
    2910,
    3
  ],
  [
    [
      2911,
      2913
    ],
    2
  ],
  [
    [
      2914,
      2915
    ],
    2
  ],
  [
    [
      2916,
      2917
    ],
    3
  ],
  [
    [
      2918,
      2927
    ],
    2
  ],
  [
    2928,
    2
  ],
  [
    2929,
    2
  ],
  [
    [
      2930,
      2935
    ],
    2
  ],
  [
    [
      2936,
      2945
    ],
    3
  ],
  [
    [
      2946,
      2947
    ],
    2
  ],
  [
    2948,
    3
  ],
  [
    [
      2949,
      2954
    ],
    2
  ],
  [
    [
      2955,
      2957
    ],
    3
  ],
  [
    [
      2958,
      2960
    ],
    2
  ],
  [
    2961,
    3
  ],
  [
    [
      2962,
      2965
    ],
    2
  ],
  [
    [
      2966,
      2968
    ],
    3
  ],
  [
    [
      2969,
      2970
    ],
    2
  ],
  [
    2971,
    3
  ],
  [
    2972,
    2
  ],
  [
    2973,
    3
  ],
  [
    [
      2974,
      2975
    ],
    2
  ],
  [
    [
      2976,
      2978
    ],
    3
  ],
  [
    [
      2979,
      2980
    ],
    2
  ],
  [
    [
      2981,
      2983
    ],
    3
  ],
  [
    [
      2984,
      2986
    ],
    2
  ],
  [
    [
      2987,
      2989
    ],
    3
  ],
  [
    [
      2990,
      2997
    ],
    2
  ],
  [
    2998,
    2
  ],
  [
    [
      2999,
      3001
    ],
    2
  ],
  [
    [
      3002,
      3005
    ],
    3
  ],
  [
    [
      3006,
      3010
    ],
    2
  ],
  [
    [
      3011,
      3013
    ],
    3
  ],
  [
    [
      3014,
      3016
    ],
    2
  ],
  [
    3017,
    3
  ],
  [
    [
      3018,
      3021
    ],
    2
  ],
  [
    [
      3022,
      3023
    ],
    3
  ],
  [
    3024,
    2
  ],
  [
    [
      3025,
      3030
    ],
    3
  ],
  [
    3031,
    2
  ],
  [
    [
      3032,
      3045
    ],
    3
  ],
  [
    3046,
    2
  ],
  [
    [
      3047,
      3055
    ],
    2
  ],
  [
    [
      3056,
      3058
    ],
    2
  ],
  [
    [
      3059,
      3066
    ],
    2
  ],
  [
    [
      3067,
      3071
    ],
    3
  ],
  [
    3072,
    2
  ],
  [
    [
      3073,
      3075
    ],
    2
  ],
  [
    3076,
    2
  ],
  [
    [
      3077,
      3084
    ],
    2
  ],
  [
    3085,
    3
  ],
  [
    [
      3086,
      3088
    ],
    2
  ],
  [
    3089,
    3
  ],
  [
    [
      3090,
      3112
    ],
    2
  ],
  [
    3113,
    3
  ],
  [
    [
      3114,
      3123
    ],
    2
  ],
  [
    3124,
    2
  ],
  [
    [
      3125,
      3129
    ],
    2
  ],
  [
    [
      3130,
      3131
    ],
    3
  ],
  [
    3132,
    2
  ],
  [
    3133,
    2
  ],
  [
    [
      3134,
      3140
    ],
    2
  ],
  [
    3141,
    3
  ],
  [
    [
      3142,
      3144
    ],
    2
  ],
  [
    3145,
    3
  ],
  [
    [
      3146,
      3149
    ],
    2
  ],
  [
    [
      3150,
      3156
    ],
    3
  ],
  [
    [
      3157,
      3158
    ],
    2
  ],
  [
    3159,
    3
  ],
  [
    [
      3160,
      3161
    ],
    2
  ],
  [
    3162,
    2
  ],
  [
    [
      3163,
      3164
    ],
    3
  ],
  [
    3165,
    2
  ],
  [
    [
      3166,
      3167
    ],
    3
  ],
  [
    [
      3168,
      3169
    ],
    2
  ],
  [
    [
      3170,
      3171
    ],
    2
  ],
  [
    [
      3172,
      3173
    ],
    3
  ],
  [
    [
      3174,
      3183
    ],
    2
  ],
  [
    [
      3184,
      3190
    ],
    3
  ],
  [
    3191,
    2
  ],
  [
    [
      3192,
      3199
    ],
    2
  ],
  [
    3200,
    2
  ],
  [
    3201,
    2
  ],
  [
    [
      3202,
      3203
    ],
    2
  ],
  [
    3204,
    2
  ],
  [
    [
      3205,
      3212
    ],
    2
  ],
  [
    3213,
    3
  ],
  [
    [
      3214,
      3216
    ],
    2
  ],
  [
    3217,
    3
  ],
  [
    [
      3218,
      3240
    ],
    2
  ],
  [
    3241,
    3
  ],
  [
    [
      3242,
      3251
    ],
    2
  ],
  [
    3252,
    3
  ],
  [
    [
      3253,
      3257
    ],
    2
  ],
  [
    [
      3258,
      3259
    ],
    3
  ],
  [
    [
      3260,
      3261
    ],
    2
  ],
  [
    [
      3262,
      3268
    ],
    2
  ],
  [
    3269,
    3
  ],
  [
    [
      3270,
      3272
    ],
    2
  ],
  [
    3273,
    3
  ],
  [
    [
      3274,
      3277
    ],
    2
  ],
  [
    [
      3278,
      3284
    ],
    3
  ],
  [
    [
      3285,
      3286
    ],
    2
  ],
  [
    [
      3287,
      3292
    ],
    3
  ],
  [
    3293,
    2
  ],
  [
    3294,
    2
  ],
  [
    3295,
    3
  ],
  [
    [
      3296,
      3297
    ],
    2
  ],
  [
    [
      3298,
      3299
    ],
    2
  ],
  [
    [
      3300,
      3301
    ],
    3
  ],
  [
    [
      3302,
      3311
    ],
    2
  ],
  [
    3312,
    3
  ],
  [
    [
      3313,
      3314
    ],
    2
  ],
  [
    3315,
    2
  ],
  [
    [
      3316,
      3327
    ],
    3
  ],
  [
    3328,
    2
  ],
  [
    3329,
    2
  ],
  [
    [
      3330,
      3331
    ],
    2
  ],
  [
    3332,
    2
  ],
  [
    [
      3333,
      3340
    ],
    2
  ],
  [
    3341,
    3
  ],
  [
    [
      3342,
      3344
    ],
    2
  ],
  [
    3345,
    3
  ],
  [
    [
      3346,
      3368
    ],
    2
  ],
  [
    3369,
    2
  ],
  [
    [
      3370,
      3385
    ],
    2
  ],
  [
    3386,
    2
  ],
  [
    [
      3387,
      3388
    ],
    2
  ],
  [
    3389,
    2
  ],
  [
    [
      3390,
      3395
    ],
    2
  ],
  [
    3396,
    2
  ],
  [
    3397,
    3
  ],
  [
    [
      3398,
      3400
    ],
    2
  ],
  [
    3401,
    3
  ],
  [
    [
      3402,
      3405
    ],
    2
  ],
  [
    3406,
    2
  ],
  [
    3407,
    2
  ],
  [
    [
      3408,
      3411
    ],
    3
  ],
  [
    [
      3412,
      3414
    ],
    2
  ],
  [
    3415,
    2
  ],
  [
    [
      3416,
      3422
    ],
    2
  ],
  [
    3423,
    2
  ],
  [
    [
      3424,
      3425
    ],
    2
  ],
  [
    [
      3426,
      3427
    ],
    2
  ],
  [
    [
      3428,
      3429
    ],
    3
  ],
  [
    [
      3430,
      3439
    ],
    2
  ],
  [
    [
      3440,
      3445
    ],
    2
  ],
  [
    [
      3446,
      3448
    ],
    2
  ],
  [
    3449,
    2
  ],
  [
    [
      3450,
      3455
    ],
    2
  ],
  [
    3456,
    3
  ],
  [
    3457,
    2
  ],
  [
    [
      3458,
      3459
    ],
    2
  ],
  [
    3460,
    3
  ],
  [
    [
      3461,
      3478
    ],
    2
  ],
  [
    [
      3479,
      3481
    ],
    3
  ],
  [
    [
      3482,
      3505
    ],
    2
  ],
  [
    3506,
    3
  ],
  [
    [
      3507,
      3515
    ],
    2
  ],
  [
    3516,
    3
  ],
  [
    3517,
    2
  ],
  [
    [
      3518,
      3519
    ],
    3
  ],
  [
    [
      3520,
      3526
    ],
    2
  ],
  [
    [
      3527,
      3529
    ],
    3
  ],
  [
    3530,
    2
  ],
  [
    [
      3531,
      3534
    ],
    3
  ],
  [
    [
      3535,
      3540
    ],
    2
  ],
  [
    3541,
    3
  ],
  [
    3542,
    2
  ],
  [
    3543,
    3
  ],
  [
    [
      3544,
      3551
    ],
    2
  ],
  [
    [
      3552,
      3557
    ],
    3
  ],
  [
    [
      3558,
      3567
    ],
    2
  ],
  [
    [
      3568,
      3569
    ],
    3
  ],
  [
    [
      3570,
      3571
    ],
    2
  ],
  [
    3572,
    2
  ],
  [
    [
      3573,
      3584
    ],
    3
  ],
  [
    [
      3585,
      3634
    ],
    2
  ],
  [
    3635,
    1,
    ""
  ],
  [
    [
      3636,
      3642
    ],
    2
  ],
  [
    [
      3643,
      3646
    ],
    3
  ],
  [
    3647,
    2
  ],
  [
    [
      3648,
      3662
    ],
    2
  ],
  [
    3663,
    2
  ],
  [
    [
      3664,
      3673
    ],
    2
  ],
  [
    [
      3674,
      3675
    ],
    2
  ],
  [
    [
      3676,
      3712
    ],
    3
  ],
  [
    [
      3713,
      3714
    ],
    2
  ],
  [
    3715,
    3
  ],
  [
    3716,
    2
  ],
  [
    3717,
    3
  ],
  [
    3718,
    2
  ],
  [
    [
      3719,
      3720
    ],
    2
  ],
  [
    3721,
    2
  ],
  [
    3722,
    2
  ],
  [
    3723,
    3
  ],
  [
    3724,
    2
  ],
  [
    3725,
    2
  ],
  [
    [
      3726,
      3731
    ],
    2
  ],
  [
    [
      3732,
      3735
    ],
    2
  ],
  [
    3736,
    2
  ],
  [
    [
      3737,
      3743
    ],
    2
  ],
  [
    3744,
    2
  ],
  [
    [
      3745,
      3747
    ],
    2
  ],
  [
    3748,
    3
  ],
  [
    3749,
    2
  ],
  [
    3750,
    3
  ],
  [
    3751,
    2
  ],
  [
    [
      3752,
      3753
    ],
    2
  ],
  [
    [
      3754,
      3755
    ],
    2
  ],
  [
    3756,
    2
  ],
  [
    [
      3757,
      3762
    ],
    2
  ],
  [
    3763,
    1,
    ""
  ],
  [
    [
      3764,
      3769
    ],
    2
  ],
  [
    3770,
    2
  ],
  [
    [
      3771,
      3773
    ],
    2
  ],
  [
    [
      3774,
      3775
    ],
    3
  ],
  [
    [
      3776,
      3780
    ],
    2
  ],
  [
    3781,
    3
  ],
  [
    3782,
    2
  ],
  [
    3783,
    3
  ],
  [
    [
      3784,
      3789
    ],
    2
  ],
  [
    3790,
    2
  ],
  [
    3791,
    3
  ],
  [
    [
      3792,
      3801
    ],
    2
  ],
  [
    [
      3802,
      3803
    ],
    3
  ],
  [
    3804,
    1,
    ""
  ],
  [
    3805,
    1,
    ""
  ],
  [
    [
      3806,
      3807
    ],
    2
  ],
  [
    [
      3808,
      3839
    ],
    3
  ],
  [
    3840,
    2
  ],
  [
    [
      3841,
      3850
    ],
    2
  ],
  [
    3851,
    2
  ],
  [
    3852,
    1,
    ""
  ],
  [
    [
      3853,
      3863
    ],
    2
  ],
  [
    [
      3864,
      3865
    ],
    2
  ],
  [
    [
      3866,
      3871
    ],
    2
  ],
  [
    [
      3872,
      3881
    ],
    2
  ],
  [
    [
      3882,
      3892
    ],
    2
  ],
  [
    3893,
    2
  ],
  [
    3894,
    2
  ],
  [
    3895,
    2
  ],
  [
    3896,
    2
  ],
  [
    3897,
    2
  ],
  [
    [
      3898,
      3901
    ],
    2
  ],
  [
    [
      3902,
      3906
    ],
    2
  ],
  [
    3907,
    1,
    ""
  ],
  [
    [
      3908,
      3911
    ],
    2
  ],
  [
    3912,
    3
  ],
  [
    [
      3913,
      3916
    ],
    2
  ],
  [
    3917,
    1,
    ""
  ],
  [
    [
      3918,
      3921
    ],
    2
  ],
  [
    3922,
    1,
    ""
  ],
  [
    [
      3923,
      3926
    ],
    2
  ],
  [
    3927,
    1,
    ""
  ],
  [
    [
      3928,
      3931
    ],
    2
  ],
  [
    3932,
    1,
    ""
  ],
  [
    [
      3933,
      3944
    ],
    2
  ],
  [
    3945,
    1,
    ""
  ],
  [
    3946,
    2
  ],
  [
    [
      3947,
      3948
    ],
    2
  ],
  [
    [
      3949,
      3952
    ],
    3
  ],
  [
    [
      3953,
      3954
    ],
    2
  ],
  [
    3955,
    1,
    ""
  ],
  [
    3956,
    2
  ],
  [
    3957,
    1,
    ""
  ],
  [
    3958,
    1,
    ""
  ],
  [
    3959,
    1,
    ""
  ],
  [
    3960,
    1,
    ""
  ],
  [
    3961,
    1,
    ""
  ],
  [
    [
      3962,
      3968
    ],
    2
  ],
  [
    3969,
    1,
    ""
  ],
  [
    [
      3970,
      3972
    ],
    2
  ],
  [
    3973,
    2
  ],
  [
    [
      3974,
      3979
    ],
    2
  ],
  [
    [
      3980,
      3983
    ],
    2
  ],
  [
    [
      3984,
      3986
    ],
    2
  ],
  [
    3987,
    1,
    ""
  ],
  [
    [
      3988,
      3989
    ],
    2
  ],
  [
    3990,
    2
  ],
  [
    3991,
    2
  ],
  [
    3992,
    3
  ],
  [
    [
      3993,
      3996
    ],
    2
  ],
  [
    3997,
    1,
    ""
  ],
  [
    [
      3998,
      4001
    ],
    2
  ],
  [
    4002,
    1,
    ""
  ],
  [
    [
      4003,
      4006
    ],
    2
  ],
  [
    4007,
    1,
    ""
  ],
  [
    [
      4008,
      4011
    ],
    2
  ],
  [
    4012,
    1,
    ""
  ],
  [
    4013,
    2
  ],
  [
    [
      4014,
      4016
    ],
    2
  ],
  [
    [
      4017,
      4023
    ],
    2
  ],
  [
    4024,
    2
  ],
  [
    4025,
    1,
    ""
  ],
  [
    [
      4026,
      4028
    ],
    2
  ],
  [
    4029,
    3
  ],
  [
    [
      4030,
      4037
    ],
    2
  ],
  [
    4038,
    2
  ],
  [
    [
      4039,
      4044
    ],
    2
  ],
  [
    4045,
    3
  ],
  [
    4046,
    2
  ],
  [
    4047,
    2
  ],
  [
    [
      4048,
      4049
    ],
    2
  ],
  [
    [
      4050,
      4052
    ],
    2
  ],
  [
    [
      4053,
      4056
    ],
    2
  ],
  [
    [
      4057,
      4058
    ],
    2
  ],
  [
    [
      4059,
      4095
    ],
    3
  ],
  [
    [
      4096,
      4129
    ],
    2
  ],
  [
    4130,
    2
  ],
  [
    [
      4131,
      4135
    ],
    2
  ],
  [
    4136,
    2
  ],
  [
    [
      4137,
      4138
    ],
    2
  ],
  [
    4139,
    2
  ],
  [
    [
      4140,
      4146
    ],
    2
  ],
  [
    [
      4147,
      4149
    ],
    2
  ],
  [
    [
      4150,
      4153
    ],
    2
  ],
  [
    [
      4154,
      4159
    ],
    2
  ],
  [
    [
      4160,
      4169
    ],
    2
  ],
  [
    [
      4170,
      4175
    ],
    2
  ],
  [
    [
      4176,
      4185
    ],
    2
  ],
  [
    [
      4186,
      4249
    ],
    2
  ],
  [
    [
      4250,
      4253
    ],
    2
  ],
  [
    [
      4254,
      4255
    ],
    2
  ],
  [
    [
      4256,
      4293
    ],
    3
  ],
  [
    4294,
    3
  ],
  [
    4295,
    1,
    ""
  ],
  [
    [
      4296,
      4300
    ],
    3
  ],
  [
    4301,
    1,
    ""
  ],
  [
    [
      4302,
      4303
    ],
    3
  ],
  [
    [
      4304,
      4342
    ],
    2
  ],
  [
    [
      4343,
      4344
    ],
    2
  ],
  [
    [
      4345,
      4346
    ],
    2
  ],
  [
    4347,
    2
  ],
  [
    4348,
    1,
    ""
  ],
  [
    [
      4349,
      4351
    ],
    2
  ],
  [
    [
      4352,
      4441
    ],
    2
  ],
  [
    [
      4442,
      4446
    ],
    2
  ],
  [
    [
      4447,
      4448
    ],
    3
  ],
  [
    [
      4449,
      4514
    ],
    2
  ],
  [
    [
      4515,
      4519
    ],
    2
  ],
  [
    [
      4520,
      4601
    ],
    2
  ],
  [
    [
      4602,
      4607
    ],
    2
  ],
  [
    [
      4608,
      4614
    ],
    2
  ],
  [
    4615,
    2
  ],
  [
    [
      4616,
      4678
    ],
    2
  ],
  [
    4679,
    2
  ],
  [
    4680,
    2
  ],
  [
    4681,
    3
  ],
  [
    [
      4682,
      4685
    ],
    2
  ],
  [
    [
      4686,
      4687
    ],
    3
  ],
  [
    [
      4688,
      4694
    ],
    2
  ],
  [
    4695,
    3
  ],
  [
    4696,
    2
  ],
  [
    4697,
    3
  ],
  [
    [
      4698,
      4701
    ],
    2
  ],
  [
    [
      4702,
      4703
    ],
    3
  ],
  [
    [
      4704,
      4742
    ],
    2
  ],
  [
    4743,
    2
  ],
  [
    4744,
    2
  ],
  [
    4745,
    3
  ],
  [
    [
      4746,
      4749
    ],
    2
  ],
  [
    [
      4750,
      4751
    ],
    3
  ],
  [
    [
      4752,
      4782
    ],
    2
  ],
  [
    4783,
    2
  ],
  [
    4784,
    2
  ],
  [
    4785,
    3
  ],
  [
    [
      4786,
      4789
    ],
    2
  ],
  [
    [
      4790,
      4791
    ],
    3
  ],
  [
    [
      4792,
      4798
    ],
    2
  ],
  [
    4799,
    3
  ],
  [
    4800,
    2
  ],
  [
    4801,
    3
  ],
  [
    [
      4802,
      4805
    ],
    2
  ],
  [
    [
      4806,
      4807
    ],
    3
  ],
  [
    [
      4808,
      4814
    ],
    2
  ],
  [
    4815,
    2
  ],
  [
    [
      4816,
      4822
    ],
    2
  ],
  [
    4823,
    3
  ],
  [
    [
      4824,
      4846
    ],
    2
  ],
  [
    4847,
    2
  ],
  [
    [
      4848,
      4878
    ],
    2
  ],
  [
    4879,
    2
  ],
  [
    4880,
    2
  ],
  [
    4881,
    3
  ],
  [
    [
      4882,
      4885
    ],
    2
  ],
  [
    [
      4886,
      4887
    ],
    3
  ],
  [
    [
      4888,
      4894
    ],
    2
  ],
  [
    4895,
    2
  ],
  [
    [
      4896,
      4934
    ],
    2
  ],
  [
    4935,
    2
  ],
  [
    [
      4936,
      4954
    ],
    2
  ],
  [
    [
      4955,
      4956
    ],
    3
  ],
  [
    [
      4957,
      4958
    ],
    2
  ],
  [
    4959,
    2
  ],
  [
    4960,
    2
  ],
  [
    [
      4961,
      4988
    ],
    2
  ],
  [
    [
      4989,
      4991
    ],
    3
  ],
  [
    [
      4992,
      5007
    ],
    2
  ],
  [
    [
      5008,
      5017
    ],
    2
  ],
  [
    [
      5018,
      5023
    ],
    3
  ],
  [
    [
      5024,
      5108
    ],
    2
  ],
  [
    5109,
    2
  ],
  [
    [
      5110,
      5111
    ],
    3
  ],
  [
    5112,
    1,
    ""
  ],
  [
    5113,
    1,
    ""
  ],
  [
    5114,
    1,
    ""
  ],
  [
    5115,
    1,
    ""
  ],
  [
    5116,
    1,
    ""
  ],
  [
    5117,
    1,
    ""
  ],
  [
    [
      5118,
      5119
    ],
    3
  ],
  [
    5120,
    2
  ],
  [
    [
      5121,
      5740
    ],
    2
  ],
  [
    [
      5741,
      5742
    ],
    2
  ],
  [
    [
      5743,
      5750
    ],
    2
  ],
  [
    [
      5751,
      5759
    ],
    2
  ],
  [
    5760,
    3
  ],
  [
    [
      5761,
      5786
    ],
    2
  ],
  [
    [
      5787,
      5788
    ],
    2
  ],
  [
    [
      5789,
      5791
    ],
    3
  ],
  [
    [
      5792,
      5866
    ],
    2
  ],
  [
    [
      5867,
      5872
    ],
    2
  ],
  [
    [
      5873,
      5880
    ],
    2
  ],
  [
    [
      5881,
      5887
    ],
    3
  ],
  [
    [
      5888,
      5900
    ],
    2
  ],
  [
    5901,
    2
  ],
  [
    [
      5902,
      5908
    ],
    2
  ],
  [
    5909,
    2
  ],
  [
    [
      5910,
      5918
    ],
    3
  ],
  [
    5919,
    2
  ],
  [
    [
      5920,
      5940
    ],
    2
  ],
  [
    [
      5941,
      5942
    ],
    2
  ],
  [
    [
      5943,
      5951
    ],
    3
  ],
  [
    [
      5952,
      5971
    ],
    2
  ],
  [
    [
      5972,
      5983
    ],
    3
  ],
  [
    [
      5984,
      5996
    ],
    2
  ],
  [
    5997,
    3
  ],
  [
    [
      5998,
      6e3
    ],
    2
  ],
  [
    6001,
    3
  ],
  [
    [
      6002,
      6003
    ],
    2
  ],
  [
    [
      6004,
      6015
    ],
    3
  ],
  [
    [
      6016,
      6067
    ],
    2
  ],
  [
    [
      6068,
      6069
    ],
    3
  ],
  [
    [
      6070,
      6099
    ],
    2
  ],
  [
    [
      6100,
      6102
    ],
    2
  ],
  [
    6103,
    2
  ],
  [
    [
      6104,
      6107
    ],
    2
  ],
  [
    6108,
    2
  ],
  [
    6109,
    2
  ],
  [
    [
      6110,
      6111
    ],
    3
  ],
  [
    [
      6112,
      6121
    ],
    2
  ],
  [
    [
      6122,
      6127
    ],
    3
  ],
  [
    [
      6128,
      6137
    ],
    2
  ],
  [
    [
      6138,
      6143
    ],
    3
  ],
  [
    [
      6144,
      6149
    ],
    2
  ],
  [
    6150,
    3
  ],
  [
    [
      6151,
      6154
    ],
    2
  ],
  [
    [
      6155,
      6157
    ],
    7
  ],
  [
    6158,
    3
  ],
  [
    6159,
    7
  ],
  [
    [
      6160,
      6169
    ],
    2
  ],
  [
    [
      6170,
      6175
    ],
    3
  ],
  [
    [
      6176,
      6263
    ],
    2
  ],
  [
    6264,
    2
  ],
  [
    [
      6265,
      6271
    ],
    3
  ],
  [
    [
      6272,
      6313
    ],
    2
  ],
  [
    6314,
    2
  ],
  [
    [
      6315,
      6319
    ],
    3
  ],
  [
    [
      6320,
      6389
    ],
    2
  ],
  [
    [
      6390,
      6399
    ],
    3
  ],
  [
    [
      6400,
      6428
    ],
    2
  ],
  [
    [
      6429,
      6430
    ],
    2
  ],
  [
    6431,
    3
  ],
  [
    [
      6432,
      6443
    ],
    2
  ],
  [
    [
      6444,
      6447
    ],
    3
  ],
  [
    [
      6448,
      6459
    ],
    2
  ],
  [
    [
      6460,
      6463
    ],
    3
  ],
  [
    6464,
    2
  ],
  [
    [
      6465,
      6467
    ],
    3
  ],
  [
    [
      6468,
      6469
    ],
    2
  ],
  [
    [
      6470,
      6509
    ],
    2
  ],
  [
    [
      6510,
      6511
    ],
    3
  ],
  [
    [
      6512,
      6516
    ],
    2
  ],
  [
    [
      6517,
      6527
    ],
    3
  ],
  [
    [
      6528,
      6569
    ],
    2
  ],
  [
    [
      6570,
      6571
    ],
    2
  ],
  [
    [
      6572,
      6575
    ],
    3
  ],
  [
    [
      6576,
      6601
    ],
    2
  ],
  [
    [
      6602,
      6607
    ],
    3
  ],
  [
    [
      6608,
      6617
    ],
    2
  ],
  [
    6618,
    2
  ],
  [
    [
      6619,
      6621
    ],
    3
  ],
  [
    [
      6622,
      6623
    ],
    2
  ],
  [
    [
      6624,
      6655
    ],
    2
  ],
  [
    [
      6656,
      6683
    ],
    2
  ],
  [
    [
      6684,
      6685
    ],
    3
  ],
  [
    [
      6686,
      6687
    ],
    2
  ],
  [
    [
      6688,
      6750
    ],
    2
  ],
  [
    6751,
    3
  ],
  [
    [
      6752,
      6780
    ],
    2
  ],
  [
    [
      6781,
      6782
    ],
    3
  ],
  [
    [
      6783,
      6793
    ],
    2
  ],
  [
    [
      6794,
      6799
    ],
    3
  ],
  [
    [
      6800,
      6809
    ],
    2
  ],
  [
    [
      6810,
      6815
    ],
    3
  ],
  [
    [
      6816,
      6822
    ],
    2
  ],
  [
    6823,
    2
  ],
  [
    [
      6824,
      6829
    ],
    2
  ],
  [
    [
      6830,
      6831
    ],
    3
  ],
  [
    [
      6832,
      6845
    ],
    2
  ],
  [
    6846,
    2
  ],
  [
    [
      6847,
      6848
    ],
    2
  ],
  [
    [
      6849,
      6862
    ],
    2
  ],
  [
    [
      6863,
      6911
    ],
    3
  ],
  [
    [
      6912,
      6987
    ],
    2
  ],
  [
    6988,
    2
  ],
  [
    [
      6989,
      6991
    ],
    3
  ],
  [
    [
      6992,
      7001
    ],
    2
  ],
  [
    [
      7002,
      7018
    ],
    2
  ],
  [
    [
      7019,
      7027
    ],
    2
  ],
  [
    [
      7028,
      7036
    ],
    2
  ],
  [
    [
      7037,
      7038
    ],
    2
  ],
  [
    7039,
    3
  ],
  [
    [
      7040,
      7082
    ],
    2
  ],
  [
    [
      7083,
      7085
    ],
    2
  ],
  [
    [
      7086,
      7097
    ],
    2
  ],
  [
    [
      7098,
      7103
    ],
    2
  ],
  [
    [
      7104,
      7155
    ],
    2
  ],
  [
    [
      7156,
      7163
    ],
    3
  ],
  [
    [
      7164,
      7167
    ],
    2
  ],
  [
    [
      7168,
      7223
    ],
    2
  ],
  [
    [
      7224,
      7226
    ],
    3
  ],
  [
    [
      7227,
      7231
    ],
    2
  ],
  [
    [
      7232,
      7241
    ],
    2
  ],
  [
    [
      7242,
      7244
    ],
    3
  ],
  [
    [
      7245,
      7293
    ],
    2
  ],
  [
    [
      7294,
      7295
    ],
    2
  ],
  [
    7296,
    1,
    ""
  ],
  [
    7297,
    1,
    ""
  ],
  [
    7298,
    1,
    ""
  ],
  [
    7299,
    1,
    ""
  ],
  [
    [
      7300,
      7301
    ],
    1,
    ""
  ],
  [
    7302,
    1,
    ""
  ],
  [
    7303,
    1,
    ""
  ],
  [
    7304,
    1,
    ""
  ],
  [
    [
      7305,
      7311
    ],
    3
  ],
  [
    7312,
    1,
    ""
  ],
  [
    7313,
    1,
    ""
  ],
  [
    7314,
    1,
    ""
  ],
  [
    7315,
    1,
    ""
  ],
  [
    7316,
    1,
    ""
  ],
  [
    7317,
    1,
    ""
  ],
  [
    7318,
    1,
    ""
  ],
  [
    7319,
    1,
    ""
  ],
  [
    7320,
    1,
    ""
  ],
  [
    7321,
    1,
    ""
  ],
  [
    7322,
    1,
    ""
  ],
  [
    7323,
    1,
    ""
  ],
  [
    7324,
    1,
    ""
  ],
  [
    7325,
    1,
    ""
  ],
  [
    7326,
    1,
    ""
  ],
  [
    7327,
    1,
    ""
  ],
  [
    7328,
    1,
    ""
  ],
  [
    7329,
    1,
    ""
  ],
  [
    7330,
    1,
    ""
  ],
  [
    7331,
    1,
    ""
  ],
  [
    7332,
    1,
    ""
  ],
  [
    7333,
    1,
    ""
  ],
  [
    7334,
    1,
    ""
  ],
  [
    7335,
    1,
    ""
  ],
  [
    7336,
    1,
    ""
  ],
  [
    7337,
    1,
    ""
  ],
  [
    7338,
    1,
    ""
  ],
  [
    7339,
    1,
    ""
  ],
  [
    7340,
    1,
    ""
  ],
  [
    7341,
    1,
    ""
  ],
  [
    7342,
    1,
    ""
  ],
  [
    7343,
    1,
    ""
  ],
  [
    7344,
    1,
    ""
  ],
  [
    7345,
    1,
    ""
  ],
  [
    7346,
    1,
    ""
  ],
  [
    7347,
    1,
    ""
  ],
  [
    7348,
    1,
    ""
  ],
  [
    7349,
    1,
    ""
  ],
  [
    7350,
    1,
    ""
  ],
  [
    7351,
    1,
    ""
  ],
  [
    7352,
    1,
    ""
  ],
  [
    7353,
    1,
    ""
  ],
  [
    7354,
    1,
    ""
  ],
  [
    [
      7355,
      7356
    ],
    3
  ],
  [
    7357,
    1,
    ""
  ],
  [
    7358,
    1,
    ""
  ],
  [
    7359,
    1,
    ""
  ],
  [
    [
      7360,
      7367
    ],
    2
  ],
  [
    [
      7368,
      7375
    ],
    3
  ],
  [
    [
      7376,
      7378
    ],
    2
  ],
  [
    7379,
    2
  ],
  [
    [
      7380,
      7410
    ],
    2
  ],
  [
    [
      7411,
      7414
    ],
    2
  ],
  [
    7415,
    2
  ],
  [
    [
      7416,
      7417
    ],
    2
  ],
  [
    7418,
    2
  ],
  [
    [
      7419,
      7423
    ],
    3
  ],
  [
    [
      7424,
      7467
    ],
    2
  ],
  [
    7468,
    1,
    "a"
  ],
  [
    7469,
    1,
    ""
  ],
  [
    7470,
    1,
    "b"
  ],
  [
    7471,
    2
  ],
  [
    7472,
    1,
    "d"
  ],
  [
    7473,
    1,
    "e"
  ],
  [
    7474,
    1,
    ""
  ],
  [
    7475,
    1,
    "g"
  ],
  [
    7476,
    1,
    "h"
  ],
  [
    7477,
    1,
    "i"
  ],
  [
    7478,
    1,
    "j"
  ],
  [
    7479,
    1,
    "k"
  ],
  [
    7480,
    1,
    "l"
  ],
  [
    7481,
    1,
    "m"
  ],
  [
    7482,
    1,
    "n"
  ],
  [
    7483,
    2
  ],
  [
    7484,
    1,
    "o"
  ],
  [
    7485,
    1,
    ""
  ],
  [
    7486,
    1,
    "p"
  ],
  [
    7487,
    1,
    "r"
  ],
  [
    7488,
    1,
    "t"
  ],
  [
    7489,
    1,
    "u"
  ],
  [
    7490,
    1,
    "w"
  ],
  [
    7491,
    1,
    "a"
  ],
  [
    7492,
    1,
    ""
  ],
  [
    7493,
    1,
    ""
  ],
  [
    7494,
    1,
    ""
  ],
  [
    7495,
    1,
    "b"
  ],
  [
    7496,
    1,
    "d"
  ],
  [
    7497,
    1,
    "e"
  ],
  [
    7498,
    1,
    ""
  ],
  [
    7499,
    1,
    ""
  ],
  [
    7500,
    1,
    ""
  ],
  [
    7501,
    1,
    "g"
  ],
  [
    7502,
    2
  ],
  [
    7503,
    1,
    "k"
  ],
  [
    7504,
    1,
    "m"
  ],
  [
    7505,
    1,
    ""
  ],
  [
    7506,
    1,
    "o"
  ],
  [
    7507,
    1,
    ""
  ],
  [
    7508,
    1,
    ""
  ],
  [
    7509,
    1,
    ""
  ],
  [
    7510,
    1,
    "p"
  ],
  [
    7511,
    1,
    "t"
  ],
  [
    7512,
    1,
    "u"
  ],
  [
    7513,
    1,
    ""
  ],
  [
    7514,
    1,
    ""
  ],
  [
    7515,
    1,
    "v"
  ],
  [
    7516,
    1,
    ""
  ],
  [
    7517,
    1,
    ""
  ],
  [
    7518,
    1,
    ""
  ],
  [
    7519,
    1,
    ""
  ],
  [
    7520,
    1,
    ""
  ],
  [
    7521,
    1,
    ""
  ],
  [
    7522,
    1,
    "i"
  ],
  [
    7523,
    1,
    "r"
  ],
  [
    7524,
    1,
    "u"
  ],
  [
    7525,
    1,
    "v"
  ],
  [
    7526,
    1,
    ""
  ],
  [
    7527,
    1,
    ""
  ],
  [
    7528,
    1,
    ""
  ],
  [
    7529,
    1,
    ""
  ],
  [
    7530,
    1,
    ""
  ],
  [
    7531,
    2
  ],
  [
    [
      7532,
      7543
    ],
    2
  ],
  [
    7544,
    1,
    ""
  ],
  [
    [
      7545,
      7578
    ],
    2
  ],
  [
    7579,
    1,
    ""
  ],
  [
    7580,
    1,
    "c"
  ],
  [
    7581,
    1,
    ""
  ],
  [
    7582,
    1,
    ""
  ],
  [
    7583,
    1,
    ""
  ],
  [
    7584,
    1,
    "f"
  ],
  [
    7585,
    1,
    ""
  ],
  [
    7586,
    1,
    ""
  ],
  [
    7587,
    1,
    ""
  ],
  [
    7588,
    1,
    ""
  ],
  [
    7589,
    1,
    ""
  ],
  [
    7590,
    1,
    ""
  ],
  [
    7591,
    1,
    ""
  ],
  [
    7592,
    1,
    ""
  ],
  [
    7593,
    1,
    ""
  ],
  [
    7594,
    1,
    ""
  ],
  [
    7595,
    1,
    ""
  ],
  [
    7596,
    1,
    ""
  ],
  [
    7597,
    1,
    ""
  ],
  [
    7598,
    1,
    ""
  ],
  [
    7599,
    1,
    ""
  ],
  [
    7600,
    1,
    ""
  ],
  [
    7601,
    1,
    ""
  ],
  [
    7602,
    1,
    ""
  ],
  [
    7603,
    1,
    ""
  ],
  [
    7604,
    1,
    ""
  ],
  [
    7605,
    1,
    ""
  ],
  [
    7606,
    1,
    ""
  ],
  [
    7607,
    1,
    ""
  ],
  [
    7608,
    1,
    ""
  ],
  [
    7609,
    1,
    ""
  ],
  [
    7610,
    1,
    ""
  ],
  [
    7611,
    1,
    "z"
  ],
  [
    7612,
    1,
    ""
  ],
  [
    7613,
    1,
    ""
  ],
  [
    7614,
    1,
    ""
  ],
  [
    7615,
    1,
    ""
  ],
  [
    [
      7616,
      7619
    ],
    2
  ],
  [
    [
      7620,
      7626
    ],
    2
  ],
  [
    [
      7627,
      7654
    ],
    2
  ],
  [
    [
      7655,
      7669
    ],
    2
  ],
  [
    [
      7670,
      7673
    ],
    2
  ],
  [
    7674,
    2
  ],
  [
    7675,
    2
  ],
  [
    7676,
    2
  ],
  [
    7677,
    2
  ],
  [
    [
      7678,
      7679
    ],
    2
  ],
  [
    7680,
    1,
    ""
  ],
  [
    7681,
    2
  ],
  [
    7682,
    1,
    ""
  ],
  [
    7683,
    2
  ],
  [
    7684,
    1,
    ""
  ],
  [
    7685,
    2
  ],
  [
    7686,
    1,
    ""
  ],
  [
    7687,
    2
  ],
  [
    7688,
    1,
    ""
  ],
  [
    7689,
    2
  ],
  [
    7690,
    1,
    ""
  ],
  [
    7691,
    2
  ],
  [
    7692,
    1,
    ""
  ],
  [
    7693,
    2
  ],
  [
    7694,
    1,
    ""
  ],
  [
    7695,
    2
  ],
  [
    7696,
    1,
    ""
  ],
  [
    7697,
    2
  ],
  [
    7698,
    1,
    ""
  ],
  [
    7699,
    2
  ],
  [
    7700,
    1,
    ""
  ],
  [
    7701,
    2
  ],
  [
    7702,
    1,
    ""
  ],
  [
    7703,
    2
  ],
  [
    7704,
    1,
    ""
  ],
  [
    7705,
    2
  ],
  [
    7706,
    1,
    ""
  ],
  [
    7707,
    2
  ],
  [
    7708,
    1,
    ""
  ],
  [
    7709,
    2
  ],
  [
    7710,
    1,
    ""
  ],
  [
    7711,
    2
  ],
  [
    7712,
    1,
    ""
  ],
  [
    7713,
    2
  ],
  [
    7714,
    1,
    ""
  ],
  [
    7715,
    2
  ],
  [
    7716,
    1,
    ""
  ],
  [
    7717,
    2
  ],
  [
    7718,
    1,
    ""
  ],
  [
    7719,
    2
  ],
  [
    7720,
    1,
    ""
  ],
  [
    7721,
    2
  ],
  [
    7722,
    1,
    ""
  ],
  [
    7723,
    2
  ],
  [
    7724,
    1,
    ""
  ],
  [
    7725,
    2
  ],
  [
    7726,
    1,
    ""
  ],
  [
    7727,
    2
  ],
  [
    7728,
    1,
    ""
  ],
  [
    7729,
    2
  ],
  [
    7730,
    1,
    ""
  ],
  [
    7731,
    2
  ],
  [
    7732,
    1,
    ""
  ],
  [
    7733,
    2
  ],
  [
    7734,
    1,
    ""
  ],
  [
    7735,
    2
  ],
  [
    7736,
    1,
    ""
  ],
  [
    7737,
    2
  ],
  [
    7738,
    1,
    ""
  ],
  [
    7739,
    2
  ],
  [
    7740,
    1,
    ""
  ],
  [
    7741,
    2
  ],
  [
    7742,
    1,
    ""
  ],
  [
    7743,
    2
  ],
  [
    7744,
    1,
    ""
  ],
  [
    7745,
    2
  ],
  [
    7746,
    1,
    ""
  ],
  [
    7747,
    2
  ],
  [
    7748,
    1,
    ""
  ],
  [
    7749,
    2
  ],
  [
    7750,
    1,
    ""
  ],
  [
    7751,
    2
  ],
  [
    7752,
    1,
    ""
  ],
  [
    7753,
    2
  ],
  [
    7754,
    1,
    ""
  ],
  [
    7755,
    2
  ],
  [
    7756,
    1,
    ""
  ],
  [
    7757,
    2
  ],
  [
    7758,
    1,
    ""
  ],
  [
    7759,
    2
  ],
  [
    7760,
    1,
    ""
  ],
  [
    7761,
    2
  ],
  [
    7762,
    1,
    ""
  ],
  [
    7763,
    2
  ],
  [
    7764,
    1,
    ""
  ],
  [
    7765,
    2
  ],
  [
    7766,
    1,
    ""
  ],
  [
    7767,
    2
  ],
  [
    7768,
    1,
    ""
  ],
  [
    7769,
    2
  ],
  [
    7770,
    1,
    ""
  ],
  [
    7771,
    2
  ],
  [
    7772,
    1,
    ""
  ],
  [
    7773,
    2
  ],
  [
    7774,
    1,
    ""
  ],
  [
    7775,
    2
  ],
  [
    7776,
    1,
    ""
  ],
  [
    7777,
    2
  ],
  [
    7778,
    1,
    ""
  ],
  [
    7779,
    2
  ],
  [
    7780,
    1,
    ""
  ],
  [
    7781,
    2
  ],
  [
    7782,
    1,
    ""
  ],
  [
    7783,
    2
  ],
  [
    7784,
    1,
    ""
  ],
  [
    7785,
    2
  ],
  [
    7786,
    1,
    ""
  ],
  [
    7787,
    2
  ],
  [
    7788,
    1,
    ""
  ],
  [
    7789,
    2
  ],
  [
    7790,
    1,
    ""
  ],
  [
    7791,
    2
  ],
  [
    7792,
    1,
    ""
  ],
  [
    7793,
    2
  ],
  [
    7794,
    1,
    ""
  ],
  [
    7795,
    2
  ],
  [
    7796,
    1,
    ""
  ],
  [
    7797,
    2
  ],
  [
    7798,
    1,
    ""
  ],
  [
    7799,
    2
  ],
  [
    7800,
    1,
    ""
  ],
  [
    7801,
    2
  ],
  [
    7802,
    1,
    ""
  ],
  [
    7803,
    2
  ],
  [
    7804,
    1,
    ""
  ],
  [
    7805,
    2
  ],
  [
    7806,
    1,
    ""
  ],
  [
    7807,
    2
  ],
  [
    7808,
    1,
    ""
  ],
  [
    7809,
    2
  ],
  [
    7810,
    1,
    ""
  ],
  [
    7811,
    2
  ],
  [
    7812,
    1,
    ""
  ],
  [
    7813,
    2
  ],
  [
    7814,
    1,
    ""
  ],
  [
    7815,
    2
  ],
  [
    7816,
    1,
    ""
  ],
  [
    7817,
    2
  ],
  [
    7818,
    1,
    ""
  ],
  [
    7819,
    2
  ],
  [
    7820,
    1,
    ""
  ],
  [
    7821,
    2
  ],
  [
    7822,
    1,
    ""
  ],
  [
    7823,
    2
  ],
  [
    7824,
    1,
    ""
  ],
  [
    7825,
    2
  ],
  [
    7826,
    1,
    ""
  ],
  [
    7827,
    2
  ],
  [
    7828,
    1,
    ""
  ],
  [
    [
      7829,
      7833
    ],
    2
  ],
  [
    7834,
    1,
    "a"
  ],
  [
    7835,
    1,
    ""
  ],
  [
    [
      7836,
      7837
    ],
    2
  ],
  [
    7838,
    1,
    ""
  ],
  [
    7839,
    2
  ],
  [
    7840,
    1,
    ""
  ],
  [
    7841,
    2
  ],
  [
    7842,
    1,
    ""
  ],
  [
    7843,
    2
  ],
  [
    7844,
    1,
    ""
  ],
  [
    7845,
    2
  ],
  [
    7846,
    1,
    ""
  ],
  [
    7847,
    2
  ],
  [
    7848,
    1,
    ""
  ],
  [
    7849,
    2
  ],
  [
    7850,
    1,
    ""
  ],
  [
    7851,
    2
  ],
  [
    7852,
    1,
    ""
  ],
  [
    7853,
    2
  ],
  [
    7854,
    1,
    ""
  ],
  [
    7855,
    2
  ],
  [
    7856,
    1,
    ""
  ],
  [
    7857,
    2
  ],
  [
    7858,
    1,
    ""
  ],
  [
    7859,
    2
  ],
  [
    7860,
    1,
    ""
  ],
  [
    7861,
    2
  ],
  [
    7862,
    1,
    ""
  ],
  [
    7863,
    2
  ],
  [
    7864,
    1,
    ""
  ],
  [
    7865,
    2
  ],
  [
    7866,
    1,
    ""
  ],
  [
    7867,
    2
  ],
  [
    7868,
    1,
    ""
  ],
  [
    7869,
    2
  ],
  [
    7870,
    1,
    ""
  ],
  [
    7871,
    2
  ],
  [
    7872,
    1,
    ""
  ],
  [
    7873,
    2
  ],
  [
    7874,
    1,
    ""
  ],
  [
    7875,
    2
  ],
  [
    7876,
    1,
    ""
  ],
  [
    7877,
    2
  ],
  [
    7878,
    1,
    ""
  ],
  [
    7879,
    2
  ],
  [
    7880,
    1,
    ""
  ],
  [
    7881,
    2
  ],
  [
    7882,
    1,
    ""
  ],
  [
    7883,
    2
  ],
  [
    7884,
    1,
    ""
  ],
  [
    7885,
    2
  ],
  [
    7886,
    1,
    ""
  ],
  [
    7887,
    2
  ],
  [
    7888,
    1,
    ""
  ],
  [
    7889,
    2
  ],
  [
    7890,
    1,
    ""
  ],
  [
    7891,
    2
  ],
  [
    7892,
    1,
    ""
  ],
  [
    7893,
    2
  ],
  [
    7894,
    1,
    ""
  ],
  [
    7895,
    2
  ],
  [
    7896,
    1,
    ""
  ],
  [
    7897,
    2
  ],
  [
    7898,
    1,
    ""
  ],
  [
    7899,
    2
  ],
  [
    7900,
    1,
    ""
  ],
  [
    7901,
    2
  ],
  [
    7902,
    1,
    ""
  ],
  [
    7903,
    2
  ],
  [
    7904,
    1,
    ""
  ],
  [
    7905,
    2
  ],
  [
    7906,
    1,
    ""
  ],
  [
    7907,
    2
  ],
  [
    7908,
    1,
    ""
  ],
  [
    7909,
    2
  ],
  [
    7910,
    1,
    ""
  ],
  [
    7911,
    2
  ],
  [
    7912,
    1,
    ""
  ],
  [
    7913,
    2
  ],
  [
    7914,
    1,
    ""
  ],
  [
    7915,
    2
  ],
  [
    7916,
    1,
    ""
  ],
  [
    7917,
    2
  ],
  [
    7918,
    1,
    ""
  ],
  [
    7919,
    2
  ],
  [
    7920,
    1,
    ""
  ],
  [
    7921,
    2
  ],
  [
    7922,
    1,
    ""
  ],
  [
    7923,
    2
  ],
  [
    7924,
    1,
    ""
  ],
  [
    7925,
    2
  ],
  [
    7926,
    1,
    ""
  ],
  [
    7927,
    2
  ],
  [
    7928,
    1,
    ""
  ],
  [
    7929,
    2
  ],
  [
    7930,
    1,
    ""
  ],
  [
    7931,
    2
  ],
  [
    7932,
    1,
    ""
  ],
  [
    7933,
    2
  ],
  [
    7934,
    1,
    ""
  ],
  [
    7935,
    2
  ],
  [
    [
      7936,
      7943
    ],
    2
  ],
  [
    7944,
    1,
    ""
  ],
  [
    7945,
    1,
    ""
  ],
  [
    7946,
    1,
    ""
  ],
  [
    7947,
    1,
    ""
  ],
  [
    7948,
    1,
    ""
  ],
  [
    7949,
    1,
    ""
  ],
  [
    7950,
    1,
    ""
  ],
  [
    7951,
    1,
    ""
  ],
  [
    [
      7952,
      7957
    ],
    2
  ],
  [
    [
      7958,
      7959
    ],
    3
  ],
  [
    7960,
    1,
    ""
  ],
  [
    7961,
    1,
    ""
  ],
  [
    7962,
    1,
    ""
  ],
  [
    7963,
    1,
    ""
  ],
  [
    7964,
    1,
    ""
  ],
  [
    7965,
    1,
    ""
  ],
  [
    [
      7966,
      7967
    ],
    3
  ],
  [
    [
      7968,
      7975
    ],
    2
  ],
  [
    7976,
    1,
    ""
  ],
  [
    7977,
    1,
    ""
  ],
  [
    7978,
    1,
    ""
  ],
  [
    7979,
    1,
    ""
  ],
  [
    7980,
    1,
    ""
  ],
  [
    7981,
    1,
    ""
  ],
  [
    7982,
    1,
    ""
  ],
  [
    7983,
    1,
    ""
  ],
  [
    [
      7984,
      7991
    ],
    2
  ],
  [
    7992,
    1,
    ""
  ],
  [
    7993,
    1,
    ""
  ],
  [
    7994,
    1,
    ""
  ],
  [
    7995,
    1,
    ""
  ],
  [
    7996,
    1,
    ""
  ],
  [
    7997,
    1,
    ""
  ],
  [
    7998,
    1,
    ""
  ],
  [
    7999,
    1,
    ""
  ],
  [
    [
      8e3,
      8005
    ],
    2
  ],
  [
    [
      8006,
      8007
    ],
    3
  ],
  [
    8008,
    1,
    ""
  ],
  [
    8009,
    1,
    ""
  ],
  [
    8010,
    1,
    ""
  ],
  [
    8011,
    1,
    ""
  ],
  [
    8012,
    1,
    ""
  ],
  [
    8013,
    1,
    ""
  ],
  [
    [
      8014,
      8015
    ],
    3
  ],
  [
    [
      8016,
      8023
    ],
    2
  ],
  [
    8024,
    3
  ],
  [
    8025,
    1,
    ""
  ],
  [
    8026,
    3
  ],
  [
    8027,
    1,
    ""
  ],
  [
    8028,
    3
  ],
  [
    8029,
    1,
    ""
  ],
  [
    8030,
    3
  ],
  [
    8031,
    1,
    ""
  ],
  [
    [
      8032,
      8039
    ],
    2
  ],
  [
    8040,
    1,
    ""
  ],
  [
    8041,
    1,
    ""
  ],
  [
    8042,
    1,
    ""
  ],
  [
    8043,
    1,
    ""
  ],
  [
    8044,
    1,
    ""
  ],
  [
    8045,
    1,
    ""
  ],
  [
    8046,
    1,
    ""
  ],
  [
    8047,
    1,
    ""
  ],
  [
    8048,
    2
  ],
  [
    8049,
    1,
    ""
  ],
  [
    8050,
    2
  ],
  [
    8051,
    1,
    ""
  ],
  [
    8052,
    2
  ],
  [
    8053,
    1,
    ""
  ],
  [
    8054,
    2
  ],
  [
    8055,
    1,
    ""
  ],
  [
    8056,
    2
  ],
  [
    8057,
    1,
    ""
  ],
  [
    8058,
    2
  ],
  [
    8059,
    1,
    ""
  ],
  [
    8060,
    2
  ],
  [
    8061,
    1,
    ""
  ],
  [
    [
      8062,
      8063
    ],
    3
  ],
  [
    8064,
    1,
    ""
  ],
  [
    8065,
    1,
    ""
  ],
  [
    8066,
    1,
    ""
  ],
  [
    8067,
    1,
    ""
  ],
  [
    8068,
    1,
    ""
  ],
  [
    8069,
    1,
    ""
  ],
  [
    8070,
    1,
    ""
  ],
  [
    8071,
    1,
    ""
  ],
  [
    8072,
    1,
    ""
  ],
  [
    8073,
    1,
    ""
  ],
  [
    8074,
    1,
    ""
  ],
  [
    8075,
    1,
    ""
  ],
  [
    8076,
    1,
    ""
  ],
  [
    8077,
    1,
    ""
  ],
  [
    8078,
    1,
    ""
  ],
  [
    8079,
    1,
    ""
  ],
  [
    8080,
    1,
    ""
  ],
  [
    8081,
    1,
    ""
  ],
  [
    8082,
    1,
    ""
  ],
  [
    8083,
    1,
    ""
  ],
  [
    8084,
    1,
    ""
  ],
  [
    8085,
    1,
    ""
  ],
  [
    8086,
    1,
    ""
  ],
  [
    8087,
    1,
    ""
  ],
  [
    8088,
    1,
    ""
  ],
  [
    8089,
    1,
    ""
  ],
  [
    8090,
    1,
    ""
  ],
  [
    8091,
    1,
    ""
  ],
  [
    8092,
    1,
    ""
  ],
  [
    8093,
    1,
    ""
  ],
  [
    8094,
    1,
    ""
  ],
  [
    8095,
    1,
    ""
  ],
  [
    8096,
    1,
    ""
  ],
  [
    8097,
    1,
    ""
  ],
  [
    8098,
    1,
    ""
  ],
  [
    8099,
    1,
    ""
  ],
  [
    8100,
    1,
    ""
  ],
  [
    8101,
    1,
    ""
  ],
  [
    8102,
    1,
    ""
  ],
  [
    8103,
    1,
    ""
  ],
  [
    8104,
    1,
    ""
  ],
  [
    8105,
    1,
    ""
  ],
  [
    8106,
    1,
    ""
  ],
  [
    8107,
    1,
    ""
  ],
  [
    8108,
    1,
    ""
  ],
  [
    8109,
    1,
    ""
  ],
  [
    8110,
    1,
    ""
  ],
  [
    8111,
    1,
    ""
  ],
  [
    [
      8112,
      8113
    ],
    2
  ],
  [
    8114,
    1,
    ""
  ],
  [
    8115,
    1,
    ""
  ],
  [
    8116,
    1,
    ""
  ],
  [
    8117,
    3
  ],
  [
    8118,
    2
  ],
  [
    8119,
    1,
    ""
  ],
  [
    8120,
    1,
    ""
  ],
  [
    8121,
    1,
    ""
  ],
  [
    8122,
    1,
    ""
  ],
  [
    8123,
    1,
    ""
  ],
  [
    8124,
    1,
    ""
  ],
  [
    8125,
    5,
    " "
  ],
  [
    8126,
    1,
    ""
  ],
  [
    8127,
    5,
    " "
  ],
  [
    8128,
    5,
    " "
  ],
  [
    8129,
    5,
    " "
  ],
  [
    8130,
    1,
    ""
  ],
  [
    8131,
    1,
    ""
  ],
  [
    8132,
    1,
    ""
  ],
  [
    8133,
    3
  ],
  [
    8134,
    2
  ],
  [
    8135,
    1,
    ""
  ],
  [
    8136,
    1,
    ""
  ],
  [
    8137,
    1,
    ""
  ],
  [
    8138,
    1,
    ""
  ],
  [
    8139,
    1,
    ""
  ],
  [
    8140,
    1,
    ""
  ],
  [
    8141,
    5,
    " "
  ],
  [
    8142,
    5,
    " "
  ],
  [
    8143,
    5,
    " "
  ],
  [
    [
      8144,
      8146
    ],
    2
  ],
  [
    8147,
    1,
    ""
  ],
  [
    [
      8148,
      8149
    ],
    3
  ],
  [
    [
      8150,
      8151
    ],
    2
  ],
  [
    8152,
    1,
    ""
  ],
  [
    8153,
    1,
    ""
  ],
  [
    8154,
    1,
    ""
  ],
  [
    8155,
    1,
    ""
  ],
  [
    8156,
    3
  ],
  [
    8157,
    5,
    " "
  ],
  [
    8158,
    5,
    " "
  ],
  [
    8159,
    5,
    " "
  ],
  [
    [
      8160,
      8162
    ],
    2
  ],
  [
    8163,
    1,
    ""
  ],
  [
    [
      8164,
      8167
    ],
    2
  ],
  [
    8168,
    1,
    ""
  ],
  [
    8169,
    1,
    ""
  ],
  [
    8170,
    1,
    ""
  ],
  [
    8171,
    1,
    ""
  ],
  [
    8172,
    1,
    ""
  ],
  [
    8173,
    5,
    " "
  ],
  [
    8174,
    5,
    " "
  ],
  [
    8175,
    5,
    "`"
  ],
  [
    [
      8176,
      8177
    ],
    3
  ],
  [
    8178,
    1,
    ""
  ],
  [
    8179,
    1,
    ""
  ],
  [
    8180,
    1,
    ""
  ],
  [
    8181,
    3
  ],
  [
    8182,
    2
  ],
  [
    8183,
    1,
    ""
  ],
  [
    8184,
    1,
    ""
  ],
  [
    8185,
    1,
    ""
  ],
  [
    8186,
    1,
    ""
  ],
  [
    8187,
    1,
    ""
  ],
  [
    8188,
    1,
    ""
  ],
  [
    8189,
    5,
    " "
  ],
  [
    8190,
    5,
    " "
  ],
  [
    8191,
    3
  ],
  [
    [
      8192,
      8202
    ],
    5,
    " "
  ],
  [
    8203,
    7
  ],
  [
    [
      8204,
      8205
    ],
    6,
    ""
  ],
  [
    [
      8206,
      8207
    ],
    3
  ],
  [
    8208,
    2
  ],
  [
    8209,
    1,
    ""
  ],
  [
    [
      8210,
      8214
    ],
    2
  ],
  [
    8215,
    5,
    " "
  ],
  [
    [
      8216,
      8227
    ],
    2
  ],
  [
    [
      8228,
      8230
    ],
    3
  ],
  [
    8231,
    2
  ],
  [
    [
      8232,
      8238
    ],
    3
  ],
  [
    8239,
    5,
    " "
  ],
  [
    [
      8240,
      8242
    ],
    2
  ],
  [
    8243,
    1,
    ""
  ],
  [
    8244,
    1,
    ""
  ],
  [
    8245,
    2
  ],
  [
    8246,
    1,
    ""
  ],
  [
    8247,
    1,
    ""
  ],
  [
    [
      8248,
      8251
    ],
    2
  ],
  [
    8252,
    5,
    "!!"
  ],
  [
    8253,
    2
  ],
  [
    8254,
    5,
    " "
  ],
  [
    [
      8255,
      8262
    ],
    2
  ],
  [
    8263,
    5,
    "??"
  ],
  [
    8264,
    5,
    "?!"
  ],
  [
    8265,
    5,
    "!?"
  ],
  [
    [
      8266,
      8269
    ],
    2
  ],
  [
    [
      8270,
      8274
    ],
    2
  ],
  [
    [
      8275,
      8276
    ],
    2
  ],
  [
    [
      8277,
      8278
    ],
    2
  ],
  [
    8279,
    1,
    ""
  ],
  [
    [
      8280,
      8286
    ],
    2
  ],
  [
    8287,
    5,
    " "
  ],
  [
    8288,
    7
  ],
  [
    [
      8289,
      8291
    ],
    3
  ],
  [
    8292,
    7
  ],
  [
    8293,
    3
  ],
  [
    [
      8294,
      8297
    ],
    3
  ],
  [
    [
      8298,
      8303
    ],
    3
  ],
  [
    8304,
    1,
    "0"
  ],
  [
    8305,
    1,
    "i"
  ],
  [
    [
      8306,
      8307
    ],
    3
  ],
  [
    8308,
    1,
    "4"
  ],
  [
    8309,
    1,
    "5"
  ],
  [
    8310,
    1,
    "6"
  ],
  [
    8311,
    1,
    "7"
  ],
  [
    8312,
    1,
    "8"
  ],
  [
    8313,
    1,
    "9"
  ],
  [
    8314,
    5,
    "+"
  ],
  [
    8315,
    1,
    ""
  ],
  [
    8316,
    5,
    "="
  ],
  [
    8317,
    5,
    "("
  ],
  [
    8318,
    5,
    ")"
  ],
  [
    8319,
    1,
    "n"
  ],
  [
    8320,
    1,
    "0"
  ],
  [
    8321,
    1,
    "1"
  ],
  [
    8322,
    1,
    "2"
  ],
  [
    8323,
    1,
    "3"
  ],
  [
    8324,
    1,
    "4"
  ],
  [
    8325,
    1,
    "5"
  ],
  [
    8326,
    1,
    "6"
  ],
  [
    8327,
    1,
    "7"
  ],
  [
    8328,
    1,
    "8"
  ],
  [
    8329,
    1,
    "9"
  ],
  [
    8330,
    5,
    "+"
  ],
  [
    8331,
    1,
    ""
  ],
  [
    8332,
    5,
    "="
  ],
  [
    8333,
    5,
    "("
  ],
  [
    8334,
    5,
    ")"
  ],
  [
    8335,
    3
  ],
  [
    8336,
    1,
    "a"
  ],
  [
    8337,
    1,
    "e"
  ],
  [
    8338,
    1,
    "o"
  ],
  [
    8339,
    1,
    "x"
  ],
  [
    8340,
    1,
    ""
  ],
  [
    8341,
    1,
    "h"
  ],
  [
    8342,
    1,
    "k"
  ],
  [
    8343,
    1,
    "l"
  ],
  [
    8344,
    1,
    "m"
  ],
  [
    8345,
    1,
    "n"
  ],
  [
    8346,
    1,
    "p"
  ],
  [
    8347,
    1,
    "s"
  ],
  [
    8348,
    1,
    "t"
  ],
  [
    [
      8349,
      8351
    ],
    3
  ],
  [
    [
      8352,
      8359
    ],
    2
  ],
  [
    8360,
    1,
    "rs"
  ],
  [
    [
      8361,
      8362
    ],
    2
  ],
  [
    8363,
    2
  ],
  [
    8364,
    2
  ],
  [
    [
      8365,
      8367
    ],
    2
  ],
  [
    [
      8368,
      8369
    ],
    2
  ],
  [
    [
      8370,
      8373
    ],
    2
  ],
  [
    [
      8374,
      8376
    ],
    2
  ],
  [
    8377,
    2
  ],
  [
    8378,
    2
  ],
  [
    [
      8379,
      8381
    ],
    2
  ],
  [
    8382,
    2
  ],
  [
    8383,
    2
  ],
  [
    8384,
    2
  ],
  [
    [
      8385,
      8399
    ],
    3
  ],
  [
    [
      8400,
      8417
    ],
    2
  ],
  [
    [
      8418,
      8419
    ],
    2
  ],
  [
    [
      8420,
      8426
    ],
    2
  ],
  [
    8427,
    2
  ],
  [
    [
      8428,
      8431
    ],
    2
  ],
  [
    8432,
    2
  ],
  [
    [
      8433,
      8447
    ],
    3
  ],
  [
    8448,
    5,
    "a/c"
  ],
  [
    8449,
    5,
    "a/s"
  ],
  [
    8450,
    1,
    "c"
  ],
  [
    8451,
    1,
    "c"
  ],
  [
    8452,
    2
  ],
  [
    8453,
    5,
    "c/o"
  ],
  [
    8454,
    5,
    "c/u"
  ],
  [
    8455,
    1,
    ""
  ],
  [
    8456,
    2
  ],
  [
    8457,
    1,
    "f"
  ],
  [
    8458,
    1,
    "g"
  ],
  [
    [
      8459,
      8462
    ],
    1,
    "h"
  ],
  [
    8463,
    1,
    ""
  ],
  [
    [
      8464,
      8465
    ],
    1,
    "i"
  ],
  [
    [
      8466,
      8467
    ],
    1,
    "l"
  ],
  [
    8468,
    2
  ],
  [
    8469,
    1,
    "n"
  ],
  [
    8470,
    1,
    "no"
  ],
  [
    [
      8471,
      8472
    ],
    2
  ],
  [
    8473,
    1,
    "p"
  ],
  [
    8474,
    1,
    "q"
  ],
  [
    [
      8475,
      8477
    ],
    1,
    "r"
  ],
  [
    [
      8478,
      8479
    ],
    2
  ],
  [
    8480,
    1,
    "sm"
  ],
  [
    8481,
    1,
    "tel"
  ],
  [
    8482,
    1,
    "tm"
  ],
  [
    8483,
    2
  ],
  [
    8484,
    1,
    "z"
  ],
  [
    8485,
    2
  ],
  [
    8486,
    1,
    ""
  ],
  [
    8487,
    2
  ],
  [
    8488,
    1,
    "z"
  ],
  [
    8489,
    2
  ],
  [
    8490,
    1,
    "k"
  ],
  [
    8491,
    1,
    ""
  ],
  [
    8492,
    1,
    "b"
  ],
  [
    8493,
    1,
    "c"
  ],
  [
    8494,
    2
  ],
  [
    [
      8495,
      8496
    ],
    1,
    "e"
  ],
  [
    8497,
    1,
    "f"
  ],
  [
    8498,
    3
  ],
  [
    8499,
    1,
    "m"
  ],
  [
    8500,
    1,
    "o"
  ],
  [
    8501,
    1,
    ""
  ],
  [
    8502,
    1,
    ""
  ],
  [
    8503,
    1,
    ""
  ],
  [
    8504,
    1,
    ""
  ],
  [
    8505,
    1,
    "i"
  ],
  [
    8506,
    2
  ],
  [
    8507,
    1,
    "fax"
  ],
  [
    8508,
    1,
    ""
  ],
  [
    [
      8509,
      8510
    ],
    1,
    ""
  ],
  [
    8511,
    1,
    ""
  ],
  [
    8512,
    1,
    ""
  ],
  [
    [
      8513,
      8516
    ],
    2
  ],
  [
    [
      8517,
      8518
    ],
    1,
    "d"
  ],
  [
    8519,
    1,
    "e"
  ],
  [
    8520,
    1,
    "i"
  ],
  [
    8521,
    1,
    "j"
  ],
  [
    [
      8522,
      8523
    ],
    2
  ],
  [
    8524,
    2
  ],
  [
    8525,
    2
  ],
  [
    8526,
    2
  ],
  [
    8527,
    2
  ],
  [
    8528,
    1,
    "17"
  ],
  [
    8529,
    1,
    "19"
  ],
  [
    8530,
    1,
    "110"
  ],
  [
    8531,
    1,
    "13"
  ],
  [
    8532,
    1,
    "23"
  ],
  [
    8533,
    1,
    "15"
  ],
  [
    8534,
    1,
    "25"
  ],
  [
    8535,
    1,
    "35"
  ],
  [
    8536,
    1,
    "45"
  ],
  [
    8537,
    1,
    "16"
  ],
  [
    8538,
    1,
    "56"
  ],
  [
    8539,
    1,
    "18"
  ],
  [
    8540,
    1,
    "38"
  ],
  [
    8541,
    1,
    "58"
  ],
  [
    8542,
    1,
    "78"
  ],
  [
    8543,
    1,
    "1"
  ],
  [
    8544,
    1,
    "i"
  ],
  [
    8545,
    1,
    "ii"
  ],
  [
    8546,
    1,
    "iii"
  ],
  [
    8547,
    1,
    "iv"
  ],
  [
    8548,
    1,
    "v"
  ],
  [
    8549,
    1,
    "vi"
  ],
  [
    8550,
    1,
    "vii"
  ],
  [
    8551,
    1,
    "viii"
  ],
  [
    8552,
    1,
    "ix"
  ],
  [
    8553,
    1,
    "x"
  ],
  [
    8554,
    1,
    "xi"
  ],
  [
    8555,
    1,
    "xii"
  ],
  [
    8556,
    1,
    "l"
  ],
  [
    8557,
    1,
    "c"
  ],
  [
    8558,
    1,
    "d"
  ],
  [
    8559,
    1,
    "m"
  ],
  [
    8560,
    1,
    "i"
  ],
  [
    8561,
    1,
    "ii"
  ],
  [
    8562,
    1,
    "iii"
  ],
  [
    8563,
    1,
    "iv"
  ],
  [
    8564,
    1,
    "v"
  ],
  [
    8565,
    1,
    "vi"
  ],
  [
    8566,
    1,
    "vii"
  ],
  [
    8567,
    1,
    "viii"
  ],
  [
    8568,
    1,
    "ix"
  ],
  [
    8569,
    1,
    "x"
  ],
  [
    8570,
    1,
    "xi"
  ],
  [
    8571,
    1,
    "xii"
  ],
  [
    8572,
    1,
    "l"
  ],
  [
    8573,
    1,
    "c"
  ],
  [
    8574,
    1,
    "d"
  ],
  [
    8575,
    1,
    "m"
  ],
  [
    [
      8576,
      8578
    ],
    2
  ],
  [
    8579,
    3
  ],
  [
    8580,
    2
  ],
  [
    [
      8581,
      8584
    ],
    2
  ],
  [
    8585,
    1,
    "03"
  ],
  [
    [
      8586,
      8587
    ],
    2
  ],
  [
    [
      8588,
      8591
    ],
    3
  ],
  [
    [
      8592,
      8682
    ],
    2
  ],
  [
    [
      8683,
      8691
    ],
    2
  ],
  [
    [
      8692,
      8703
    ],
    2
  ],
  [
    [
      8704,
      8747
    ],
    2
  ],
  [
    8748,
    1,
    ""
  ],
  [
    8749,
    1,
    ""
  ],
  [
    8750,
    2
  ],
  [
    8751,
    1,
    ""
  ],
  [
    8752,
    1,
    ""
  ],
  [
    [
      8753,
      8945
    ],
    2
  ],
  [
    [
      8946,
      8959
    ],
    2
  ],
  [
    8960,
    2
  ],
  [
    8961,
    2
  ],
  [
    [
      8962,
      9e3
    ],
    2
  ],
  [
    9001,
    1,
    ""
  ],
  [
    9002,
    1,
    ""
  ],
  [
    [
      9003,
      9082
    ],
    2
  ],
  [
    9083,
    2
  ],
  [
    9084,
    2
  ],
  [
    [
      9085,
      9114
    ],
    2
  ],
  [
    [
      9115,
      9166
    ],
    2
  ],
  [
    [
      9167,
      9168
    ],
    2
  ],
  [
    [
      9169,
      9179
    ],
    2
  ],
  [
    [
      9180,
      9191
    ],
    2
  ],
  [
    9192,
    2
  ],
  [
    [
      9193,
      9203
    ],
    2
  ],
  [
    [
      9204,
      9210
    ],
    2
  ],
  [
    [
      9211,
      9214
    ],
    2
  ],
  [
    9215,
    2
  ],
  [
    [
      9216,
      9252
    ],
    2
  ],
  [
    [
      9253,
      9254
    ],
    2
  ],
  [
    [
      9255,
      9279
    ],
    3
  ],
  [
    [
      9280,
      9290
    ],
    2
  ],
  [
    [
      9291,
      9311
    ],
    3
  ],
  [
    9312,
    1,
    "1"
  ],
  [
    9313,
    1,
    "2"
  ],
  [
    9314,
    1,
    "3"
  ],
  [
    9315,
    1,
    "4"
  ],
  [
    9316,
    1,
    "5"
  ],
  [
    9317,
    1,
    "6"
  ],
  [
    9318,
    1,
    "7"
  ],
  [
    9319,
    1,
    "8"
  ],
  [
    9320,
    1,
    "9"
  ],
  [
    9321,
    1,
    "10"
  ],
  [
    9322,
    1,
    "11"
  ],
  [
    9323,
    1,
    "12"
  ],
  [
    9324,
    1,
    "13"
  ],
  [
    9325,
    1,
    "14"
  ],
  [
    9326,
    1,
    "15"
  ],
  [
    9327,
    1,
    "16"
  ],
  [
    9328,
    1,
    "17"
  ],
  [
    9329,
    1,
    "18"
  ],
  [
    9330,
    1,
    "19"
  ],
  [
    9331,
    1,
    "20"
  ],
  [
    9332,
    5,
    "(1)"
  ],
  [
    9333,
    5,
    "(2)"
  ],
  [
    9334,
    5,
    "(3)"
  ],
  [
    9335,
    5,
    "(4)"
  ],
  [
    9336,
    5,
    "(5)"
  ],
  [
    9337,
    5,
    "(6)"
  ],
  [
    9338,
    5,
    "(7)"
  ],
  [
    9339,
    5,
    "(8)"
  ],
  [
    9340,
    5,
    "(9)"
  ],
  [
    9341,
    5,
    "(10)"
  ],
  [
    9342,
    5,
    "(11)"
  ],
  [
    9343,
    5,
    "(12)"
  ],
  [
    9344,
    5,
    "(13)"
  ],
  [
    9345,
    5,
    "(14)"
  ],
  [
    9346,
    5,
    "(15)"
  ],
  [
    9347,
    5,
    "(16)"
  ],
  [
    9348,
    5,
    "(17)"
  ],
  [
    9349,
    5,
    "(18)"
  ],
  [
    9350,
    5,
    "(19)"
  ],
  [
    9351,
    5,
    "(20)"
  ],
  [
    [
      9352,
      9371
    ],
    3
  ],
  [
    9372,
    5,
    "(a)"
  ],
  [
    9373,
    5,
    "(b)"
  ],
  [
    9374,
    5,
    "(c)"
  ],
  [
    9375,
    5,
    "(d)"
  ],
  [
    9376,
    5,
    "(e)"
  ],
  [
    9377,
    5,
    "(f)"
  ],
  [
    9378,
    5,
    "(g)"
  ],
  [
    9379,
    5,
    "(h)"
  ],
  [
    9380,
    5,
    "(i)"
  ],
  [
    9381,
    5,
    "(j)"
  ],
  [
    9382,
    5,
    "(k)"
  ],
  [
    9383,
    5,
    "(l)"
  ],
  [
    9384,
    5,
    "(m)"
  ],
  [
    9385,
    5,
    "(n)"
  ],
  [
    9386,
    5,
    "(o)"
  ],
  [
    9387,
    5,
    "(p)"
  ],
  [
    9388,
    5,
    "(q)"
  ],
  [
    9389,
    5,
    "(r)"
  ],
  [
    9390,
    5,
    "(s)"
  ],
  [
    9391,
    5,
    "(t)"
  ],
  [
    9392,
    5,
    "(u)"
  ],
  [
    9393,
    5,
    "(v)"
  ],
  [
    9394,
    5,
    "(w)"
  ],
  [
    9395,
    5,
    "(x)"
  ],
  [
    9396,
    5,
    "(y)"
  ],
  [
    9397,
    5,
    "(z)"
  ],
  [
    9398,
    1,
    "a"
  ],
  [
    9399,
    1,
    "b"
  ],
  [
    9400,
    1,
    "c"
  ],
  [
    9401,
    1,
    "d"
  ],
  [
    9402,
    1,
    "e"
  ],
  [
    9403,
    1,
    "f"
  ],
  [
    9404,
    1,
    "g"
  ],
  [
    9405,
    1,
    "h"
  ],
  [
    9406,
    1,
    "i"
  ],
  [
    9407,
    1,
    "j"
  ],
  [
    9408,
    1,
    "k"
  ],
  [
    9409,
    1,
    "l"
  ],
  [
    9410,
    1,
    "m"
  ],
  [
    9411,
    1,
    "n"
  ],
  [
    9412,
    1,
    "o"
  ],
  [
    9413,
    1,
    "p"
  ],
  [
    9414,
    1,
    "q"
  ],
  [
    9415,
    1,
    "r"
  ],
  [
    9416,
    1,
    "s"
  ],
  [
    9417,
    1,
    "t"
  ],
  [
    9418,
    1,
    "u"
  ],
  [
    9419,
    1,
    "v"
  ],
  [
    9420,
    1,
    "w"
  ],
  [
    9421,
    1,
    "x"
  ],
  [
    9422,
    1,
    "y"
  ],
  [
    9423,
    1,
    "z"
  ],
  [
    9424,
    1,
    "a"
  ],
  [
    9425,
    1,
    "b"
  ],
  [
    9426,
    1,
    "c"
  ],
  [
    9427,
    1,
    "d"
  ],
  [
    9428,
    1,
    "e"
  ],
  [
    9429,
    1,
    "f"
  ],
  [
    9430,
    1,
    "g"
  ],
  [
    9431,
    1,
    "h"
  ],
  [
    9432,
    1,
    "i"
  ],
  [
    9433,
    1,
    "j"
  ],
  [
    9434,
    1,
    "k"
  ],
  [
    9435,
    1,
    "l"
  ],
  [
    9436,
    1,
    "m"
  ],
  [
    9437,
    1,
    "n"
  ],
  [
    9438,
    1,
    "o"
  ],
  [
    9439,
    1,
    "p"
  ],
  [
    9440,
    1,
    "q"
  ],
  [
    9441,
    1,
    "r"
  ],
  [
    9442,
    1,
    "s"
  ],
  [
    9443,
    1,
    "t"
  ],
  [
    9444,
    1,
    "u"
  ],
  [
    9445,
    1,
    "v"
  ],
  [
    9446,
    1,
    "w"
  ],
  [
    9447,
    1,
    "x"
  ],
  [
    9448,
    1,
    "y"
  ],
  [
    9449,
    1,
    "z"
  ],
  [
    9450,
    1,
    "0"
  ],
  [
    [
      9451,
      9470
    ],
    2
  ],
  [
    9471,
    2
  ],
  [
    [
      9472,
      9621
    ],
    2
  ],
  [
    [
      9622,
      9631
    ],
    2
  ],
  [
    [
      9632,
      9711
    ],
    2
  ],
  [
    [
      9712,
      9719
    ],
    2
  ],
  [
    [
      9720,
      9727
    ],
    2
  ],
  [
    [
      9728,
      9747
    ],
    2
  ],
  [
    [
      9748,
      9749
    ],
    2
  ],
  [
    [
      9750,
      9751
    ],
    2
  ],
  [
    9752,
    2
  ],
  [
    9753,
    2
  ],
  [
    [
      9754,
      9839
    ],
    2
  ],
  [
    [
      9840,
      9841
    ],
    2
  ],
  [
    [
      9842,
      9853
    ],
    2
  ],
  [
    [
      9854,
      9855
    ],
    2
  ],
  [
    [
      9856,
      9865
    ],
    2
  ],
  [
    [
      9866,
      9873
    ],
    2
  ],
  [
    [
      9874,
      9884
    ],
    2
  ],
  [
    9885,
    2
  ],
  [
    [
      9886,
      9887
    ],
    2
  ],
  [
    [
      9888,
      9889
    ],
    2
  ],
  [
    [
      9890,
      9905
    ],
    2
  ],
  [
    9906,
    2
  ],
  [
    [
      9907,
      9916
    ],
    2
  ],
  [
    [
      9917,
      9919
    ],
    2
  ],
  [
    [
      9920,
      9923
    ],
    2
  ],
  [
    [
      9924,
      9933
    ],
    2
  ],
  [
    9934,
    2
  ],
  [
    [
      9935,
      9953
    ],
    2
  ],
  [
    9954,
    2
  ],
  [
    9955,
    2
  ],
  [
    [
      9956,
      9959
    ],
    2
  ],
  [
    [
      9960,
      9983
    ],
    2
  ],
  [
    9984,
    2
  ],
  [
    [
      9985,
      9988
    ],
    2
  ],
  [
    9989,
    2
  ],
  [
    [
      9990,
      9993
    ],
    2
  ],
  [
    [
      9994,
      9995
    ],
    2
  ],
  [
    [
      9996,
      10023
    ],
    2
  ],
  [
    10024,
    2
  ],
  [
    [
      10025,
      10059
    ],
    2
  ],
  [
    10060,
    2
  ],
  [
    10061,
    2
  ],
  [
    10062,
    2
  ],
  [
    [
      10063,
      10066
    ],
    2
  ],
  [
    [
      10067,
      10069
    ],
    2
  ],
  [
    10070,
    2
  ],
  [
    10071,
    2
  ],
  [
    [
      10072,
      10078
    ],
    2
  ],
  [
    [
      10079,
      10080
    ],
    2
  ],
  [
    [
      10081,
      10087
    ],
    2
  ],
  [
    [
      10088,
      10101
    ],
    2
  ],
  [
    [
      10102,
      10132
    ],
    2
  ],
  [
    [
      10133,
      10135
    ],
    2
  ],
  [
    [
      10136,
      10159
    ],
    2
  ],
  [
    10160,
    2
  ],
  [
    [
      10161,
      10174
    ],
    2
  ],
  [
    10175,
    2
  ],
  [
    [
      10176,
      10182
    ],
    2
  ],
  [
    [
      10183,
      10186
    ],
    2
  ],
  [
    10187,
    2
  ],
  [
    10188,
    2
  ],
  [
    10189,
    2
  ],
  [
    [
      10190,
      10191
    ],
    2
  ],
  [
    [
      10192,
      10219
    ],
    2
  ],
  [
    [
      10220,
      10223
    ],
    2
  ],
  [
    [
      10224,
      10239
    ],
    2
  ],
  [
    [
      10240,
      10495
    ],
    2
  ],
  [
    [
      10496,
      10763
    ],
    2
  ],
  [
    10764,
    1,
    ""
  ],
  [
    [
      10765,
      10867
    ],
    2
  ],
  [
    10868,
    5,
    "::="
  ],
  [
    10869,
    5,
    "=="
  ],
  [
    10870,
    5,
    "==="
  ],
  [
    [
      10871,
      10971
    ],
    2
  ],
  [
    10972,
    1,
    ""
  ],
  [
    [
      10973,
      11007
    ],
    2
  ],
  [
    [
      11008,
      11021
    ],
    2
  ],
  [
    [
      11022,
      11027
    ],
    2
  ],
  [
    [
      11028,
      11034
    ],
    2
  ],
  [
    [
      11035,
      11039
    ],
    2
  ],
  [
    [
      11040,
      11043
    ],
    2
  ],
  [
    [
      11044,
      11084
    ],
    2
  ],
  [
    [
      11085,
      11087
    ],
    2
  ],
  [
    [
      11088,
      11092
    ],
    2
  ],
  [
    [
      11093,
      11097
    ],
    2
  ],
  [
    [
      11098,
      11123
    ],
    2
  ],
  [
    [
      11124,
      11125
    ],
    3
  ],
  [
    [
      11126,
      11157
    ],
    2
  ],
  [
    11158,
    3
  ],
  [
    11159,
    2
  ],
  [
    [
      11160,
      11193
    ],
    2
  ],
  [
    [
      11194,
      11196
    ],
    2
  ],
  [
    [
      11197,
      11208
    ],
    2
  ],
  [
    11209,
    2
  ],
  [
    [
      11210,
      11217
    ],
    2
  ],
  [
    11218,
    2
  ],
  [
    [
      11219,
      11243
    ],
    2
  ],
  [
    [
      11244,
      11247
    ],
    2
  ],
  [
    [
      11248,
      11262
    ],
    2
  ],
  [
    11263,
    2
  ],
  [
    11264,
    1,
    ""
  ],
  [
    11265,
    1,
    ""
  ],
  [
    11266,
    1,
    ""
  ],
  [
    11267,
    1,
    ""
  ],
  [
    11268,
    1,
    ""
  ],
  [
    11269,
    1,
    ""
  ],
  [
    11270,
    1,
    ""
  ],
  [
    11271,
    1,
    ""
  ],
  [
    11272,
    1,
    ""
  ],
  [
    11273,
    1,
    ""
  ],
  [
    11274,
    1,
    ""
  ],
  [
    11275,
    1,
    ""
  ],
  [
    11276,
    1,
    ""
  ],
  [
    11277,
    1,
    ""
  ],
  [
    11278,
    1,
    ""
  ],
  [
    11279,
    1,
    ""
  ],
  [
    11280,
    1,
    ""
  ],
  [
    11281,
    1,
    ""
  ],
  [
    11282,
    1,
    ""
  ],
  [
    11283,
    1,
    ""
  ],
  [
    11284,
    1,
    ""
  ],
  [
    11285,
    1,
    ""
  ],
  [
    11286,
    1,
    ""
  ],
  [
    11287,
    1,
    ""
  ],
  [
    11288,
    1,
    ""
  ],
  [
    11289,
    1,
    ""
  ],
  [
    11290,
    1,
    ""
  ],
  [
    11291,
    1,
    ""
  ],
  [
    11292,
    1,
    ""
  ],
  [
    11293,
    1,
    ""
  ],
  [
    11294,
    1,
    ""
  ],
  [
    11295,
    1,
    ""
  ],
  [
    11296,
    1,
    ""
  ],
  [
    11297,
    1,
    ""
  ],
  [
    11298,
    1,
    ""
  ],
  [
    11299,
    1,
    ""
  ],
  [
    11300,
    1,
    ""
  ],
  [
    11301,
    1,
    ""
  ],
  [
    11302,
    1,
    ""
  ],
  [
    11303,
    1,
    ""
  ],
  [
    11304,
    1,
    ""
  ],
  [
    11305,
    1,
    ""
  ],
  [
    11306,
    1,
    ""
  ],
  [
    11307,
    1,
    ""
  ],
  [
    11308,
    1,
    ""
  ],
  [
    11309,
    1,
    ""
  ],
  [
    11310,
    1,
    ""
  ],
  [
    11311,
    1,
    ""
  ],
  [
    [
      11312,
      11358
    ],
    2
  ],
  [
    11359,
    2
  ],
  [
    11360,
    1,
    ""
  ],
  [
    11361,
    2
  ],
  [
    11362,
    1,
    ""
  ],
  [
    11363,
    1,
    ""
  ],
  [
    11364,
    1,
    ""
  ],
  [
    [
      11365,
      11366
    ],
    2
  ],
  [
    11367,
    1,
    ""
  ],
  [
    11368,
    2
  ],
  [
    11369,
    1,
    ""
  ],
  [
    11370,
    2
  ],
  [
    11371,
    1,
    ""
  ],
  [
    11372,
    2
  ],
  [
    11373,
    1,
    ""
  ],
  [
    11374,
    1,
    ""
  ],
  [
    11375,
    1,
    ""
  ],
  [
    11376,
    1,
    ""
  ],
  [
    11377,
    2
  ],
  [
    11378,
    1,
    ""
  ],
  [
    11379,
    2
  ],
  [
    11380,
    2
  ],
  [
    11381,
    1,
    ""
  ],
  [
    [
      11382,
      11383
    ],
    2
  ],
  [
    [
      11384,
      11387
    ],
    2
  ],
  [
    11388,
    1,
    "j"
  ],
  [
    11389,
    1,
    "v"
  ],
  [
    11390,
    1,
    ""
  ],
  [
    11391,
    1,
    ""
  ],
  [
    11392,
    1,
    ""
  ],
  [
    11393,
    2
  ],
  [
    11394,
    1,
    ""
  ],
  [
    11395,
    2
  ],
  [
    11396,
    1,
    ""
  ],
  [
    11397,
    2
  ],
  [
    11398,
    1,
    ""
  ],
  [
    11399,
    2
  ],
  [
    11400,
    1,
    ""
  ],
  [
    11401,
    2
  ],
  [
    11402,
    1,
    ""
  ],
  [
    11403,
    2
  ],
  [
    11404,
    1,
    ""
  ],
  [
    11405,
    2
  ],
  [
    11406,
    1,
    ""
  ],
  [
    11407,
    2
  ],
  [
    11408,
    1,
    ""
  ],
  [
    11409,
    2
  ],
  [
    11410,
    1,
    ""
  ],
  [
    11411,
    2
  ],
  [
    11412,
    1,
    ""
  ],
  [
    11413,
    2
  ],
  [
    11414,
    1,
    ""
  ],
  [
    11415,
    2
  ],
  [
    11416,
    1,
    ""
  ],
  [
    11417,
    2
  ],
  [
    11418,
    1,
    ""
  ],
  [
    11419,
    2
  ],
  [
    11420,
    1,
    ""
  ],
  [
    11421,
    2
  ],
  [
    11422,
    1,
    ""
  ],
  [
    11423,
    2
  ],
  [
    11424,
    1,
    ""
  ],
  [
    11425,
    2
  ],
  [
    11426,
    1,
    ""
  ],
  [
    11427,
    2
  ],
  [
    11428,
    1,
    ""
  ],
  [
    11429,
    2
  ],
  [
    11430,
    1,
    ""
  ],
  [
    11431,
    2
  ],
  [
    11432,
    1,
    ""
  ],
  [
    11433,
    2
  ],
  [
    11434,
    1,
    ""
  ],
  [
    11435,
    2
  ],
  [
    11436,
    1,
    ""
  ],
  [
    11437,
    2
  ],
  [
    11438,
    1,
    ""
  ],
  [
    11439,
    2
  ],
  [
    11440,
    1,
    ""
  ],
  [
    11441,
    2
  ],
  [
    11442,
    1,
    ""
  ],
  [
    11443,
    2
  ],
  [
    11444,
    1,
    ""
  ],
  [
    11445,
    2
  ],
  [
    11446,
    1,
    ""
  ],
  [
    11447,
    2
  ],
  [
    11448,
    1,
    ""
  ],
  [
    11449,
    2
  ],
  [
    11450,
    1,
    ""
  ],
  [
    11451,
    2
  ],
  [
    11452,
    1,
    ""
  ],
  [
    11453,
    2
  ],
  [
    11454,
    1,
    ""
  ],
  [
    11455,
    2
  ],
  [
    11456,
    1,
    ""
  ],
  [
    11457,
    2
  ],
  [
    11458,
    1,
    ""
  ],
  [
    11459,
    2
  ],
  [
    11460,
    1,
    ""
  ],
  [
    11461,
    2
  ],
  [
    11462,
    1,
    ""
  ],
  [
    11463,
    2
  ],
  [
    11464,
    1,
    ""
  ],
  [
    11465,
    2
  ],
  [
    11466,
    1,
    ""
  ],
  [
    11467,
    2
  ],
  [
    11468,
    1,
    ""
  ],
  [
    11469,
    2
  ],
  [
    11470,
    1,
    ""
  ],
  [
    11471,
    2
  ],
  [
    11472,
    1,
    ""
  ],
  [
    11473,
    2
  ],
  [
    11474,
    1,
    ""
  ],
  [
    11475,
    2
  ],
  [
    11476,
    1,
    ""
  ],
  [
    11477,
    2
  ],
  [
    11478,
    1,
    ""
  ],
  [
    11479,
    2
  ],
  [
    11480,
    1,
    ""
  ],
  [
    11481,
    2
  ],
  [
    11482,
    1,
    ""
  ],
  [
    11483,
    2
  ],
  [
    11484,
    1,
    ""
  ],
  [
    11485,
    2
  ],
  [
    11486,
    1,
    ""
  ],
  [
    11487,
    2
  ],
  [
    11488,
    1,
    ""
  ],
  [
    11489,
    2
  ],
  [
    11490,
    1,
    ""
  ],
  [
    [
      11491,
      11492
    ],
    2
  ],
  [
    [
      11493,
      11498
    ],
    2
  ],
  [
    11499,
    1,
    ""
  ],
  [
    11500,
    2
  ],
  [
    11501,
    1,
    ""
  ],
  [
    [
      11502,
      11505
    ],
    2
  ],
  [
    11506,
    1,
    ""
  ],
  [
    11507,
    2
  ],
  [
    [
      11508,
      11512
    ],
    3
  ],
  [
    [
      11513,
      11519
    ],
    2
  ],
  [
    [
      11520,
      11557
    ],
    2
  ],
  [
    11558,
    3
  ],
  [
    11559,
    2
  ],
  [
    [
      11560,
      11564
    ],
    3
  ],
  [
    11565,
    2
  ],
  [
    [
      11566,
      11567
    ],
    3
  ],
  [
    [
      11568,
      11621
    ],
    2
  ],
  [
    [
      11622,
      11623
    ],
    2
  ],
  [
    [
      11624,
      11630
    ],
    3
  ],
  [
    11631,
    1,
    ""
  ],
  [
    11632,
    2
  ],
  [
    [
      11633,
      11646
    ],
    3
  ],
  [
    11647,
    2
  ],
  [
    [
      11648,
      11670
    ],
    2
  ],
  [
    [
      11671,
      11679
    ],
    3
  ],
  [
    [
      11680,
      11686
    ],
    2
  ],
  [
    11687,
    3
  ],
  [
    [
      11688,
      11694
    ],
    2
  ],
  [
    11695,
    3
  ],
  [
    [
      11696,
      11702
    ],
    2
  ],
  [
    11703,
    3
  ],
  [
    [
      11704,
      11710
    ],
    2
  ],
  [
    11711,
    3
  ],
  [
    [
      11712,
      11718
    ],
    2
  ],
  [
    11719,
    3
  ],
  [
    [
      11720,
      11726
    ],
    2
  ],
  [
    11727,
    3
  ],
  [
    [
      11728,
      11734
    ],
    2
  ],
  [
    11735,
    3
  ],
  [
    [
      11736,
      11742
    ],
    2
  ],
  [
    11743,
    3
  ],
  [
    [
      11744,
      11775
    ],
    2
  ],
  [
    [
      11776,
      11799
    ],
    2
  ],
  [
    [
      11800,
      11803
    ],
    2
  ],
  [
    [
      11804,
      11805
    ],
    2
  ],
  [
    [
      11806,
      11822
    ],
    2
  ],
  [
    11823,
    2
  ],
  [
    11824,
    2
  ],
  [
    11825,
    2
  ],
  [
    [
      11826,
      11835
    ],
    2
  ],
  [
    [
      11836,
      11842
    ],
    2
  ],
  [
    [
      11843,
      11844
    ],
    2
  ],
  [
    [
      11845,
      11849
    ],
    2
  ],
  [
    [
      11850,
      11854
    ],
    2
  ],
  [
    11855,
    2
  ],
  [
    [
      11856,
      11858
    ],
    2
  ],
  [
    [
      11859,
      11869
    ],
    2
  ],
  [
    [
      11870,
      11903
    ],
    3
  ],
  [
    [
      11904,
      11929
    ],
    2
  ],
  [
    11930,
    3
  ],
  [
    [
      11931,
      11934
    ],
    2
  ],
  [
    11935,
    1,
    ""
  ],
  [
    [
      11936,
      12018
    ],
    2
  ],
  [
    12019,
    1,
    ""
  ],
  [
    [
      12020,
      12031
    ],
    3
  ],
  [
    12032,
    1,
    ""
  ],
  [
    12033,
    1,
    ""
  ],
  [
    12034,
    1,
    ""
  ],
  [
    12035,
    1,
    ""
  ],
  [
    12036,
    1,
    ""
  ],
  [
    12037,
    1,
    ""
  ],
  [
    12038,
    1,
    ""
  ],
  [
    12039,
    1,
    ""
  ],
  [
    12040,
    1,
    ""
  ],
  [
    12041,
    1,
    ""
  ],
  [
    12042,
    1,
    ""
  ],
  [
    12043,
    1,
    ""
  ],
  [
    12044,
    1,
    ""
  ],
  [
    12045,
    1,
    ""
  ],
  [
    12046,
    1,
    ""
  ],
  [
    12047,
    1,
    ""
  ],
  [
    12048,
    1,
    ""
  ],
  [
    12049,
    1,
    ""
  ],
  [
    12050,
    1,
    ""
  ],
  [
    12051,
    1,
    ""
  ],
  [
    12052,
    1,
    ""
  ],
  [
    12053,
    1,
    ""
  ],
  [
    12054,
    1,
    ""
  ],
  [
    12055,
    1,
    ""
  ],
  [
    12056,
    1,
    ""
  ],
  [
    12057,
    1,
    ""
  ],
  [
    12058,
    1,
    ""
  ],
  [
    12059,
    1,
    ""
  ],
  [
    12060,
    1,
    ""
  ],
  [
    12061,
    1,
    ""
  ],
  [
    12062,
    1,
    ""
  ],
  [
    12063,
    1,
    ""
  ],
  [
    12064,
    1,
    ""
  ],
  [
    12065,
    1,
    ""
  ],
  [
    12066,
    1,
    ""
  ],
  [
    12067,
    1,
    ""
  ],
  [
    12068,
    1,
    ""
  ],
  [
    12069,
    1,
    ""
  ],
  [
    12070,
    1,
    ""
  ],
  [
    12071,
    1,
    ""
  ],
  [
    12072,
    1,
    ""
  ],
  [
    12073,
    1,
    ""
  ],
  [
    12074,
    1,
    ""
  ],
  [
    12075,
    1,
    ""
  ],
  [
    12076,
    1,
    ""
  ],
  [
    12077,
    1,
    ""
  ],
  [
    12078,
    1,
    ""
  ],
  [
    12079,
    1,
    ""
  ],
  [
    12080,
    1,
    ""
  ],
  [
    12081,
    1,
    ""
  ],
  [
    12082,
    1,
    ""
  ],
  [
    12083,
    1,
    ""
  ],
  [
    12084,
    1,
    ""
  ],
  [
    12085,
    1,
    ""
  ],
  [
    12086,
    1,
    ""
  ],
  [
    12087,
    1,
    ""
  ],
  [
    12088,
    1,
    ""
  ],
  [
    12089,
    1,
    ""
  ],
  [
    12090,
    1,
    ""
  ],
  [
    12091,
    1,
    ""
  ],
  [
    12092,
    1,
    ""
  ],
  [
    12093,
    1,
    ""
  ],
  [
    12094,
    1,
    ""
  ],
  [
    12095,
    1,
    ""
  ],
  [
    12096,
    1,
    ""
  ],
  [
    12097,
    1,
    ""
  ],
  [
    12098,
    1,
    ""
  ],
  [
    12099,
    1,
    ""
  ],
  [
    12100,
    1,
    ""
  ],
  [
    12101,
    1,
    ""
  ],
  [
    12102,
    1,
    ""
  ],
  [
    12103,
    1,
    ""
  ],
  [
    12104,
    1,
    ""
  ],
  [
    12105,
    1,
    ""
  ],
  [
    12106,
    1,
    ""
  ],
  [
    12107,
    1,
    ""
  ],
  [
    12108,
    1,
    ""
  ],
  [
    12109,
    1,
    ""
  ],
  [
    12110,
    1,
    ""
  ],
  [
    12111,
    1,
    ""
  ],
  [
    12112,
    1,
    ""
  ],
  [
    12113,
    1,
    ""
  ],
  [
    12114,
    1,
    ""
  ],
  [
    12115,
    1,
    ""
  ],
  [
    12116,
    1,
    ""
  ],
  [
    12117,
    1,
    ""
  ],
  [
    12118,
    1,
    ""
  ],
  [
    12119,
    1,
    ""
  ],
  [
    12120,
    1,
    ""
  ],
  [
    12121,
    1,
    ""
  ],
  [
    12122,
    1,
    ""
  ],
  [
    12123,
    1,
    ""
  ],
  [
    12124,
    1,
    ""
  ],
  [
    12125,
    1,
    ""
  ],
  [
    12126,
    1,
    ""
  ],
  [
    12127,
    1,
    ""
  ],
  [
    12128,
    1,
    ""
  ],
  [
    12129,
    1,
    ""
  ],
  [
    12130,
    1,
    ""
  ],
  [
    12131,
    1,
    ""
  ],
  [
    12132,
    1,
    ""
  ],
  [
    12133,
    1,
    ""
  ],
  [
    12134,
    1,
    ""
  ],
  [
    12135,
    1,
    ""
  ],
  [
    12136,
    1,
    ""
  ],
  [
    12137,
    1,
    ""
  ],
  [
    12138,
    1,
    ""
  ],
  [
    12139,
    1,
    ""
  ],
  [
    12140,
    1,
    ""
  ],
  [
    12141,
    1,
    ""
  ],
  [
    12142,
    1,
    ""
  ],
  [
    12143,
    1,
    ""
  ],
  [
    12144,
    1,
    ""
  ],
  [
    12145,
    1,
    ""
  ],
  [
    12146,
    1,
    ""
  ],
  [
    12147,
    1,
    ""
  ],
  [
    12148,
    1,
    ""
  ],
  [
    12149,
    1,
    ""
  ],
  [
    12150,
    1,
    ""
  ],
  [
    12151,
    1,
    ""
  ],
  [
    12152,
    1,
    ""
  ],
  [
    12153,
    1,
    ""
  ],
  [
    12154,
    1,
    ""
  ],
  [
    12155,
    1,
    ""
  ],
  [
    12156,
    1,
    ""
  ],
  [
    12157,
    1,
    ""
  ],
  [
    12158,
    1,
    ""
  ],
  [
    12159,
    1,
    ""
  ],
  [
    12160,
    1,
    ""
  ],
  [
    12161,
    1,
    ""
  ],
  [
    12162,
    1,
    ""
  ],
  [
    12163,
    1,
    ""
  ],
  [
    12164,
    1,
    ""
  ],
  [
    12165,
    1,
    ""
  ],
  [
    12166,
    1,
    ""
  ],
  [
    12167,
    1,
    ""
  ],
  [
    12168,
    1,
    ""
  ],
  [
    12169,
    1,
    ""
  ],
  [
    12170,
    1,
    ""
  ],
  [
    12171,
    1,
    ""
  ],
  [
    12172,
    1,
    ""
  ],
  [
    12173,
    1,
    ""
  ],
  [
    12174,
    1,
    ""
  ],
  [
    12175,
    1,
    ""
  ],
  [
    12176,
    1,
    ""
  ],
  [
    12177,
    1,
    ""
  ],
  [
    12178,
    1,
    ""
  ],
  [
    12179,
    1,
    ""
  ],
  [
    12180,
    1,
    ""
  ],
  [
    12181,
    1,
    ""
  ],
  [
    12182,
    1,
    ""
  ],
  [
    12183,
    1,
    ""
  ],
  [
    12184,
    1,
    ""
  ],
  [
    12185,
    1,
    ""
  ],
  [
    12186,
    1,
    ""
  ],
  [
    12187,
    1,
    ""
  ],
  [
    12188,
    1,
    ""
  ],
  [
    12189,
    1,
    ""
  ],
  [
    12190,
    1,
    ""
  ],
  [
    12191,
    1,
    ""
  ],
  [
    12192,
    1,
    ""
  ],
  [
    12193,
    1,
    ""
  ],
  [
    12194,
    1,
    ""
  ],
  [
    12195,
    1,
    ""
  ],
  [
    12196,
    1,
    ""
  ],
  [
    12197,
    1,
    ""
  ],
  [
    12198,
    1,
    ""
  ],
  [
    12199,
    1,
    ""
  ],
  [
    12200,
    1,
    ""
  ],
  [
    12201,
    1,
    ""
  ],
  [
    12202,
    1,
    ""
  ],
  [
    12203,
    1,
    ""
  ],
  [
    12204,
    1,
    ""
  ],
  [
    12205,
    1,
    ""
  ],
  [
    12206,
    1,
    ""
  ],
  [
    12207,
    1,
    ""
  ],
  [
    12208,
    1,
    ""
  ],
  [
    12209,
    1,
    ""
  ],
  [
    12210,
    1,
    ""
  ],
  [
    12211,
    1,
    ""
  ],
  [
    12212,
    1,
    ""
  ],
  [
    12213,
    1,
    ""
  ],
  [
    12214,
    1,
    ""
  ],
  [
    12215,
    1,
    ""
  ],
  [
    12216,
    1,
    ""
  ],
  [
    12217,
    1,
    ""
  ],
  [
    12218,
    1,
    ""
  ],
  [
    12219,
    1,
    ""
  ],
  [
    12220,
    1,
    ""
  ],
  [
    12221,
    1,
    ""
  ],
  [
    12222,
    1,
    ""
  ],
  [
    12223,
    1,
    ""
  ],
  [
    12224,
    1,
    ""
  ],
  [
    12225,
    1,
    ""
  ],
  [
    12226,
    1,
    ""
  ],
  [
    12227,
    1,
    ""
  ],
  [
    12228,
    1,
    ""
  ],
  [
    12229,
    1,
    ""
  ],
  [
    12230,
    1,
    ""
  ],
  [
    12231,
    1,
    ""
  ],
  [
    12232,
    1,
    ""
  ],
  [
    12233,
    1,
    ""
  ],
  [
    12234,
    1,
    ""
  ],
  [
    12235,
    1,
    ""
  ],
  [
    12236,
    1,
    ""
  ],
  [
    12237,
    1,
    ""
  ],
  [
    12238,
    1,
    ""
  ],
  [
    12239,
    1,
    ""
  ],
  [
    12240,
    1,
    ""
  ],
  [
    12241,
    1,
    ""
  ],
  [
    12242,
    1,
    ""
  ],
  [
    12243,
    1,
    ""
  ],
  [
    12244,
    1,
    ""
  ],
  [
    12245,
    1,
    ""
  ],
  [
    [
      12246,
      12271
    ],
    3
  ],
  [
    [
      12272,
      12283
    ],
    3
  ],
  [
    [
      12284,
      12287
    ],
    3
  ],
  [
    12288,
    5,
    " "
  ],
  [
    12289,
    2
  ],
  [
    12290,
    1,
    "."
  ],
  [
    [
      12291,
      12292
    ],
    2
  ],
  [
    [
      12293,
      12295
    ],
    2
  ],
  [
    [
      12296,
      12329
    ],
    2
  ],
  [
    [
      12330,
      12333
    ],
    2
  ],
  [
    [
      12334,
      12341
    ],
    2
  ],
  [
    12342,
    1,
    ""
  ],
  [
    12343,
    2
  ],
  [
    12344,
    1,
    ""
  ],
  [
    12345,
    1,
    ""
  ],
  [
    12346,
    1,
    ""
  ],
  [
    12347,
    2
  ],
  [
    12348,
    2
  ],
  [
    12349,
    2
  ],
  [
    12350,
    2
  ],
  [
    12351,
    2
  ],
  [
    12352,
    3
  ],
  [
    [
      12353,
      12436
    ],
    2
  ],
  [
    [
      12437,
      12438
    ],
    2
  ],
  [
    [
      12439,
      12440
    ],
    3
  ],
  [
    [
      12441,
      12442
    ],
    2
  ],
  [
    12443,
    5,
    " "
  ],
  [
    12444,
    5,
    " "
  ],
  [
    [
      12445,
      12446
    ],
    2
  ],
  [
    12447,
    1,
    ""
  ],
  [
    12448,
    2
  ],
  [
    [
      12449,
      12542
    ],
    2
  ],
  [
    12543,
    1,
    ""
  ],
  [
    [
      12544,
      12548
    ],
    3
  ],
  [
    [
      12549,
      12588
    ],
    2
  ],
  [
    12589,
    2
  ],
  [
    12590,
    2
  ],
  [
    12591,
    2
  ],
  [
    12592,
    3
  ],
  [
    12593,
    1,
    ""
  ],
  [
    12594,
    1,
    ""
  ],
  [
    12595,
    1,
    ""
  ],
  [
    12596,
    1,
    ""
  ],
  [
    12597,
    1,
    ""
  ],
  [
    12598,
    1,
    ""
  ],
  [
    12599,
    1,
    ""
  ],
  [
    12600,
    1,
    ""
  ],
  [
    12601,
    1,
    ""
  ],
  [
    12602,
    1,
    ""
  ],
  [
    12603,
    1,
    ""
  ],
  [
    12604,
    1,
    ""
  ],
  [
    12605,
    1,
    ""
  ],
  [
    12606,
    1,
    ""
  ],
  [
    12607,
    1,
    ""
  ],
  [
    12608,
    1,
    ""
  ],
  [
    12609,
    1,
    ""
  ],
  [
    12610,
    1,
    ""
  ],
  [
    12611,
    1,
    ""
  ],
  [
    12612,
    1,
    ""
  ],
  [
    12613,
    1,
    ""
  ],
  [
    12614,
    1,
    ""
  ],
  [
    12615,
    1,
    ""
  ],
  [
    12616,
    1,
    ""
  ],
  [
    12617,
    1,
    ""
  ],
  [
    12618,
    1,
    ""
  ],
  [
    12619,
    1,
    ""
  ],
  [
    12620,
    1,
    ""
  ],
  [
    12621,
    1,
    ""
  ],
  [
    12622,
    1,
    ""
  ],
  [
    12623,
    1,
    ""
  ],
  [
    12624,
    1,
    ""
  ],
  [
    12625,
    1,
    ""
  ],
  [
    12626,
    1,
    ""
  ],
  [
    12627,
    1,
    ""
  ],
  [
    12628,
    1,
    ""
  ],
  [
    12629,
    1,
    ""
  ],
  [
    12630,
    1,
    ""
  ],
  [
    12631,
    1,
    ""
  ],
  [
    12632,
    1,
    ""
  ],
  [
    12633,
    1,
    ""
  ],
  [
    12634,
    1,
    ""
  ],
  [
    12635,
    1,
    ""
  ],
  [
    12636,
    1,
    ""
  ],
  [
    12637,
    1,
    ""
  ],
  [
    12638,
    1,
    ""
  ],
  [
    12639,
    1,
    ""
  ],
  [
    12640,
    1,
    ""
  ],
  [
    12641,
    1,
    ""
  ],
  [
    12642,
    1,
    ""
  ],
  [
    12643,
    1,
    ""
  ],
  [
    12644,
    3
  ],
  [
    12645,
    1,
    ""
  ],
  [
    12646,
    1,
    ""
  ],
  [
    12647,
    1,
    ""
  ],
  [
    12648,
    1,
    ""
  ],
  [
    12649,
    1,
    ""
  ],
  [
    12650,
    1,
    ""
  ],
  [
    12651,
    1,
    ""
  ],
  [
    12652,
    1,
    ""
  ],
  [
    12653,
    1,
    ""
  ],
  [
    12654,
    1,
    ""
  ],
  [
    12655,
    1,
    ""
  ],
  [
    12656,
    1,
    ""
  ],
  [
    12657,
    1,
    ""
  ],
  [
    12658,
    1,
    ""
  ],
  [
    12659,
    1,
    ""
  ],
  [
    12660,
    1,
    ""
  ],
  [
    12661,
    1,
    ""
  ],
  [
    12662,
    1,
    ""
  ],
  [
    12663,
    1,
    ""
  ],
  [
    12664,
    1,
    ""
  ],
  [
    12665,
    1,
    ""
  ],
  [
    12666,
    1,
    ""
  ],
  [
    12667,
    1,
    ""
  ],
  [
    12668,
    1,
    ""
  ],
  [
    12669,
    1,
    ""
  ],
  [
    12670,
    1,
    ""
  ],
  [
    12671,
    1,
    ""
  ],
  [
    12672,
    1,
    ""
  ],
  [
    12673,
    1,
    ""
  ],
  [
    12674,
    1,
    ""
  ],
  [
    12675,
    1,
    ""
  ],
  [
    12676,
    1,
    ""
  ],
  [
    12677,
    1,
    ""
  ],
  [
    12678,
    1,
    ""
  ],
  [
    12679,
    1,
    ""
  ],
  [
    12680,
    1,
    ""
  ],
  [
    12681,
    1,
    ""
  ],
  [
    12682,
    1,
    ""
  ],
  [
    12683,
    1,
    ""
  ],
  [
    12684,
    1,
    ""
  ],
  [
    12685,
    1,
    ""
  ],
  [
    12686,
    1,
    ""
  ],
  [
    12687,
    3
  ],
  [
    [
      12688,
      12689
    ],
    2
  ],
  [
    12690,
    1,
    ""
  ],
  [
    12691,
    1,
    ""
  ],
  [
    12692,
    1,
    ""
  ],
  [
    12693,
    1,
    ""
  ],
  [
    12694,
    1,
    ""
  ],
  [
    12695,
    1,
    ""
  ],
  [
    12696,
    1,
    ""
  ],
  [
    12697,
    1,
    ""
  ],
  [
    12698,
    1,
    ""
  ],
  [
    12699,
    1,
    ""
  ],
  [
    12700,
    1,
    ""
  ],
  [
    12701,
    1,
    ""
  ],
  [
    12702,
    1,
    ""
  ],
  [
    12703,
    1,
    ""
  ],
  [
    [
      12704,
      12727
    ],
    2
  ],
  [
    [
      12728,
      12730
    ],
    2
  ],
  [
    [
      12731,
      12735
    ],
    2
  ],
  [
    [
      12736,
      12751
    ],
    2
  ],
  [
    [
      12752,
      12771
    ],
    2
  ],
  [
    [
      12772,
      12782
    ],
    3
  ],
  [
    12783,
    3
  ],
  [
    [
      12784,
      12799
    ],
    2
  ],
  [
    12800,
    5,
    "()"
  ],
  [
    12801,
    5,
    "()"
  ],
  [
    12802,
    5,
    "()"
  ],
  [
    12803,
    5,
    "()"
  ],
  [
    12804,
    5,
    "()"
  ],
  [
    12805,
    5,
    "()"
  ],
  [
    12806,
    5,
    "()"
  ],
  [
    12807,
    5,
    "()"
  ],
  [
    12808,
    5,
    "()"
  ],
  [
    12809,
    5,
    "()"
  ],
  [
    12810,
    5,
    "()"
  ],
  [
    12811,
    5,
    "()"
  ],
  [
    12812,
    5,
    "()"
  ],
  [
    12813,
    5,
    "()"
  ],
  [
    12814,
    5,
    "()"
  ],
  [
    12815,
    5,
    "()"
  ],
  [
    12816,
    5,
    "()"
  ],
  [
    12817,
    5,
    "()"
  ],
  [
    12818,
    5,
    "()"
  ],
  [
    12819,
    5,
    "()"
  ],
  [
    12820,
    5,
    "()"
  ],
  [
    12821,
    5,
    "()"
  ],
  [
    12822,
    5,
    "()"
  ],
  [
    12823,
    5,
    "()"
  ],
  [
    12824,
    5,
    "()"
  ],
  [
    12825,
    5,
    "()"
  ],
  [
    12826,
    5,
    "()"
  ],
  [
    12827,
    5,
    "()"
  ],
  [
    12828,
    5,
    "()"
  ],
  [
    12829,
    5,
    "()"
  ],
  [
    12830,
    5,
    "()"
  ],
  [
    12831,
    3
  ],
  [
    12832,
    5,
    "()"
  ],
  [
    12833,
    5,
    "()"
  ],
  [
    12834,
    5,
    "()"
  ],
  [
    12835,
    5,
    "()"
  ],
  [
    12836,
    5,
    "()"
  ],
  [
    12837,
    5,
    "()"
  ],
  [
    12838,
    5,
    "()"
  ],
  [
    12839,
    5,
    "()"
  ],
  [
    12840,
    5,
    "()"
  ],
  [
    12841,
    5,
    "()"
  ],
  [
    12842,
    5,
    "()"
  ],
  [
    12843,
    5,
    "()"
  ],
  [
    12844,
    5,
    "()"
  ],
  [
    12845,
    5,
    "()"
  ],
  [
    12846,
    5,
    "()"
  ],
  [
    12847,
    5,
    "()"
  ],
  [
    12848,
    5,
    "()"
  ],
  [
    12849,
    5,
    "()"
  ],
  [
    12850,
    5,
    "()"
  ],
  [
    12851,
    5,
    "()"
  ],
  [
    12852,
    5,
    "()"
  ],
  [
    12853,
    5,
    "()"
  ],
  [
    12854,
    5,
    "()"
  ],
  [
    12855,
    5,
    "()"
  ],
  [
    12856,
    5,
    "()"
  ],
  [
    12857,
    5,
    "()"
  ],
  [
    12858,
    5,
    "()"
  ],
  [
    12859,
    5,
    "()"
  ],
  [
    12860,
    5,
    "()"
  ],
  [
    12861,
    5,
    "()"
  ],
  [
    12862,
    5,
    "()"
  ],
  [
    12863,
    5,
    "()"
  ],
  [
    12864,
    5,
    "()"
  ],
  [
    12865,
    5,
    "()"
  ],
  [
    12866,
    5,
    "()"
  ],
  [
    12867,
    5,
    "()"
  ],
  [
    12868,
    1,
    ""
  ],
  [
    12869,
    1,
    ""
  ],
  [
    12870,
    1,
    ""
  ],
  [
    12871,
    1,
    ""
  ],
  [
    [
      12872,
      12879
    ],
    2
  ],
  [
    12880,
    1,
    "pte"
  ],
  [
    12881,
    1,
    "21"
  ],
  [
    12882,
    1,
    "22"
  ],
  [
    12883,
    1,
    "23"
  ],
  [
    12884,
    1,
    "24"
  ],
  [
    12885,
    1,
    "25"
  ],
  [
    12886,
    1,
    "26"
  ],
  [
    12887,
    1,
    "27"
  ],
  [
    12888,
    1,
    "28"
  ],
  [
    12889,
    1,
    "29"
  ],
  [
    12890,
    1,
    "30"
  ],
  [
    12891,
    1,
    "31"
  ],
  [
    12892,
    1,
    "32"
  ],
  [
    12893,
    1,
    "33"
  ],
  [
    12894,
    1,
    "34"
  ],
  [
    12895,
    1,
    "35"
  ],
  [
    12896,
    1,
    ""
  ],
  [
    12897,
    1,
    ""
  ],
  [
    12898,
    1,
    ""
  ],
  [
    12899,
    1,
    ""
  ],
  [
    12900,
    1,
    ""
  ],
  [
    12901,
    1,
    ""
  ],
  [
    12902,
    1,
    ""
  ],
  [
    12903,
    1,
    ""
  ],
  [
    12904,
    1,
    ""
  ],
  [
    12905,
    1,
    ""
  ],
  [
    12906,
    1,
    ""
  ],
  [
    12907,
    1,
    ""
  ],
  [
    12908,
    1,
    ""
  ],
  [
    12909,
    1,
    ""
  ],
  [
    12910,
    1,
    ""
  ],
  [
    12911,
    1,
    ""
  ],
  [
    12912,
    1,
    ""
  ],
  [
    12913,
    1,
    ""
  ],
  [
    12914,
    1,
    ""
  ],
  [
    12915,
    1,
    ""
  ],
  [
    12916,
    1,
    ""
  ],
  [
    12917,
    1,
    ""
  ],
  [
    12918,
    1,
    ""
  ],
  [
    12919,
    1,
    ""
  ],
  [
    12920,
    1,
    ""
  ],
  [
    12921,
    1,
    ""
  ],
  [
    12922,
    1,
    ""
  ],
  [
    12923,
    1,
    ""
  ],
  [
    12924,
    1,
    ""
  ],
  [
    12925,
    1,
    ""
  ],
  [
    12926,
    1,
    ""
  ],
  [
    12927,
    2
  ],
  [
    12928,
    1,
    ""
  ],
  [
    12929,
    1,
    ""
  ],
  [
    12930,
    1,
    ""
  ],
  [
    12931,
    1,
    ""
  ],
  [
    12932,
    1,
    ""
  ],
  [
    12933,
    1,
    ""
  ],
  [
    12934,
    1,
    ""
  ],
  [
    12935,
    1,
    ""
  ],
  [
    12936,
    1,
    ""
  ],
  [
    12937,
    1,
    ""
  ],
  [
    12938,
    1,
    ""
  ],
  [
    12939,
    1,
    ""
  ],
  [
    12940,
    1,
    ""
  ],
  [
    12941,
    1,
    ""
  ],
  [
    12942,
    1,
    ""
  ],
  [
    12943,
    1,
    ""
  ],
  [
    12944,
    1,
    ""
  ],
  [
    12945,
    1,
    ""
  ],
  [
    12946,
    1,
    ""
  ],
  [
    12947,
    1,
    ""
  ],
  [
    12948,
    1,
    ""
  ],
  [
    12949,
    1,
    ""
  ],
  [
    12950,
    1,
    ""
  ],
  [
    12951,
    1,
    ""
  ],
  [
    12952,
    1,
    ""
  ],
  [
    12953,
    1,
    ""
  ],
  [
    12954,
    1,
    ""
  ],
  [
    12955,
    1,
    ""
  ],
  [
    12956,
    1,
    ""
  ],
  [
    12957,
    1,
    ""
  ],
  [
    12958,
    1,
    ""
  ],
  [
    12959,
    1,
    ""
  ],
  [
    12960,
    1,
    ""
  ],
  [
    12961,
    1,
    ""
  ],
  [
    12962,
    1,
    ""
  ],
  [
    12963,
    1,
    ""
  ],
  [
    12964,
    1,
    ""
  ],
  [
    12965,
    1,
    ""
  ],
  [
    12966,
    1,
    ""
  ],
  [
    12967,
    1,
    ""
  ],
  [
    12968,
    1,
    ""
  ],
  [
    12969,
    1,
    ""
  ],
  [
    12970,
    1,
    ""
  ],
  [
    12971,
    1,
    ""
  ],
  [
    12972,
    1,
    ""
  ],
  [
    12973,
    1,
    ""
  ],
  [
    12974,
    1,
    ""
  ],
  [
    12975,
    1,
    ""
  ],
  [
    12976,
    1,
    ""
  ],
  [
    12977,
    1,
    "36"
  ],
  [
    12978,
    1,
    "37"
  ],
  [
    12979,
    1,
    "38"
  ],
  [
    12980,
    1,
    "39"
  ],
  [
    12981,
    1,
    "40"
  ],
  [
    12982,
    1,
    "41"
  ],
  [
    12983,
    1,
    "42"
  ],
  [
    12984,
    1,
    "43"
  ],
  [
    12985,
    1,
    "44"
  ],
  [
    12986,
    1,
    "45"
  ],
  [
    12987,
    1,
    "46"
  ],
  [
    12988,
    1,
    "47"
  ],
  [
    12989,
    1,
    "48"
  ],
  [
    12990,
    1,
    "49"
  ],
  [
    12991,
    1,
    "50"
  ],
  [
    12992,
    1,
    "1"
  ],
  [
    12993,
    1,
    "2"
  ],
  [
    12994,
    1,
    "3"
  ],
  [
    12995,
    1,
    "4"
  ],
  [
    12996,
    1,
    "5"
  ],
  [
    12997,
    1,
    "6"
  ],
  [
    12998,
    1,
    "7"
  ],
  [
    12999,
    1,
    "8"
  ],
  [
    13e3,
    1,
    "9"
  ],
  [
    13001,
    1,
    "10"
  ],
  [
    13002,
    1,
    "11"
  ],
  [
    13003,
    1,
    "12"
  ],
  [
    13004,
    1,
    "hg"
  ],
  [
    13005,
    1,
    "erg"
  ],
  [
    13006,
    1,
    "ev"
  ],
  [
    13007,
    1,
    "ltd"
  ],
  [
    13008,
    1,
    ""
  ],
  [
    13009,
    1,
    ""
  ],
  [
    13010,
    1,
    ""
  ],
  [
    13011,
    1,
    ""
  ],
  [
    13012,
    1,
    ""
  ],
  [
    13013,
    1,
    ""
  ],
  [
    13014,
    1,
    ""
  ],
  [
    13015,
    1,
    ""
  ],
  [
    13016,
    1,
    ""
  ],
  [
    13017,
    1,
    ""
  ],
  [
    13018,
    1,
    ""
  ],
  [
    13019,
    1,
    ""
  ],
  [
    13020,
    1,
    ""
  ],
  [
    13021,
    1,
    ""
  ],
  [
    13022,
    1,
    ""
  ],
  [
    13023,
    1,
    ""
  ],
  [
    13024,
    1,
    ""
  ],
  [
    13025,
    1,
    ""
  ],
  [
    13026,
    1,
    ""
  ],
  [
    13027,
    1,
    ""
  ],
  [
    13028,
    1,
    ""
  ],
  [
    13029,
    1,
    ""
  ],
  [
    13030,
    1,
    ""
  ],
  [
    13031,
    1,
    ""
  ],
  [
    13032,
    1,
    ""
  ],
  [
    13033,
    1,
    ""
  ],
  [
    13034,
    1,
    ""
  ],
  [
    13035,
    1,
    ""
  ],
  [
    13036,
    1,
    ""
  ],
  [
    13037,
    1,
    ""
  ],
  [
    13038,
    1,
    ""
  ],
  [
    13039,
    1,
    ""
  ],
  [
    13040,
    1,
    ""
  ],
  [
    13041,
    1,
    ""
  ],
  [
    13042,
    1,
    ""
  ],
  [
    13043,
    1,
    ""
  ],
  [
    13044,
    1,
    ""
  ],
  [
    13045,
    1,
    ""
  ],
  [
    13046,
    1,
    ""
  ],
  [
    13047,
    1,
    ""
  ],
  [
    13048,
    1,
    ""
  ],
  [
    13049,
    1,
    ""
  ],
  [
    13050,
    1,
    ""
  ],
  [
    13051,
    1,
    ""
  ],
  [
    13052,
    1,
    ""
  ],
  [
    13053,
    1,
    ""
  ],
  [
    13054,
    1,
    ""
  ],
  [
    13055,
    1,
    ""
  ],
  [
    13056,
    1,
    ""
  ],
  [
    13057,
    1,
    ""
  ],
  [
    13058,
    1,
    ""
  ],
  [
    13059,
    1,
    ""
  ],
  [
    13060,
    1,
    ""
  ],
  [
    13061,
    1,
    ""
  ],
  [
    13062,
    1,
    ""
  ],
  [
    13063,
    1,
    ""
  ],
  [
    13064,
    1,
    ""
  ],
  [
    13065,
    1,
    ""
  ],
  [
    13066,
    1,
    ""
  ],
  [
    13067,
    1,
    ""
  ],
  [
    13068,
    1,
    ""
  ],
  [
    13069,
    1,
    ""
  ],
  [
    13070,
    1,
    ""
  ],
  [
    13071,
    1,
    ""
  ],
  [
    13072,
    1,
    ""
  ],
  [
    13073,
    1,
    ""
  ],
  [
    13074,
    1,
    ""
  ],
  [
    13075,
    1,
    ""
  ],
  [
    13076,
    1,
    ""
  ],
  [
    13077,
    1,
    ""
  ],
  [
    13078,
    1,
    ""
  ],
  [
    13079,
    1,
    ""
  ],
  [
    13080,
    1,
    ""
  ],
  [
    13081,
    1,
    ""
  ],
  [
    13082,
    1,
    ""
  ],
  [
    13083,
    1,
    ""
  ],
  [
    13084,
    1,
    ""
  ],
  [
    13085,
    1,
    ""
  ],
  [
    13086,
    1,
    ""
  ],
  [
    13087,
    1,
    ""
  ],
  [
    13088,
    1,
    ""
  ],
  [
    13089,
    1,
    ""
  ],
  [
    13090,
    1,
    ""
  ],
  [
    13091,
    1,
    ""
  ],
  [
    13092,
    1,
    ""
  ],
  [
    13093,
    1,
    ""
  ],
  [
    13094,
    1,
    ""
  ],
  [
    13095,
    1,
    ""
  ],
  [
    13096,
    1,
    ""
  ],
  [
    13097,
    1,
    ""
  ],
  [
    13098,
    1,
    ""
  ],
  [
    13099,
    1,
    ""
  ],
  [
    13100,
    1,
    ""
  ],
  [
    13101,
    1,
    ""
  ],
  [
    13102,
    1,
    ""
  ],
  [
    13103,
    1,
    ""
  ],
  [
    13104,
    1,
    ""
  ],
  [
    13105,
    1,
    ""
  ],
  [
    13106,
    1,
    ""
  ],
  [
    13107,
    1,
    ""
  ],
  [
    13108,
    1,
    ""
  ],
  [
    13109,
    1,
    ""
  ],
  [
    13110,
    1,
    ""
  ],
  [
    13111,
    1,
    ""
  ],
  [
    13112,
    1,
    ""
  ],
  [
    13113,
    1,
    ""
  ],
  [
    13114,
    1,
    ""
  ],
  [
    13115,
    1,
    ""
  ],
  [
    13116,
    1,
    ""
  ],
  [
    13117,
    1,
    ""
  ],
  [
    13118,
    1,
    ""
  ],
  [
    13119,
    1,
    ""
  ],
  [
    13120,
    1,
    ""
  ],
  [
    13121,
    1,
    ""
  ],
  [
    13122,
    1,
    ""
  ],
  [
    13123,
    1,
    ""
  ],
  [
    13124,
    1,
    ""
  ],
  [
    13125,
    1,
    ""
  ],
  [
    13126,
    1,
    ""
  ],
  [
    13127,
    1,
    ""
  ],
  [
    13128,
    1,
    ""
  ],
  [
    13129,
    1,
    ""
  ],
  [
    13130,
    1,
    ""
  ],
  [
    13131,
    1,
    ""
  ],
  [
    13132,
    1,
    ""
  ],
  [
    13133,
    1,
    ""
  ],
  [
    13134,
    1,
    ""
  ],
  [
    13135,
    1,
    ""
  ],
  [
    13136,
    1,
    ""
  ],
  [
    13137,
    1,
    ""
  ],
  [
    13138,
    1,
    ""
  ],
  [
    13139,
    1,
    ""
  ],
  [
    13140,
    1,
    ""
  ],
  [
    13141,
    1,
    ""
  ],
  [
    13142,
    1,
    ""
  ],
  [
    13143,
    1,
    ""
  ],
  [
    13144,
    1,
    "0"
  ],
  [
    13145,
    1,
    "1"
  ],
  [
    13146,
    1,
    "2"
  ],
  [
    13147,
    1,
    "3"
  ],
  [
    13148,
    1,
    "4"
  ],
  [
    13149,
    1,
    "5"
  ],
  [
    13150,
    1,
    "6"
  ],
  [
    13151,
    1,
    "7"
  ],
  [
    13152,
    1,
    "8"
  ],
  [
    13153,
    1,
    "9"
  ],
  [
    13154,
    1,
    "10"
  ],
  [
    13155,
    1,
    "11"
  ],
  [
    13156,
    1,
    "12"
  ],
  [
    13157,
    1,
    "13"
  ],
  [
    13158,
    1,
    "14"
  ],
  [
    13159,
    1,
    "15"
  ],
  [
    13160,
    1,
    "16"
  ],
  [
    13161,
    1,
    "17"
  ],
  [
    13162,
    1,
    "18"
  ],
  [
    13163,
    1,
    "19"
  ],
  [
    13164,
    1,
    "20"
  ],
  [
    13165,
    1,
    "21"
  ],
  [
    13166,
    1,
    "22"
  ],
  [
    13167,
    1,
    "23"
  ],
  [
    13168,
    1,
    "24"
  ],
  [
    13169,
    1,
    "hpa"
  ],
  [
    13170,
    1,
    "da"
  ],
  [
    13171,
    1,
    "au"
  ],
  [
    13172,
    1,
    "bar"
  ],
  [
    13173,
    1,
    "ov"
  ],
  [
    13174,
    1,
    "pc"
  ],
  [
    13175,
    1,
    "dm"
  ],
  [
    13176,
    1,
    "dm2"
  ],
  [
    13177,
    1,
    "dm3"
  ],
  [
    13178,
    1,
    "iu"
  ],
  [
    13179,
    1,
    ""
  ],
  [
    13180,
    1,
    ""
  ],
  [
    13181,
    1,
    ""
  ],
  [
    13182,
    1,
    ""
  ],
  [
    13183,
    1,
    ""
  ],
  [
    13184,
    1,
    "pa"
  ],
  [
    13185,
    1,
    "na"
  ],
  [
    13186,
    1,
    "a"
  ],
  [
    13187,
    1,
    "ma"
  ],
  [
    13188,
    1,
    "ka"
  ],
  [
    13189,
    1,
    "kb"
  ],
  [
    13190,
    1,
    "mb"
  ],
  [
    13191,
    1,
    "gb"
  ],
  [
    13192,
    1,
    "cal"
  ],
  [
    13193,
    1,
    "kcal"
  ],
  [
    13194,
    1,
    "pf"
  ],
  [
    13195,
    1,
    "nf"
  ],
  [
    13196,
    1,
    "f"
  ],
  [
    13197,
    1,
    "g"
  ],
  [
    13198,
    1,
    "mg"
  ],
  [
    13199,
    1,
    "kg"
  ],
  [
    13200,
    1,
    "hz"
  ],
  [
    13201,
    1,
    "khz"
  ],
  [
    13202,
    1,
    "mhz"
  ],
  [
    13203,
    1,
    "ghz"
  ],
  [
    13204,
    1,
    "thz"
  ],
  [
    13205,
    1,
    "l"
  ],
  [
    13206,
    1,
    "ml"
  ],
  [
    13207,
    1,
    "dl"
  ],
  [
    13208,
    1,
    "kl"
  ],
  [
    13209,
    1,
    "fm"
  ],
  [
    13210,
    1,
    "nm"
  ],
  [
    13211,
    1,
    "m"
  ],
  [
    13212,
    1,
    "mm"
  ],
  [
    13213,
    1,
    "cm"
  ],
  [
    13214,
    1,
    "km"
  ],
  [
    13215,
    1,
    "mm2"
  ],
  [
    13216,
    1,
    "cm2"
  ],
  [
    13217,
    1,
    "m2"
  ],
  [
    13218,
    1,
    "km2"
  ],
  [
    13219,
    1,
    "mm3"
  ],
  [
    13220,
    1,
    "cm3"
  ],
  [
    13221,
    1,
    "m3"
  ],
  [
    13222,
    1,
    "km3"
  ],
  [
    13223,
    1,
    "ms"
  ],
  [
    13224,
    1,
    "ms2"
  ],
  [
    13225,
    1,
    "pa"
  ],
  [
    13226,
    1,
    "kpa"
  ],
  [
    13227,
    1,
    "mpa"
  ],
  [
    13228,
    1,
    "gpa"
  ],
  [
    13229,
    1,
    "rad"
  ],
  [
    13230,
    1,
    "rads"
  ],
  [
    13231,
    1,
    "rads2"
  ],
  [
    13232,
    1,
    "ps"
  ],
  [
    13233,
    1,
    "ns"
  ],
  [
    13234,
    1,
    "s"
  ],
  [
    13235,
    1,
    "ms"
  ],
  [
    13236,
    1,
    "pv"
  ],
  [
    13237,
    1,
    "nv"
  ],
  [
    13238,
    1,
    "v"
  ],
  [
    13239,
    1,
    "mv"
  ],
  [
    13240,
    1,
    "kv"
  ],
  [
    13241,
    1,
    "mv"
  ],
  [
    13242,
    1,
    "pw"
  ],
  [
    13243,
    1,
    "nw"
  ],
  [
    13244,
    1,
    "w"
  ],
  [
    13245,
    1,
    "mw"
  ],
  [
    13246,
    1,
    "kw"
  ],
  [
    13247,
    1,
    "mw"
  ],
  [
    13248,
    1,
    "k"
  ],
  [
    13249,
    1,
    "m"
  ],
  [
    13250,
    3
  ],
  [
    13251,
    1,
    "bq"
  ],
  [
    13252,
    1,
    "cc"
  ],
  [
    13253,
    1,
    "cd"
  ],
  [
    13254,
    1,
    "ckg"
  ],
  [
    13255,
    3
  ],
  [
    13256,
    1,
    "db"
  ],
  [
    13257,
    1,
    "gy"
  ],
  [
    13258,
    1,
    "ha"
  ],
  [
    13259,
    1,
    "hp"
  ],
  [
    13260,
    1,
    "in"
  ],
  [
    13261,
    1,
    "kk"
  ],
  [
    13262,
    1,
    "km"
  ],
  [
    13263,
    1,
    "kt"
  ],
  [
    13264,
    1,
    "lm"
  ],
  [
    13265,
    1,
    "ln"
  ],
  [
    13266,
    1,
    "log"
  ],
  [
    13267,
    1,
    "lx"
  ],
  [
    13268,
    1,
    "mb"
  ],
  [
    13269,
    1,
    "mil"
  ],
  [
    13270,
    1,
    "mol"
  ],
  [
    13271,
    1,
    "ph"
  ],
  [
    13272,
    3
  ],
  [
    13273,
    1,
    "ppm"
  ],
  [
    13274,
    1,
    "pr"
  ],
  [
    13275,
    1,
    "sr"
  ],
  [
    13276,
    1,
    "sv"
  ],
  [
    13277,
    1,
    "wb"
  ],
  [
    13278,
    1,
    "vm"
  ],
  [
    13279,
    1,
    "am"
  ],
  [
    13280,
    1,
    "1"
  ],
  [
    13281,
    1,
    "2"
  ],
  [
    13282,
    1,
    "3"
  ],
  [
    13283,
    1,
    "4"
  ],
  [
    13284,
    1,
    "5"
  ],
  [
    13285,
    1,
    "6"
  ],
  [
    13286,
    1,
    "7"
  ],
  [
    13287,
    1,
    "8"
  ],
  [
    13288,
    1,
    "9"
  ],
  [
    13289,
    1,
    "10"
  ],
  [
    13290,
    1,
    "11"
  ],
  [
    13291,
    1,
    "12"
  ],
  [
    13292,
    1,
    "13"
  ],
  [
    13293,
    1,
    "14"
  ],
  [
    13294,
    1,
    "15"
  ],
  [
    13295,
    1,
    "16"
  ],
  [
    13296,
    1,
    "17"
  ],
  [
    13297,
    1,
    "18"
  ],
  [
    13298,
    1,
    "19"
  ],
  [
    13299,
    1,
    "20"
  ],
  [
    13300,
    1,
    "21"
  ],
  [
    13301,
    1,
    "22"
  ],
  [
    13302,
    1,
    "23"
  ],
  [
    13303,
    1,
    "24"
  ],
  [
    13304,
    1,
    "25"
  ],
  [
    13305,
    1,
    "26"
  ],
  [
    13306,
    1,
    "27"
  ],
  [
    13307,
    1,
    "28"
  ],
  [
    13308,
    1,
    "29"
  ],
  [
    13309,
    1,
    "30"
  ],
  [
    13310,
    1,
    "31"
  ],
  [
    13311,
    1,
    "gal"
  ],
  [
    [
      13312,
      19893
    ],
    2
  ],
  [
    [
      19894,
      19903
    ],
    2
  ],
  [
    [
      19904,
      19967
    ],
    2
  ],
  [
    [
      19968,
      40869
    ],
    2
  ],
  [
    [
      40870,
      40891
    ],
    2
  ],
  [
    [
      40892,
      40899
    ],
    2
  ],
  [
    [
      40900,
      40907
    ],
    2
  ],
  [
    40908,
    2
  ],
  [
    [
      40909,
      40917
    ],
    2
  ],
  [
    [
      40918,
      40938
    ],
    2
  ],
  [
    [
      40939,
      40943
    ],
    2
  ],
  [
    [
      40944,
      40956
    ],
    2
  ],
  [
    [
      40957,
      40959
    ],
    2
  ],
  [
    [
      40960,
      42124
    ],
    2
  ],
  [
    [
      42125,
      42127
    ],
    3
  ],
  [
    [
      42128,
      42145
    ],
    2
  ],
  [
    [
      42146,
      42147
    ],
    2
  ],
  [
    [
      42148,
      42163
    ],
    2
  ],
  [
    42164,
    2
  ],
  [
    [
      42165,
      42176
    ],
    2
  ],
  [
    42177,
    2
  ],
  [
    [
      42178,
      42180
    ],
    2
  ],
  [
    42181,
    2
  ],
  [
    42182,
    2
  ],
  [
    [
      42183,
      42191
    ],
    3
  ],
  [
    [
      42192,
      42237
    ],
    2
  ],
  [
    [
      42238,
      42239
    ],
    2
  ],
  [
    [
      42240,
      42508
    ],
    2
  ],
  [
    [
      42509,
      42511
    ],
    2
  ],
  [
    [
      42512,
      42539
    ],
    2
  ],
  [
    [
      42540,
      42559
    ],
    3
  ],
  [
    42560,
    1,
    ""
  ],
  [
    42561,
    2
  ],
  [
    42562,
    1,
    ""
  ],
  [
    42563,
    2
  ],
  [
    42564,
    1,
    ""
  ],
  [
    42565,
    2
  ],
  [
    42566,
    1,
    ""
  ],
  [
    42567,
    2
  ],
  [
    42568,
    1,
    ""
  ],
  [
    42569,
    2
  ],
  [
    42570,
    1,
    ""
  ],
  [
    42571,
    2
  ],
  [
    42572,
    1,
    ""
  ],
  [
    42573,
    2
  ],
  [
    42574,
    1,
    ""
  ],
  [
    42575,
    2
  ],
  [
    42576,
    1,
    ""
  ],
  [
    42577,
    2
  ],
  [
    42578,
    1,
    ""
  ],
  [
    42579,
    2
  ],
  [
    42580,
    1,
    ""
  ],
  [
    42581,
    2
  ],
  [
    42582,
    1,
    ""
  ],
  [
    42583,
    2
  ],
  [
    42584,
    1,
    ""
  ],
  [
    42585,
    2
  ],
  [
    42586,
    1,
    ""
  ],
  [
    42587,
    2
  ],
  [
    42588,
    1,
    ""
  ],
  [
    42589,
    2
  ],
  [
    42590,
    1,
    ""
  ],
  [
    42591,
    2
  ],
  [
    42592,
    1,
    ""
  ],
  [
    42593,
    2
  ],
  [
    42594,
    1,
    ""
  ],
  [
    42595,
    2
  ],
  [
    42596,
    1,
    ""
  ],
  [
    42597,
    2
  ],
  [
    42598,
    1,
    ""
  ],
  [
    42599,
    2
  ],
  [
    42600,
    1,
    ""
  ],
  [
    42601,
    2
  ],
  [
    42602,
    1,
    ""
  ],
  [
    42603,
    2
  ],
  [
    42604,
    1,
    ""
  ],
  [
    [
      42605,
      42607
    ],
    2
  ],
  [
    [
      42608,
      42611
    ],
    2
  ],
  [
    [
      42612,
      42619
    ],
    2
  ],
  [
    [
      42620,
      42621
    ],
    2
  ],
  [
    42622,
    2
  ],
  [
    42623,
    2
  ],
  [
    42624,
    1,
    ""
  ],
  [
    42625,
    2
  ],
  [
    42626,
    1,
    ""
  ],
  [
    42627,
    2
  ],
  [
    42628,
    1,
    ""
  ],
  [
    42629,
    2
  ],
  [
    42630,
    1,
    ""
  ],
  [
    42631,
    2
  ],
  [
    42632,
    1,
    ""
  ],
  [
    42633,
    2
  ],
  [
    42634,
    1,
    ""
  ],
  [
    42635,
    2
  ],
  [
    42636,
    1,
    ""
  ],
  [
    42637,
    2
  ],
  [
    42638,
    1,
    ""
  ],
  [
    42639,
    2
  ],
  [
    42640,
    1,
    ""
  ],
  [
    42641,
    2
  ],
  [
    42642,
    1,
    ""
  ],
  [
    42643,
    2
  ],
  [
    42644,
    1,
    ""
  ],
  [
    42645,
    2
  ],
  [
    42646,
    1,
    ""
  ],
  [
    42647,
    2
  ],
  [
    42648,
    1,
    ""
  ],
  [
    42649,
    2
  ],
  [
    42650,
    1,
    ""
  ],
  [
    42651,
    2
  ],
  [
    42652,
    1,
    ""
  ],
  [
    42653,
    1,
    ""
  ],
  [
    42654,
    2
  ],
  [
    42655,
    2
  ],
  [
    [
      42656,
      42725
    ],
    2
  ],
  [
    [
      42726,
      42735
    ],
    2
  ],
  [
    [
      42736,
      42737
    ],
    2
  ],
  [
    [
      42738,
      42743
    ],
    2
  ],
  [
    [
      42744,
      42751
    ],
    3
  ],
  [
    [
      42752,
      42774
    ],
    2
  ],
  [
    [
      42775,
      42778
    ],
    2
  ],
  [
    [
      42779,
      42783
    ],
    2
  ],
  [
    [
      42784,
      42785
    ],
    2
  ],
  [
    42786,
    1,
    ""
  ],
  [
    42787,
    2
  ],
  [
    42788,
    1,
    ""
  ],
  [
    42789,
    2
  ],
  [
    42790,
    1,
    ""
  ],
  [
    42791,
    2
  ],
  [
    42792,
    1,
    ""
  ],
  [
    42793,
    2
  ],
  [
    42794,
    1,
    ""
  ],
  [
    42795,
    2
  ],
  [
    42796,
    1,
    ""
  ],
  [
    42797,
    2
  ],
  [
    42798,
    1,
    ""
  ],
  [
    [
      42799,
      42801
    ],
    2
  ],
  [
    42802,
    1,
    ""
  ],
  [
    42803,
    2
  ],
  [
    42804,
    1,
    ""
  ],
  [
    42805,
    2
  ],
  [
    42806,
    1,
    ""
  ],
  [
    42807,
    2
  ],
  [
    42808,
    1,
    ""
  ],
  [
    42809,
    2
  ],
  [
    42810,
    1,
    ""
  ],
  [
    42811,
    2
  ],
  [
    42812,
    1,
    ""
  ],
  [
    42813,
    2
  ],
  [
    42814,
    1,
    ""
  ],
  [
    42815,
    2
  ],
  [
    42816,
    1,
    ""
  ],
  [
    42817,
    2
  ],
  [
    42818,
    1,
    ""
  ],
  [
    42819,
    2
  ],
  [
    42820,
    1,
    ""
  ],
  [
    42821,
    2
  ],
  [
    42822,
    1,
    ""
  ],
  [
    42823,
    2
  ],
  [
    42824,
    1,
    ""
  ],
  [
    42825,
    2
  ],
  [
    42826,
    1,
    ""
  ],
  [
    42827,
    2
  ],
  [
    42828,
    1,
    ""
  ],
  [
    42829,
    2
  ],
  [
    42830,
    1,
    ""
  ],
  [
    42831,
    2
  ],
  [
    42832,
    1,
    ""
  ],
  [
    42833,
    2
  ],
  [
    42834,
    1,
    ""
  ],
  [
    42835,
    2
  ],
  [
    42836,
    1,
    ""
  ],
  [
    42837,
    2
  ],
  [
    42838,
    1,
    ""
  ],
  [
    42839,
    2
  ],
  [
    42840,
    1,
    ""
  ],
  [
    42841,
    2
  ],
  [
    42842,
    1,
    ""
  ],
  [
    42843,
    2
  ],
  [
    42844,
    1,
    ""
  ],
  [
    42845,
    2
  ],
  [
    42846,
    1,
    ""
  ],
  [
    42847,
    2
  ],
  [
    42848,
    1,
    ""
  ],
  [
    42849,
    2
  ],
  [
    42850,
    1,
    ""
  ],
  [
    42851,
    2
  ],
  [
    42852,
    1,
    ""
  ],
  [
    42853,
    2
  ],
  [
    42854,
    1,
    ""
  ],
  [
    42855,
    2
  ],
  [
    42856,
    1,
    ""
  ],
  [
    42857,
    2
  ],
  [
    42858,
    1,
    ""
  ],
  [
    42859,
    2
  ],
  [
    42860,
    1,
    ""
  ],
  [
    42861,
    2
  ],
  [
    42862,
    1,
    ""
  ],
  [
    42863,
    2
  ],
  [
    42864,
    1,
    ""
  ],
  [
    [
      42865,
      42872
    ],
    2
  ],
  [
    42873,
    1,
    ""
  ],
  [
    42874,
    2
  ],
  [
    42875,
    1,
    ""
  ],
  [
    42876,
    2
  ],
  [
    42877,
    1,
    ""
  ],
  [
    42878,
    1,
    ""
  ],
  [
    42879,
    2
  ],
  [
    42880,
    1,
    ""
  ],
  [
    42881,
    2
  ],
  [
    42882,
    1,
    ""
  ],
  [
    42883,
    2
  ],
  [
    42884,
    1,
    ""
  ],
  [
    42885,
    2
  ],
  [
    42886,
    1,
    ""
  ],
  [
    [
      42887,
      42888
    ],
    2
  ],
  [
    [
      42889,
      42890
    ],
    2
  ],
  [
    42891,
    1,
    ""
  ],
  [
    42892,
    2
  ],
  [
    42893,
    1,
    ""
  ],
  [
    42894,
    2
  ],
  [
    42895,
    2
  ],
  [
    42896,
    1,
    ""
  ],
  [
    42897,
    2
  ],
  [
    42898,
    1,
    ""
  ],
  [
    42899,
    2
  ],
  [
    [
      42900,
      42901
    ],
    2
  ],
  [
    42902,
    1,
    ""
  ],
  [
    42903,
    2
  ],
  [
    42904,
    1,
    ""
  ],
  [
    42905,
    2
  ],
  [
    42906,
    1,
    ""
  ],
  [
    42907,
    2
  ],
  [
    42908,
    1,
    ""
  ],
  [
    42909,
    2
  ],
  [
    42910,
    1,
    ""
  ],
  [
    42911,
    2
  ],
  [
    42912,
    1,
    ""
  ],
  [
    42913,
    2
  ],
  [
    42914,
    1,
    ""
  ],
  [
    42915,
    2
  ],
  [
    42916,
    1,
    ""
  ],
  [
    42917,
    2
  ],
  [
    42918,
    1,
    ""
  ],
  [
    42919,
    2
  ],
  [
    42920,
    1,
    ""
  ],
  [
    42921,
    2
  ],
  [
    42922,
    1,
    ""
  ],
  [
    42923,
    1,
    ""
  ],
  [
    42924,
    1,
    ""
  ],
  [
    42925,
    1,
    ""
  ],
  [
    42926,
    1,
    ""
  ],
  [
    42927,
    2
  ],
  [
    42928,
    1,
    ""
  ],
  [
    42929,
    1,
    ""
  ],
  [
    42930,
    1,
    ""
  ],
  [
    42931,
    1,
    ""
  ],
  [
    42932,
    1,
    ""
  ],
  [
    42933,
    2
  ],
  [
    42934,
    1,
    ""
  ],
  [
    42935,
    2
  ],
  [
    42936,
    1,
    ""
  ],
  [
    42937,
    2
  ],
  [
    42938,
    1,
    ""
  ],
  [
    42939,
    2
  ],
  [
    42940,
    1,
    ""
  ],
  [
    42941,
    2
  ],
  [
    42942,
    1,
    ""
  ],
  [
    42943,
    2
  ],
  [
    42944,
    1,
    ""
  ],
  [
    42945,
    2
  ],
  [
    42946,
    1,
    ""
  ],
  [
    42947,
    2
  ],
  [
    42948,
    1,
    ""
  ],
  [
    42949,
    1,
    ""
  ],
  [
    42950,
    1,
    ""
  ],
  [
    42951,
    1,
    ""
  ],
  [
    42952,
    2
  ],
  [
    42953,
    1,
    ""
  ],
  [
    42954,
    2
  ],
  [
    [
      42955,
      42959
    ],
    3
  ],
  [
    42960,
    1,
    ""
  ],
  [
    42961,
    2
  ],
  [
    42962,
    3
  ],
  [
    42963,
    2
  ],
  [
    42964,
    3
  ],
  [
    42965,
    2
  ],
  [
    42966,
    1,
    ""
  ],
  [
    42967,
    2
  ],
  [
    42968,
    1,
    ""
  ],
  [
    42969,
    2
  ],
  [
    [
      42970,
      42993
    ],
    3
  ],
  [
    42994,
    1,
    "c"
  ],
  [
    42995,
    1,
    "f"
  ],
  [
    42996,
    1,
    "q"
  ],
  [
    42997,
    1,
    ""
  ],
  [
    42998,
    2
  ],
  [
    42999,
    2
  ],
  [
    43e3,
    1,
    ""
  ],
  [
    43001,
    1,
    ""
  ],
  [
    43002,
    2
  ],
  [
    [
      43003,
      43007
    ],
    2
  ],
  [
    [
      43008,
      43047
    ],
    2
  ],
  [
    [
      43048,
      43051
    ],
    2
  ],
  [
    43052,
    2
  ],
  [
    [
      43053,
      43055
    ],
    3
  ],
  [
    [
      43056,
      43065
    ],
    2
  ],
  [
    [
      43066,
      43071
    ],
    3
  ],
  [
    [
      43072,
      43123
    ],
    2
  ],
  [
    [
      43124,
      43127
    ],
    2
  ],
  [
    [
      43128,
      43135
    ],
    3
  ],
  [
    [
      43136,
      43204
    ],
    2
  ],
  [
    43205,
    2
  ],
  [
    [
      43206,
      43213
    ],
    3
  ],
  [
    [
      43214,
      43215
    ],
    2
  ],
  [
    [
      43216,
      43225
    ],
    2
  ],
  [
    [
      43226,
      43231
    ],
    3
  ],
  [
    [
      43232,
      43255
    ],
    2
  ],
  [
    [
      43256,
      43258
    ],
    2
  ],
  [
    43259,
    2
  ],
  [
    43260,
    2
  ],
  [
    43261,
    2
  ],
  [
    [
      43262,
      43263
    ],
    2
  ],
  [
    [
      43264,
      43309
    ],
    2
  ],
  [
    [
      43310,
      43311
    ],
    2
  ],
  [
    [
      43312,
      43347
    ],
    2
  ],
  [
    [
      43348,
      43358
    ],
    3
  ],
  [
    43359,
    2
  ],
  [
    [
      43360,
      43388
    ],
    2
  ],
  [
    [
      43389,
      43391
    ],
    3
  ],
  [
    [
      43392,
      43456
    ],
    2
  ],
  [
    [
      43457,
      43469
    ],
    2
  ],
  [
    43470,
    3
  ],
  [
    [
      43471,
      43481
    ],
    2
  ],
  [
    [
      43482,
      43485
    ],
    3
  ],
  [
    [
      43486,
      43487
    ],
    2
  ],
  [
    [
      43488,
      43518
    ],
    2
  ],
  [
    43519,
    3
  ],
  [
    [
      43520,
      43574
    ],
    2
  ],
  [
    [
      43575,
      43583
    ],
    3
  ],
  [
    [
      43584,
      43597
    ],
    2
  ],
  [
    [
      43598,
      43599
    ],
    3
  ],
  [
    [
      43600,
      43609
    ],
    2
  ],
  [
    [
      43610,
      43611
    ],
    3
  ],
  [
    [
      43612,
      43615
    ],
    2
  ],
  [
    [
      43616,
      43638
    ],
    2
  ],
  [
    [
      43639,
      43641
    ],
    2
  ],
  [
    [
      43642,
      43643
    ],
    2
  ],
  [
    [
      43644,
      43647
    ],
    2
  ],
  [
    [
      43648,
      43714
    ],
    2
  ],
  [
    [
      43715,
      43738
    ],
    3
  ],
  [
    [
      43739,
      43741
    ],
    2
  ],
  [
    [
      43742,
      43743
    ],
    2
  ],
  [
    [
      43744,
      43759
    ],
    2
  ],
  [
    [
      43760,
      43761
    ],
    2
  ],
  [
    [
      43762,
      43766
    ],
    2
  ],
  [
    [
      43767,
      43776
    ],
    3
  ],
  [
    [
      43777,
      43782
    ],
    2
  ],
  [
    [
      43783,
      43784
    ],
    3
  ],
  [
    [
      43785,
      43790
    ],
    2
  ],
  [
    [
      43791,
      43792
    ],
    3
  ],
  [
    [
      43793,
      43798
    ],
    2
  ],
  [
    [
      43799,
      43807
    ],
    3
  ],
  [
    [
      43808,
      43814
    ],
    2
  ],
  [
    43815,
    3
  ],
  [
    [
      43816,
      43822
    ],
    2
  ],
  [
    43823,
    3
  ],
  [
    [
      43824,
      43866
    ],
    2
  ],
  [
    43867,
    2
  ],
  [
    43868,
    1,
    ""
  ],
  [
    43869,
    1,
    ""
  ],
  [
    43870,
    1,
    ""
  ],
  [
    43871,
    1,
    ""
  ],
  [
    [
      43872,
      43875
    ],
    2
  ],
  [
    [
      43876,
      43877
    ],
    2
  ],
  [
    [
      43878,
      43879
    ],
    2
  ],
  [
    43880,
    2
  ],
  [
    43881,
    1,
    ""
  ],
  [
    [
      43882,
      43883
    ],
    2
  ],
  [
    [
      43884,
      43887
    ],
    3
  ],
  [
    43888,
    1,
    ""
  ],
  [
    43889,
    1,
    ""
  ],
  [
    43890,
    1,
    ""
  ],
  [
    43891,
    1,
    ""
  ],
  [
    43892,
    1,
    ""
  ],
  [
    43893,
    1,
    ""
  ],
  [
    43894,
    1,
    ""
  ],
  [
    43895,
    1,
    ""
  ],
  [
    43896,
    1,
    ""
  ],
  [
    43897,
    1,
    ""
  ],
  [
    43898,
    1,
    ""
  ],
  [
    43899,
    1,
    ""
  ],
  [
    43900,
    1,
    ""
  ],
  [
    43901,
    1,
    ""
  ],
  [
    43902,
    1,
    ""
  ],
  [
    43903,
    1,
    ""
  ],
  [
    43904,
    1,
    ""
  ],
  [
    43905,
    1,
    ""
  ],
  [
    43906,
    1,
    ""
  ],
  [
    43907,
    1,
    ""
  ],
  [
    43908,
    1,
    ""
  ],
  [
    43909,
    1,
    ""
  ],
  [
    43910,
    1,
    ""
  ],
  [
    43911,
    1,
    ""
  ],
  [
    43912,
    1,
    ""
  ],
  [
    43913,
    1,
    ""
  ],
  [
    43914,
    1,
    ""
  ],
  [
    43915,
    1,
    ""
  ],
  [
    43916,
    1,
    ""
  ],
  [
    43917,
    1,
    ""
  ],
  [
    43918,
    1,
    ""
  ],
  [
    43919,
    1,
    ""
  ],
  [
    43920,
    1,
    ""
  ],
  [
    43921,
    1,
    ""
  ],
  [
    43922,
    1,
    ""
  ],
  [
    43923,
    1,
    ""
  ],
  [
    43924,
    1,
    ""
  ],
  [
    43925,
    1,
    ""
  ],
  [
    43926,
    1,
    ""
  ],
  [
    43927,
    1,
    ""
  ],
  [
    43928,
    1,
    ""
  ],
  [
    43929,
    1,
    ""
  ],
  [
    43930,
    1,
    ""
  ],
  [
    43931,
    1,
    ""
  ],
  [
    43932,
    1,
    ""
  ],
  [
    43933,
    1,
    ""
  ],
  [
    43934,
    1,
    ""
  ],
  [
    43935,
    1,
    ""
  ],
  [
    43936,
    1,
    ""
  ],
  [
    43937,
    1,
    ""
  ],
  [
    43938,
    1,
    ""
  ],
  [
    43939,
    1,
    ""
  ],
  [
    43940,
    1,
    ""
  ],
  [
    43941,
    1,
    ""
  ],
  [
    43942,
    1,
    ""
  ],
  [
    43943,
    1,
    ""
  ],
  [
    43944,
    1,
    ""
  ],
  [
    43945,
    1,
    ""
  ],
  [
    43946,
    1,
    ""
  ],
  [
    43947,
    1,
    ""
  ],
  [
    43948,
    1,
    ""
  ],
  [
    43949,
    1,
    ""
  ],
  [
    43950,
    1,
    ""
  ],
  [
    43951,
    1,
    ""
  ],
  [
    43952,
    1,
    ""
  ],
  [
    43953,
    1,
    ""
  ],
  [
    43954,
    1,
    ""
  ],
  [
    43955,
    1,
    ""
  ],
  [
    43956,
    1,
    ""
  ],
  [
    43957,
    1,
    ""
  ],
  [
    43958,
    1,
    ""
  ],
  [
    43959,
    1,
    ""
  ],
  [
    43960,
    1,
    ""
  ],
  [
    43961,
    1,
    ""
  ],
  [
    43962,
    1,
    ""
  ],
  [
    43963,
    1,
    ""
  ],
  [
    43964,
    1,
    ""
  ],
  [
    43965,
    1,
    ""
  ],
  [
    43966,
    1,
    ""
  ],
  [
    43967,
    1,
    ""
  ],
  [
    [
      43968,
      44010
    ],
    2
  ],
  [
    44011,
    2
  ],
  [
    [
      44012,
      44013
    ],
    2
  ],
  [
    [
      44014,
      44015
    ],
    3
  ],
  [
    [
      44016,
      44025
    ],
    2
  ],
  [
    [
      44026,
      44031
    ],
    3
  ],
  [
    [
      44032,
      55203
    ],
    2
  ],
  [
    [
      55204,
      55215
    ],
    3
  ],
  [
    [
      55216,
      55238
    ],
    2
  ],
  [
    [
      55239,
      55242
    ],
    3
  ],
  [
    [
      55243,
      55291
    ],
    2
  ],
  [
    [
      55292,
      55295
    ],
    3
  ],
  [
    [
      55296,
      57343
    ],
    3
  ],
  [
    [
      57344,
      63743
    ],
    3
  ],
  [
    63744,
    1,
    ""
  ],
  [
    63745,
    1,
    ""
  ],
  [
    63746,
    1,
    ""
  ],
  [
    63747,
    1,
    ""
  ],
  [
    63748,
    1,
    ""
  ],
  [
    63749,
    1,
    ""
  ],
  [
    63750,
    1,
    ""
  ],
  [
    [
      63751,
      63752
    ],
    1,
    ""
  ],
  [
    63753,
    1,
    ""
  ],
  [
    63754,
    1,
    ""
  ],
  [
    63755,
    1,
    ""
  ],
  [
    63756,
    1,
    ""
  ],
  [
    63757,
    1,
    ""
  ],
  [
    63758,
    1,
    ""
  ],
  [
    63759,
    1,
    ""
  ],
  [
    63760,
    1,
    ""
  ],
  [
    63761,
    1,
    ""
  ],
  [
    63762,
    1,
    ""
  ],
  [
    63763,
    1,
    ""
  ],
  [
    63764,
    1,
    ""
  ],
  [
    63765,
    1,
    ""
  ],
  [
    63766,
    1,
    ""
  ],
  [
    63767,
    1,
    ""
  ],
  [
    63768,
    1,
    ""
  ],
  [
    63769,
    1,
    ""
  ],
  [
    63770,
    1,
    ""
  ],
  [
    63771,
    1,
    ""
  ],
  [
    63772,
    1,
    ""
  ],
  [
    63773,
    1,
    ""
  ],
  [
    63774,
    1,
    ""
  ],
  [
    63775,
    1,
    ""
  ],
  [
    63776,
    1,
    ""
  ],
  [
    63777,
    1,
    ""
  ],
  [
    63778,
    1,
    ""
  ],
  [
    63779,
    1,
    ""
  ],
  [
    63780,
    1,
    ""
  ],
  [
    63781,
    1,
    ""
  ],
  [
    63782,
    1,
    ""
  ],
  [
    63783,
    1,
    ""
  ],
  [
    63784,
    1,
    ""
  ],
  [
    63785,
    1,
    ""
  ],
  [
    63786,
    1,
    ""
  ],
  [
    63787,
    1,
    ""
  ],
  [
    63788,
    1,
    ""
  ],
  [
    63789,
    1,
    ""
  ],
  [
    63790,
    1,
    ""
  ],
  [
    63791,
    1,
    ""
  ],
  [
    63792,
    1,
    ""
  ],
  [
    63793,
    1,
    ""
  ],
  [
    63794,
    1,
    ""
  ],
  [
    63795,
    1,
    ""
  ],
  [
    63796,
    1,
    ""
  ],
  [
    63797,
    1,
    ""
  ],
  [
    63798,
    1,
    ""
  ],
  [
    63799,
    1,
    ""
  ],
  [
    63800,
    1,
    ""
  ],
  [
    63801,
    1,
    ""
  ],
  [
    63802,
    1,
    ""
  ],
  [
    63803,
    1,
    ""
  ],
  [
    63804,
    1,
    ""
  ],
  [
    63805,
    1,
    ""
  ],
  [
    63806,
    1,
    ""
  ],
  [
    63807,
    1,
    ""
  ],
  [
    63808,
    1,
    ""
  ],
  [
    63809,
    1,
    ""
  ],
  [
    63810,
    1,
    ""
  ],
  [
    63811,
    1,
    ""
  ],
  [
    63812,
    1,
    ""
  ],
  [
    63813,
    1,
    ""
  ],
  [
    63814,
    1,
    ""
  ],
  [
    63815,
    1,
    ""
  ],
  [
    63816,
    1,
    ""
  ],
  [
    63817,
    1,
    ""
  ],
  [
    63818,
    1,
    ""
  ],
  [
    63819,
    1,
    ""
  ],
  [
    63820,
    1,
    ""
  ],
  [
    63821,
    1,
    ""
  ],
  [
    63822,
    1,
    ""
  ],
  [
    63823,
    1,
    ""
  ],
  [
    63824,
    1,
    ""
  ],
  [
    63825,
    1,
    ""
  ],
  [
    63826,
    1,
    ""
  ],
  [
    63827,
    1,
    ""
  ],
  [
    63828,
    1,
    ""
  ],
  [
    63829,
    1,
    ""
  ],
  [
    63830,
    1,
    ""
  ],
  [
    63831,
    1,
    ""
  ],
  [
    63832,
    1,
    ""
  ],
  [
    63833,
    1,
    ""
  ],
  [
    63834,
    1,
    ""
  ],
  [
    63835,
    1,
    ""
  ],
  [
    63836,
    1,
    ""
  ],
  [
    63837,
    1,
    ""
  ],
  [
    63838,
    1,
    ""
  ],
  [
    63839,
    1,
    ""
  ],
  [
    63840,
    1,
    ""
  ],
  [
    63841,
    1,
    ""
  ],
  [
    63842,
    1,
    ""
  ],
  [
    63843,
    1,
    ""
  ],
  [
    63844,
    1,
    ""
  ],
  [
    63845,
    1,
    ""
  ],
  [
    63846,
    1,
    ""
  ],
  [
    63847,
    1,
    ""
  ],
  [
    63848,
    1,
    ""
  ],
  [
    63849,
    1,
    ""
  ],
  [
    63850,
    1,
    ""
  ],
  [
    63851,
    1,
    ""
  ],
  [
    63852,
    1,
    ""
  ],
  [
    63853,
    1,
    ""
  ],
  [
    63854,
    1,
    ""
  ],
  [
    63855,
    1,
    ""
  ],
  [
    63856,
    1,
    ""
  ],
  [
    63857,
    1,
    ""
  ],
  [
    63858,
    1,
    ""
  ],
  [
    63859,
    1,
    ""
  ],
  [
    63860,
    1,
    ""
  ],
  [
    63861,
    1,
    ""
  ],
  [
    63862,
    1,
    ""
  ],
  [
    63863,
    1,
    ""
  ],
  [
    63864,
    1,
    ""
  ],
  [
    63865,
    1,
    ""
  ],
  [
    63866,
    1,
    ""
  ],
  [
    63867,
    1,
    ""
  ],
  [
    63868,
    1,
    ""
  ],
  [
    63869,
    1,
    ""
  ],
  [
    63870,
    1,
    ""
  ],
  [
    63871,
    1,
    ""
  ],
  [
    63872,
    1,
    ""
  ],
  [
    63873,
    1,
    ""
  ],
  [
    63874,
    1,
    ""
  ],
  [
    63875,
    1,
    ""
  ],
  [
    63876,
    1,
    ""
  ],
  [
    63877,
    1,
    ""
  ],
  [
    63878,
    1,
    ""
  ],
  [
    63879,
    1,
    ""
  ],
  [
    63880,
    1,
    ""
  ],
  [
    63881,
    1,
    ""
  ],
  [
    63882,
    1,
    ""
  ],
  [
    63883,
    1,
    ""
  ],
  [
    63884,
    1,
    ""
  ],
  [
    63885,
    1,
    ""
  ],
  [
    63886,
    1,
    ""
  ],
  [
    63887,
    1,
    ""
  ],
  [
    63888,
    1,
    ""
  ],
  [
    63889,
    1,
    ""
  ],
  [
    63890,
    1,
    ""
  ],
  [
    63891,
    1,
    ""
  ],
  [
    63892,
    1,
    ""
  ],
  [
    63893,
    1,
    ""
  ],
  [
    63894,
    1,
    ""
  ],
  [
    63895,
    1,
    ""
  ],
  [
    63896,
    1,
    ""
  ],
  [
    63897,
    1,
    ""
  ],
  [
    63898,
    1,
    ""
  ],
  [
    63899,
    1,
    ""
  ],
  [
    63900,
    1,
    ""
  ],
  [
    63901,
    1,
    ""
  ],
  [
    63902,
    1,
    ""
  ],
  [
    63903,
    1,
    ""
  ],
  [
    63904,
    1,
    ""
  ],
  [
    63905,
    1,
    ""
  ],
  [
    63906,
    1,
    ""
  ],
  [
    63907,
    1,
    ""
  ],
  [
    63908,
    1,
    ""
  ],
  [
    63909,
    1,
    ""
  ],
  [
    63910,
    1,
    ""
  ],
  [
    63911,
    1,
    ""
  ],
  [
    63912,
    1,
    ""
  ],
  [
    63913,
    1,
    ""
  ],
  [
    63914,
    1,
    ""
  ],
  [
    63915,
    1,
    ""
  ],
  [
    63916,
    1,
    ""
  ],
  [
    63917,
    1,
    ""
  ],
  [
    63918,
    1,
    ""
  ],
  [
    63919,
    1,
    ""
  ],
  [
    63920,
    1,
    ""
  ],
  [
    63921,
    1,
    ""
  ],
  [
    63922,
    1,
    ""
  ],
  [
    63923,
    1,
    ""
  ],
  [
    63924,
    1,
    ""
  ],
  [
    63925,
    1,
    ""
  ],
  [
    63926,
    1,
    ""
  ],
  [
    63927,
    1,
    ""
  ],
  [
    63928,
    1,
    ""
  ],
  [
    63929,
    1,
    ""
  ],
  [
    63930,
    1,
    ""
  ],
  [
    63931,
    1,
    ""
  ],
  [
    63932,
    1,
    ""
  ],
  [
    63933,
    1,
    ""
  ],
  [
    63934,
    1,
    ""
  ],
  [
    63935,
    1,
    ""
  ],
  [
    63936,
    1,
    ""
  ],
  [
    63937,
    1,
    ""
  ],
  [
    63938,
    1,
    ""
  ],
  [
    63939,
    1,
    ""
  ],
  [
    63940,
    1,
    ""
  ],
  [
    63941,
    1,
    ""
  ],
  [
    63942,
    1,
    ""
  ],
  [
    63943,
    1,
    ""
  ],
  [
    63944,
    1,
    ""
  ],
  [
    63945,
    1,
    ""
  ],
  [
    63946,
    1,
    ""
  ],
  [
    63947,
    1,
    ""
  ],
  [
    63948,
    1,
    ""
  ],
  [
    63949,
    1,
    ""
  ],
  [
    63950,
    1,
    ""
  ],
  [
    63951,
    1,
    ""
  ],
  [
    63952,
    1,
    ""
  ],
  [
    63953,
    1,
    ""
  ],
  [
    63954,
    1,
    ""
  ],
  [
    63955,
    1,
    ""
  ],
  [
    63956,
    1,
    ""
  ],
  [
    63957,
    1,
    ""
  ],
  [
    63958,
    1,
    ""
  ],
  [
    63959,
    1,
    ""
  ],
  [
    63960,
    1,
    ""
  ],
  [
    63961,
    1,
    ""
  ],
  [
    63962,
    1,
    ""
  ],
  [
    63963,
    1,
    ""
  ],
  [
    63964,
    1,
    ""
  ],
  [
    63965,
    1,
    ""
  ],
  [
    63966,
    1,
    ""
  ],
  [
    63967,
    1,
    ""
  ],
  [
    63968,
    1,
    ""
  ],
  [
    63969,
    1,
    ""
  ],
  [
    63970,
    1,
    ""
  ],
  [
    63971,
    1,
    ""
  ],
  [
    63972,
    1,
    ""
  ],
  [
    63973,
    1,
    ""
  ],
  [
    63974,
    1,
    ""
  ],
  [
    63975,
    1,
    ""
  ],
  [
    63976,
    1,
    ""
  ],
  [
    63977,
    1,
    ""
  ],
  [
    63978,
    1,
    ""
  ],
  [
    63979,
    1,
    ""
  ],
  [
    63980,
    1,
    ""
  ],
  [
    63981,
    1,
    ""
  ],
  [
    63982,
    1,
    ""
  ],
  [
    63983,
    1,
    ""
  ],
  [
    63984,
    1,
    ""
  ],
  [
    63985,
    1,
    ""
  ],
  [
    63986,
    1,
    ""
  ],
  [
    63987,
    1,
    ""
  ],
  [
    63988,
    1,
    ""
  ],
  [
    63989,
    1,
    ""
  ],
  [
    63990,
    1,
    ""
  ],
  [
    63991,
    1,
    ""
  ],
  [
    63992,
    1,
    ""
  ],
  [
    63993,
    1,
    ""
  ],
  [
    63994,
    1,
    ""
  ],
  [
    63995,
    1,
    ""
  ],
  [
    63996,
    1,
    ""
  ],
  [
    63997,
    1,
    ""
  ],
  [
    63998,
    1,
    ""
  ],
  [
    63999,
    1,
    ""
  ],
  [
    64e3,
    1,
    ""
  ],
  [
    64001,
    1,
    ""
  ],
  [
    64002,
    1,
    ""
  ],
  [
    64003,
    1,
    ""
  ],
  [
    64004,
    1,
    ""
  ],
  [
    64005,
    1,
    ""
  ],
  [
    64006,
    1,
    ""
  ],
  [
    64007,
    1,
    ""
  ],
  [
    64008,
    1,
    ""
  ],
  [
    64009,
    1,
    ""
  ],
  [
    64010,
    1,
    ""
  ],
  [
    64011,
    1,
    ""
  ],
  [
    64012,
    1,
    ""
  ],
  [
    64013,
    1,
    ""
  ],
  [
    [
      64014,
      64015
    ],
    2
  ],
  [
    64016,
    1,
    ""
  ],
  [
    64017,
    2
  ],
  [
    64018,
    1,
    ""
  ],
  [
    [
      64019,
      64020
    ],
    2
  ],
  [
    64021,
    1,
    ""
  ],
  [
    64022,
    1,
    ""
  ],
  [
    64023,
    1,
    ""
  ],
  [
    64024,
    1,
    ""
  ],
  [
    64025,
    1,
    ""
  ],
  [
    64026,
    1,
    ""
  ],
  [
    64027,
    1,
    ""
  ],
  [
    64028,
    1,
    ""
  ],
  [
    64029,
    1,
    ""
  ],
  [
    64030,
    1,
    ""
  ],
  [
    64031,
    2
  ],
  [
    64032,
    1,
    ""
  ],
  [
    64033,
    2
  ],
  [
    64034,
    1,
    ""
  ],
  [
    [
      64035,
      64036
    ],
    2
  ],
  [
    64037,
    1,
    ""
  ],
  [
    64038,
    1,
    ""
  ],
  [
    [
      64039,
      64041
    ],
    2
  ],
  [
    64042,
    1,
    ""
  ],
  [
    64043,
    1,
    ""
  ],
  [
    64044,
    1,
    ""
  ],
  [
    64045,
    1,
    ""
  ],
  [
    64046,
    1,
    ""
  ],
  [
    64047,
    1,
    ""
  ],
  [
    64048,
    1,
    ""
  ],
  [
    64049,
    1,
    ""
  ],
  [
    64050,
    1,
    ""
  ],
  [
    64051,
    1,
    ""
  ],
  [
    64052,
    1,
    ""
  ],
  [
    64053,
    1,
    ""
  ],
  [
    64054,
    1,
    ""
  ],
  [
    64055,
    1,
    ""
  ],
  [
    64056,
    1,
    ""
  ],
  [
    64057,
    1,
    ""
  ],
  [
    64058,
    1,
    ""
  ],
  [
    64059,
    1,
    ""
  ],
  [
    64060,
    1,
    ""
  ],
  [
    64061,
    1,
    ""
  ],
  [
    64062,
    1,
    ""
  ],
  [
    64063,
    1,
    ""
  ],
  [
    64064,
    1,
    ""
  ],
  [
    64065,
    1,
    ""
  ],
  [
    64066,
    1,
    ""
  ],
  [
    64067,
    1,
    ""
  ],
  [
    64068,
    1,
    ""
  ],
  [
    64069,
    1,
    ""
  ],
  [
    64070,
    1,
    ""
  ],
  [
    64071,
    1,
    ""
  ],
  [
    64072,
    1,
    ""
  ],
  [
    64073,
    1,
    ""
  ],
  [
    64074,
    1,
    ""
  ],
  [
    64075,
    1,
    ""
  ],
  [
    64076,
    1,
    ""
  ],
  [
    64077,
    1,
    ""
  ],
  [
    64078,
    1,
    ""
  ],
  [
    64079,
    1,
    ""
  ],
  [
    64080,
    1,
    ""
  ],
  [
    64081,
    1,
    ""
  ],
  [
    64082,
    1,
    ""
  ],
  [
    64083,
    1,
    ""
  ],
  [
    64084,
    1,
    ""
  ],
  [
    64085,
    1,
    ""
  ],
  [
    64086,
    1,
    ""
  ],
  [
    64087,
    1,
    ""
  ],
  [
    64088,
    1,
    ""
  ],
  [
    64089,
    1,
    ""
  ],
  [
    64090,
    1,
    ""
  ],
  [
    64091,
    1,
    ""
  ],
  [
    64092,
    1,
    ""
  ],
  [
    [
      64093,
      64094
    ],
    1,
    ""
  ],
  [
    64095,
    1,
    ""
  ],
  [
    64096,
    1,
    ""
  ],
  [
    64097,
    1,
    ""
  ],
  [
    64098,
    1,
    ""
  ],
  [
    64099,
    1,
    ""
  ],
  [
    64100,
    1,
    ""
  ],
  [
    64101,
    1,
    ""
  ],
  [
    64102,
    1,
    ""
  ],
  [
    64103,
    1,
    ""
  ],
  [
    64104,
    1,
    ""
  ],
  [
    64105,
    1,
    ""
  ],
  [
    64106,
    1,
    ""
  ],
  [
    64107,
    1,
    ""
  ],
  [
    64108,
    1,
    ""
  ],
  [
    64109,
    1,
    ""
  ],
  [
    [
      64110,
      64111
    ],
    3
  ],
  [
    64112,
    1,
    ""
  ],
  [
    64113,
    1,
    ""
  ],
  [
    64114,
    1,
    ""
  ],
  [
    64115,
    1,
    ""
  ],
  [
    64116,
    1,
    ""
  ],
  [
    64117,
    1,
    ""
  ],
  [
    64118,
    1,
    ""
  ],
  [
    64119,
    1,
    ""
  ],
  [
    64120,
    1,
    ""
  ],
  [
    64121,
    1,
    ""
  ],
  [
    64122,
    1,
    ""
  ],
  [
    64123,
    1,
    ""
  ],
  [
    64124,
    1,
    ""
  ],
  [
    64125,
    1,
    ""
  ],
  [
    64126,
    1,
    ""
  ],
  [
    64127,
    1,
    ""
  ],
  [
    64128,
    1,
    ""
  ],
  [
    64129,
    1,
    ""
  ],
  [
    64130,
    1,
    ""
  ],
  [
    64131,
    1,
    ""
  ],
  [
    64132,
    1,
    ""
  ],
  [
    64133,
    1,
    ""
  ],
  [
    64134,
    1,
    ""
  ],
  [
    64135,
    1,
    ""
  ],
  [
    64136,
    1,
    ""
  ],
  [
    64137,
    1,
    ""
  ],
  [
    64138,
    1,
    ""
  ],
  [
    64139,
    1,
    ""
  ],
  [
    64140,
    1,
    ""
  ],
  [
    64141,
    1,
    ""
  ],
  [
    64142,
    1,
    ""
  ],
  [
    64143,
    1,
    ""
  ],
  [
    64144,
    1,
    ""
  ],
  [
    64145,
    1,
    ""
  ],
  [
    64146,
    1,
    ""
  ],
  [
    64147,
    1,
    ""
  ],
  [
    64148,
    1,
    ""
  ],
  [
    64149,
    1,
    ""
  ],
  [
    64150,
    1,
    ""
  ],
  [
    64151,
    1,
    ""
  ],
  [
    64152,
    1,
    ""
  ],
  [
    64153,
    1,
    ""
  ],
  [
    64154,
    1,
    ""
  ],
  [
    64155,
    1,
    ""
  ],
  [
    64156,
    1,
    ""
  ],
  [
    64157,
    1,
    ""
  ],
  [
    64158,
    1,
    ""
  ],
  [
    64159,
    1,
    ""
  ],
  [
    64160,
    1,
    ""
  ],
  [
    64161,
    1,
    ""
  ],
  [
    64162,
    1,
    ""
  ],
  [
    64163,
    1,
    ""
  ],
  [
    64164,
    1,
    ""
  ],
  [
    64165,
    1,
    ""
  ],
  [
    64166,
    1,
    ""
  ],
  [
    64167,
    1,
    ""
  ],
  [
    64168,
    1,
    ""
  ],
  [
    64169,
    1,
    ""
  ],
  [
    64170,
    1,
    ""
  ],
  [
    64171,
    1,
    ""
  ],
  [
    64172,
    1,
    ""
  ],
  [
    64173,
    1,
    ""
  ],
  [
    64174,
    1,
    ""
  ],
  [
    64175,
    1,
    ""
  ],
  [
    64176,
    1,
    ""
  ],
  [
    64177,
    1,
    ""
  ],
  [
    64178,
    1,
    ""
  ],
  [
    64179,
    1,
    ""
  ],
  [
    64180,
    1,
    ""
  ],
  [
    64181,
    1,
    ""
  ],
  [
    64182,
    1,
    ""
  ],
  [
    64183,
    1,
    ""
  ],
  [
    64184,
    1,
    ""
  ],
  [
    64185,
    1,
    ""
  ],
  [
    64186,
    1,
    ""
  ],
  [
    64187,
    1,
    ""
  ],
  [
    64188,
    1,
    ""
  ],
  [
    64189,
    1,
    ""
  ],
  [
    64190,
    1,
    ""
  ],
  [
    64191,
    1,
    ""
  ],
  [
    64192,
    1,
    ""
  ],
  [
    64193,
    1,
    ""
  ],
  [
    64194,
    1,
    ""
  ],
  [
    64195,
    1,
    ""
  ],
  [
    64196,
    1,
    ""
  ],
  [
    64197,
    1,
    ""
  ],
  [
    64198,
    1,
    ""
  ],
  [
    64199,
    1,
    ""
  ],
  [
    64200,
    1,
    ""
  ],
  [
    64201,
    1,
    ""
  ],
  [
    64202,
    1,
    ""
  ],
  [
    64203,
    1,
    ""
  ],
  [
    64204,
    1,
    ""
  ],
  [
    64205,
    1,
    ""
  ],
  [
    64206,
    1,
    ""
  ],
  [
    64207,
    1,
    ""
  ],
  [
    64208,
    1,
    ""
  ],
  [
    64209,
    1,
    ""
  ],
  [
    64210,
    1,
    ""
  ],
  [
    64211,
    1,
    ""
  ],
  [
    64212,
    1,
    ""
  ],
  [
    64213,
    1,
    ""
  ],
  [
    64214,
    1,
    ""
  ],
  [
    64215,
    1,
    ""
  ],
  [
    64216,
    1,
    ""
  ],
  [
    64217,
    1,
    ""
  ],
  [
    [
      64218,
      64255
    ],
    3
  ],
  [
    64256,
    1,
    "ff"
  ],
  [
    64257,
    1,
    "fi"
  ],
  [
    64258,
    1,
    "fl"
  ],
  [
    64259,
    1,
    "ffi"
  ],
  [
    64260,
    1,
    "ffl"
  ],
  [
    [
      64261,
      64262
    ],
    1,
    "st"
  ],
  [
    [
      64263,
      64274
    ],
    3
  ],
  [
    64275,
    1,
    ""
  ],
  [
    64276,
    1,
    ""
  ],
  [
    64277,
    1,
    ""
  ],
  [
    64278,
    1,
    ""
  ],
  [
    64279,
    1,
    ""
  ],
  [
    [
      64280,
      64284
    ],
    3
  ],
  [
    64285,
    1,
    ""
  ],
  [
    64286,
    2
  ],
  [
    64287,
    1,
    ""
  ],
  [
    64288,
    1,
    ""
  ],
  [
    64289,
    1,
    ""
  ],
  [
    64290,
    1,
    ""
  ],
  [
    64291,
    1,
    ""
  ],
  [
    64292,
    1,
    ""
  ],
  [
    64293,
    1,
    ""
  ],
  [
    64294,
    1,
    ""
  ],
  [
    64295,
    1,
    ""
  ],
  [
    64296,
    1,
    ""
  ],
  [
    64297,
    5,
    "+"
  ],
  [
    64298,
    1,
    ""
  ],
  [
    64299,
    1,
    ""
  ],
  [
    64300,
    1,
    ""
  ],
  [
    64301,
    1,
    ""
  ],
  [
    64302,
    1,
    ""
  ],
  [
    64303,
    1,
    ""
  ],
  [
    64304,
    1,
    ""
  ],
  [
    64305,
    1,
    ""
  ],
  [
    64306,
    1,
    ""
  ],
  [
    64307,
    1,
    ""
  ],
  [
    64308,
    1,
    ""
  ],
  [
    64309,
    1,
    ""
  ],
  [
    64310,
    1,
    ""
  ],
  [
    64311,
    3
  ],
  [
    64312,
    1,
    ""
  ],
  [
    64313,
    1,
    ""
  ],
  [
    64314,
    1,
    ""
  ],
  [
    64315,
    1,
    ""
  ],
  [
    64316,
    1,
    ""
  ],
  [
    64317,
    3
  ],
  [
    64318,
    1,
    ""
  ],
  [
    64319,
    3
  ],
  [
    64320,
    1,
    ""
  ],
  [
    64321,
    1,
    ""
  ],
  [
    64322,
    3
  ],
  [
    64323,
    1,
    ""
  ],
  [
    64324,
    1,
    ""
  ],
  [
    64325,
    3
  ],
  [
    64326,
    1,
    ""
  ],
  [
    64327,
    1,
    ""
  ],
  [
    64328,
    1,
    ""
  ],
  [
    64329,
    1,
    ""
  ],
  [
    64330,
    1,
    ""
  ],
  [
    64331,
    1,
    ""
  ],
  [
    64332,
    1,
    ""
  ],
  [
    64333,
    1,
    ""
  ],
  [
    64334,
    1,
    ""
  ],
  [
    64335,
    1,
    ""
  ],
  [
    [
      64336,
      64337
    ],
    1,
    ""
  ],
  [
    [
      64338,
      64341
    ],
    1,
    ""
  ],
  [
    [
      64342,
      64345
    ],
    1,
    ""
  ],
  [
    [
      64346,
      64349
    ],
    1,
    ""
  ],
  [
    [
      64350,
      64353
    ],
    1,
    ""
  ],
  [
    [
      64354,
      64357
    ],
    1,
    ""
  ],
  [
    [
      64358,
      64361
    ],
    1,
    ""
  ],
  [
    [
      64362,
      64365
    ],
    1,
    ""
  ],
  [
    [
      64366,
      64369
    ],
    1,
    ""
  ],
  [
    [
      64370,
      64373
    ],
    1,
    ""
  ],
  [
    [
      64374,
      64377
    ],
    1,
    ""
  ],
  [
    [
      64378,
      64381
    ],
    1,
    ""
  ],
  [
    [
      64382,
      64385
    ],
    1,
    ""
  ],
  [
    [
      64386,
      64387
    ],
    1,
    ""
  ],
  [
    [
      64388,
      64389
    ],
    1,
    ""
  ],
  [
    [
      64390,
      64391
    ],
    1,
    ""
  ],
  [
    [
      64392,
      64393
    ],
    1,
    ""
  ],
  [
    [
      64394,
      64395
    ],
    1,
    ""
  ],
  [
    [
      64396,
      64397
    ],
    1,
    ""
  ],
  [
    [
      64398,
      64401
    ],
    1,
    ""
  ],
  [
    [
      64402,
      64405
    ],
    1,
    ""
  ],
  [
    [
      64406,
      64409
    ],
    1,
    ""
  ],
  [
    [
      64410,
      64413
    ],
    1,
    ""
  ],
  [
    [
      64414,
      64415
    ],
    1,
    ""
  ],
  [
    [
      64416,
      64419
    ],
    1,
    ""
  ],
  [
    [
      64420,
      64421
    ],
    1,
    ""
  ],
  [
    [
      64422,
      64425
    ],
    1,
    ""
  ],
  [
    [
      64426,
      64429
    ],
    1,
    ""
  ],
  [
    [
      64430,
      64431
    ],
    1,
    ""
  ],
  [
    [
      64432,
      64433
    ],
    1,
    ""
  ],
  [
    [
      64434,
      64449
    ],
    2
  ],
  [
    64450,
    2
  ],
  [
    [
      64451,
      64466
    ],
    3
  ],
  [
    [
      64467,
      64470
    ],
    1,
    ""
  ],
  [
    [
      64471,
      64472
    ],
    1,
    ""
  ],
  [
    [
      64473,
      64474
    ],
    1,
    ""
  ],
  [
    [
      64475,
      64476
    ],
    1,
    ""
  ],
  [
    64477,
    1,
    ""
  ],
  [
    [
      64478,
      64479
    ],
    1,
    ""
  ],
  [
    [
      64480,
      64481
    ],
    1,
    ""
  ],
  [
    [
      64482,
      64483
    ],
    1,
    ""
  ],
  [
    [
      64484,
      64487
    ],
    1,
    ""
  ],
  [
    [
      64488,
      64489
    ],
    1,
    ""
  ],
  [
    [
      64490,
      64491
    ],
    1,
    ""
  ],
  [
    [
      64492,
      64493
    ],
    1,
    ""
  ],
  [
    [
      64494,
      64495
    ],
    1,
    ""
  ],
  [
    [
      64496,
      64497
    ],
    1,
    ""
  ],
  [
    [
      64498,
      64499
    ],
    1,
    ""
  ],
  [
    [
      64500,
      64501
    ],
    1,
    ""
  ],
  [
    [
      64502,
      64504
    ],
    1,
    ""
  ],
  [
    [
      64505,
      64507
    ],
    1,
    ""
  ],
  [
    [
      64508,
      64511
    ],
    1,
    ""
  ],
  [
    64512,
    1,
    ""
  ],
  [
    64513,
    1,
    ""
  ],
  [
    64514,
    1,
    ""
  ],
  [
    64515,
    1,
    ""
  ],
  [
    64516,
    1,
    ""
  ],
  [
    64517,
    1,
    ""
  ],
  [
    64518,
    1,
    ""
  ],
  [
    64519,
    1,
    ""
  ],
  [
    64520,
    1,
    ""
  ],
  [
    64521,
    1,
    ""
  ],
  [
    64522,
    1,
    ""
  ],
  [
    64523,
    1,
    ""
  ],
  [
    64524,
    1,
    ""
  ],
  [
    64525,
    1,
    ""
  ],
  [
    64526,
    1,
    ""
  ],
  [
    64527,
    1,
    ""
  ],
  [
    64528,
    1,
    ""
  ],
  [
    64529,
    1,
    ""
  ],
  [
    64530,
    1,
    ""
  ],
  [
    64531,
    1,
    ""
  ],
  [
    64532,
    1,
    ""
  ],
  [
    64533,
    1,
    ""
  ],
  [
    64534,
    1,
    ""
  ],
  [
    64535,
    1,
    ""
  ],
  [
    64536,
    1,
    ""
  ],
  [
    64537,
    1,
    ""
  ],
  [
    64538,
    1,
    ""
  ],
  [
    64539,
    1,
    ""
  ],
  [
    64540,
    1,
    ""
  ],
  [
    64541,
    1,
    ""
  ],
  [
    64542,
    1,
    ""
  ],
  [
    64543,
    1,
    ""
  ],
  [
    64544,
    1,
    ""
  ],
  [
    64545,
    1,
    ""
  ],
  [
    64546,
    1,
    ""
  ],
  [
    64547,
    1,
    ""
  ],
  [
    64548,
    1,
    ""
  ],
  [
    64549,
    1,
    ""
  ],
  [
    64550,
    1,
    ""
  ],
  [
    64551,
    1,
    ""
  ],
  [
    64552,
    1,
    ""
  ],
  [
    64553,
    1,
    ""
  ],
  [
    64554,
    1,
    ""
  ],
  [
    64555,
    1,
    ""
  ],
  [
    64556,
    1,
    ""
  ],
  [
    64557,
    1,
    ""
  ],
  [
    64558,
    1,
    ""
  ],
  [
    64559,
    1,
    ""
  ],
  [
    64560,
    1,
    ""
  ],
  [
    64561,
    1,
    ""
  ],
  [
    64562,
    1,
    ""
  ],
  [
    64563,
    1,
    ""
  ],
  [
    64564,
    1,
    ""
  ],
  [
    64565,
    1,
    ""
  ],
  [
    64566,
    1,
    ""
  ],
  [
    64567,
    1,
    ""
  ],
  [
    64568,
    1,
    ""
  ],
  [
    64569,
    1,
    ""
  ],
  [
    64570,
    1,
    ""
  ],
  [
    64571,
    1,
    ""
  ],
  [
    64572,
    1,
    ""
  ],
  [
    64573,
    1,
    ""
  ],
  [
    64574,
    1,
    ""
  ],
  [
    64575,
    1,
    ""
  ],
  [
    64576,
    1,
    ""
  ],
  [
    64577,
    1,
    ""
  ],
  [
    64578,
    1,
    ""
  ],
  [
    64579,
    1,
    ""
  ],
  [
    64580,
    1,
    ""
  ],
  [
    64581,
    1,
    ""
  ],
  [
    64582,
    1,
    ""
  ],
  [
    64583,
    1,
    ""
  ],
  [
    64584,
    1,
    ""
  ],
  [
    64585,
    1,
    ""
  ],
  [
    64586,
    1,
    ""
  ],
  [
    64587,
    1,
    ""
  ],
  [
    64588,
    1,
    ""
  ],
  [
    64589,
    1,
    ""
  ],
  [
    64590,
    1,
    ""
  ],
  [
    64591,
    1,
    ""
  ],
  [
    64592,
    1,
    ""
  ],
  [
    64593,
    1,
    ""
  ],
  [
    64594,
    1,
    ""
  ],
  [
    64595,
    1,
    ""
  ],
  [
    64596,
    1,
    ""
  ],
  [
    64597,
    1,
    ""
  ],
  [
    64598,
    1,
    ""
  ],
  [
    64599,
    1,
    ""
  ],
  [
    64600,
    1,
    ""
  ],
  [
    64601,
    1,
    ""
  ],
  [
    64602,
    1,
    ""
  ],
  [
    64603,
    1,
    ""
  ],
  [
    64604,
    1,
    ""
  ],
  [
    64605,
    1,
    ""
  ],
  [
    64606,
    5,
    " "
  ],
  [
    64607,
    5,
    " "
  ],
  [
    64608,
    5,
    " "
  ],
  [
    64609,
    5,
    " "
  ],
  [
    64610,
    5,
    " "
  ],
  [
    64611,
    5,
    " "
  ],
  [
    64612,
    1,
    ""
  ],
  [
    64613,
    1,
    ""
  ],
  [
    64614,
    1,
    ""
  ],
  [
    64615,
    1,
    ""
  ],
  [
    64616,
    1,
    ""
  ],
  [
    64617,
    1,
    ""
  ],
  [
    64618,
    1,
    ""
  ],
  [
    64619,
    1,
    ""
  ],
  [
    64620,
    1,
    ""
  ],
  [
    64621,
    1,
    ""
  ],
  [
    64622,
    1,
    ""
  ],
  [
    64623,
    1,
    ""
  ],
  [
    64624,
    1,
    ""
  ],
  [
    64625,
    1,
    ""
  ],
  [
    64626,
    1,
    ""
  ],
  [
    64627,
    1,
    ""
  ],
  [
    64628,
    1,
    ""
  ],
  [
    64629,
    1,
    ""
  ],
  [
    64630,
    1,
    ""
  ],
  [
    64631,
    1,
    ""
  ],
  [
    64632,
    1,
    ""
  ],
  [
    64633,
    1,
    ""
  ],
  [
    64634,
    1,
    ""
  ],
  [
    64635,
    1,
    ""
  ],
  [
    64636,
    1,
    ""
  ],
  [
    64637,
    1,
    ""
  ],
  [
    64638,
    1,
    ""
  ],
  [
    64639,
    1,
    ""
  ],
  [
    64640,
    1,
    ""
  ],
  [
    64641,
    1,
    ""
  ],
  [
    64642,
    1,
    ""
  ],
  [
    64643,
    1,
    ""
  ],
  [
    64644,
    1,
    ""
  ],
  [
    64645,
    1,
    ""
  ],
  [
    64646,
    1,
    ""
  ],
  [
    64647,
    1,
    ""
  ],
  [
    64648,
    1,
    ""
  ],
  [
    64649,
    1,
    ""
  ],
  [
    64650,
    1,
    ""
  ],
  [
    64651,
    1,
    ""
  ],
  [
    64652,
    1,
    ""
  ],
  [
    64653,
    1,
    ""
  ],
  [
    64654,
    1,
    ""
  ],
  [
    64655,
    1,
    ""
  ],
  [
    64656,
    1,
    ""
  ],
  [
    64657,
    1,
    ""
  ],
  [
    64658,
    1,
    ""
  ],
  [
    64659,
    1,
    ""
  ],
  [
    64660,
    1,
    ""
  ],
  [
    64661,
    1,
    ""
  ],
  [
    64662,
    1,
    ""
  ],
  [
    64663,
    1,
    ""
  ],
  [
    64664,
    1,
    ""
  ],
  [
    64665,
    1,
    ""
  ],
  [
    64666,
    1,
    ""
  ],
  [
    64667,
    1,
    ""
  ],
  [
    64668,
    1,
    ""
  ],
  [
    64669,
    1,
    ""
  ],
  [
    64670,
    1,
    ""
  ],
  [
    64671,
    1,
    ""
  ],
  [
    64672,
    1,
    ""
  ],
  [
    64673,
    1,
    ""
  ],
  [
    64674,
    1,
    ""
  ],
  [
    64675,
    1,
    ""
  ],
  [
    64676,
    1,
    ""
  ],
  [
    64677,
    1,
    ""
  ],
  [
    64678,
    1,
    ""
  ],
  [
    64679,
    1,
    ""
  ],
  [
    64680,
    1,
    ""
  ],
  [
    64681,
    1,
    ""
  ],
  [
    64682,
    1,
    ""
  ],
  [
    64683,
    1,
    ""
  ],
  [
    64684,
    1,
    ""
  ],
  [
    64685,
    1,
    ""
  ],
  [
    64686,
    1,
    ""
  ],
  [
    64687,
    1,
    ""
  ],
  [
    64688,
    1,
    ""
  ],
  [
    64689,
    1,
    ""
  ],
  [
    64690,
    1,
    ""
  ],
  [
    64691,
    1,
    ""
  ],
  [
    64692,
    1,
    ""
  ],
  [
    64693,
    1,
    ""
  ],
  [
    64694,
    1,
    ""
  ],
  [
    64695,
    1,
    ""
  ],
  [
    64696,
    1,
    ""
  ],
  [
    64697,
    1,
    ""
  ],
  [
    64698,
    1,
    ""
  ],
  [
    64699,
    1,
    ""
  ],
  [
    64700,
    1,
    ""
  ],
  [
    64701,
    1,
    ""
  ],
  [
    64702,
    1,
    ""
  ],
  [
    64703,
    1,
    ""
  ],
  [
    64704,
    1,
    ""
  ],
  [
    64705,
    1,
    ""
  ],
  [
    64706,
    1,
    ""
  ],
  [
    64707,
    1,
    ""
  ],
  [
    64708,
    1,
    ""
  ],
  [
    64709,
    1,
    ""
  ],
  [
    64710,
    1,
    ""
  ],
  [
    64711,
    1,
    ""
  ],
  [
    64712,
    1,
    ""
  ],
  [
    64713,
    1,
    ""
  ],
  [
    64714,
    1,
    ""
  ],
  [
    64715,
    1,
    ""
  ],
  [
    64716,
    1,
    ""
  ],
  [
    64717,
    1,
    ""
  ],
  [
    64718,
    1,
    ""
  ],
  [
    64719,
    1,
    ""
  ],
  [
    64720,
    1,
    ""
  ],
  [
    64721,
    1,
    ""
  ],
  [
    64722,
    1,
    ""
  ],
  [
    64723,
    1,
    ""
  ],
  [
    64724,
    1,
    ""
  ],
  [
    64725,
    1,
    ""
  ],
  [
    64726,
    1,
    ""
  ],
  [
    64727,
    1,
    ""
  ],
  [
    64728,
    1,
    ""
  ],
  [
    64729,
    1,
    ""
  ],
  [
    64730,
    1,
    ""
  ],
  [
    64731,
    1,
    ""
  ],
  [
    64732,
    1,
    ""
  ],
  [
    64733,
    1,
    ""
  ],
  [
    64734,
    1,
    ""
  ],
  [
    64735,
    1,
    ""
  ],
  [
    64736,
    1,
    ""
  ],
  [
    64737,
    1,
    ""
  ],
  [
    64738,
    1,
    ""
  ],
  [
    64739,
    1,
    ""
  ],
  [
    64740,
    1,
    ""
  ],
  [
    64741,
    1,
    ""
  ],
  [
    64742,
    1,
    ""
  ],
  [
    64743,
    1,
    ""
  ],
  [
    64744,
    1,
    ""
  ],
  [
    64745,
    1,
    ""
  ],
  [
    64746,
    1,
    ""
  ],
  [
    64747,
    1,
    ""
  ],
  [
    64748,
    1,
    ""
  ],
  [
    64749,
    1,
    ""
  ],
  [
    64750,
    1,
    ""
  ],
  [
    64751,
    1,
    ""
  ],
  [
    64752,
    1,
    ""
  ],
  [
    64753,
    1,
    ""
  ],
  [
    64754,
    1,
    ""
  ],
  [
    64755,
    1,
    ""
  ],
  [
    64756,
    1,
    ""
  ],
  [
    64757,
    1,
    ""
  ],
  [
    64758,
    1,
    ""
  ],
  [
    64759,
    1,
    ""
  ],
  [
    64760,
    1,
    ""
  ],
  [
    64761,
    1,
    ""
  ],
  [
    64762,
    1,
    ""
  ],
  [
    64763,
    1,
    ""
  ],
  [
    64764,
    1,
    ""
  ],
  [
    64765,
    1,
    ""
  ],
  [
    64766,
    1,
    ""
  ],
  [
    64767,
    1,
    ""
  ],
  [
    64768,
    1,
    ""
  ],
  [
    64769,
    1,
    ""
  ],
  [
    64770,
    1,
    ""
  ],
  [
    64771,
    1,
    ""
  ],
  [
    64772,
    1,
    ""
  ],
  [
    64773,
    1,
    ""
  ],
  [
    64774,
    1,
    ""
  ],
  [
    64775,
    1,
    ""
  ],
  [
    64776,
    1,
    ""
  ],
  [
    64777,
    1,
    ""
  ],
  [
    64778,
    1,
    ""
  ],
  [
    64779,
    1,
    ""
  ],
  [
    64780,
    1,
    ""
  ],
  [
    64781,
    1,
    ""
  ],
  [
    64782,
    1,
    ""
  ],
  [
    64783,
    1,
    ""
  ],
  [
    64784,
    1,
    ""
  ],
  [
    64785,
    1,
    ""
  ],
  [
    64786,
    1,
    ""
  ],
  [
    64787,
    1,
    ""
  ],
  [
    64788,
    1,
    ""
  ],
  [
    64789,
    1,
    ""
  ],
  [
    64790,
    1,
    ""
  ],
  [
    64791,
    1,
    ""
  ],
  [
    64792,
    1,
    ""
  ],
  [
    64793,
    1,
    ""
  ],
  [
    64794,
    1,
    ""
  ],
  [
    64795,
    1,
    ""
  ],
  [
    64796,
    1,
    ""
  ],
  [
    64797,
    1,
    ""
  ],
  [
    64798,
    1,
    ""
  ],
  [
    64799,
    1,
    ""
  ],
  [
    64800,
    1,
    ""
  ],
  [
    64801,
    1,
    ""
  ],
  [
    64802,
    1,
    ""
  ],
  [
    64803,
    1,
    ""
  ],
  [
    64804,
    1,
    ""
  ],
  [
    64805,
    1,
    ""
  ],
  [
    64806,
    1,
    ""
  ],
  [
    64807,
    1,
    ""
  ],
  [
    64808,
    1,
    ""
  ],
  [
    64809,
    1,
    ""
  ],
  [
    64810,
    1,
    ""
  ],
  [
    64811,
    1,
    ""
  ],
  [
    64812,
    1,
    ""
  ],
  [
    64813,
    1,
    ""
  ],
  [
    64814,
    1,
    ""
  ],
  [
    64815,
    1,
    ""
  ],
  [
    64816,
    1,
    ""
  ],
  [
    64817,
    1,
    ""
  ],
  [
    64818,
    1,
    ""
  ],
  [
    64819,
    1,
    ""
  ],
  [
    64820,
    1,
    ""
  ],
  [
    64821,
    1,
    ""
  ],
  [
    64822,
    1,
    ""
  ],
  [
    64823,
    1,
    ""
  ],
  [
    64824,
    1,
    ""
  ],
  [
    64825,
    1,
    ""
  ],
  [
    64826,
    1,
    ""
  ],
  [
    64827,
    1,
    ""
  ],
  [
    [
      64828,
      64829
    ],
    1,
    ""
  ],
  [
    [
      64830,
      64831
    ],
    2
  ],
  [
    [
      64832,
      64847
    ],
    2
  ],
  [
    64848,
    1,
    ""
  ],
  [
    [
      64849,
      64850
    ],
    1,
    ""
  ],
  [
    64851,
    1,
    ""
  ],
  [
    64852,
    1,
    ""
  ],
  [
    64853,
    1,
    ""
  ],
  [
    64854,
    1,
    ""
  ],
  [
    64855,
    1,
    ""
  ],
  [
    [
      64856,
      64857
    ],
    1,
    ""
  ],
  [
    64858,
    1,
    ""
  ],
  [
    64859,
    1,
    ""
  ],
  [
    64860,
    1,
    ""
  ],
  [
    64861,
    1,
    ""
  ],
  [
    64862,
    1,
    ""
  ],
  [
    [
      64863,
      64864
    ],
    1,
    ""
  ],
  [
    64865,
    1,
    ""
  ],
  [
    [
      64866,
      64867
    ],
    1,
    ""
  ],
  [
    [
      64868,
      64869
    ],
    1,
    ""
  ],
  [
    64870,
    1,
    ""
  ],
  [
    [
      64871,
      64872
    ],
    1,
    ""
  ],
  [
    64873,
    1,
    ""
  ],
  [
    [
      64874,
      64875
    ],
    1,
    ""
  ],
  [
    [
      64876,
      64877
    ],
    1,
    ""
  ],
  [
    64878,
    1,
    ""
  ],
  [
    [
      64879,
      64880
    ],
    1,
    ""
  ],
  [
    [
      64881,
      64882
    ],
    1,
    ""
  ],
  [
    64883,
    1,
    ""
  ],
  [
    64884,
    1,
    ""
  ],
  [
    64885,
    1,
    ""
  ],
  [
    [
      64886,
      64887
    ],
    1,
    ""
  ],
  [
    64888,
    1,
    ""
  ],
  [
    64889,
    1,
    ""
  ],
  [
    64890,
    1,
    ""
  ],
  [
    64891,
    1,
    ""
  ],
  [
    [
      64892,
      64893
    ],
    1,
    ""
  ],
  [
    64894,
    1,
    ""
  ],
  [
    64895,
    1,
    ""
  ],
  [
    64896,
    1,
    ""
  ],
  [
    64897,
    1,
    ""
  ],
  [
    64898,
    1,
    ""
  ],
  [
    [
      64899,
      64900
    ],
    1,
    ""
  ],
  [
    [
      64901,
      64902
    ],
    1,
    ""
  ],
  [
    [
      64903,
      64904
    ],
    1,
    ""
  ],
  [
    64905,
    1,
    ""
  ],
  [
    64906,
    1,
    ""
  ],
  [
    64907,
    1,
    ""
  ],
  [
    64908,
    1,
    ""
  ],
  [
    64909,
    1,
    ""
  ],
  [
    64910,
    1,
    ""
  ],
  [
    64911,
    1,
    ""
  ],
  [
    [
      64912,
      64913
    ],
    3
  ],
  [
    64914,
    1,
    ""
  ],
  [
    64915,
    1,
    ""
  ],
  [
    64916,
    1,
    ""
  ],
  [
    64917,
    1,
    ""
  ],
  [
    64918,
    1,
    ""
  ],
  [
    [
      64919,
      64920
    ],
    1,
    ""
  ],
  [
    64921,
    1,
    ""
  ],
  [
    64922,
    1,
    ""
  ],
  [
    64923,
    1,
    ""
  ],
  [
    [
      64924,
      64925
    ],
    1,
    ""
  ],
  [
    64926,
    1,
    ""
  ],
  [
    64927,
    1,
    ""
  ],
  [
    64928,
    1,
    ""
  ],
  [
    64929,
    1,
    ""
  ],
  [
    64930,
    1,
    ""
  ],
  [
    64931,
    1,
    ""
  ],
  [
    64932,
    1,
    ""
  ],
  [
    64933,
    1,
    ""
  ],
  [
    64934,
    1,
    ""
  ],
  [
    64935,
    1,
    ""
  ],
  [
    64936,
    1,
    ""
  ],
  [
    64937,
    1,
    ""
  ],
  [
    64938,
    1,
    ""
  ],
  [
    64939,
    1,
    ""
  ],
  [
    64940,
    1,
    ""
  ],
  [
    64941,
    1,
    ""
  ],
  [
    64942,
    1,
    ""
  ],
  [
    64943,
    1,
    ""
  ],
  [
    64944,
    1,
    ""
  ],
  [
    64945,
    1,
    ""
  ],
  [
    64946,
    1,
    ""
  ],
  [
    64947,
    1,
    ""
  ],
  [
    64948,
    1,
    ""
  ],
  [
    64949,
    1,
    ""
  ],
  [
    64950,
    1,
    ""
  ],
  [
    64951,
    1,
    ""
  ],
  [
    64952,
    1,
    ""
  ],
  [
    64953,
    1,
    ""
  ],
  [
    64954,
    1,
    ""
  ],
  [
    64955,
    1,
    ""
  ],
  [
    64956,
    1,
    ""
  ],
  [
    64957,
    1,
    ""
  ],
  [
    64958,
    1,
    ""
  ],
  [
    64959,
    1,
    ""
  ],
  [
    64960,
    1,
    ""
  ],
  [
    64961,
    1,
    ""
  ],
  [
    64962,
    1,
    ""
  ],
  [
    64963,
    1,
    ""
  ],
  [
    64964,
    1,
    ""
  ],
  [
    64965,
    1,
    ""
  ],
  [
    64966,
    1,
    ""
  ],
  [
    64967,
    1,
    ""
  ],
  [
    [
      64968,
      64974
    ],
    3
  ],
  [
    64975,
    2
  ],
  [
    [
      64976,
      65007
    ],
    3
  ],
  [
    65008,
    1,
    ""
  ],
  [
    65009,
    1,
    ""
  ],
  [
    65010,
    1,
    ""
  ],
  [
    65011,
    1,
    ""
  ],
  [
    65012,
    1,
    ""
  ],
  [
    65013,
    1,
    ""
  ],
  [
    65014,
    1,
    ""
  ],
  [
    65015,
    1,
    ""
  ],
  [
    65016,
    1,
    ""
  ],
  [
    65017,
    1,
    ""
  ],
  [
    65018,
    5,
    "   "
  ],
  [
    65019,
    5,
    " "
  ],
  [
    65020,
    1,
    ""
  ],
  [
    65021,
    2
  ],
  [
    [
      65022,
      65023
    ],
    2
  ],
  [
    [
      65024,
      65039
    ],
    7
  ],
  [
    65040,
    5,
    ","
  ],
  [
    65041,
    1,
    ""
  ],
  [
    65042,
    3
  ],
  [
    65043,
    5,
    ":"
  ],
  [
    65044,
    5,
    ";"
  ],
  [
    65045,
    5,
    "!"
  ],
  [
    65046,
    5,
    "?"
  ],
  [
    65047,
    1,
    ""
  ],
  [
    65048,
    1,
    ""
  ],
  [
    65049,
    3
  ],
  [
    [
      65050,
      65055
    ],
    3
  ],
  [
    [
      65056,
      65059
    ],
    2
  ],
  [
    [
      65060,
      65062
    ],
    2
  ],
  [
    [
      65063,
      65069
    ],
    2
  ],
  [
    [
      65070,
      65071
    ],
    2
  ],
  [
    65072,
    3
  ],
  [
    65073,
    1,
    ""
  ],
  [
    65074,
    1,
    ""
  ],
  [
    [
      65075,
      65076
    ],
    5,
    "_"
  ],
  [
    65077,
    5,
    "("
  ],
  [
    65078,
    5,
    ")"
  ],
  [
    65079,
    5,
    "{"
  ],
  [
    65080,
    5,
    "}"
  ],
  [
    65081,
    1,
    ""
  ],
  [
    65082,
    1,
    ""
  ],
  [
    65083,
    1,
    ""
  ],
  [
    65084,
    1,
    ""
  ],
  [
    65085,
    1,
    ""
  ],
  [
    65086,
    1,
    ""
  ],
  [
    65087,
    1,
    ""
  ],
  [
    65088,
    1,
    ""
  ],
  [
    65089,
    1,
    ""
  ],
  [
    65090,
    1,
    ""
  ],
  [
    65091,
    1,
    ""
  ],
  [
    65092,
    1,
    ""
  ],
  [
    [
      65093,
      65094
    ],
    2
  ],
  [
    65095,
    5,
    "["
  ],
  [
    65096,
    5,
    "]"
  ],
  [
    [
      65097,
      65100
    ],
    5,
    " "
  ],
  [
    [
      65101,
      65103
    ],
    5,
    "_"
  ],
  [
    65104,
    5,
    ","
  ],
  [
    65105,
    1,
    ""
  ],
  [
    65106,
    3
  ],
  [
    65107,
    3
  ],
  [
    65108,
    5,
    ";"
  ],
  [
    65109,
    5,
    ":"
  ],
  [
    65110,
    5,
    "?"
  ],
  [
    65111,
    5,
    "!"
  ],
  [
    65112,
    1,
    ""
  ],
  [
    65113,
    5,
    "("
  ],
  [
    65114,
    5,
    ")"
  ],
  [
    65115,
    5,
    "{"
  ],
  [
    65116,
    5,
    "}"
  ],
  [
    65117,
    1,
    ""
  ],
  [
    65118,
    1,
    ""
  ],
  [
    65119,
    5,
    "#"
  ],
  [
    65120,
    5,
    "&"
  ],
  [
    65121,
    5,
    "*"
  ],
  [
    65122,
    5,
    "+"
  ],
  [
    65123,
    1,
    "-"
  ],
  [
    65124,
    5,
    "<"
  ],
  [
    65125,
    5,
    ">"
  ],
  [
    65126,
    5,
    "="
  ],
  [
    65127,
    3
  ],
  [
    65128,
    5,
    "\\"
  ],
  [
    65129,
    5,
    "$"
  ],
  [
    65130,
    5,
    "%"
  ],
  [
    65131,
    5,
    "@"
  ],
  [
    [
      65132,
      65135
    ],
    3
  ],
  [
    65136,
    5,
    " "
  ],
  [
    65137,
    1,
    ""
  ],
  [
    65138,
    5,
    " "
  ],
  [
    65139,
    2
  ],
  [
    65140,
    5,
    " "
  ],
  [
    65141,
    3
  ],
  [
    65142,
    5,
    " "
  ],
  [
    65143,
    1,
    ""
  ],
  [
    65144,
    5,
    " "
  ],
  [
    65145,
    1,
    ""
  ],
  [
    65146,
    5,
    " "
  ],
  [
    65147,
    1,
    ""
  ],
  [
    65148,
    5,
    " "
  ],
  [
    65149,
    1,
    ""
  ],
  [
    65150,
    5,
    " "
  ],
  [
    65151,
    1,
    ""
  ],
  [
    65152,
    1,
    ""
  ],
  [
    [
      65153,
      65154
    ],
    1,
    ""
  ],
  [
    [
      65155,
      65156
    ],
    1,
    ""
  ],
  [
    [
      65157,
      65158
    ],
    1,
    ""
  ],
  [
    [
      65159,
      65160
    ],
    1,
    ""
  ],
  [
    [
      65161,
      65164
    ],
    1,
    ""
  ],
  [
    [
      65165,
      65166
    ],
    1,
    ""
  ],
  [
    [
      65167,
      65170
    ],
    1,
    ""
  ],
  [
    [
      65171,
      65172
    ],
    1,
    ""
  ],
  [
    [
      65173,
      65176
    ],
    1,
    ""
  ],
  [
    [
      65177,
      65180
    ],
    1,
    ""
  ],
  [
    [
      65181,
      65184
    ],
    1,
    ""
  ],
  [
    [
      65185,
      65188
    ],
    1,
    ""
  ],
  [
    [
      65189,
      65192
    ],
    1,
    ""
  ],
  [
    [
      65193,
      65194
    ],
    1,
    ""
  ],
  [
    [
      65195,
      65196
    ],
    1,
    ""
  ],
  [
    [
      65197,
      65198
    ],
    1,
    ""
  ],
  [
    [
      65199,
      65200
    ],
    1,
    ""
  ],
  [
    [
      65201,
      65204
    ],
    1,
    ""
  ],
  [
    [
      65205,
      65208
    ],
    1,
    ""
  ],
  [
    [
      65209,
      65212
    ],
    1,
    ""
  ],
  [
    [
      65213,
      65216
    ],
    1,
    ""
  ],
  [
    [
      65217,
      65220
    ],
    1,
    ""
  ],
  [
    [
      65221,
      65224
    ],
    1,
    ""
  ],
  [
    [
      65225,
      65228
    ],
    1,
    ""
  ],
  [
    [
      65229,
      65232
    ],
    1,
    ""
  ],
  [
    [
      65233,
      65236
    ],
    1,
    ""
  ],
  [
    [
      65237,
      65240
    ],
    1,
    ""
  ],
  [
    [
      65241,
      65244
    ],
    1,
    ""
  ],
  [
    [
      65245,
      65248
    ],
    1,
    ""
  ],
  [
    [
      65249,
      65252
    ],
    1,
    ""
  ],
  [
    [
      65253,
      65256
    ],
    1,
    ""
  ],
  [
    [
      65257,
      65260
    ],
    1,
    ""
  ],
  [
    [
      65261,
      65262
    ],
    1,
    ""
  ],
  [
    [
      65263,
      65264
    ],
    1,
    ""
  ],
  [
    [
      65265,
      65268
    ],
    1,
    ""
  ],
  [
    [
      65269,
      65270
    ],
    1,
    ""
  ],
  [
    [
      65271,
      65272
    ],
    1,
    ""
  ],
  [
    [
      65273,
      65274
    ],
    1,
    ""
  ],
  [
    [
      65275,
      65276
    ],
    1,
    ""
  ],
  [
    [
      65277,
      65278
    ],
    3
  ],
  [
    65279,
    7
  ],
  [
    65280,
    3
  ],
  [
    65281,
    5,
    "!"
  ],
  [
    65282,
    5,
    '"'
  ],
  [
    65283,
    5,
    "#"
  ],
  [
    65284,
    5,
    "$"
  ],
  [
    65285,
    5,
    "%"
  ],
  [
    65286,
    5,
    "&"
  ],
  [
    65287,
    5,
    "'"
  ],
  [
    65288,
    5,
    "("
  ],
  [
    65289,
    5,
    ")"
  ],
  [
    65290,
    5,
    "*"
  ],
  [
    65291,
    5,
    "+"
  ],
  [
    65292,
    5,
    ","
  ],
  [
    65293,
    1,
    "-"
  ],
  [
    65294,
    1,
    "."
  ],
  [
    65295,
    5,
    "/"
  ],
  [
    65296,
    1,
    "0"
  ],
  [
    65297,
    1,
    "1"
  ],
  [
    65298,
    1,
    "2"
  ],
  [
    65299,
    1,
    "3"
  ],
  [
    65300,
    1,
    "4"
  ],
  [
    65301,
    1,
    "5"
  ],
  [
    65302,
    1,
    "6"
  ],
  [
    65303,
    1,
    "7"
  ],
  [
    65304,
    1,
    "8"
  ],
  [
    65305,
    1,
    "9"
  ],
  [
    65306,
    5,
    ":"
  ],
  [
    65307,
    5,
    ";"
  ],
  [
    65308,
    5,
    "<"
  ],
  [
    65309,
    5,
    "="
  ],
  [
    65310,
    5,
    ">"
  ],
  [
    65311,
    5,
    "?"
  ],
  [
    65312,
    5,
    "@"
  ],
  [
    65313,
    1,
    "a"
  ],
  [
    65314,
    1,
    "b"
  ],
  [
    65315,
    1,
    "c"
  ],
  [
    65316,
    1,
    "d"
  ],
  [
    65317,
    1,
    "e"
  ],
  [
    65318,
    1,
    "f"
  ],
  [
    65319,
    1,
    "g"
  ],
  [
    65320,
    1,
    "h"
  ],
  [
    65321,
    1,
    "i"
  ],
  [
    65322,
    1,
    "j"
  ],
  [
    65323,
    1,
    "k"
  ],
  [
    65324,
    1,
    "l"
  ],
  [
    65325,
    1,
    "m"
  ],
  [
    65326,
    1,
    "n"
  ],
  [
    65327,
    1,
    "o"
  ],
  [
    65328,
    1,
    "p"
  ],
  [
    65329,
    1,
    "q"
  ],
  [
    65330,
    1,
    "r"
  ],
  [
    65331,
    1,
    "s"
  ],
  [
    65332,
    1,
    "t"
  ],
  [
    65333,
    1,
    "u"
  ],
  [
    65334,
    1,
    "v"
  ],
  [
    65335,
    1,
    "w"
  ],
  [
    65336,
    1,
    "x"
  ],
  [
    65337,
    1,
    "y"
  ],
  [
    65338,
    1,
    "z"
  ],
  [
    65339,
    5,
    "["
  ],
  [
    65340,
    5,
    "\\"
  ],
  [
    65341,
    5,
    "]"
  ],
  [
    65342,
    5,
    "^"
  ],
  [
    65343,
    5,
    "_"
  ],
  [
    65344,
    5,
    "`"
  ],
  [
    65345,
    1,
    "a"
  ],
  [
    65346,
    1,
    "b"
  ],
  [
    65347,
    1,
    "c"
  ],
  [
    65348,
    1,
    "d"
  ],
  [
    65349,
    1,
    "e"
  ],
  [
    65350,
    1,
    "f"
  ],
  [
    65351,
    1,
    "g"
  ],
  [
    65352,
    1,
    "h"
  ],
  [
    65353,
    1,
    "i"
  ],
  [
    65354,
    1,
    "j"
  ],
  [
    65355,
    1,
    "k"
  ],
  [
    65356,
    1,
    "l"
  ],
  [
    65357,
    1,
    "m"
  ],
  [
    65358,
    1,
    "n"
  ],
  [
    65359,
    1,
    "o"
  ],
  [
    65360,
    1,
    "p"
  ],
  [
    65361,
    1,
    "q"
  ],
  [
    65362,
    1,
    "r"
  ],
  [
    65363,
    1,
    "s"
  ],
  [
    65364,
    1,
    "t"
  ],
  [
    65365,
    1,
    "u"
  ],
  [
    65366,
    1,
    "v"
  ],
  [
    65367,
    1,
    "w"
  ],
  [
    65368,
    1,
    "x"
  ],
  [
    65369,
    1,
    "y"
  ],
  [
    65370,
    1,
    "z"
  ],
  [
    65371,
    5,
    "{"
  ],
  [
    65372,
    5,
    "|"
  ],
  [
    65373,
    5,
    "}"
  ],
  [
    65374,
    5,
    "~"
  ],
  [
    65375,
    1,
    ""
  ],
  [
    65376,
    1,
    ""
  ],
  [
    65377,
    1,
    "."
  ],
  [
    65378,
    1,
    ""
  ],
  [
    65379,
    1,
    ""
  ],
  [
    65380,
    1,
    ""
  ],
  [
    65381,
    1,
    ""
  ],
  [
    65382,
    1,
    ""
  ],
  [
    65383,
    1,
    ""
  ],
  [
    65384,
    1,
    ""
  ],
  [
    65385,
    1,
    ""
  ],
  [
    65386,
    1,
    ""
  ],
  [
    65387,
    1,
    ""
  ],
  [
    65388,
    1,
    ""
  ],
  [
    65389,
    1,
    ""
  ],
  [
    65390,
    1,
    ""
  ],
  [
    65391,
    1,
    ""
  ],
  [
    65392,
    1,
    ""
  ],
  [
    65393,
    1,
    ""
  ],
  [
    65394,
    1,
    ""
  ],
  [
    65395,
    1,
    ""
  ],
  [
    65396,
    1,
    ""
  ],
  [
    65397,
    1,
    ""
  ],
  [
    65398,
    1,
    ""
  ],
  [
    65399,
    1,
    ""
  ],
  [
    65400,
    1,
    ""
  ],
  [
    65401,
    1,
    ""
  ],
  [
    65402,
    1,
    ""
  ],
  [
    65403,
    1,
    ""
  ],
  [
    65404,
    1,
    ""
  ],
  [
    65405,
    1,
    ""
  ],
  [
    65406,
    1,
    ""
  ],
  [
    65407,
    1,
    ""
  ],
  [
    65408,
    1,
    ""
  ],
  [
    65409,
    1,
    ""
  ],
  [
    65410,
    1,
    ""
  ],
  [
    65411,
    1,
    ""
  ],
  [
    65412,
    1,
    ""
  ],
  [
    65413,
    1,
    ""
  ],
  [
    65414,
    1,
    ""
  ],
  [
    65415,
    1,
    ""
  ],
  [
    65416,
    1,
    ""
  ],
  [
    65417,
    1,
    ""
  ],
  [
    65418,
    1,
    ""
  ],
  [
    65419,
    1,
    ""
  ],
  [
    65420,
    1,
    ""
  ],
  [
    65421,
    1,
    ""
  ],
  [
    65422,
    1,
    ""
  ],
  [
    65423,
    1,
    ""
  ],
  [
    65424,
    1,
    ""
  ],
  [
    65425,
    1,
    ""
  ],
  [
    65426,
    1,
    ""
  ],
  [
    65427,
    1,
    ""
  ],
  [
    65428,
    1,
    ""
  ],
  [
    65429,
    1,
    ""
  ],
  [
    65430,
    1,
    ""
  ],
  [
    65431,
    1,
    ""
  ],
  [
    65432,
    1,
    ""
  ],
  [
    65433,
    1,
    ""
  ],
  [
    65434,
    1,
    ""
  ],
  [
    65435,
    1,
    ""
  ],
  [
    65436,
    1,
    ""
  ],
  [
    65437,
    1,
    ""
  ],
  [
    65438,
    1,
    ""
  ],
  [
    65439,
    1,
    ""
  ],
  [
    65440,
    3
  ],
  [
    65441,
    1,
    ""
  ],
  [
    65442,
    1,
    ""
  ],
  [
    65443,
    1,
    ""
  ],
  [
    65444,
    1,
    ""
  ],
  [
    65445,
    1,
    ""
  ],
  [
    65446,
    1,
    ""
  ],
  [
    65447,
    1,
    ""
  ],
  [
    65448,
    1,
    ""
  ],
  [
    65449,
    1,
    ""
  ],
  [
    65450,
    1,
    ""
  ],
  [
    65451,
    1,
    ""
  ],
  [
    65452,
    1,
    ""
  ],
  [
    65453,
    1,
    ""
  ],
  [
    65454,
    1,
    ""
  ],
  [
    65455,
    1,
    ""
  ],
  [
    65456,
    1,
    ""
  ],
  [
    65457,
    1,
    ""
  ],
  [
    65458,
    1,
    ""
  ],
  [
    65459,
    1,
    ""
  ],
  [
    65460,
    1,
    ""
  ],
  [
    65461,
    1,
    ""
  ],
  [
    65462,
    1,
    ""
  ],
  [
    65463,
    1,
    ""
  ],
  [
    65464,
    1,
    ""
  ],
  [
    65465,
    1,
    ""
  ],
  [
    65466,
    1,
    ""
  ],
  [
    65467,
    1,
    ""
  ],
  [
    65468,
    1,
    ""
  ],
  [
    65469,
    1,
    ""
  ],
  [
    65470,
    1,
    ""
  ],
  [
    [
      65471,
      65473
    ],
    3
  ],
  [
    65474,
    1,
    ""
  ],
  [
    65475,
    1,
    ""
  ],
  [
    65476,
    1,
    ""
  ],
  [
    65477,
    1,
    ""
  ],
  [
    65478,
    1,
    ""
  ],
  [
    65479,
    1,
    ""
  ],
  [
    [
      65480,
      65481
    ],
    3
  ],
  [
    65482,
    1,
    ""
  ],
  [
    65483,
    1,
    ""
  ],
  [
    65484,
    1,
    ""
  ],
  [
    65485,
    1,
    ""
  ],
  [
    65486,
    1,
    ""
  ],
  [
    65487,
    1,
    ""
  ],
  [
    [
      65488,
      65489
    ],
    3
  ],
  [
    65490,
    1,
    ""
  ],
  [
    65491,
    1,
    ""
  ],
  [
    65492,
    1,
    ""
  ],
  [
    65493,
    1,
    ""
  ],
  [
    65494,
    1,
    ""
  ],
  [
    65495,
    1,
    ""
  ],
  [
    [
      65496,
      65497
    ],
    3
  ],
  [
    65498,
    1,
    ""
  ],
  [
    65499,
    1,
    ""
  ],
  [
    65500,
    1,
    ""
  ],
  [
    [
      65501,
      65503
    ],
    3
  ],
  [
    65504,
    1,
    ""
  ],
  [
    65505,
    1,
    ""
  ],
  [
    65506,
    1,
    ""
  ],
  [
    65507,
    5,
    " "
  ],
  [
    65508,
    1,
    ""
  ],
  [
    65509,
    1,
    ""
  ],
  [
    65510,
    1,
    ""
  ],
  [
    65511,
    3
  ],
  [
    65512,
    1,
    ""
  ],
  [
    65513,
    1,
    ""
  ],
  [
    65514,
    1,
    ""
  ],
  [
    65515,
    1,
    ""
  ],
  [
    65516,
    1,
    ""
  ],
  [
    65517,
    1,
    ""
  ],
  [
    65518,
    1,
    ""
  ],
  [
    [
      65519,
      65528
    ],
    3
  ],
  [
    [
      65529,
      65531
    ],
    3
  ],
  [
    65532,
    3
  ],
  [
    65533,
    3
  ],
  [
    [
      65534,
      65535
    ],
    3
  ],
  [
    [
      65536,
      65547
    ],
    2
  ],
  [
    65548,
    3
  ],
  [
    [
      65549,
      65574
    ],
    2
  ],
  [
    65575,
    3
  ],
  [
    [
      65576,
      65594
    ],
    2
  ],
  [
    65595,
    3
  ],
  [
    [
      65596,
      65597
    ],
    2
  ],
  [
    65598,
    3
  ],
  [
    [
      65599,
      65613
    ],
    2
  ],
  [
    [
      65614,
      65615
    ],
    3
  ],
  [
    [
      65616,
      65629
    ],
    2
  ],
  [
    [
      65630,
      65663
    ],
    3
  ],
  [
    [
      65664,
      65786
    ],
    2
  ],
  [
    [
      65787,
      65791
    ],
    3
  ],
  [
    [
      65792,
      65794
    ],
    2
  ],
  [
    [
      65795,
      65798
    ],
    3
  ],
  [
    [
      65799,
      65843
    ],
    2
  ],
  [
    [
      65844,
      65846
    ],
    3
  ],
  [
    [
      65847,
      65855
    ],
    2
  ],
  [
    [
      65856,
      65930
    ],
    2
  ],
  [
    [
      65931,
      65932
    ],
    2
  ],
  [
    [
      65933,
      65934
    ],
    2
  ],
  [
    65935,
    3
  ],
  [
    [
      65936,
      65947
    ],
    2
  ],
  [
    65948,
    2
  ],
  [
    [
      65949,
      65951
    ],
    3
  ],
  [
    65952,
    2
  ],
  [
    [
      65953,
      65999
    ],
    3
  ],
  [
    [
      66e3,
      66044
    ],
    2
  ],
  [
    66045,
    2
  ],
  [
    [
      66046,
      66175
    ],
    3
  ],
  [
    [
      66176,
      66204
    ],
    2
  ],
  [
    [
      66205,
      66207
    ],
    3
  ],
  [
    [
      66208,
      66256
    ],
    2
  ],
  [
    [
      66257,
      66271
    ],
    3
  ],
  [
    66272,
    2
  ],
  [
    [
      66273,
      66299
    ],
    2
  ],
  [
    [
      66300,
      66303
    ],
    3
  ],
  [
    [
      66304,
      66334
    ],
    2
  ],
  [
    66335,
    2
  ],
  [
    [
      66336,
      66339
    ],
    2
  ],
  [
    [
      66340,
      66348
    ],
    3
  ],
  [
    [
      66349,
      66351
    ],
    2
  ],
  [
    [
      66352,
      66368
    ],
    2
  ],
  [
    66369,
    2
  ],
  [
    [
      66370,
      66377
    ],
    2
  ],
  [
    66378,
    2
  ],
  [
    [
      66379,
      66383
    ],
    3
  ],
  [
    [
      66384,
      66426
    ],
    2
  ],
  [
    [
      66427,
      66431
    ],
    3
  ],
  [
    [
      66432,
      66461
    ],
    2
  ],
  [
    66462,
    3
  ],
  [
    66463,
    2
  ],
  [
    [
      66464,
      66499
    ],
    2
  ],
  [
    [
      66500,
      66503
    ],
    3
  ],
  [
    [
      66504,
      66511
    ],
    2
  ],
  [
    [
      66512,
      66517
    ],
    2
  ],
  [
    [
      66518,
      66559
    ],
    3
  ],
  [
    66560,
    1,
    ""
  ],
  [
    66561,
    1,
    ""
  ],
  [
    66562,
    1,
    ""
  ],
  [
    66563,
    1,
    ""
  ],
  [
    66564,
    1,
    ""
  ],
  [
    66565,
    1,
    ""
  ],
  [
    66566,
    1,
    ""
  ],
  [
    66567,
    1,
    ""
  ],
  [
    66568,
    1,
    ""
  ],
  [
    66569,
    1,
    ""
  ],
  [
    66570,
    1,
    ""
  ],
  [
    66571,
    1,
    ""
  ],
  [
    66572,
    1,
    ""
  ],
  [
    66573,
    1,
    ""
  ],
  [
    66574,
    1,
    ""
  ],
  [
    66575,
    1,
    ""
  ],
  [
    66576,
    1,
    ""
  ],
  [
    66577,
    1,
    ""
  ],
  [
    66578,
    1,
    ""
  ],
  [
    66579,
    1,
    ""
  ],
  [
    66580,
    1,
    ""
  ],
  [
    66581,
    1,
    ""
  ],
  [
    66582,
    1,
    ""
  ],
  [
    66583,
    1,
    ""
  ],
  [
    66584,
    1,
    ""
  ],
  [
    66585,
    1,
    ""
  ],
  [
    66586,
    1,
    ""
  ],
  [
    66587,
    1,
    ""
  ],
  [
    66588,
    1,
    ""
  ],
  [
    66589,
    1,
    ""
  ],
  [
    66590,
    1,
    ""
  ],
  [
    66591,
    1,
    ""
  ],
  [
    66592,
    1,
    ""
  ],
  [
    66593,
    1,
    ""
  ],
  [
    66594,
    1,
    ""
  ],
  [
    66595,
    1,
    ""
  ],
  [
    66596,
    1,
    ""
  ],
  [
    66597,
    1,
    ""
  ],
  [
    66598,
    1,
    ""
  ],
  [
    66599,
    1,
    ""
  ],
  [
    [
      66600,
      66637
    ],
    2
  ],
  [
    [
      66638,
      66717
    ],
    2
  ],
  [
    [
      66718,
      66719
    ],
    3
  ],
  [
    [
      66720,
      66729
    ],
    2
  ],
  [
    [
      66730,
      66735
    ],
    3
  ],
  [
    66736,
    1,
    ""
  ],
  [
    66737,
    1,
    ""
  ],
  [
    66738,
    1,
    ""
  ],
  [
    66739,
    1,
    ""
  ],
  [
    66740,
    1,
    ""
  ],
  [
    66741,
    1,
    ""
  ],
  [
    66742,
    1,
    ""
  ],
  [
    66743,
    1,
    ""
  ],
  [
    66744,
    1,
    ""
  ],
  [
    66745,
    1,
    ""
  ],
  [
    66746,
    1,
    ""
  ],
  [
    66747,
    1,
    ""
  ],
  [
    66748,
    1,
    ""
  ],
  [
    66749,
    1,
    ""
  ],
  [
    66750,
    1,
    ""
  ],
  [
    66751,
    1,
    ""
  ],
  [
    66752,
    1,
    ""
  ],
  [
    66753,
    1,
    ""
  ],
  [
    66754,
    1,
    ""
  ],
  [
    66755,
    1,
    ""
  ],
  [
    66756,
    1,
    ""
  ],
  [
    66757,
    1,
    ""
  ],
  [
    66758,
    1,
    ""
  ],
  [
    66759,
    1,
    ""
  ],
  [
    66760,
    1,
    ""
  ],
  [
    66761,
    1,
    ""
  ],
  [
    66762,
    1,
    ""
  ],
  [
    66763,
    1,
    ""
  ],
  [
    66764,
    1,
    ""
  ],
  [
    66765,
    1,
    ""
  ],
  [
    66766,
    1,
    ""
  ],
  [
    66767,
    1,
    ""
  ],
  [
    66768,
    1,
    ""
  ],
  [
    66769,
    1,
    ""
  ],
  [
    66770,
    1,
    ""
  ],
  [
    66771,
    1,
    ""
  ],
  [
    [
      66772,
      66775
    ],
    3
  ],
  [
    [
      66776,
      66811
    ],
    2
  ],
  [
    [
      66812,
      66815
    ],
    3
  ],
  [
    [
      66816,
      66855
    ],
    2
  ],
  [
    [
      66856,
      66863
    ],
    3
  ],
  [
    [
      66864,
      66915
    ],
    2
  ],
  [
    [
      66916,
      66926
    ],
    3
  ],
  [
    66927,
    2
  ],
  [
    66928,
    1,
    ""
  ],
  [
    66929,
    1,
    ""
  ],
  [
    66930,
    1,
    ""
  ],
  [
    66931,
    1,
    ""
  ],
  [
    66932,
    1,
    ""
  ],
  [
    66933,
    1,
    ""
  ],
  [
    66934,
    1,
    ""
  ],
  [
    66935,
    1,
    ""
  ],
  [
    66936,
    1,
    ""
  ],
  [
    66937,
    1,
    ""
  ],
  [
    66938,
    1,
    ""
  ],
  [
    66939,
    3
  ],
  [
    66940,
    1,
    ""
  ],
  [
    66941,
    1,
    ""
  ],
  [
    66942,
    1,
    ""
  ],
  [
    66943,
    1,
    ""
  ],
  [
    66944,
    1,
    ""
  ],
  [
    66945,
    1,
    ""
  ],
  [
    66946,
    1,
    ""
  ],
  [
    66947,
    1,
    ""
  ],
  [
    66948,
    1,
    ""
  ],
  [
    66949,
    1,
    ""
  ],
  [
    66950,
    1,
    ""
  ],
  [
    66951,
    1,
    ""
  ],
  [
    66952,
    1,
    ""
  ],
  [
    66953,
    1,
    ""
  ],
  [
    66954,
    1,
    ""
  ],
  [
    66955,
    3
  ],
  [
    66956,
    1,
    ""
  ],
  [
    66957,
    1,
    ""
  ],
  [
    66958,
    1,
    ""
  ],
  [
    66959,
    1,
    ""
  ],
  [
    66960,
    1,
    ""
  ],
  [
    66961,
    1,
    ""
  ],
  [
    66962,
    1,
    ""
  ],
  [
    66963,
    3
  ],
  [
    66964,
    1,
    ""
  ],
  [
    66965,
    1,
    ""
  ],
  [
    66966,
    3
  ],
  [
    [
      66967,
      66977
    ],
    2
  ],
  [
    66978,
    3
  ],
  [
    [
      66979,
      66993
    ],
    2
  ],
  [
    66994,
    3
  ],
  [
    [
      66995,
      67001
    ],
    2
  ],
  [
    67002,
    3
  ],
  [
    [
      67003,
      67004
    ],
    2
  ],
  [
    [
      67005,
      67071
    ],
    3
  ],
  [
    [
      67072,
      67382
    ],
    2
  ],
  [
    [
      67383,
      67391
    ],
    3
  ],
  [
    [
      67392,
      67413
    ],
    2
  ],
  [
    [
      67414,
      67423
    ],
    3
  ],
  [
    [
      67424,
      67431
    ],
    2
  ],
  [
    [
      67432,
      67455
    ],
    3
  ],
  [
    67456,
    2
  ],
  [
    67457,
    1,
    ""
  ],
  [
    67458,
    1,
    ""
  ],
  [
    67459,
    1,
    ""
  ],
  [
    67460,
    1,
    ""
  ],
  [
    67461,
    1,
    ""
  ],
  [
    67462,
    3
  ],
  [
    67463,
    1,
    ""
  ],
  [
    67464,
    1,
    ""
  ],
  [
    67465,
    1,
    ""
  ],
  [
    67466,
    1,
    ""
  ],
  [
    67467,
    1,
    ""
  ],
  [
    67468,
    1,
    ""
  ],
  [
    67469,
    1,
    ""
  ],
  [
    67470,
    1,
    ""
  ],
  [
    67471,
    1,
    ""
  ],
  [
    67472,
    1,
    ""
  ],
  [
    67473,
    1,
    ""
  ],
  [
    67474,
    1,
    ""
  ],
  [
    67475,
    1,
    ""
  ],
  [
    67476,
    1,
    ""
  ],
  [
    67477,
    1,
    ""
  ],
  [
    67478,
    1,
    ""
  ],
  [
    67479,
    1,
    ""
  ],
  [
    67480,
    1,
    ""
  ],
  [
    67481,
    1,
    ""
  ],
  [
    67482,
    1,
    ""
  ],
  [
    67483,
    1,
    ""
  ],
  [
    67484,
    1,
    ""
  ],
  [
    67485,
    1,
    ""
  ],
  [
    67486,
    1,
    ""
  ],
  [
    67487,
    1,
    ""
  ],
  [
    67488,
    1,
    ""
  ],
  [
    67489,
    1,
    ""
  ],
  [
    67490,
    1,
    ""
  ],
  [
    67491,
    1,
    ""
  ],
  [
    67492,
    1,
    ""
  ],
  [
    67493,
    1,
    "q"
  ],
  [
    67494,
    1,
    ""
  ],
  [
    67495,
    1,
    ""
  ],
  [
    67496,
    1,
    ""
  ],
  [
    67497,
    1,
    ""
  ],
  [
    67498,
    1,
    ""
  ],
  [
    67499,
    1,
    ""
  ],
  [
    67500,
    1,
    ""
  ],
  [
    67501,
    1,
    ""
  ],
  [
    67502,
    1,
    ""
  ],
  [
    67503,
    1,
    ""
  ],
  [
    67504,
    1,
    ""
  ],
  [
    67505,
    3
  ],
  [
    67506,
    1,
    ""
  ],
  [
    67507,
    1,
    ""
  ],
  [
    67508,
    1,
    ""
  ],
  [
    67509,
    1,
    ""
  ],
  [
    67510,
    1,
    ""
  ],
  [
    67511,
    1,
    ""
  ],
  [
    67512,
    1,
    ""
  ],
  [
    67513,
    1,
    ""
  ],
  [
    67514,
    1,
    ""
  ],
  [
    [
      67515,
      67583
    ],
    3
  ],
  [
    [
      67584,
      67589
    ],
    2
  ],
  [
    [
      67590,
      67591
    ],
    3
  ],
  [
    67592,
    2
  ],
  [
    67593,
    3
  ],
  [
    [
      67594,
      67637
    ],
    2
  ],
  [
    67638,
    3
  ],
  [
    [
      67639,
      67640
    ],
    2
  ],
  [
    [
      67641,
      67643
    ],
    3
  ],
  [
    67644,
    2
  ],
  [
    [
      67645,
      67646
    ],
    3
  ],
  [
    67647,
    2
  ],
  [
    [
      67648,
      67669
    ],
    2
  ],
  [
    67670,
    3
  ],
  [
    [
      67671,
      67679
    ],
    2
  ],
  [
    [
      67680,
      67702
    ],
    2
  ],
  [
    [
      67703,
      67711
    ],
    2
  ],
  [
    [
      67712,
      67742
    ],
    2
  ],
  [
    [
      67743,
      67750
    ],
    3
  ],
  [
    [
      67751,
      67759
    ],
    2
  ],
  [
    [
      67760,
      67807
    ],
    3
  ],
  [
    [
      67808,
      67826
    ],
    2
  ],
  [
    67827,
    3
  ],
  [
    [
      67828,
      67829
    ],
    2
  ],
  [
    [
      67830,
      67834
    ],
    3
  ],
  [
    [
      67835,
      67839
    ],
    2
  ],
  [
    [
      67840,
      67861
    ],
    2
  ],
  [
    [
      67862,
      67865
    ],
    2
  ],
  [
    [
      67866,
      67867
    ],
    2
  ],
  [
    [
      67868,
      67870
    ],
    3
  ],
  [
    67871,
    2
  ],
  [
    [
      67872,
      67897
    ],
    2
  ],
  [
    [
      67898,
      67902
    ],
    3
  ],
  [
    67903,
    2
  ],
  [
    [
      67904,
      67967
    ],
    3
  ],
  [
    [
      67968,
      68023
    ],
    2
  ],
  [
    [
      68024,
      68027
    ],
    3
  ],
  [
    [
      68028,
      68029
    ],
    2
  ],
  [
    [
      68030,
      68031
    ],
    2
  ],
  [
    [
      68032,
      68047
    ],
    2
  ],
  [
    [
      68048,
      68049
    ],
    3
  ],
  [
    [
      68050,
      68095
    ],
    2
  ],
  [
    [
      68096,
      68099
    ],
    2
  ],
  [
    68100,
    3
  ],
  [
    [
      68101,
      68102
    ],
    2
  ],
  [
    [
      68103,
      68107
    ],
    3
  ],
  [
    [
      68108,
      68115
    ],
    2
  ],
  [
    68116,
    3
  ],
  [
    [
      68117,
      68119
    ],
    2
  ],
  [
    68120,
    3
  ],
  [
    [
      68121,
      68147
    ],
    2
  ],
  [
    [
      68148,
      68149
    ],
    2
  ],
  [
    [
      68150,
      68151
    ],
    3
  ],
  [
    [
      68152,
      68154
    ],
    2
  ],
  [
    [
      68155,
      68158
    ],
    3
  ],
  [
    68159,
    2
  ],
  [
    [
      68160,
      68167
    ],
    2
  ],
  [
    68168,
    2
  ],
  [
    [
      68169,
      68175
    ],
    3
  ],
  [
    [
      68176,
      68184
    ],
    2
  ],
  [
    [
      68185,
      68191
    ],
    3
  ],
  [
    [
      68192,
      68220
    ],
    2
  ],
  [
    [
      68221,
      68223
    ],
    2
  ],
  [
    [
      68224,
      68252
    ],
    2
  ],
  [
    [
      68253,
      68255
    ],
    2
  ],
  [
    [
      68256,
      68287
    ],
    3
  ],
  [
    [
      68288,
      68295
    ],
    2
  ],
  [
    68296,
    2
  ],
  [
    [
      68297,
      68326
    ],
    2
  ],
  [
    [
      68327,
      68330
    ],
    3
  ],
  [
    [
      68331,
      68342
    ],
    2
  ],
  [
    [
      68343,
      68351
    ],
    3
  ],
  [
    [
      68352,
      68405
    ],
    2
  ],
  [
    [
      68406,
      68408
    ],
    3
  ],
  [
    [
      68409,
      68415
    ],
    2
  ],
  [
    [
      68416,
      68437
    ],
    2
  ],
  [
    [
      68438,
      68439
    ],
    3
  ],
  [
    [
      68440,
      68447
    ],
    2
  ],
  [
    [
      68448,
      68466
    ],
    2
  ],
  [
    [
      68467,
      68471
    ],
    3
  ],
  [
    [
      68472,
      68479
    ],
    2
  ],
  [
    [
      68480,
      68497
    ],
    2
  ],
  [
    [
      68498,
      68504
    ],
    3
  ],
  [
    [
      68505,
      68508
    ],
    2
  ],
  [
    [
      68509,
      68520
    ],
    3
  ],
  [
    [
      68521,
      68527
    ],
    2
  ],
  [
    [
      68528,
      68607
    ],
    3
  ],
  [
    [
      68608,
      68680
    ],
    2
  ],
  [
    [
      68681,
      68735
    ],
    3
  ],
  [
    68736,
    1,
    ""
  ],
  [
    68737,
    1,
    ""
  ],
  [
    68738,
    1,
    ""
  ],
  [
    68739,
    1,
    ""
  ],
  [
    68740,
    1,
    ""
  ],
  [
    68741,
    1,
    ""
  ],
  [
    68742,
    1,
    ""
  ],
  [
    68743,
    1,
    ""
  ],
  [
    68744,
    1,
    ""
  ],
  [
    68745,
    1,
    ""
  ],
  [
    68746,
    1,
    ""
  ],
  [
    68747,
    1,
    ""
  ],
  [
    68748,
    1,
    ""
  ],
  [
    68749,
    1,
    ""
  ],
  [
    68750,
    1,
    ""
  ],
  [
    68751,
    1,
    ""
  ],
  [
    68752,
    1,
    ""
  ],
  [
    68753,
    1,
    ""
  ],
  [
    68754,
    1,
    ""
  ],
  [
    68755,
    1,
    ""
  ],
  [
    68756,
    1,
    ""
  ],
  [
    68757,
    1,
    ""
  ],
  [
    68758,
    1,
    ""
  ],
  [
    68759,
    1,
    ""
  ],
  [
    68760,
    1,
    ""
  ],
  [
    68761,
    1,
    ""
  ],
  [
    68762,
    1,
    ""
  ],
  [
    68763,
    1,
    ""
  ],
  [
    68764,
    1,
    ""
  ],
  [
    68765,
    1,
    ""
  ],
  [
    68766,
    1,
    ""
  ],
  [
    68767,
    1,
    ""
  ],
  [
    68768,
    1,
    ""
  ],
  [
    68769,
    1,
    ""
  ],
  [
    68770,
    1,
    ""
  ],
  [
    68771,
    1,
    ""
  ],
  [
    68772,
    1,
    ""
  ],
  [
    68773,
    1,
    ""
  ],
  [
    68774,
    1,
    ""
  ],
  [
    68775,
    1,
    ""
  ],
  [
    68776,
    1,
    ""
  ],
  [
    68777,
    1,
    ""
  ],
  [
    68778,
    1,
    ""
  ],
  [
    68779,
    1,
    ""
  ],
  [
    68780,
    1,
    ""
  ],
  [
    68781,
    1,
    ""
  ],
  [
    68782,
    1,
    ""
  ],
  [
    68783,
    1,
    ""
  ],
  [
    68784,
    1,
    ""
  ],
  [
    68785,
    1,
    ""
  ],
  [
    68786,
    1,
    ""
  ],
  [
    [
      68787,
      68799
    ],
    3
  ],
  [
    [
      68800,
      68850
    ],
    2
  ],
  [
    [
      68851,
      68857
    ],
    3
  ],
  [
    [
      68858,
      68863
    ],
    2
  ],
  [
    [
      68864,
      68903
    ],
    2
  ],
  [
    [
      68904,
      68911
    ],
    3
  ],
  [
    [
      68912,
      68921
    ],
    2
  ],
  [
    [
      68922,
      69215
    ],
    3
  ],
  [
    [
      69216,
      69246
    ],
    2
  ],
  [
    69247,
    3
  ],
  [
    [
      69248,
      69289
    ],
    2
  ],
  [
    69290,
    3
  ],
  [
    [
      69291,
      69292
    ],
    2
  ],
  [
    69293,
    2
  ],
  [
    [
      69294,
      69295
    ],
    3
  ],
  [
    [
      69296,
      69297
    ],
    2
  ],
  [
    [
      69298,
      69372
    ],
    3
  ],
  [
    [
      69373,
      69375
    ],
    2
  ],
  [
    [
      69376,
      69404
    ],
    2
  ],
  [
    [
      69405,
      69414
    ],
    2
  ],
  [
    69415,
    2
  ],
  [
    [
      69416,
      69423
    ],
    3
  ],
  [
    [
      69424,
      69456
    ],
    2
  ],
  [
    [
      69457,
      69465
    ],
    2
  ],
  [
    [
      69466,
      69487
    ],
    3
  ],
  [
    [
      69488,
      69509
    ],
    2
  ],
  [
    [
      69510,
      69513
    ],
    2
  ],
  [
    [
      69514,
      69551
    ],
    3
  ],
  [
    [
      69552,
      69572
    ],
    2
  ],
  [
    [
      69573,
      69579
    ],
    2
  ],
  [
    [
      69580,
      69599
    ],
    3
  ],
  [
    [
      69600,
      69622
    ],
    2
  ],
  [
    [
      69623,
      69631
    ],
    3
  ],
  [
    [
      69632,
      69702
    ],
    2
  ],
  [
    [
      69703,
      69709
    ],
    2
  ],
  [
    [
      69710,
      69713
    ],
    3
  ],
  [
    [
      69714,
      69733
    ],
    2
  ],
  [
    [
      69734,
      69743
    ],
    2
  ],
  [
    [
      69744,
      69749
    ],
    2
  ],
  [
    [
      69750,
      69758
    ],
    3
  ],
  [
    69759,
    2
  ],
  [
    [
      69760,
      69818
    ],
    2
  ],
  [
    [
      69819,
      69820
    ],
    2
  ],
  [
    69821,
    3
  ],
  [
    [
      69822,
      69825
    ],
    2
  ],
  [
    69826,
    2
  ],
  [
    [
      69827,
      69836
    ],
    3
  ],
  [
    69837,
    3
  ],
  [
    [
      69838,
      69839
    ],
    3
  ],
  [
    [
      69840,
      69864
    ],
    2
  ],
  [
    [
      69865,
      69871
    ],
    3
  ],
  [
    [
      69872,
      69881
    ],
    2
  ],
  [
    [
      69882,
      69887
    ],
    3
  ],
  [
    [
      69888,
      69940
    ],
    2
  ],
  [
    69941,
    3
  ],
  [
    [
      69942,
      69951
    ],
    2
  ],
  [
    [
      69952,
      69955
    ],
    2
  ],
  [
    [
      69956,
      69958
    ],
    2
  ],
  [
    69959,
    2
  ],
  [
    [
      69960,
      69967
    ],
    3
  ],
  [
    [
      69968,
      70003
    ],
    2
  ],
  [
    [
      70004,
      70005
    ],
    2
  ],
  [
    70006,
    2
  ],
  [
    [
      70007,
      70015
    ],
    3
  ],
  [
    [
      70016,
      70084
    ],
    2
  ],
  [
    [
      70085,
      70088
    ],
    2
  ],
  [
    [
      70089,
      70092
    ],
    2
  ],
  [
    70093,
    2
  ],
  [
    [
      70094,
      70095
    ],
    2
  ],
  [
    [
      70096,
      70105
    ],
    2
  ],
  [
    70106,
    2
  ],
  [
    70107,
    2
  ],
  [
    70108,
    2
  ],
  [
    [
      70109,
      70111
    ],
    2
  ],
  [
    70112,
    3
  ],
  [
    [
      70113,
      70132
    ],
    2
  ],
  [
    [
      70133,
      70143
    ],
    3
  ],
  [
    [
      70144,
      70161
    ],
    2
  ],
  [
    70162,
    3
  ],
  [
    [
      70163,
      70199
    ],
    2
  ],
  [
    [
      70200,
      70205
    ],
    2
  ],
  [
    70206,
    2
  ],
  [
    [
      70207,
      70209
    ],
    2
  ],
  [
    [
      70210,
      70271
    ],
    3
  ],
  [
    [
      70272,
      70278
    ],
    2
  ],
  [
    70279,
    3
  ],
  [
    70280,
    2
  ],
  [
    70281,
    3
  ],
  [
    [
      70282,
      70285
    ],
    2
  ],
  [
    70286,
    3
  ],
  [
    [
      70287,
      70301
    ],
    2
  ],
  [
    70302,
    3
  ],
  [
    [
      70303,
      70312
    ],
    2
  ],
  [
    70313,
    2
  ],
  [
    [
      70314,
      70319
    ],
    3
  ],
  [
    [
      70320,
      70378
    ],
    2
  ],
  [
    [
      70379,
      70383
    ],
    3
  ],
  [
    [
      70384,
      70393
    ],
    2
  ],
  [
    [
      70394,
      70399
    ],
    3
  ],
  [
    70400,
    2
  ],
  [
    [
      70401,
      70403
    ],
    2
  ],
  [
    70404,
    3
  ],
  [
    [
      70405,
      70412
    ],
    2
  ],
  [
    [
      70413,
      70414
    ],
    3
  ],
  [
    [
      70415,
      70416
    ],
    2
  ],
  [
    [
      70417,
      70418
    ],
    3
  ],
  [
    [
      70419,
      70440
    ],
    2
  ],
  [
    70441,
    3
  ],
  [
    [
      70442,
      70448
    ],
    2
  ],
  [
    70449,
    3
  ],
  [
    [
      70450,
      70451
    ],
    2
  ],
  [
    70452,
    3
  ],
  [
    [
      70453,
      70457
    ],
    2
  ],
  [
    70458,
    3
  ],
  [
    70459,
    2
  ],
  [
    [
      70460,
      70468
    ],
    2
  ],
  [
    [
      70469,
      70470
    ],
    3
  ],
  [
    [
      70471,
      70472
    ],
    2
  ],
  [
    [
      70473,
      70474
    ],
    3
  ],
  [
    [
      70475,
      70477
    ],
    2
  ],
  [
    [
      70478,
      70479
    ],
    3
  ],
  [
    70480,
    2
  ],
  [
    [
      70481,
      70486
    ],
    3
  ],
  [
    70487,
    2
  ],
  [
    [
      70488,
      70492
    ],
    3
  ],
  [
    [
      70493,
      70499
    ],
    2
  ],
  [
    [
      70500,
      70501
    ],
    3
  ],
  [
    [
      70502,
      70508
    ],
    2
  ],
  [
    [
      70509,
      70511
    ],
    3
  ],
  [
    [
      70512,
      70516
    ],
    2
  ],
  [
    [
      70517,
      70655
    ],
    3
  ],
  [
    [
      70656,
      70730
    ],
    2
  ],
  [
    [
      70731,
      70735
    ],
    2
  ],
  [
    [
      70736,
      70745
    ],
    2
  ],
  [
    70746,
    2
  ],
  [
    70747,
    2
  ],
  [
    70748,
    3
  ],
  [
    70749,
    2
  ],
  [
    70750,
    2
  ],
  [
    70751,
    2
  ],
  [
    [
      70752,
      70753
    ],
    2
  ],
  [
    [
      70754,
      70783
    ],
    3
  ],
  [
    [
      70784,
      70853
    ],
    2
  ],
  [
    70854,
    2
  ],
  [
    70855,
    2
  ],
  [
    [
      70856,
      70863
    ],
    3
  ],
  [
    [
      70864,
      70873
    ],
    2
  ],
  [
    [
      70874,
      71039
    ],
    3
  ],
  [
    [
      71040,
      71093
    ],
    2
  ],
  [
    [
      71094,
      71095
    ],
    3
  ],
  [
    [
      71096,
      71104
    ],
    2
  ],
  [
    [
      71105,
      71113
    ],
    2
  ],
  [
    [
      71114,
      71127
    ],
    2
  ],
  [
    [
      71128,
      71133
    ],
    2
  ],
  [
    [
      71134,
      71167
    ],
    3
  ],
  [
    [
      71168,
      71232
    ],
    2
  ],
  [
    [
      71233,
      71235
    ],
    2
  ],
  [
    71236,
    2
  ],
  [
    [
      71237,
      71247
    ],
    3
  ],
  [
    [
      71248,
      71257
    ],
    2
  ],
  [
    [
      71258,
      71263
    ],
    3
  ],
  [
    [
      71264,
      71276
    ],
    2
  ],
  [
    [
      71277,
      71295
    ],
    3
  ],
  [
    [
      71296,
      71351
    ],
    2
  ],
  [
    71352,
    2
  ],
  [
    71353,
    2
  ],
  [
    [
      71354,
      71359
    ],
    3
  ],
  [
    [
      71360,
      71369
    ],
    2
  ],
  [
    [
      71370,
      71423
    ],
    3
  ],
  [
    [
      71424,
      71449
    ],
    2
  ],
  [
    71450,
    2
  ],
  [
    [
      71451,
      71452
    ],
    3
  ],
  [
    [
      71453,
      71467
    ],
    2
  ],
  [
    [
      71468,
      71471
    ],
    3
  ],
  [
    [
      71472,
      71481
    ],
    2
  ],
  [
    [
      71482,
      71487
    ],
    2
  ],
  [
    [
      71488,
      71494
    ],
    2
  ],
  [
    [
      71495,
      71679
    ],
    3
  ],
  [
    [
      71680,
      71738
    ],
    2
  ],
  [
    71739,
    2
  ],
  [
    [
      71740,
      71839
    ],
    3
  ],
  [
    71840,
    1,
    ""
  ],
  [
    71841,
    1,
    ""
  ],
  [
    71842,
    1,
    ""
  ],
  [
    71843,
    1,
    ""
  ],
  [
    71844,
    1,
    ""
  ],
  [
    71845,
    1,
    ""
  ],
  [
    71846,
    1,
    ""
  ],
  [
    71847,
    1,
    ""
  ],
  [
    71848,
    1,
    ""
  ],
  [
    71849,
    1,
    ""
  ],
  [
    71850,
    1,
    ""
  ],
  [
    71851,
    1,
    ""
  ],
  [
    71852,
    1,
    ""
  ],
  [
    71853,
    1,
    ""
  ],
  [
    71854,
    1,
    ""
  ],
  [
    71855,
    1,
    ""
  ],
  [
    71856,
    1,
    ""
  ],
  [
    71857,
    1,
    ""
  ],
  [
    71858,
    1,
    ""
  ],
  [
    71859,
    1,
    ""
  ],
  [
    71860,
    1,
    ""
  ],
  [
    71861,
    1,
    ""
  ],
  [
    71862,
    1,
    ""
  ],
  [
    71863,
    1,
    ""
  ],
  [
    71864,
    1,
    ""
  ],
  [
    71865,
    1,
    ""
  ],
  [
    71866,
    1,
    ""
  ],
  [
    71867,
    1,
    ""
  ],
  [
    71868,
    1,
    ""
  ],
  [
    71869,
    1,
    ""
  ],
  [
    71870,
    1,
    ""
  ],
  [
    71871,
    1,
    ""
  ],
  [
    [
      71872,
      71913
    ],
    2
  ],
  [
    [
      71914,
      71922
    ],
    2
  ],
  [
    [
      71923,
      71934
    ],
    3
  ],
  [
    71935,
    2
  ],
  [
    [
      71936,
      71942
    ],
    2
  ],
  [
    [
      71943,
      71944
    ],
    3
  ],
  [
    71945,
    2
  ],
  [
    [
      71946,
      71947
    ],
    3
  ],
  [
    [
      71948,
      71955
    ],
    2
  ],
  [
    71956,
    3
  ],
  [
    [
      71957,
      71958
    ],
    2
  ],
  [
    71959,
    3
  ],
  [
    [
      71960,
      71989
    ],
    2
  ],
  [
    71990,
    3
  ],
  [
    [
      71991,
      71992
    ],
    2
  ],
  [
    [
      71993,
      71994
    ],
    3
  ],
  [
    [
      71995,
      72003
    ],
    2
  ],
  [
    [
      72004,
      72006
    ],
    2
  ],
  [
    [
      72007,
      72015
    ],
    3
  ],
  [
    [
      72016,
      72025
    ],
    2
  ],
  [
    [
      72026,
      72095
    ],
    3
  ],
  [
    [
      72096,
      72103
    ],
    2
  ],
  [
    [
      72104,
      72105
    ],
    3
  ],
  [
    [
      72106,
      72151
    ],
    2
  ],
  [
    [
      72152,
      72153
    ],
    3
  ],
  [
    [
      72154,
      72161
    ],
    2
  ],
  [
    72162,
    2
  ],
  [
    [
      72163,
      72164
    ],
    2
  ],
  [
    [
      72165,
      72191
    ],
    3
  ],
  [
    [
      72192,
      72254
    ],
    2
  ],
  [
    [
      72255,
      72262
    ],
    2
  ],
  [
    72263,
    2
  ],
  [
    [
      72264,
      72271
    ],
    3
  ],
  [
    [
      72272,
      72323
    ],
    2
  ],
  [
    [
      72324,
      72325
    ],
    2
  ],
  [
    [
      72326,
      72345
    ],
    2
  ],
  [
    [
      72346,
      72348
    ],
    2
  ],
  [
    72349,
    2
  ],
  [
    [
      72350,
      72354
    ],
    2
  ],
  [
    [
      72355,
      72367
    ],
    3
  ],
  [
    [
      72368,
      72383
    ],
    2
  ],
  [
    [
      72384,
      72440
    ],
    2
  ],
  [
    [
      72441,
      72447
    ],
    3
  ],
  [
    [
      72448,
      72457
    ],
    2
  ],
  [
    [
      72458,
      72703
    ],
    3
  ],
  [
    [
      72704,
      72712
    ],
    2
  ],
  [
    72713,
    3
  ],
  [
    [
      72714,
      72758
    ],
    2
  ],
  [
    72759,
    3
  ],
  [
    [
      72760,
      72768
    ],
    2
  ],
  [
    [
      72769,
      72773
    ],
    2
  ],
  [
    [
      72774,
      72783
    ],
    3
  ],
  [
    [
      72784,
      72793
    ],
    2
  ],
  [
    [
      72794,
      72812
    ],
    2
  ],
  [
    [
      72813,
      72815
    ],
    3
  ],
  [
    [
      72816,
      72817
    ],
    2
  ],
  [
    [
      72818,
      72847
    ],
    2
  ],
  [
    [
      72848,
      72849
    ],
    3
  ],
  [
    [
      72850,
      72871
    ],
    2
  ],
  [
    72872,
    3
  ],
  [
    [
      72873,
      72886
    ],
    2
  ],
  [
    [
      72887,
      72959
    ],
    3
  ],
  [
    [
      72960,
      72966
    ],
    2
  ],
  [
    72967,
    3
  ],
  [
    [
      72968,
      72969
    ],
    2
  ],
  [
    72970,
    3
  ],
  [
    [
      72971,
      73014
    ],
    2
  ],
  [
    [
      73015,
      73017
    ],
    3
  ],
  [
    73018,
    2
  ],
  [
    73019,
    3
  ],
  [
    [
      73020,
      73021
    ],
    2
  ],
  [
    73022,
    3
  ],
  [
    [
      73023,
      73031
    ],
    2
  ],
  [
    [
      73032,
      73039
    ],
    3
  ],
  [
    [
      73040,
      73049
    ],
    2
  ],
  [
    [
      73050,
      73055
    ],
    3
  ],
  [
    [
      73056,
      73061
    ],
    2
  ],
  [
    73062,
    3
  ],
  [
    [
      73063,
      73064
    ],
    2
  ],
  [
    73065,
    3
  ],
  [
    [
      73066,
      73102
    ],
    2
  ],
  [
    73103,
    3
  ],
  [
    [
      73104,
      73105
    ],
    2
  ],
  [
    73106,
    3
  ],
  [
    [
      73107,
      73112
    ],
    2
  ],
  [
    [
      73113,
      73119
    ],
    3
  ],
  [
    [
      73120,
      73129
    ],
    2
  ],
  [
    [
      73130,
      73439
    ],
    3
  ],
  [
    [
      73440,
      73462
    ],
    2
  ],
  [
    [
      73463,
      73464
    ],
    2
  ],
  [
    [
      73465,
      73471
    ],
    3
  ],
  [
    [
      73472,
      73488
    ],
    2
  ],
  [
    73489,
    3
  ],
  [
    [
      73490,
      73530
    ],
    2
  ],
  [
    [
      73531,
      73533
    ],
    3
  ],
  [
    [
      73534,
      73538
    ],
    2
  ],
  [
    [
      73539,
      73551
    ],
    2
  ],
  [
    [
      73552,
      73561
    ],
    2
  ],
  [
    [
      73562,
      73647
    ],
    3
  ],
  [
    73648,
    2
  ],
  [
    [
      73649,
      73663
    ],
    3
  ],
  [
    [
      73664,
      73713
    ],
    2
  ],
  [
    [
      73714,
      73726
    ],
    3
  ],
  [
    73727,
    2
  ],
  [
    [
      73728,
      74606
    ],
    2
  ],
  [
    [
      74607,
      74648
    ],
    2
  ],
  [
    74649,
    2
  ],
  [
    [
      74650,
      74751
    ],
    3
  ],
  [
    [
      74752,
      74850
    ],
    2
  ],
  [
    [
      74851,
      74862
    ],
    2
  ],
  [
    74863,
    3
  ],
  [
    [
      74864,
      74867
    ],
    2
  ],
  [
    74868,
    2
  ],
  [
    [
      74869,
      74879
    ],
    3
  ],
  [
    [
      74880,
      75075
    ],
    2
  ],
  [
    [
      75076,
      77711
    ],
    3
  ],
  [
    [
      77712,
      77808
    ],
    2
  ],
  [
    [
      77809,
      77810
    ],
    2
  ],
  [
    [
      77811,
      77823
    ],
    3
  ],
  [
    [
      77824,
      78894
    ],
    2
  ],
  [
    78895,
    2
  ],
  [
    [
      78896,
      78904
    ],
    3
  ],
  [
    [
      78905,
      78911
    ],
    3
  ],
  [
    [
      78912,
      78933
    ],
    2
  ],
  [
    [
      78934,
      82943
    ],
    3
  ],
  [
    [
      82944,
      83526
    ],
    2
  ],
  [
    [
      83527,
      92159
    ],
    3
  ],
  [
    [
      92160,
      92728
    ],
    2
  ],
  [
    [
      92729,
      92735
    ],
    3
  ],
  [
    [
      92736,
      92766
    ],
    2
  ],
  [
    92767,
    3
  ],
  [
    [
      92768,
      92777
    ],
    2
  ],
  [
    [
      92778,
      92781
    ],
    3
  ],
  [
    [
      92782,
      92783
    ],
    2
  ],
  [
    [
      92784,
      92862
    ],
    2
  ],
  [
    92863,
    3
  ],
  [
    [
      92864,
      92873
    ],
    2
  ],
  [
    [
      92874,
      92879
    ],
    3
  ],
  [
    [
      92880,
      92909
    ],
    2
  ],
  [
    [
      92910,
      92911
    ],
    3
  ],
  [
    [
      92912,
      92916
    ],
    2
  ],
  [
    92917,
    2
  ],
  [
    [
      92918,
      92927
    ],
    3
  ],
  [
    [
      92928,
      92982
    ],
    2
  ],
  [
    [
      92983,
      92991
    ],
    2
  ],
  [
    [
      92992,
      92995
    ],
    2
  ],
  [
    [
      92996,
      92997
    ],
    2
  ],
  [
    [
      92998,
      93007
    ],
    3
  ],
  [
    [
      93008,
      93017
    ],
    2
  ],
  [
    93018,
    3
  ],
  [
    [
      93019,
      93025
    ],
    2
  ],
  [
    93026,
    3
  ],
  [
    [
      93027,
      93047
    ],
    2
  ],
  [
    [
      93048,
      93052
    ],
    3
  ],
  [
    [
      93053,
      93071
    ],
    2
  ],
  [
    [
      93072,
      93759
    ],
    3
  ],
  [
    93760,
    1,
    ""
  ],
  [
    93761,
    1,
    ""
  ],
  [
    93762,
    1,
    ""
  ],
  [
    93763,
    1,
    ""
  ],
  [
    93764,
    1,
    ""
  ],
  [
    93765,
    1,
    ""
  ],
  [
    93766,
    1,
    ""
  ],
  [
    93767,
    1,
    ""
  ],
  [
    93768,
    1,
    ""
  ],
  [
    93769,
    1,
    ""
  ],
  [
    93770,
    1,
    ""
  ],
  [
    93771,
    1,
    ""
  ],
  [
    93772,
    1,
    ""
  ],
  [
    93773,
    1,
    ""
  ],
  [
    93774,
    1,
    ""
  ],
  [
    93775,
    1,
    ""
  ],
  [
    93776,
    1,
    ""
  ],
  [
    93777,
    1,
    ""
  ],
  [
    93778,
    1,
    ""
  ],
  [
    93779,
    1,
    ""
  ],
  [
    93780,
    1,
    ""
  ],
  [
    93781,
    1,
    ""
  ],
  [
    93782,
    1,
    ""
  ],
  [
    93783,
    1,
    ""
  ],
  [
    93784,
    1,
    ""
  ],
  [
    93785,
    1,
    ""
  ],
  [
    93786,
    1,
    ""
  ],
  [
    93787,
    1,
    ""
  ],
  [
    93788,
    1,
    ""
  ],
  [
    93789,
    1,
    ""
  ],
  [
    93790,
    1,
    ""
  ],
  [
    93791,
    1,
    ""
  ],
  [
    [
      93792,
      93823
    ],
    2
  ],
  [
    [
      93824,
      93850
    ],
    2
  ],
  [
    [
      93851,
      93951
    ],
    3
  ],
  [
    [
      93952,
      94020
    ],
    2
  ],
  [
    [
      94021,
      94026
    ],
    2
  ],
  [
    [
      94027,
      94030
    ],
    3
  ],
  [
    94031,
    2
  ],
  [
    [
      94032,
      94078
    ],
    2
  ],
  [
    [
      94079,
      94087
    ],
    2
  ],
  [
    [
      94088,
      94094
    ],
    3
  ],
  [
    [
      94095,
      94111
    ],
    2
  ],
  [
    [
      94112,
      94175
    ],
    3
  ],
  [
    94176,
    2
  ],
  [
    94177,
    2
  ],
  [
    94178,
    2
  ],
  [
    94179,
    2
  ],
  [
    94180,
    2
  ],
  [
    [
      94181,
      94191
    ],
    3
  ],
  [
    [
      94192,
      94193
    ],
    2
  ],
  [
    [
      94194,
      94207
    ],
    3
  ],
  [
    [
      94208,
      100332
    ],
    2
  ],
  [
    [
      100333,
      100337
    ],
    2
  ],
  [
    [
      100338,
      100343
    ],
    2
  ],
  [
    [
      100344,
      100351
    ],
    3
  ],
  [
    [
      100352,
      101106
    ],
    2
  ],
  [
    [
      101107,
      101589
    ],
    2
  ],
  [
    [
      101590,
      101631
    ],
    3
  ],
  [
    [
      101632,
      101640
    ],
    2
  ],
  [
    [
      101641,
      110575
    ],
    3
  ],
  [
    [
      110576,
      110579
    ],
    2
  ],
  [
    110580,
    3
  ],
  [
    [
      110581,
      110587
    ],
    2
  ],
  [
    110588,
    3
  ],
  [
    [
      110589,
      110590
    ],
    2
  ],
  [
    110591,
    3
  ],
  [
    [
      110592,
      110593
    ],
    2
  ],
  [
    [
      110594,
      110878
    ],
    2
  ],
  [
    [
      110879,
      110882
    ],
    2
  ],
  [
    [
      110883,
      110897
    ],
    3
  ],
  [
    110898,
    2
  ],
  [
    [
      110899,
      110927
    ],
    3
  ],
  [
    [
      110928,
      110930
    ],
    2
  ],
  [
    [
      110931,
      110932
    ],
    3
  ],
  [
    110933,
    2
  ],
  [
    [
      110934,
      110947
    ],
    3
  ],
  [
    [
      110948,
      110951
    ],
    2
  ],
  [
    [
      110952,
      110959
    ],
    3
  ],
  [
    [
      110960,
      111355
    ],
    2
  ],
  [
    [
      111356,
      113663
    ],
    3
  ],
  [
    [
      113664,
      113770
    ],
    2
  ],
  [
    [
      113771,
      113775
    ],
    3
  ],
  [
    [
      113776,
      113788
    ],
    2
  ],
  [
    [
      113789,
      113791
    ],
    3
  ],
  [
    [
      113792,
      113800
    ],
    2
  ],
  [
    [
      113801,
      113807
    ],
    3
  ],
  [
    [
      113808,
      113817
    ],
    2
  ],
  [
    [
      113818,
      113819
    ],
    3
  ],
  [
    113820,
    2
  ],
  [
    [
      113821,
      113822
    ],
    2
  ],
  [
    113823,
    2
  ],
  [
    [
      113824,
      113827
    ],
    7
  ],
  [
    [
      113828,
      118527
    ],
    3
  ],
  [
    [
      118528,
      118573
    ],
    2
  ],
  [
    [
      118574,
      118575
    ],
    3
  ],
  [
    [
      118576,
      118598
    ],
    2
  ],
  [
    [
      118599,
      118607
    ],
    3
  ],
  [
    [
      118608,
      118723
    ],
    2
  ],
  [
    [
      118724,
      118783
    ],
    3
  ],
  [
    [
      118784,
      119029
    ],
    2
  ],
  [
    [
      119030,
      119039
    ],
    3
  ],
  [
    [
      119040,
      119078
    ],
    2
  ],
  [
    [
      119079,
      119080
    ],
    3
  ],
  [
    119081,
    2
  ],
  [
    [
      119082,
      119133
    ],
    2
  ],
  [
    119134,
    1,
    ""
  ],
  [
    119135,
    1,
    ""
  ],
  [
    119136,
    1,
    ""
  ],
  [
    119137,
    1,
    ""
  ],
  [
    119138,
    1,
    ""
  ],
  [
    119139,
    1,
    ""
  ],
  [
    119140,
    1,
    ""
  ],
  [
    [
      119141,
      119154
    ],
    2
  ],
  [
    [
      119155,
      119162
    ],
    3
  ],
  [
    [
      119163,
      119226
    ],
    2
  ],
  [
    119227,
    1,
    ""
  ],
  [
    119228,
    1,
    ""
  ],
  [
    119229,
    1,
    ""
  ],
  [
    119230,
    1,
    ""
  ],
  [
    119231,
    1,
    ""
  ],
  [
    119232,
    1,
    ""
  ],
  [
    [
      119233,
      119261
    ],
    2
  ],
  [
    [
      119262,
      119272
    ],
    2
  ],
  [
    [
      119273,
      119274
    ],
    2
  ],
  [
    [
      119275,
      119295
    ],
    3
  ],
  [
    [
      119296,
      119365
    ],
    2
  ],
  [
    [
      119366,
      119487
    ],
    3
  ],
  [
    [
      119488,
      119507
    ],
    2
  ],
  [
    [
      119508,
      119519
    ],
    3
  ],
  [
    [
      119520,
      119539
    ],
    2
  ],
  [
    [
      119540,
      119551
    ],
    3
  ],
  [
    [
      119552,
      119638
    ],
    2
  ],
  [
    [
      119639,
      119647
    ],
    3
  ],
  [
    [
      119648,
      119665
    ],
    2
  ],
  [
    [
      119666,
      119672
    ],
    2
  ],
  [
    [
      119673,
      119807
    ],
    3
  ],
  [
    119808,
    1,
    "a"
  ],
  [
    119809,
    1,
    "b"
  ],
  [
    119810,
    1,
    "c"
  ],
  [
    119811,
    1,
    "d"
  ],
  [
    119812,
    1,
    "e"
  ],
  [
    119813,
    1,
    "f"
  ],
  [
    119814,
    1,
    "g"
  ],
  [
    119815,
    1,
    "h"
  ],
  [
    119816,
    1,
    "i"
  ],
  [
    119817,
    1,
    "j"
  ],
  [
    119818,
    1,
    "k"
  ],
  [
    119819,
    1,
    "l"
  ],
  [
    119820,
    1,
    "m"
  ],
  [
    119821,
    1,
    "n"
  ],
  [
    119822,
    1,
    "o"
  ],
  [
    119823,
    1,
    "p"
  ],
  [
    119824,
    1,
    "q"
  ],
  [
    119825,
    1,
    "r"
  ],
  [
    119826,
    1,
    "s"
  ],
  [
    119827,
    1,
    "t"
  ],
  [
    119828,
    1,
    "u"
  ],
  [
    119829,
    1,
    "v"
  ],
  [
    119830,
    1,
    "w"
  ],
  [
    119831,
    1,
    "x"
  ],
  [
    119832,
    1,
    "y"
  ],
  [
    119833,
    1,
    "z"
  ],
  [
    119834,
    1,
    "a"
  ],
  [
    119835,
    1,
    "b"
  ],
  [
    119836,
    1,
    "c"
  ],
  [
    119837,
    1,
    "d"
  ],
  [
    119838,
    1,
    "e"
  ],
  [
    119839,
    1,
    "f"
  ],
  [
    119840,
    1,
    "g"
  ],
  [
    119841,
    1,
    "h"
  ],
  [
    119842,
    1,
    "i"
  ],
  [
    119843,
    1,
    "j"
  ],
  [
    119844,
    1,
    "k"
  ],
  [
    119845,
    1,
    "l"
  ],
  [
    119846,
    1,
    "m"
  ],
  [
    119847,
    1,
    "n"
  ],
  [
    119848,
    1,
    "o"
  ],
  [
    119849,
    1,
    "p"
  ],
  [
    119850,
    1,
    "q"
  ],
  [
    119851,
    1,
    "r"
  ],
  [
    119852,
    1,
    "s"
  ],
  [
    119853,
    1,
    "t"
  ],
  [
    119854,
    1,
    "u"
  ],
  [
    119855,
    1,
    "v"
  ],
  [
    119856,
    1,
    "w"
  ],
  [
    119857,
    1,
    "x"
  ],
  [
    119858,
    1,
    "y"
  ],
  [
    119859,
    1,
    "z"
  ],
  [
    119860,
    1,
    "a"
  ],
  [
    119861,
    1,
    "b"
  ],
  [
    119862,
    1,
    "c"
  ],
  [
    119863,
    1,
    "d"
  ],
  [
    119864,
    1,
    "e"
  ],
  [
    119865,
    1,
    "f"
  ],
  [
    119866,
    1,
    "g"
  ],
  [
    119867,
    1,
    "h"
  ],
  [
    119868,
    1,
    "i"
  ],
  [
    119869,
    1,
    "j"
  ],
  [
    119870,
    1,
    "k"
  ],
  [
    119871,
    1,
    "l"
  ],
  [
    119872,
    1,
    "m"
  ],
  [
    119873,
    1,
    "n"
  ],
  [
    119874,
    1,
    "o"
  ],
  [
    119875,
    1,
    "p"
  ],
  [
    119876,
    1,
    "q"
  ],
  [
    119877,
    1,
    "r"
  ],
  [
    119878,
    1,
    "s"
  ],
  [
    119879,
    1,
    "t"
  ],
  [
    119880,
    1,
    "u"
  ],
  [
    119881,
    1,
    "v"
  ],
  [
    119882,
    1,
    "w"
  ],
  [
    119883,
    1,
    "x"
  ],
  [
    119884,
    1,
    "y"
  ],
  [
    119885,
    1,
    "z"
  ],
  [
    119886,
    1,
    "a"
  ],
  [
    119887,
    1,
    "b"
  ],
  [
    119888,
    1,
    "c"
  ],
  [
    119889,
    1,
    "d"
  ],
  [
    119890,
    1,
    "e"
  ],
  [
    119891,
    1,
    "f"
  ],
  [
    119892,
    1,
    "g"
  ],
  [
    119893,
    3
  ],
  [
    119894,
    1,
    "i"
  ],
  [
    119895,
    1,
    "j"
  ],
  [
    119896,
    1,
    "k"
  ],
  [
    119897,
    1,
    "l"
  ],
  [
    119898,
    1,
    "m"
  ],
  [
    119899,
    1,
    "n"
  ],
  [
    119900,
    1,
    "o"
  ],
  [
    119901,
    1,
    "p"
  ],
  [
    119902,
    1,
    "q"
  ],
  [
    119903,
    1,
    "r"
  ],
  [
    119904,
    1,
    "s"
  ],
  [
    119905,
    1,
    "t"
  ],
  [
    119906,
    1,
    "u"
  ],
  [
    119907,
    1,
    "v"
  ],
  [
    119908,
    1,
    "w"
  ],
  [
    119909,
    1,
    "x"
  ],
  [
    119910,
    1,
    "y"
  ],
  [
    119911,
    1,
    "z"
  ],
  [
    119912,
    1,
    "a"
  ],
  [
    119913,
    1,
    "b"
  ],
  [
    119914,
    1,
    "c"
  ],
  [
    119915,
    1,
    "d"
  ],
  [
    119916,
    1,
    "e"
  ],
  [
    119917,
    1,
    "f"
  ],
  [
    119918,
    1,
    "g"
  ],
  [
    119919,
    1,
    "h"
  ],
  [
    119920,
    1,
    "i"
  ],
  [
    119921,
    1,
    "j"
  ],
  [
    119922,
    1,
    "k"
  ],
  [
    119923,
    1,
    "l"
  ],
  [
    119924,
    1,
    "m"
  ],
  [
    119925,
    1,
    "n"
  ],
  [
    119926,
    1,
    "o"
  ],
  [
    119927,
    1,
    "p"
  ],
  [
    119928,
    1,
    "q"
  ],
  [
    119929,
    1,
    "r"
  ],
  [
    119930,
    1,
    "s"
  ],
  [
    119931,
    1,
    "t"
  ],
  [
    119932,
    1,
    "u"
  ],
  [
    119933,
    1,
    "v"
  ],
  [
    119934,
    1,
    "w"
  ],
  [
    119935,
    1,
    "x"
  ],
  [
    119936,
    1,
    "y"
  ],
  [
    119937,
    1,
    "z"
  ],
  [
    119938,
    1,
    "a"
  ],
  [
    119939,
    1,
    "b"
  ],
  [
    119940,
    1,
    "c"
  ],
  [
    119941,
    1,
    "d"
  ],
  [
    119942,
    1,
    "e"
  ],
  [
    119943,
    1,
    "f"
  ],
  [
    119944,
    1,
    "g"
  ],
  [
    119945,
    1,
    "h"
  ],
  [
    119946,
    1,
    "i"
  ],
  [
    119947,
    1,
    "j"
  ],
  [
    119948,
    1,
    "k"
  ],
  [
    119949,
    1,
    "l"
  ],
  [
    119950,
    1,
    "m"
  ],
  [
    119951,
    1,
    "n"
  ],
  [
    119952,
    1,
    "o"
  ],
  [
    119953,
    1,
    "p"
  ],
  [
    119954,
    1,
    "q"
  ],
  [
    119955,
    1,
    "r"
  ],
  [
    119956,
    1,
    "s"
  ],
  [
    119957,
    1,
    "t"
  ],
  [
    119958,
    1,
    "u"
  ],
  [
    119959,
    1,
    "v"
  ],
  [
    119960,
    1,
    "w"
  ],
  [
    119961,
    1,
    "x"
  ],
  [
    119962,
    1,
    "y"
  ],
  [
    119963,
    1,
    "z"
  ],
  [
    119964,
    1,
    "a"
  ],
  [
    119965,
    3
  ],
  [
    119966,
    1,
    "c"
  ],
  [
    119967,
    1,
    "d"
  ],
  [
    [
      119968,
      119969
    ],
    3
  ],
  [
    119970,
    1,
    "g"
  ],
  [
    [
      119971,
      119972
    ],
    3
  ],
  [
    119973,
    1,
    "j"
  ],
  [
    119974,
    1,
    "k"
  ],
  [
    [
      119975,
      119976
    ],
    3
  ],
  [
    119977,
    1,
    "n"
  ],
  [
    119978,
    1,
    "o"
  ],
  [
    119979,
    1,
    "p"
  ],
  [
    119980,
    1,
    "q"
  ],
  [
    119981,
    3
  ],
  [
    119982,
    1,
    "s"
  ],
  [
    119983,
    1,
    "t"
  ],
  [
    119984,
    1,
    "u"
  ],
  [
    119985,
    1,
    "v"
  ],
  [
    119986,
    1,
    "w"
  ],
  [
    119987,
    1,
    "x"
  ],
  [
    119988,
    1,
    "y"
  ],
  [
    119989,
    1,
    "z"
  ],
  [
    119990,
    1,
    "a"
  ],
  [
    119991,
    1,
    "b"
  ],
  [
    119992,
    1,
    "c"
  ],
  [
    119993,
    1,
    "d"
  ],
  [
    119994,
    3
  ],
  [
    119995,
    1,
    "f"
  ],
  [
    119996,
    3
  ],
  [
    119997,
    1,
    "h"
  ],
  [
    119998,
    1,
    "i"
  ],
  [
    119999,
    1,
    "j"
  ],
  [
    12e4,
    1,
    "k"
  ],
  [
    120001,
    1,
    "l"
  ],
  [
    120002,
    1,
    "m"
  ],
  [
    120003,
    1,
    "n"
  ],
  [
    120004,
    3
  ],
  [
    120005,
    1,
    "p"
  ],
  [
    120006,
    1,
    "q"
  ],
  [
    120007,
    1,
    "r"
  ],
  [
    120008,
    1,
    "s"
  ],
  [
    120009,
    1,
    "t"
  ],
  [
    120010,
    1,
    "u"
  ],
  [
    120011,
    1,
    "v"
  ],
  [
    120012,
    1,
    "w"
  ],
  [
    120013,
    1,
    "x"
  ],
  [
    120014,
    1,
    "y"
  ],
  [
    120015,
    1,
    "z"
  ],
  [
    120016,
    1,
    "a"
  ],
  [
    120017,
    1,
    "b"
  ],
  [
    120018,
    1,
    "c"
  ],
  [
    120019,
    1,
    "d"
  ],
  [
    120020,
    1,
    "e"
  ],
  [
    120021,
    1,
    "f"
  ],
  [
    120022,
    1,
    "g"
  ],
  [
    120023,
    1,
    "h"
  ],
  [
    120024,
    1,
    "i"
  ],
  [
    120025,
    1,
    "j"
  ],
  [
    120026,
    1,
    "k"
  ],
  [
    120027,
    1,
    "l"
  ],
  [
    120028,
    1,
    "m"
  ],
  [
    120029,
    1,
    "n"
  ],
  [
    120030,
    1,
    "o"
  ],
  [
    120031,
    1,
    "p"
  ],
  [
    120032,
    1,
    "q"
  ],
  [
    120033,
    1,
    "r"
  ],
  [
    120034,
    1,
    "s"
  ],
  [
    120035,
    1,
    "t"
  ],
  [
    120036,
    1,
    "u"
  ],
  [
    120037,
    1,
    "v"
  ],
  [
    120038,
    1,
    "w"
  ],
  [
    120039,
    1,
    "x"
  ],
  [
    120040,
    1,
    "y"
  ],
  [
    120041,
    1,
    "z"
  ],
  [
    120042,
    1,
    "a"
  ],
  [
    120043,
    1,
    "b"
  ],
  [
    120044,
    1,
    "c"
  ],
  [
    120045,
    1,
    "d"
  ],
  [
    120046,
    1,
    "e"
  ],
  [
    120047,
    1,
    "f"
  ],
  [
    120048,
    1,
    "g"
  ],
  [
    120049,
    1,
    "h"
  ],
  [
    120050,
    1,
    "i"
  ],
  [
    120051,
    1,
    "j"
  ],
  [
    120052,
    1,
    "k"
  ],
  [
    120053,
    1,
    "l"
  ],
  [
    120054,
    1,
    "m"
  ],
  [
    120055,
    1,
    "n"
  ],
  [
    120056,
    1,
    "o"
  ],
  [
    120057,
    1,
    "p"
  ],
  [
    120058,
    1,
    "q"
  ],
  [
    120059,
    1,
    "r"
  ],
  [
    120060,
    1,
    "s"
  ],
  [
    120061,
    1,
    "t"
  ],
  [
    120062,
    1,
    "u"
  ],
  [
    120063,
    1,
    "v"
  ],
  [
    120064,
    1,
    "w"
  ],
  [
    120065,
    1,
    "x"
  ],
  [
    120066,
    1,
    "y"
  ],
  [
    120067,
    1,
    "z"
  ],
  [
    120068,
    1,
    "a"
  ],
  [
    120069,
    1,
    "b"
  ],
  [
    120070,
    3
  ],
  [
    120071,
    1,
    "d"
  ],
  [
    120072,
    1,
    "e"
  ],
  [
    120073,
    1,
    "f"
  ],
  [
    120074,
    1,
    "g"
  ],
  [
    [
      120075,
      120076
    ],
    3
  ],
  [
    120077,
    1,
    "j"
  ],
  [
    120078,
    1,
    "k"
  ],
  [
    120079,
    1,
    "l"
  ],
  [
    120080,
    1,
    "m"
  ],
  [
    120081,
    1,
    "n"
  ],
  [
    120082,
    1,
    "o"
  ],
  [
    120083,
    1,
    "p"
  ],
  [
    120084,
    1,
    "q"
  ],
  [
    120085,
    3
  ],
  [
    120086,
    1,
    "s"
  ],
  [
    120087,
    1,
    "t"
  ],
  [
    120088,
    1,
    "u"
  ],
  [
    120089,
    1,
    "v"
  ],
  [
    120090,
    1,
    "w"
  ],
  [
    120091,
    1,
    "x"
  ],
  [
    120092,
    1,
    "y"
  ],
  [
    120093,
    3
  ],
  [
    120094,
    1,
    "a"
  ],
  [
    120095,
    1,
    "b"
  ],
  [
    120096,
    1,
    "c"
  ],
  [
    120097,
    1,
    "d"
  ],
  [
    120098,
    1,
    "e"
  ],
  [
    120099,
    1,
    "f"
  ],
  [
    120100,
    1,
    "g"
  ],
  [
    120101,
    1,
    "h"
  ],
  [
    120102,
    1,
    "i"
  ],
  [
    120103,
    1,
    "j"
  ],
  [
    120104,
    1,
    "k"
  ],
  [
    120105,
    1,
    "l"
  ],
  [
    120106,
    1,
    "m"
  ],
  [
    120107,
    1,
    "n"
  ],
  [
    120108,
    1,
    "o"
  ],
  [
    120109,
    1,
    "p"
  ],
  [
    120110,
    1,
    "q"
  ],
  [
    120111,
    1,
    "r"
  ],
  [
    120112,
    1,
    "s"
  ],
  [
    120113,
    1,
    "t"
  ],
  [
    120114,
    1,
    "u"
  ],
  [
    120115,
    1,
    "v"
  ],
  [
    120116,
    1,
    "w"
  ],
  [
    120117,
    1,
    "x"
  ],
  [
    120118,
    1,
    "y"
  ],
  [
    120119,
    1,
    "z"
  ],
  [
    120120,
    1,
    "a"
  ],
  [
    120121,
    1,
    "b"
  ],
  [
    120122,
    3
  ],
  [
    120123,
    1,
    "d"
  ],
  [
    120124,
    1,
    "e"
  ],
  [
    120125,
    1,
    "f"
  ],
  [
    120126,
    1,
    "g"
  ],
  [
    120127,
    3
  ],
  [
    120128,
    1,
    "i"
  ],
  [
    120129,
    1,
    "j"
  ],
  [
    120130,
    1,
    "k"
  ],
  [
    120131,
    1,
    "l"
  ],
  [
    120132,
    1,
    "m"
  ],
  [
    120133,
    3
  ],
  [
    120134,
    1,
    "o"
  ],
  [
    [
      120135,
      120137
    ],
    3
  ],
  [
    120138,
    1,
    "s"
  ],
  [
    120139,
    1,
    "t"
  ],
  [
    120140,
    1,
    "u"
  ],
  [
    120141,
    1,
    "v"
  ],
  [
    120142,
    1,
    "w"
  ],
  [
    120143,
    1,
    "x"
  ],
  [
    120144,
    1,
    "y"
  ],
  [
    120145,
    3
  ],
  [
    120146,
    1,
    "a"
  ],
  [
    120147,
    1,
    "b"
  ],
  [
    120148,
    1,
    "c"
  ],
  [
    120149,
    1,
    "d"
  ],
  [
    120150,
    1,
    "e"
  ],
  [
    120151,
    1,
    "f"
  ],
  [
    120152,
    1,
    "g"
  ],
  [
    120153,
    1,
    "h"
  ],
  [
    120154,
    1,
    "i"
  ],
  [
    120155,
    1,
    "j"
  ],
  [
    120156,
    1,
    "k"
  ],
  [
    120157,
    1,
    "l"
  ],
  [
    120158,
    1,
    "m"
  ],
  [
    120159,
    1,
    "n"
  ],
  [
    120160,
    1,
    "o"
  ],
  [
    120161,
    1,
    "p"
  ],
  [
    120162,
    1,
    "q"
  ],
  [
    120163,
    1,
    "r"
  ],
  [
    120164,
    1,
    "s"
  ],
  [
    120165,
    1,
    "t"
  ],
  [
    120166,
    1,
    "u"
  ],
  [
    120167,
    1,
    "v"
  ],
  [
    120168,
    1,
    "w"
  ],
  [
    120169,
    1,
    "x"
  ],
  [
    120170,
    1,
    "y"
  ],
  [
    120171,
    1,
    "z"
  ],
  [
    120172,
    1,
    "a"
  ],
  [
    120173,
    1,
    "b"
  ],
  [
    120174,
    1,
    "c"
  ],
  [
    120175,
    1,
    "d"
  ],
  [
    120176,
    1,
    "e"
  ],
  [
    120177,
    1,
    "f"
  ],
  [
    120178,
    1,
    "g"
  ],
  [
    120179,
    1,
    "h"
  ],
  [
    120180,
    1,
    "i"
  ],
  [
    120181,
    1,
    "j"
  ],
  [
    120182,
    1,
    "k"
  ],
  [
    120183,
    1,
    "l"
  ],
  [
    120184,
    1,
    "m"
  ],
  [
    120185,
    1,
    "n"
  ],
  [
    120186,
    1,
    "o"
  ],
  [
    120187,
    1,
    "p"
  ],
  [
    120188,
    1,
    "q"
  ],
  [
    120189,
    1,
    "r"
  ],
  [
    120190,
    1,
    "s"
  ],
  [
    120191,
    1,
    "t"
  ],
  [
    120192,
    1,
    "u"
  ],
  [
    120193,
    1,
    "v"
  ],
  [
    120194,
    1,
    "w"
  ],
  [
    120195,
    1,
    "x"
  ],
  [
    120196,
    1,
    "y"
  ],
  [
    120197,
    1,
    "z"
  ],
  [
    120198,
    1,
    "a"
  ],
  [
    120199,
    1,
    "b"
  ],
  [
    120200,
    1,
    "c"
  ],
  [
    120201,
    1,
    "d"
  ],
  [
    120202,
    1,
    "e"
  ],
  [
    120203,
    1,
    "f"
  ],
  [
    120204,
    1,
    "g"
  ],
  [
    120205,
    1,
    "h"
  ],
  [
    120206,
    1,
    "i"
  ],
  [
    120207,
    1,
    "j"
  ],
  [
    120208,
    1,
    "k"
  ],
  [
    120209,
    1,
    "l"
  ],
  [
    120210,
    1,
    "m"
  ],
  [
    120211,
    1,
    "n"
  ],
  [
    120212,
    1,
    "o"
  ],
  [
    120213,
    1,
    "p"
  ],
  [
    120214,
    1,
    "q"
  ],
  [
    120215,
    1,
    "r"
  ],
  [
    120216,
    1,
    "s"
  ],
  [
    120217,
    1,
    "t"
  ],
  [
    120218,
    1,
    "u"
  ],
  [
    120219,
    1,
    "v"
  ],
  [
    120220,
    1,
    "w"
  ],
  [
    120221,
    1,
    "x"
  ],
  [
    120222,
    1,
    "y"
  ],
  [
    120223,
    1,
    "z"
  ],
  [
    120224,
    1,
    "a"
  ],
  [
    120225,
    1,
    "b"
  ],
  [
    120226,
    1,
    "c"
  ],
  [
    120227,
    1,
    "d"
  ],
  [
    120228,
    1,
    "e"
  ],
  [
    120229,
    1,
    "f"
  ],
  [
    120230,
    1,
    "g"
  ],
  [
    120231,
    1,
    "h"
  ],
  [
    120232,
    1,
    "i"
  ],
  [
    120233,
    1,
    "j"
  ],
  [
    120234,
    1,
    "k"
  ],
  [
    120235,
    1,
    "l"
  ],
  [
    120236,
    1,
    "m"
  ],
  [
    120237,
    1,
    "n"
  ],
  [
    120238,
    1,
    "o"
  ],
  [
    120239,
    1,
    "p"
  ],
  [
    120240,
    1,
    "q"
  ],
  [
    120241,
    1,
    "r"
  ],
  [
    120242,
    1,
    "s"
  ],
  [
    120243,
    1,
    "t"
  ],
  [
    120244,
    1,
    "u"
  ],
  [
    120245,
    1,
    "v"
  ],
  [
    120246,
    1,
    "w"
  ],
  [
    120247,
    1,
    "x"
  ],
  [
    120248,
    1,
    "y"
  ],
  [
    120249,
    1,
    "z"
  ],
  [
    120250,
    1,
    "a"
  ],
  [
    120251,
    1,
    "b"
  ],
  [
    120252,
    1,
    "c"
  ],
  [
    120253,
    1,
    "d"
  ],
  [
    120254,
    1,
    "e"
  ],
  [
    120255,
    1,
    "f"
  ],
  [
    120256,
    1,
    "g"
  ],
  [
    120257,
    1,
    "h"
  ],
  [
    120258,
    1,
    "i"
  ],
  [
    120259,
    1,
    "j"
  ],
  [
    120260,
    1,
    "k"
  ],
  [
    120261,
    1,
    "l"
  ],
  [
    120262,
    1,
    "m"
  ],
  [
    120263,
    1,
    "n"
  ],
  [
    120264,
    1,
    "o"
  ],
  [
    120265,
    1,
    "p"
  ],
  [
    120266,
    1,
    "q"
  ],
  [
    120267,
    1,
    "r"
  ],
  [
    120268,
    1,
    "s"
  ],
  [
    120269,
    1,
    "t"
  ],
  [
    120270,
    1,
    "u"
  ],
  [
    120271,
    1,
    "v"
  ],
  [
    120272,
    1,
    "w"
  ],
  [
    120273,
    1,
    "x"
  ],
  [
    120274,
    1,
    "y"
  ],
  [
    120275,
    1,
    "z"
  ],
  [
    120276,
    1,
    "a"
  ],
  [
    120277,
    1,
    "b"
  ],
  [
    120278,
    1,
    "c"
  ],
  [
    120279,
    1,
    "d"
  ],
  [
    120280,
    1,
    "e"
  ],
  [
    120281,
    1,
    "f"
  ],
  [
    120282,
    1,
    "g"
  ],
  [
    120283,
    1,
    "h"
  ],
  [
    120284,
    1,
    "i"
  ],
  [
    120285,
    1,
    "j"
  ],
  [
    120286,
    1,
    "k"
  ],
  [
    120287,
    1,
    "l"
  ],
  [
    120288,
    1,
    "m"
  ],
  [
    120289,
    1,
    "n"
  ],
  [
    120290,
    1,
    "o"
  ],
  [
    120291,
    1,
    "p"
  ],
  [
    120292,
    1,
    "q"
  ],
  [
    120293,
    1,
    "r"
  ],
  [
    120294,
    1,
    "s"
  ],
  [
    120295,
    1,
    "t"
  ],
  [
    120296,
    1,
    "u"
  ],
  [
    120297,
    1,
    "v"
  ],
  [
    120298,
    1,
    "w"
  ],
  [
    120299,
    1,
    "x"
  ],
  [
    120300,
    1,
    "y"
  ],
  [
    120301,
    1,
    "z"
  ],
  [
    120302,
    1,
    "a"
  ],
  [
    120303,
    1,
    "b"
  ],
  [
    120304,
    1,
    "c"
  ],
  [
    120305,
    1,
    "d"
  ],
  [
    120306,
    1,
    "e"
  ],
  [
    120307,
    1,
    "f"
  ],
  [
    120308,
    1,
    "g"
  ],
  [
    120309,
    1,
    "h"
  ],
  [
    120310,
    1,
    "i"
  ],
  [
    120311,
    1,
    "j"
  ],
  [
    120312,
    1,
    "k"
  ],
  [
    120313,
    1,
    "l"
  ],
  [
    120314,
    1,
    "m"
  ],
  [
    120315,
    1,
    "n"
  ],
  [
    120316,
    1,
    "o"
  ],
  [
    120317,
    1,
    "p"
  ],
  [
    120318,
    1,
    "q"
  ],
  [
    120319,
    1,
    "r"
  ],
  [
    120320,
    1,
    "s"
  ],
  [
    120321,
    1,
    "t"
  ],
  [
    120322,
    1,
    "u"
  ],
  [
    120323,
    1,
    "v"
  ],
  [
    120324,
    1,
    "w"
  ],
  [
    120325,
    1,
    "x"
  ],
  [
    120326,
    1,
    "y"
  ],
  [
    120327,
    1,
    "z"
  ],
  [
    120328,
    1,
    "a"
  ],
  [
    120329,
    1,
    "b"
  ],
  [
    120330,
    1,
    "c"
  ],
  [
    120331,
    1,
    "d"
  ],
  [
    120332,
    1,
    "e"
  ],
  [
    120333,
    1,
    "f"
  ],
  [
    120334,
    1,
    "g"
  ],
  [
    120335,
    1,
    "h"
  ],
  [
    120336,
    1,
    "i"
  ],
  [
    120337,
    1,
    "j"
  ],
  [
    120338,
    1,
    "k"
  ],
  [
    120339,
    1,
    "l"
  ],
  [
    120340,
    1,
    "m"
  ],
  [
    120341,
    1,
    "n"
  ],
  [
    120342,
    1,
    "o"
  ],
  [
    120343,
    1,
    "p"
  ],
  [
    120344,
    1,
    "q"
  ],
  [
    120345,
    1,
    "r"
  ],
  [
    120346,
    1,
    "s"
  ],
  [
    120347,
    1,
    "t"
  ],
  [
    120348,
    1,
    "u"
  ],
  [
    120349,
    1,
    "v"
  ],
  [
    120350,
    1,
    "w"
  ],
  [
    120351,
    1,
    "x"
  ],
  [
    120352,
    1,
    "y"
  ],
  [
    120353,
    1,
    "z"
  ],
  [
    120354,
    1,
    "a"
  ],
  [
    120355,
    1,
    "b"
  ],
  [
    120356,
    1,
    "c"
  ],
  [
    120357,
    1,
    "d"
  ],
  [
    120358,
    1,
    "e"
  ],
  [
    120359,
    1,
    "f"
  ],
  [
    120360,
    1,
    "g"
  ],
  [
    120361,
    1,
    "h"
  ],
  [
    120362,
    1,
    "i"
  ],
  [
    120363,
    1,
    "j"
  ],
  [
    120364,
    1,
    "k"
  ],
  [
    120365,
    1,
    "l"
  ],
  [
    120366,
    1,
    "m"
  ],
  [
    120367,
    1,
    "n"
  ],
  [
    120368,
    1,
    "o"
  ],
  [
    120369,
    1,
    "p"
  ],
  [
    120370,
    1,
    "q"
  ],
  [
    120371,
    1,
    "r"
  ],
  [
    120372,
    1,
    "s"
  ],
  [
    120373,
    1,
    "t"
  ],
  [
    120374,
    1,
    "u"
  ],
  [
    120375,
    1,
    "v"
  ],
  [
    120376,
    1,
    "w"
  ],
  [
    120377,
    1,
    "x"
  ],
  [
    120378,
    1,
    "y"
  ],
  [
    120379,
    1,
    "z"
  ],
  [
    120380,
    1,
    "a"
  ],
  [
    120381,
    1,
    "b"
  ],
  [
    120382,
    1,
    "c"
  ],
  [
    120383,
    1,
    "d"
  ],
  [
    120384,
    1,
    "e"
  ],
  [
    120385,
    1,
    "f"
  ],
  [
    120386,
    1,
    "g"
  ],
  [
    120387,
    1,
    "h"
  ],
  [
    120388,
    1,
    "i"
  ],
  [
    120389,
    1,
    "j"
  ],
  [
    120390,
    1,
    "k"
  ],
  [
    120391,
    1,
    "l"
  ],
  [
    120392,
    1,
    "m"
  ],
  [
    120393,
    1,
    "n"
  ],
  [
    120394,
    1,
    "o"
  ],
  [
    120395,
    1,
    "p"
  ],
  [
    120396,
    1,
    "q"
  ],
  [
    120397,
    1,
    "r"
  ],
  [
    120398,
    1,
    "s"
  ],
  [
    120399,
    1,
    "t"
  ],
  [
    120400,
    1,
    "u"
  ],
  [
    120401,
    1,
    "v"
  ],
  [
    120402,
    1,
    "w"
  ],
  [
    120403,
    1,
    "x"
  ],
  [
    120404,
    1,
    "y"
  ],
  [
    120405,
    1,
    "z"
  ],
  [
    120406,
    1,
    "a"
  ],
  [
    120407,
    1,
    "b"
  ],
  [
    120408,
    1,
    "c"
  ],
  [
    120409,
    1,
    "d"
  ],
  [
    120410,
    1,
    "e"
  ],
  [
    120411,
    1,
    "f"
  ],
  [
    120412,
    1,
    "g"
  ],
  [
    120413,
    1,
    "h"
  ],
  [
    120414,
    1,
    "i"
  ],
  [
    120415,
    1,
    "j"
  ],
  [
    120416,
    1,
    "k"
  ],
  [
    120417,
    1,
    "l"
  ],
  [
    120418,
    1,
    "m"
  ],
  [
    120419,
    1,
    "n"
  ],
  [
    120420,
    1,
    "o"
  ],
  [
    120421,
    1,
    "p"
  ],
  [
    120422,
    1,
    "q"
  ],
  [
    120423,
    1,
    "r"
  ],
  [
    120424,
    1,
    "s"
  ],
  [
    120425,
    1,
    "t"
  ],
  [
    120426,
    1,
    "u"
  ],
  [
    120427,
    1,
    "v"
  ],
  [
    120428,
    1,
    "w"
  ],
  [
    120429,
    1,
    "x"
  ],
  [
    120430,
    1,
    "y"
  ],
  [
    120431,
    1,
    "z"
  ],
  [
    120432,
    1,
    "a"
  ],
  [
    120433,
    1,
    "b"
  ],
  [
    120434,
    1,
    "c"
  ],
  [
    120435,
    1,
    "d"
  ],
  [
    120436,
    1,
    "e"
  ],
  [
    120437,
    1,
    "f"
  ],
  [
    120438,
    1,
    "g"
  ],
  [
    120439,
    1,
    "h"
  ],
  [
    120440,
    1,
    "i"
  ],
  [
    120441,
    1,
    "j"
  ],
  [
    120442,
    1,
    "k"
  ],
  [
    120443,
    1,
    "l"
  ],
  [
    120444,
    1,
    "m"
  ],
  [
    120445,
    1,
    "n"
  ],
  [
    120446,
    1,
    "o"
  ],
  [
    120447,
    1,
    "p"
  ],
  [
    120448,
    1,
    "q"
  ],
  [
    120449,
    1,
    "r"
  ],
  [
    120450,
    1,
    "s"
  ],
  [
    120451,
    1,
    "t"
  ],
  [
    120452,
    1,
    "u"
  ],
  [
    120453,
    1,
    "v"
  ],
  [
    120454,
    1,
    "w"
  ],
  [
    120455,
    1,
    "x"
  ],
  [
    120456,
    1,
    "y"
  ],
  [
    120457,
    1,
    "z"
  ],
  [
    120458,
    1,
    "a"
  ],
  [
    120459,
    1,
    "b"
  ],
  [
    120460,
    1,
    "c"
  ],
  [
    120461,
    1,
    "d"
  ],
  [
    120462,
    1,
    "e"
  ],
  [
    120463,
    1,
    "f"
  ],
  [
    120464,
    1,
    "g"
  ],
  [
    120465,
    1,
    "h"
  ],
  [
    120466,
    1,
    "i"
  ],
  [
    120467,
    1,
    "j"
  ],
  [
    120468,
    1,
    "k"
  ],
  [
    120469,
    1,
    "l"
  ],
  [
    120470,
    1,
    "m"
  ],
  [
    120471,
    1,
    "n"
  ],
  [
    120472,
    1,
    "o"
  ],
  [
    120473,
    1,
    "p"
  ],
  [
    120474,
    1,
    "q"
  ],
  [
    120475,
    1,
    "r"
  ],
  [
    120476,
    1,
    "s"
  ],
  [
    120477,
    1,
    "t"
  ],
  [
    120478,
    1,
    "u"
  ],
  [
    120479,
    1,
    "v"
  ],
  [
    120480,
    1,
    "w"
  ],
  [
    120481,
    1,
    "x"
  ],
  [
    120482,
    1,
    "y"
  ],
  [
    120483,
    1,
    "z"
  ],
  [
    120484,
    1,
    ""
  ],
  [
    120485,
    1,
    ""
  ],
  [
    [
      120486,
      120487
    ],
    3
  ],
  [
    120488,
    1,
    ""
  ],
  [
    120489,
    1,
    ""
  ],
  [
    120490,
    1,
    ""
  ],
  [
    120491,
    1,
    ""
  ],
  [
    120492,
    1,
    ""
  ],
  [
    120493,
    1,
    ""
  ],
  [
    120494,
    1,
    ""
  ],
  [
    120495,
    1,
    ""
  ],
  [
    120496,
    1,
    ""
  ],
  [
    120497,
    1,
    ""
  ],
  [
    120498,
    1,
    ""
  ],
  [
    120499,
    1,
    ""
  ],
  [
    120500,
    1,
    ""
  ],
  [
    120501,
    1,
    ""
  ],
  [
    120502,
    1,
    ""
  ],
  [
    120503,
    1,
    ""
  ],
  [
    120504,
    1,
    ""
  ],
  [
    120505,
    1,
    ""
  ],
  [
    120506,
    1,
    ""
  ],
  [
    120507,
    1,
    ""
  ],
  [
    120508,
    1,
    ""
  ],
  [
    120509,
    1,
    ""
  ],
  [
    120510,
    1,
    ""
  ],
  [
    120511,
    1,
    ""
  ],
  [
    120512,
    1,
    ""
  ],
  [
    120513,
    1,
    ""
  ],
  [
    120514,
    1,
    ""
  ],
  [
    120515,
    1,
    ""
  ],
  [
    120516,
    1,
    ""
  ],
  [
    120517,
    1,
    ""
  ],
  [
    120518,
    1,
    ""
  ],
  [
    120519,
    1,
    ""
  ],
  [
    120520,
    1,
    ""
  ],
  [
    120521,
    1,
    ""
  ],
  [
    120522,
    1,
    ""
  ],
  [
    120523,
    1,
    ""
  ],
  [
    120524,
    1,
    ""
  ],
  [
    120525,
    1,
    ""
  ],
  [
    120526,
    1,
    ""
  ],
  [
    120527,
    1,
    ""
  ],
  [
    120528,
    1,
    ""
  ],
  [
    120529,
    1,
    ""
  ],
  [
    120530,
    1,
    ""
  ],
  [
    [
      120531,
      120532
    ],
    1,
    ""
  ],
  [
    120533,
    1,
    ""
  ],
  [
    120534,
    1,
    ""
  ],
  [
    120535,
    1,
    ""
  ],
  [
    120536,
    1,
    ""
  ],
  [
    120537,
    1,
    ""
  ],
  [
    120538,
    1,
    ""
  ],
  [
    120539,
    1,
    ""
  ],
  [
    120540,
    1,
    ""
  ],
  [
    120541,
    1,
    ""
  ],
  [
    120542,
    1,
    ""
  ],
  [
    120543,
    1,
    ""
  ],
  [
    120544,
    1,
    ""
  ],
  [
    120545,
    1,
    ""
  ],
  [
    120546,
    1,
    ""
  ],
  [
    120547,
    1,
    ""
  ],
  [
    120548,
    1,
    ""
  ],
  [
    120549,
    1,
    ""
  ],
  [
    120550,
    1,
    ""
  ],
  [
    120551,
    1,
    ""
  ],
  [
    120552,
    1,
    ""
  ],
  [
    120553,
    1,
    ""
  ],
  [
    120554,
    1,
    ""
  ],
  [
    120555,
    1,
    ""
  ],
  [
    120556,
    1,
    ""
  ],
  [
    120557,
    1,
    ""
  ],
  [
    120558,
    1,
    ""
  ],
  [
    120559,
    1,
    ""
  ],
  [
    120560,
    1,
    ""
  ],
  [
    120561,
    1,
    ""
  ],
  [
    120562,
    1,
    ""
  ],
  [
    120563,
    1,
    ""
  ],
  [
    120564,
    1,
    ""
  ],
  [
    120565,
    1,
    ""
  ],
  [
    120566,
    1,
    ""
  ],
  [
    120567,
    1,
    ""
  ],
  [
    120568,
    1,
    ""
  ],
  [
    120569,
    1,
    ""
  ],
  [
    120570,
    1,
    ""
  ],
  [
    120571,
    1,
    ""
  ],
  [
    120572,
    1,
    ""
  ],
  [
    120573,
    1,
    ""
  ],
  [
    120574,
    1,
    ""
  ],
  [
    120575,
    1,
    ""
  ],
  [
    120576,
    1,
    ""
  ],
  [
    120577,
    1,
    ""
  ],
  [
    120578,
    1,
    ""
  ],
  [
    120579,
    1,
    ""
  ],
  [
    120580,
    1,
    ""
  ],
  [
    120581,
    1,
    ""
  ],
  [
    120582,
    1,
    ""
  ],
  [
    120583,
    1,
    ""
  ],
  [
    120584,
    1,
    ""
  ],
  [
    120585,
    1,
    ""
  ],
  [
    120586,
    1,
    ""
  ],
  [
    120587,
    1,
    ""
  ],
  [
    120588,
    1,
    ""
  ],
  [
    [
      120589,
      120590
    ],
    1,
    ""
  ],
  [
    120591,
    1,
    ""
  ],
  [
    120592,
    1,
    ""
  ],
  [
    120593,
    1,
    ""
  ],
  [
    120594,
    1,
    ""
  ],
  [
    120595,
    1,
    ""
  ],
  [
    120596,
    1,
    ""
  ],
  [
    120597,
    1,
    ""
  ],
  [
    120598,
    1,
    ""
  ],
  [
    120599,
    1,
    ""
  ],
  [
    120600,
    1,
    ""
  ],
  [
    120601,
    1,
    ""
  ],
  [
    120602,
    1,
    ""
  ],
  [
    120603,
    1,
    ""
  ],
  [
    120604,
    1,
    ""
  ],
  [
    120605,
    1,
    ""
  ],
  [
    120606,
    1,
    ""
  ],
  [
    120607,
    1,
    ""
  ],
  [
    120608,
    1,
    ""
  ],
  [
    120609,
    1,
    ""
  ],
  [
    120610,
    1,
    ""
  ],
  [
    120611,
    1,
    ""
  ],
  [
    120612,
    1,
    ""
  ],
  [
    120613,
    1,
    ""
  ],
  [
    120614,
    1,
    ""
  ],
  [
    120615,
    1,
    ""
  ],
  [
    120616,
    1,
    ""
  ],
  [
    120617,
    1,
    ""
  ],
  [
    120618,
    1,
    ""
  ],
  [
    120619,
    1,
    ""
  ],
  [
    120620,
    1,
    ""
  ],
  [
    120621,
    1,
    ""
  ],
  [
    120622,
    1,
    ""
  ],
  [
    120623,
    1,
    ""
  ],
  [
    120624,
    1,
    ""
  ],
  [
    120625,
    1,
    ""
  ],
  [
    120626,
    1,
    ""
  ],
  [
    120627,
    1,
    ""
  ],
  [
    120628,
    1,
    ""
  ],
  [
    120629,
    1,
    ""
  ],
  [
    120630,
    1,
    ""
  ],
  [
    120631,
    1,
    ""
  ],
  [
    120632,
    1,
    ""
  ],
  [
    120633,
    1,
    ""
  ],
  [
    120634,
    1,
    ""
  ],
  [
    120635,
    1,
    ""
  ],
  [
    120636,
    1,
    ""
  ],
  [
    120637,
    1,
    ""
  ],
  [
    120638,
    1,
    ""
  ],
  [
    120639,
    1,
    ""
  ],
  [
    120640,
    1,
    ""
  ],
  [
    120641,
    1,
    ""
  ],
  [
    120642,
    1,
    ""
  ],
  [
    120643,
    1,
    ""
  ],
  [
    120644,
    1,
    ""
  ],
  [
    120645,
    1,
    ""
  ],
  [
    120646,
    1,
    ""
  ],
  [
    [
      120647,
      120648
    ],
    1,
    ""
  ],
  [
    120649,
    1,
    ""
  ],
  [
    120650,
    1,
    ""
  ],
  [
    120651,
    1,
    ""
  ],
  [
    120652,
    1,
    ""
  ],
  [
    120653,
    1,
    ""
  ],
  [
    120654,
    1,
    ""
  ],
  [
    120655,
    1,
    ""
  ],
  [
    120656,
    1,
    ""
  ],
  [
    120657,
    1,
    ""
  ],
  [
    120658,
    1,
    ""
  ],
  [
    120659,
    1,
    ""
  ],
  [
    120660,
    1,
    ""
  ],
  [
    120661,
    1,
    ""
  ],
  [
    120662,
    1,
    ""
  ],
  [
    120663,
    1,
    ""
  ],
  [
    120664,
    1,
    ""
  ],
  [
    120665,
    1,
    ""
  ],
  [
    120666,
    1,
    ""
  ],
  [
    120667,
    1,
    ""
  ],
  [
    120668,
    1,
    ""
  ],
  [
    120669,
    1,
    ""
  ],
  [
    120670,
    1,
    ""
  ],
  [
    120671,
    1,
    ""
  ],
  [
    120672,
    1,
    ""
  ],
  [
    120673,
    1,
    ""
  ],
  [
    120674,
    1,
    ""
  ],
  [
    120675,
    1,
    ""
  ],
  [
    120676,
    1,
    ""
  ],
  [
    120677,
    1,
    ""
  ],
  [
    120678,
    1,
    ""
  ],
  [
    120679,
    1,
    ""
  ],
  [
    120680,
    1,
    ""
  ],
  [
    120681,
    1,
    ""
  ],
  [
    120682,
    1,
    ""
  ],
  [
    120683,
    1,
    ""
  ],
  [
    120684,
    1,
    ""
  ],
  [
    120685,
    1,
    ""
  ],
  [
    120686,
    1,
    ""
  ],
  [
    120687,
    1,
    ""
  ],
  [
    120688,
    1,
    ""
  ],
  [
    120689,
    1,
    ""
  ],
  [
    120690,
    1,
    ""
  ],
  [
    120691,
    1,
    ""
  ],
  [
    120692,
    1,
    ""
  ],
  [
    120693,
    1,
    ""
  ],
  [
    120694,
    1,
    ""
  ],
  [
    120695,
    1,
    ""
  ],
  [
    120696,
    1,
    ""
  ],
  [
    120697,
    1,
    ""
  ],
  [
    120698,
    1,
    ""
  ],
  [
    120699,
    1,
    ""
  ],
  [
    120700,
    1,
    ""
  ],
  [
    120701,
    1,
    ""
  ],
  [
    120702,
    1,
    ""
  ],
  [
    120703,
    1,
    ""
  ],
  [
    120704,
    1,
    ""
  ],
  [
    [
      120705,
      120706
    ],
    1,
    ""
  ],
  [
    120707,
    1,
    ""
  ],
  [
    120708,
    1,
    ""
  ],
  [
    120709,
    1,
    ""
  ],
  [
    120710,
    1,
    ""
  ],
  [
    120711,
    1,
    ""
  ],
  [
    120712,
    1,
    ""
  ],
  [
    120713,
    1,
    ""
  ],
  [
    120714,
    1,
    ""
  ],
  [
    120715,
    1,
    ""
  ],
  [
    120716,
    1,
    ""
  ],
  [
    120717,
    1,
    ""
  ],
  [
    120718,
    1,
    ""
  ],
  [
    120719,
    1,
    ""
  ],
  [
    120720,
    1,
    ""
  ],
  [
    120721,
    1,
    ""
  ],
  [
    120722,
    1,
    ""
  ],
  [
    120723,
    1,
    ""
  ],
  [
    120724,
    1,
    ""
  ],
  [
    120725,
    1,
    ""
  ],
  [
    120726,
    1,
    ""
  ],
  [
    120727,
    1,
    ""
  ],
  [
    120728,
    1,
    ""
  ],
  [
    120729,
    1,
    ""
  ],
  [
    120730,
    1,
    ""
  ],
  [
    120731,
    1,
    ""
  ],
  [
    120732,
    1,
    ""
  ],
  [
    120733,
    1,
    ""
  ],
  [
    120734,
    1,
    ""
  ],
  [
    120735,
    1,
    ""
  ],
  [
    120736,
    1,
    ""
  ],
  [
    120737,
    1,
    ""
  ],
  [
    120738,
    1,
    ""
  ],
  [
    120739,
    1,
    ""
  ],
  [
    120740,
    1,
    ""
  ],
  [
    120741,
    1,
    ""
  ],
  [
    120742,
    1,
    ""
  ],
  [
    120743,
    1,
    ""
  ],
  [
    120744,
    1,
    ""
  ],
  [
    120745,
    1,
    ""
  ],
  [
    120746,
    1,
    ""
  ],
  [
    120747,
    1,
    ""
  ],
  [
    120748,
    1,
    ""
  ],
  [
    120749,
    1,
    ""
  ],
  [
    120750,
    1,
    ""
  ],
  [
    120751,
    1,
    ""
  ],
  [
    120752,
    1,
    ""
  ],
  [
    120753,
    1,
    ""
  ],
  [
    120754,
    1,
    ""
  ],
  [
    120755,
    1,
    ""
  ],
  [
    120756,
    1,
    ""
  ],
  [
    120757,
    1,
    ""
  ],
  [
    120758,
    1,
    ""
  ],
  [
    120759,
    1,
    ""
  ],
  [
    120760,
    1,
    ""
  ],
  [
    120761,
    1,
    ""
  ],
  [
    120762,
    1,
    ""
  ],
  [
    [
      120763,
      120764
    ],
    1,
    ""
  ],
  [
    120765,
    1,
    ""
  ],
  [
    120766,
    1,
    ""
  ],
  [
    120767,
    1,
    ""
  ],
  [
    120768,
    1,
    ""
  ],
  [
    120769,
    1,
    ""
  ],
  [
    120770,
    1,
    ""
  ],
  [
    120771,
    1,
    ""
  ],
  [
    120772,
    1,
    ""
  ],
  [
    120773,
    1,
    ""
  ],
  [
    120774,
    1,
    ""
  ],
  [
    120775,
    1,
    ""
  ],
  [
    120776,
    1,
    ""
  ],
  [
    120777,
    1,
    ""
  ],
  [
    [
      120778,
      120779
    ],
    1,
    ""
  ],
  [
    [
      120780,
      120781
    ],
    3
  ],
  [
    120782,
    1,
    "0"
  ],
  [
    120783,
    1,
    "1"
  ],
  [
    120784,
    1,
    "2"
  ],
  [
    120785,
    1,
    "3"
  ],
  [
    120786,
    1,
    "4"
  ],
  [
    120787,
    1,
    "5"
  ],
  [
    120788,
    1,
    "6"
  ],
  [
    120789,
    1,
    "7"
  ],
  [
    120790,
    1,
    "8"
  ],
  [
    120791,
    1,
    "9"
  ],
  [
    120792,
    1,
    "0"
  ],
  [
    120793,
    1,
    "1"
  ],
  [
    120794,
    1,
    "2"
  ],
  [
    120795,
    1,
    "3"
  ],
  [
    120796,
    1,
    "4"
  ],
  [
    120797,
    1,
    "5"
  ],
  [
    120798,
    1,
    "6"
  ],
  [
    120799,
    1,
    "7"
  ],
  [
    120800,
    1,
    "8"
  ],
  [
    120801,
    1,
    "9"
  ],
  [
    120802,
    1,
    "0"
  ],
  [
    120803,
    1,
    "1"
  ],
  [
    120804,
    1,
    "2"
  ],
  [
    120805,
    1,
    "3"
  ],
  [
    120806,
    1,
    "4"
  ],
  [
    120807,
    1,
    "5"
  ],
  [
    120808,
    1,
    "6"
  ],
  [
    120809,
    1,
    "7"
  ],
  [
    120810,
    1,
    "8"
  ],
  [
    120811,
    1,
    "9"
  ],
  [
    120812,
    1,
    "0"
  ],
  [
    120813,
    1,
    "1"
  ],
  [
    120814,
    1,
    "2"
  ],
  [
    120815,
    1,
    "3"
  ],
  [
    120816,
    1,
    "4"
  ],
  [
    120817,
    1,
    "5"
  ],
  [
    120818,
    1,
    "6"
  ],
  [
    120819,
    1,
    "7"
  ],
  [
    120820,
    1,
    "8"
  ],
  [
    120821,
    1,
    "9"
  ],
  [
    120822,
    1,
    "0"
  ],
  [
    120823,
    1,
    "1"
  ],
  [
    120824,
    1,
    "2"
  ],
  [
    120825,
    1,
    "3"
  ],
  [
    120826,
    1,
    "4"
  ],
  [
    120827,
    1,
    "5"
  ],
  [
    120828,
    1,
    "6"
  ],
  [
    120829,
    1,
    "7"
  ],
  [
    120830,
    1,
    "8"
  ],
  [
    120831,
    1,
    "9"
  ],
  [
    [
      120832,
      121343
    ],
    2
  ],
  [
    [
      121344,
      121398
    ],
    2
  ],
  [
    [
      121399,
      121402
    ],
    2
  ],
  [
    [
      121403,
      121452
    ],
    2
  ],
  [
    [
      121453,
      121460
    ],
    2
  ],
  [
    121461,
    2
  ],
  [
    [
      121462,
      121475
    ],
    2
  ],
  [
    121476,
    2
  ],
  [
    [
      121477,
      121483
    ],
    2
  ],
  [
    [
      121484,
      121498
    ],
    3
  ],
  [
    [
      121499,
      121503
    ],
    2
  ],
  [
    121504,
    3
  ],
  [
    [
      121505,
      121519
    ],
    2
  ],
  [
    [
      121520,
      122623
    ],
    3
  ],
  [
    [
      122624,
      122654
    ],
    2
  ],
  [
    [
      122655,
      122660
    ],
    3
  ],
  [
    [
      122661,
      122666
    ],
    2
  ],
  [
    [
      122667,
      122879
    ],
    3
  ],
  [
    [
      122880,
      122886
    ],
    2
  ],
  [
    122887,
    3
  ],
  [
    [
      122888,
      122904
    ],
    2
  ],
  [
    [
      122905,
      122906
    ],
    3
  ],
  [
    [
      122907,
      122913
    ],
    2
  ],
  [
    122914,
    3
  ],
  [
    [
      122915,
      122916
    ],
    2
  ],
  [
    122917,
    3
  ],
  [
    [
      122918,
      122922
    ],
    2
  ],
  [
    [
      122923,
      122927
    ],
    3
  ],
  [
    122928,
    1,
    ""
  ],
  [
    122929,
    1,
    ""
  ],
  [
    122930,
    1,
    ""
  ],
  [
    122931,
    1,
    ""
  ],
  [
    122932,
    1,
    ""
  ],
  [
    122933,
    1,
    ""
  ],
  [
    122934,
    1,
    ""
  ],
  [
    122935,
    1,
    ""
  ],
  [
    122936,
    1,
    ""
  ],
  [
    122937,
    1,
    ""
  ],
  [
    122938,
    1,
    ""
  ],
  [
    122939,
    1,
    ""
  ],
  [
    122940,
    1,
    ""
  ],
  [
    122941,
    1,
    ""
  ],
  [
    122942,
    1,
    ""
  ],
  [
    122943,
    1,
    ""
  ],
  [
    122944,
    1,
    ""
  ],
  [
    122945,
    1,
    ""
  ],
  [
    122946,
    1,
    ""
  ],
  [
    122947,
    1,
    ""
  ],
  [
    122948,
    1,
    ""
  ],
  [
    122949,
    1,
    ""
  ],
  [
    122950,
    1,
    ""
  ],
  [
    122951,
    1,
    ""
  ],
  [
    122952,
    1,
    ""
  ],
  [
    122953,
    1,
    ""
  ],
  [
    122954,
    1,
    ""
  ],
  [
    122955,
    1,
    ""
  ],
  [
    122956,
    1,
    ""
  ],
  [
    122957,
    1,
    ""
  ],
  [
    122958,
    1,
    ""
  ],
  [
    122959,
    1,
    ""
  ],
  [
    122960,
    1,
    ""
  ],
  [
    122961,
    1,
    ""
  ],
  [
    122962,
    1,
    ""
  ],
  [
    122963,
    1,
    ""
  ],
  [
    122964,
    1,
    ""
  ],
  [
    122965,
    1,
    ""
  ],
  [
    122966,
    1,
    ""
  ],
  [
    122967,
    1,
    ""
  ],
  [
    122968,
    1,
    ""
  ],
  [
    122969,
    1,
    ""
  ],
  [
    122970,
    1,
    ""
  ],
  [
    122971,
    1,
    ""
  ],
  [
    122972,
    1,
    ""
  ],
  [
    122973,
    1,
    ""
  ],
  [
    122974,
    1,
    ""
  ],
  [
    122975,
    1,
    ""
  ],
  [
    122976,
    1,
    ""
  ],
  [
    122977,
    1,
    ""
  ],
  [
    122978,
    1,
    ""
  ],
  [
    122979,
    1,
    ""
  ],
  [
    122980,
    1,
    ""
  ],
  [
    122981,
    1,
    ""
  ],
  [
    122982,
    1,
    ""
  ],
  [
    122983,
    1,
    ""
  ],
  [
    122984,
    1,
    ""
  ],
  [
    122985,
    1,
    ""
  ],
  [
    122986,
    1,
    ""
  ],
  [
    122987,
    1,
    ""
  ],
  [
    122988,
    1,
    ""
  ],
  [
    122989,
    1,
    ""
  ],
  [
    [
      122990,
      123022
    ],
    3
  ],
  [
    123023,
    2
  ],
  [
    [
      123024,
      123135
    ],
    3
  ],
  [
    [
      123136,
      123180
    ],
    2
  ],
  [
    [
      123181,
      123183
    ],
    3
  ],
  [
    [
      123184,
      123197
    ],
    2
  ],
  [
    [
      123198,
      123199
    ],
    3
  ],
  [
    [
      123200,
      123209
    ],
    2
  ],
  [
    [
      123210,
      123213
    ],
    3
  ],
  [
    123214,
    2
  ],
  [
    123215,
    2
  ],
  [
    [
      123216,
      123535
    ],
    3
  ],
  [
    [
      123536,
      123566
    ],
    2
  ],
  [
    [
      123567,
      123583
    ],
    3
  ],
  [
    [
      123584,
      123641
    ],
    2
  ],
  [
    [
      123642,
      123646
    ],
    3
  ],
  [
    123647,
    2
  ],
  [
    [
      123648,
      124111
    ],
    3
  ],
  [
    [
      124112,
      124153
    ],
    2
  ],
  [
    [
      124154,
      124895
    ],
    3
  ],
  [
    [
      124896,
      124902
    ],
    2
  ],
  [
    124903,
    3
  ],
  [
    [
      124904,
      124907
    ],
    2
  ],
  [
    124908,
    3
  ],
  [
    [
      124909,
      124910
    ],
    2
  ],
  [
    124911,
    3
  ],
  [
    [
      124912,
      124926
    ],
    2
  ],
  [
    124927,
    3
  ],
  [
    [
      124928,
      125124
    ],
    2
  ],
  [
    [
      125125,
      125126
    ],
    3
  ],
  [
    [
      125127,
      125135
    ],
    2
  ],
  [
    [
      125136,
      125142
    ],
    2
  ],
  [
    [
      125143,
      125183
    ],
    3
  ],
  [
    125184,
    1,
    ""
  ],
  [
    125185,
    1,
    ""
  ],
  [
    125186,
    1,
    ""
  ],
  [
    125187,
    1,
    ""
  ],
  [
    125188,
    1,
    ""
  ],
  [
    125189,
    1,
    ""
  ],
  [
    125190,
    1,
    ""
  ],
  [
    125191,
    1,
    ""
  ],
  [
    125192,
    1,
    ""
  ],
  [
    125193,
    1,
    ""
  ],
  [
    125194,
    1,
    ""
  ],
  [
    125195,
    1,
    ""
  ],
  [
    125196,
    1,
    ""
  ],
  [
    125197,
    1,
    ""
  ],
  [
    125198,
    1,
    ""
  ],
  [
    125199,
    1,
    ""
  ],
  [
    125200,
    1,
    ""
  ],
  [
    125201,
    1,
    ""
  ],
  [
    125202,
    1,
    ""
  ],
  [
    125203,
    1,
    ""
  ],
  [
    125204,
    1,
    ""
  ],
  [
    125205,
    1,
    ""
  ],
  [
    125206,
    1,
    ""
  ],
  [
    125207,
    1,
    ""
  ],
  [
    125208,
    1,
    ""
  ],
  [
    125209,
    1,
    ""
  ],
  [
    125210,
    1,
    ""
  ],
  [
    125211,
    1,
    ""
  ],
  [
    125212,
    1,
    ""
  ],
  [
    125213,
    1,
    ""
  ],
  [
    125214,
    1,
    ""
  ],
  [
    125215,
    1,
    ""
  ],
  [
    125216,
    1,
    ""
  ],
  [
    125217,
    1,
    ""
  ],
  [
    [
      125218,
      125258
    ],
    2
  ],
  [
    125259,
    2
  ],
  [
    [
      125260,
      125263
    ],
    3
  ],
  [
    [
      125264,
      125273
    ],
    2
  ],
  [
    [
      125274,
      125277
    ],
    3
  ],
  [
    [
      125278,
      125279
    ],
    2
  ],
  [
    [
      125280,
      126064
    ],
    3
  ],
  [
    [
      126065,
      126132
    ],
    2
  ],
  [
    [
      126133,
      126208
    ],
    3
  ],
  [
    [
      126209,
      126269
    ],
    2
  ],
  [
    [
      126270,
      126463
    ],
    3
  ],
  [
    126464,
    1,
    ""
  ],
  [
    126465,
    1,
    ""
  ],
  [
    126466,
    1,
    ""
  ],
  [
    126467,
    1,
    ""
  ],
  [
    126468,
    3
  ],
  [
    126469,
    1,
    ""
  ],
  [
    126470,
    1,
    ""
  ],
  [
    126471,
    1,
    ""
  ],
  [
    126472,
    1,
    ""
  ],
  [
    126473,
    1,
    ""
  ],
  [
    126474,
    1,
    ""
  ],
  [
    126475,
    1,
    ""
  ],
  [
    126476,
    1,
    ""
  ],
  [
    126477,
    1,
    ""
  ],
  [
    126478,
    1,
    ""
  ],
  [
    126479,
    1,
    ""
  ],
  [
    126480,
    1,
    ""
  ],
  [
    126481,
    1,
    ""
  ],
  [
    126482,
    1,
    ""
  ],
  [
    126483,
    1,
    ""
  ],
  [
    126484,
    1,
    ""
  ],
  [
    126485,
    1,
    ""
  ],
  [
    126486,
    1,
    ""
  ],
  [
    126487,
    1,
    ""
  ],
  [
    126488,
    1,
    ""
  ],
  [
    126489,
    1,
    ""
  ],
  [
    126490,
    1,
    ""
  ],
  [
    126491,
    1,
    ""
  ],
  [
    126492,
    1,
    ""
  ],
  [
    126493,
    1,
    ""
  ],
  [
    126494,
    1,
    ""
  ],
  [
    126495,
    1,
    ""
  ],
  [
    126496,
    3
  ],
  [
    126497,
    1,
    ""
  ],
  [
    126498,
    1,
    ""
  ],
  [
    126499,
    3
  ],
  [
    126500,
    1,
    ""
  ],
  [
    [
      126501,
      126502
    ],
    3
  ],
  [
    126503,
    1,
    ""
  ],
  [
    126504,
    3
  ],
  [
    126505,
    1,
    ""
  ],
  [
    126506,
    1,
    ""
  ],
  [
    126507,
    1,
    ""
  ],
  [
    126508,
    1,
    ""
  ],
  [
    126509,
    1,
    ""
  ],
  [
    126510,
    1,
    ""
  ],
  [
    126511,
    1,
    ""
  ],
  [
    126512,
    1,
    ""
  ],
  [
    126513,
    1,
    ""
  ],
  [
    126514,
    1,
    ""
  ],
  [
    126515,
    3
  ],
  [
    126516,
    1,
    ""
  ],
  [
    126517,
    1,
    ""
  ],
  [
    126518,
    1,
    ""
  ],
  [
    126519,
    1,
    ""
  ],
  [
    126520,
    3
  ],
  [
    126521,
    1,
    ""
  ],
  [
    126522,
    3
  ],
  [
    126523,
    1,
    ""
  ],
  [
    [
      126524,
      126529
    ],
    3
  ],
  [
    126530,
    1,
    ""
  ],
  [
    [
      126531,
      126534
    ],
    3
  ],
  [
    126535,
    1,
    ""
  ],
  [
    126536,
    3
  ],
  [
    126537,
    1,
    ""
  ],
  [
    126538,
    3
  ],
  [
    126539,
    1,
    ""
  ],
  [
    126540,
    3
  ],
  [
    126541,
    1,
    ""
  ],
  [
    126542,
    1,
    ""
  ],
  [
    126543,
    1,
    ""
  ],
  [
    126544,
    3
  ],
  [
    126545,
    1,
    ""
  ],
  [
    126546,
    1,
    ""
  ],
  [
    126547,
    3
  ],
  [
    126548,
    1,
    ""
  ],
  [
    [
      126549,
      126550
    ],
    3
  ],
  [
    126551,
    1,
    ""
  ],
  [
    126552,
    3
  ],
  [
    126553,
    1,
    ""
  ],
  [
    126554,
    3
  ],
  [
    126555,
    1,
    ""
  ],
  [
    126556,
    3
  ],
  [
    126557,
    1,
    ""
  ],
  [
    126558,
    3
  ],
  [
    126559,
    1,
    ""
  ],
  [
    126560,
    3
  ],
  [
    126561,
    1,
    ""
  ],
  [
    126562,
    1,
    ""
  ],
  [
    126563,
    3
  ],
  [
    126564,
    1,
    ""
  ],
  [
    [
      126565,
      126566
    ],
    3
  ],
  [
    126567,
    1,
    ""
  ],
  [
    126568,
    1,
    ""
  ],
  [
    126569,
    1,
    ""
  ],
  [
    126570,
    1,
    ""
  ],
  [
    126571,
    3
  ],
  [
    126572,
    1,
    ""
  ],
  [
    126573,
    1,
    ""
  ],
  [
    126574,
    1,
    ""
  ],
  [
    126575,
    1,
    ""
  ],
  [
    126576,
    1,
    ""
  ],
  [
    126577,
    1,
    ""
  ],
  [
    126578,
    1,
    ""
  ],
  [
    126579,
    3
  ],
  [
    126580,
    1,
    ""
  ],
  [
    126581,
    1,
    ""
  ],
  [
    126582,
    1,
    ""
  ],
  [
    126583,
    1,
    ""
  ],
  [
    126584,
    3
  ],
  [
    126585,
    1,
    ""
  ],
  [
    126586,
    1,
    ""
  ],
  [
    126587,
    1,
    ""
  ],
  [
    126588,
    1,
    ""
  ],
  [
    126589,
    3
  ],
  [
    126590,
    1,
    ""
  ],
  [
    126591,
    3
  ],
  [
    126592,
    1,
    ""
  ],
  [
    126593,
    1,
    ""
  ],
  [
    126594,
    1,
    ""
  ],
  [
    126595,
    1,
    ""
  ],
  [
    126596,
    1,
    ""
  ],
  [
    126597,
    1,
    ""
  ],
  [
    126598,
    1,
    ""
  ],
  [
    126599,
    1,
    ""
  ],
  [
    126600,
    1,
    ""
  ],
  [
    126601,
    1,
    ""
  ],
  [
    126602,
    3
  ],
  [
    126603,
    1,
    ""
  ],
  [
    126604,
    1,
    ""
  ],
  [
    126605,
    1,
    ""
  ],
  [
    126606,
    1,
    ""
  ],
  [
    126607,
    1,
    ""
  ],
  [
    126608,
    1,
    ""
  ],
  [
    126609,
    1,
    ""
  ],
  [
    126610,
    1,
    ""
  ],
  [
    126611,
    1,
    ""
  ],
  [
    126612,
    1,
    ""
  ],
  [
    126613,
    1,
    ""
  ],
  [
    126614,
    1,
    ""
  ],
  [
    126615,
    1,
    ""
  ],
  [
    126616,
    1,
    ""
  ],
  [
    126617,
    1,
    ""
  ],
  [
    126618,
    1,
    ""
  ],
  [
    126619,
    1,
    ""
  ],
  [
    [
      126620,
      126624
    ],
    3
  ],
  [
    126625,
    1,
    ""
  ],
  [
    126626,
    1,
    ""
  ],
  [
    126627,
    1,
    ""
  ],
  [
    126628,
    3
  ],
  [
    126629,
    1,
    ""
  ],
  [
    126630,
    1,
    ""
  ],
  [
    126631,
    1,
    ""
  ],
  [
    126632,
    1,
    ""
  ],
  [
    126633,
    1,
    ""
  ],
  [
    126634,
    3
  ],
  [
    126635,
    1,
    ""
  ],
  [
    126636,
    1,
    ""
  ],
  [
    126637,
    1,
    ""
  ],
  [
    126638,
    1,
    ""
  ],
  [
    126639,
    1,
    ""
  ],
  [
    126640,
    1,
    ""
  ],
  [
    126641,
    1,
    ""
  ],
  [
    126642,
    1,
    ""
  ],
  [
    126643,
    1,
    ""
  ],
  [
    126644,
    1,
    ""
  ],
  [
    126645,
    1,
    ""
  ],
  [
    126646,
    1,
    ""
  ],
  [
    126647,
    1,
    ""
  ],
  [
    126648,
    1,
    ""
  ],
  [
    126649,
    1,
    ""
  ],
  [
    126650,
    1,
    ""
  ],
  [
    126651,
    1,
    ""
  ],
  [
    [
      126652,
      126703
    ],
    3
  ],
  [
    [
      126704,
      126705
    ],
    2
  ],
  [
    [
      126706,
      126975
    ],
    3
  ],
  [
    [
      126976,
      127019
    ],
    2
  ],
  [
    [
      127020,
      127023
    ],
    3
  ],
  [
    [
      127024,
      127123
    ],
    2
  ],
  [
    [
      127124,
      127135
    ],
    3
  ],
  [
    [
      127136,
      127150
    ],
    2
  ],
  [
    [
      127151,
      127152
    ],
    3
  ],
  [
    [
      127153,
      127166
    ],
    2
  ],
  [
    127167,
    2
  ],
  [
    127168,
    3
  ],
  [
    [
      127169,
      127183
    ],
    2
  ],
  [
    127184,
    3
  ],
  [
    [
      127185,
      127199
    ],
    2
  ],
  [
    [
      127200,
      127221
    ],
    2
  ],
  [
    [
      127222,
      127231
    ],
    3
  ],
  [
    127232,
    3
  ],
  [
    127233,
    5,
    "0,"
  ],
  [
    127234,
    5,
    "1,"
  ],
  [
    127235,
    5,
    "2,"
  ],
  [
    127236,
    5,
    "3,"
  ],
  [
    127237,
    5,
    "4,"
  ],
  [
    127238,
    5,
    "5,"
  ],
  [
    127239,
    5,
    "6,"
  ],
  [
    127240,
    5,
    "7,"
  ],
  [
    127241,
    5,
    "8,"
  ],
  [
    127242,
    5,
    "9,"
  ],
  [
    [
      127243,
      127244
    ],
    2
  ],
  [
    [
      127245,
      127247
    ],
    2
  ],
  [
    127248,
    5,
    "(a)"
  ],
  [
    127249,
    5,
    "(b)"
  ],
  [
    127250,
    5,
    "(c)"
  ],
  [
    127251,
    5,
    "(d)"
  ],
  [
    127252,
    5,
    "(e)"
  ],
  [
    127253,
    5,
    "(f)"
  ],
  [
    127254,
    5,
    "(g)"
  ],
  [
    127255,
    5,
    "(h)"
  ],
  [
    127256,
    5,
    "(i)"
  ],
  [
    127257,
    5,
    "(j)"
  ],
  [
    127258,
    5,
    "(k)"
  ],
  [
    127259,
    5,
    "(l)"
  ],
  [
    127260,
    5,
    "(m)"
  ],
  [
    127261,
    5,
    "(n)"
  ],
  [
    127262,
    5,
    "(o)"
  ],
  [
    127263,
    5,
    "(p)"
  ],
  [
    127264,
    5,
    "(q)"
  ],
  [
    127265,
    5,
    "(r)"
  ],
  [
    127266,
    5,
    "(s)"
  ],
  [
    127267,
    5,
    "(t)"
  ],
  [
    127268,
    5,
    "(u)"
  ],
  [
    127269,
    5,
    "(v)"
  ],
  [
    127270,
    5,
    "(w)"
  ],
  [
    127271,
    5,
    "(x)"
  ],
  [
    127272,
    5,
    "(y)"
  ],
  [
    127273,
    5,
    "(z)"
  ],
  [
    127274,
    1,
    "s"
  ],
  [
    127275,
    1,
    "c"
  ],
  [
    127276,
    1,
    "r"
  ],
  [
    127277,
    1,
    "cd"
  ],
  [
    127278,
    1,
    "wz"
  ],
  [
    127279,
    2
  ],
  [
    127280,
    1,
    "a"
  ],
  [
    127281,
    1,
    "b"
  ],
  [
    127282,
    1,
    "c"
  ],
  [
    127283,
    1,
    "d"
  ],
  [
    127284,
    1,
    "e"
  ],
  [
    127285,
    1,
    "f"
  ],
  [
    127286,
    1,
    "g"
  ],
  [
    127287,
    1,
    "h"
  ],
  [
    127288,
    1,
    "i"
  ],
  [
    127289,
    1,
    "j"
  ],
  [
    127290,
    1,
    "k"
  ],
  [
    127291,
    1,
    "l"
  ],
  [
    127292,
    1,
    "m"
  ],
  [
    127293,
    1,
    "n"
  ],
  [
    127294,
    1,
    "o"
  ],
  [
    127295,
    1,
    "p"
  ],
  [
    127296,
    1,
    "q"
  ],
  [
    127297,
    1,
    "r"
  ],
  [
    127298,
    1,
    "s"
  ],
  [
    127299,
    1,
    "t"
  ],
  [
    127300,
    1,
    "u"
  ],
  [
    127301,
    1,
    "v"
  ],
  [
    127302,
    1,
    "w"
  ],
  [
    127303,
    1,
    "x"
  ],
  [
    127304,
    1,
    "y"
  ],
  [
    127305,
    1,
    "z"
  ],
  [
    127306,
    1,
    "hv"
  ],
  [
    127307,
    1,
    "mv"
  ],
  [
    127308,
    1,
    "sd"
  ],
  [
    127309,
    1,
    "ss"
  ],
  [
    127310,
    1,
    "ppv"
  ],
  [
    127311,
    1,
    "wc"
  ],
  [
    [
      127312,
      127318
    ],
    2
  ],
  [
    127319,
    2
  ],
  [
    [
      127320,
      127326
    ],
    2
  ],
  [
    127327,
    2
  ],
  [
    [
      127328,
      127337
    ],
    2
  ],
  [
    127338,
    1,
    "mc"
  ],
  [
    127339,
    1,
    "md"
  ],
  [
    127340,
    1,
    "mr"
  ],
  [
    [
      127341,
      127343
    ],
    2
  ],
  [
    [
      127344,
      127352
    ],
    2
  ],
  [
    127353,
    2
  ],
  [
    127354,
    2
  ],
  [
    [
      127355,
      127356
    ],
    2
  ],
  [
    [
      127357,
      127358
    ],
    2
  ],
  [
    127359,
    2
  ],
  [
    [
      127360,
      127369
    ],
    2
  ],
  [
    [
      127370,
      127373
    ],
    2
  ],
  [
    [
      127374,
      127375
    ],
    2
  ],
  [
    127376,
    1,
    "dj"
  ],
  [
    [
      127377,
      127386
    ],
    2
  ],
  [
    [
      127387,
      127404
    ],
    2
  ],
  [
    127405,
    2
  ],
  [
    [
      127406,
      127461
    ],
    3
  ],
  [
    [
      127462,
      127487
    ],
    2
  ],
  [
    127488,
    1,
    ""
  ],
  [
    127489,
    1,
    ""
  ],
  [
    127490,
    1,
    ""
  ],
  [
    [
      127491,
      127503
    ],
    3
  ],
  [
    127504,
    1,
    ""
  ],
  [
    127505,
    1,
    ""
  ],
  [
    127506,
    1,
    ""
  ],
  [
    127507,
    1,
    ""
  ],
  [
    127508,
    1,
    ""
  ],
  [
    127509,
    1,
    ""
  ],
  [
    127510,
    1,
    ""
  ],
  [
    127511,
    1,
    ""
  ],
  [
    127512,
    1,
    ""
  ],
  [
    127513,
    1,
    ""
  ],
  [
    127514,
    1,
    ""
  ],
  [
    127515,
    1,
    ""
  ],
  [
    127516,
    1,
    ""
  ],
  [
    127517,
    1,
    ""
  ],
  [
    127518,
    1,
    ""
  ],
  [
    127519,
    1,
    ""
  ],
  [
    127520,
    1,
    ""
  ],
  [
    127521,
    1,
    ""
  ],
  [
    127522,
    1,
    ""
  ],
  [
    127523,
    1,
    ""
  ],
  [
    127524,
    1,
    ""
  ],
  [
    127525,
    1,
    ""
  ],
  [
    127526,
    1,
    ""
  ],
  [
    127527,
    1,
    ""
  ],
  [
    127528,
    1,
    ""
  ],
  [
    127529,
    1,
    ""
  ],
  [
    127530,
    1,
    ""
  ],
  [
    127531,
    1,
    ""
  ],
  [
    127532,
    1,
    ""
  ],
  [
    127533,
    1,
    ""
  ],
  [
    127534,
    1,
    ""
  ],
  [
    127535,
    1,
    ""
  ],
  [
    127536,
    1,
    ""
  ],
  [
    127537,
    1,
    ""
  ],
  [
    127538,
    1,
    ""
  ],
  [
    127539,
    1,
    ""
  ],
  [
    127540,
    1,
    ""
  ],
  [
    127541,
    1,
    ""
  ],
  [
    127542,
    1,
    ""
  ],
  [
    127543,
    1,
    ""
  ],
  [
    127544,
    1,
    ""
  ],
  [
    127545,
    1,
    ""
  ],
  [
    127546,
    1,
    ""
  ],
  [
    127547,
    1,
    ""
  ],
  [
    [
      127548,
      127551
    ],
    3
  ],
  [
    127552,
    1,
    ""
  ],
  [
    127553,
    1,
    ""
  ],
  [
    127554,
    1,
    ""
  ],
  [
    127555,
    1,
    ""
  ],
  [
    127556,
    1,
    ""
  ],
  [
    127557,
    1,
    ""
  ],
  [
    127558,
    1,
    ""
  ],
  [
    127559,
    1,
    ""
  ],
  [
    127560,
    1,
    ""
  ],
  [
    [
      127561,
      127567
    ],
    3
  ],
  [
    127568,
    1,
    ""
  ],
  [
    127569,
    1,
    ""
  ],
  [
    [
      127570,
      127583
    ],
    3
  ],
  [
    [
      127584,
      127589
    ],
    2
  ],
  [
    [
      127590,
      127743
    ],
    3
  ],
  [
    [
      127744,
      127776
    ],
    2
  ],
  [
    [
      127777,
      127788
    ],
    2
  ],
  [
    [
      127789,
      127791
    ],
    2
  ],
  [
    [
      127792,
      127797
    ],
    2
  ],
  [
    127798,
    2
  ],
  [
    [
      127799,
      127868
    ],
    2
  ],
  [
    127869,
    2
  ],
  [
    [
      127870,
      127871
    ],
    2
  ],
  [
    [
      127872,
      127891
    ],
    2
  ],
  [
    [
      127892,
      127903
    ],
    2
  ],
  [
    [
      127904,
      127940
    ],
    2
  ],
  [
    127941,
    2
  ],
  [
    [
      127942,
      127946
    ],
    2
  ],
  [
    [
      127947,
      127950
    ],
    2
  ],
  [
    [
      127951,
      127955
    ],
    2
  ],
  [
    [
      127956,
      127967
    ],
    2
  ],
  [
    [
      127968,
      127984
    ],
    2
  ],
  [
    [
      127985,
      127991
    ],
    2
  ],
  [
    [
      127992,
      127999
    ],
    2
  ],
  [
    [
      128e3,
      128062
    ],
    2
  ],
  [
    128063,
    2
  ],
  [
    128064,
    2
  ],
  [
    128065,
    2
  ],
  [
    [
      128066,
      128247
    ],
    2
  ],
  [
    128248,
    2
  ],
  [
    [
      128249,
      128252
    ],
    2
  ],
  [
    [
      128253,
      128254
    ],
    2
  ],
  [
    128255,
    2
  ],
  [
    [
      128256,
      128317
    ],
    2
  ],
  [
    [
      128318,
      128319
    ],
    2
  ],
  [
    [
      128320,
      128323
    ],
    2
  ],
  [
    [
      128324,
      128330
    ],
    2
  ],
  [
    [
      128331,
      128335
    ],
    2
  ],
  [
    [
      128336,
      128359
    ],
    2
  ],
  [
    [
      128360,
      128377
    ],
    2
  ],
  [
    128378,
    2
  ],
  [
    [
      128379,
      128419
    ],
    2
  ],
  [
    128420,
    2
  ],
  [
    [
      128421,
      128506
    ],
    2
  ],
  [
    [
      128507,
      128511
    ],
    2
  ],
  [
    128512,
    2
  ],
  [
    [
      128513,
      128528
    ],
    2
  ],
  [
    128529,
    2
  ],
  [
    [
      128530,
      128532
    ],
    2
  ],
  [
    128533,
    2
  ],
  [
    128534,
    2
  ],
  [
    128535,
    2
  ],
  [
    128536,
    2
  ],
  [
    128537,
    2
  ],
  [
    128538,
    2
  ],
  [
    128539,
    2
  ],
  [
    [
      128540,
      128542
    ],
    2
  ],
  [
    128543,
    2
  ],
  [
    [
      128544,
      128549
    ],
    2
  ],
  [
    [
      128550,
      128551
    ],
    2
  ],
  [
    [
      128552,
      128555
    ],
    2
  ],
  [
    128556,
    2
  ],
  [
    128557,
    2
  ],
  [
    [
      128558,
      128559
    ],
    2
  ],
  [
    [
      128560,
      128563
    ],
    2
  ],
  [
    128564,
    2
  ],
  [
    [
      128565,
      128576
    ],
    2
  ],
  [
    [
      128577,
      128578
    ],
    2
  ],
  [
    [
      128579,
      128580
    ],
    2
  ],
  [
    [
      128581,
      128591
    ],
    2
  ],
  [
    [
      128592,
      128639
    ],
    2
  ],
  [
    [
      128640,
      128709
    ],
    2
  ],
  [
    [
      128710,
      128719
    ],
    2
  ],
  [
    128720,
    2
  ],
  [
    [
      128721,
      128722
    ],
    2
  ],
  [
    [
      128723,
      128724
    ],
    2
  ],
  [
    128725,
    2
  ],
  [
    [
      128726,
      128727
    ],
    2
  ],
  [
    [
      128728,
      128731
    ],
    3
  ],
  [
    128732,
    2
  ],
  [
    [
      128733,
      128735
    ],
    2
  ],
  [
    [
      128736,
      128748
    ],
    2
  ],
  [
    [
      128749,
      128751
    ],
    3
  ],
  [
    [
      128752,
      128755
    ],
    2
  ],
  [
    [
      128756,
      128758
    ],
    2
  ],
  [
    [
      128759,
      128760
    ],
    2
  ],
  [
    128761,
    2
  ],
  [
    128762,
    2
  ],
  [
    [
      128763,
      128764
    ],
    2
  ],
  [
    [
      128765,
      128767
    ],
    3
  ],
  [
    [
      128768,
      128883
    ],
    2
  ],
  [
    [
      128884,
      128886
    ],
    2
  ],
  [
    [
      128887,
      128890
    ],
    3
  ],
  [
    [
      128891,
      128895
    ],
    2
  ],
  [
    [
      128896,
      128980
    ],
    2
  ],
  [
    [
      128981,
      128984
    ],
    2
  ],
  [
    128985,
    2
  ],
  [
    [
      128986,
      128991
    ],
    3
  ],
  [
    [
      128992,
      129003
    ],
    2
  ],
  [
    [
      129004,
      129007
    ],
    3
  ],
  [
    129008,
    2
  ],
  [
    [
      129009,
      129023
    ],
    3
  ],
  [
    [
      129024,
      129035
    ],
    2
  ],
  [
    [
      129036,
      129039
    ],
    3
  ],
  [
    [
      129040,
      129095
    ],
    2
  ],
  [
    [
      129096,
      129103
    ],
    3
  ],
  [
    [
      129104,
      129113
    ],
    2
  ],
  [
    [
      129114,
      129119
    ],
    3
  ],
  [
    [
      129120,
      129159
    ],
    2
  ],
  [
    [
      129160,
      129167
    ],
    3
  ],
  [
    [
      129168,
      129197
    ],
    2
  ],
  [
    [
      129198,
      129199
    ],
    3
  ],
  [
    [
      129200,
      129201
    ],
    2
  ],
  [
    [
      129202,
      129279
    ],
    3
  ],
  [
    [
      129280,
      129291
    ],
    2
  ],
  [
    129292,
    2
  ],
  [
    [
      129293,
      129295
    ],
    2
  ],
  [
    [
      129296,
      129304
    ],
    2
  ],
  [
    [
      129305,
      129310
    ],
    2
  ],
  [
    129311,
    2
  ],
  [
    [
      129312,
      129319
    ],
    2
  ],
  [
    [
      129320,
      129327
    ],
    2
  ],
  [
    129328,
    2
  ],
  [
    [
      129329,
      129330
    ],
    2
  ],
  [
    [
      129331,
      129342
    ],
    2
  ],
  [
    129343,
    2
  ],
  [
    [
      129344,
      129355
    ],
    2
  ],
  [
    129356,
    2
  ],
  [
    [
      129357,
      129359
    ],
    2
  ],
  [
    [
      129360,
      129374
    ],
    2
  ],
  [
    [
      129375,
      129387
    ],
    2
  ],
  [
    [
      129388,
      129392
    ],
    2
  ],
  [
    129393,
    2
  ],
  [
    129394,
    2
  ],
  [
    [
      129395,
      129398
    ],
    2
  ],
  [
    [
      129399,
      129400
    ],
    2
  ],
  [
    129401,
    2
  ],
  [
    129402,
    2
  ],
  [
    129403,
    2
  ],
  [
    [
      129404,
      129407
    ],
    2
  ],
  [
    [
      129408,
      129412
    ],
    2
  ],
  [
    [
      129413,
      129425
    ],
    2
  ],
  [
    [
      129426,
      129431
    ],
    2
  ],
  [
    [
      129432,
      129442
    ],
    2
  ],
  [
    [
      129443,
      129444
    ],
    2
  ],
  [
    [
      129445,
      129450
    ],
    2
  ],
  [
    [
      129451,
      129453
    ],
    2
  ],
  [
    [
      129454,
      129455
    ],
    2
  ],
  [
    [
      129456,
      129465
    ],
    2
  ],
  [
    [
      129466,
      129471
    ],
    2
  ],
  [
    129472,
    2
  ],
  [
    [
      129473,
      129474
    ],
    2
  ],
  [
    [
      129475,
      129482
    ],
    2
  ],
  [
    129483,
    2
  ],
  [
    129484,
    2
  ],
  [
    [
      129485,
      129487
    ],
    2
  ],
  [
    [
      129488,
      129510
    ],
    2
  ],
  [
    [
      129511,
      129535
    ],
    2
  ],
  [
    [
      129536,
      129619
    ],
    2
  ],
  [
    [
      129620,
      129631
    ],
    3
  ],
  [
    [
      129632,
      129645
    ],
    2
  ],
  [
    [
      129646,
      129647
    ],
    3
  ],
  [
    [
      129648,
      129651
    ],
    2
  ],
  [
    129652,
    2
  ],
  [
    [
      129653,
      129655
    ],
    2
  ],
  [
    [
      129656,
      129658
    ],
    2
  ],
  [
    [
      129659,
      129660
    ],
    2
  ],
  [
    [
      129661,
      129663
    ],
    3
  ],
  [
    [
      129664,
      129666
    ],
    2
  ],
  [
    [
      129667,
      129670
    ],
    2
  ],
  [
    [
      129671,
      129672
    ],
    2
  ],
  [
    [
      129673,
      129679
    ],
    3
  ],
  [
    [
      129680,
      129685
    ],
    2
  ],
  [
    [
      129686,
      129704
    ],
    2
  ],
  [
    [
      129705,
      129708
    ],
    2
  ],
  [
    [
      129709,
      129711
    ],
    2
  ],
  [
    [
      129712,
      129718
    ],
    2
  ],
  [
    [
      129719,
      129722
    ],
    2
  ],
  [
    [
      129723,
      129725
    ],
    2
  ],
  [
    129726,
    3
  ],
  [
    129727,
    2
  ],
  [
    [
      129728,
      129730
    ],
    2
  ],
  [
    [
      129731,
      129733
    ],
    2
  ],
  [
    [
      129734,
      129741
    ],
    3
  ],
  [
    [
      129742,
      129743
    ],
    2
  ],
  [
    [
      129744,
      129750
    ],
    2
  ],
  [
    [
      129751,
      129753
    ],
    2
  ],
  [
    [
      129754,
      129755
    ],
    2
  ],
  [
    [
      129756,
      129759
    ],
    3
  ],
  [
    [
      129760,
      129767
    ],
    2
  ],
  [
    129768,
    2
  ],
  [
    [
      129769,
      129775
    ],
    3
  ],
  [
    [
      129776,
      129782
    ],
    2
  ],
  [
    [
      129783,
      129784
    ],
    2
  ],
  [
    [
      129785,
      129791
    ],
    3
  ],
  [
    [
      129792,
      129938
    ],
    2
  ],
  [
    129939,
    3
  ],
  [
    [
      129940,
      129994
    ],
    2
  ],
  [
    [
      129995,
      130031
    ],
    3
  ],
  [
    130032,
    1,
    "0"
  ],
  [
    130033,
    1,
    "1"
  ],
  [
    130034,
    1,
    "2"
  ],
  [
    130035,
    1,
    "3"
  ],
  [
    130036,
    1,
    "4"
  ],
  [
    130037,
    1,
    "5"
  ],
  [
    130038,
    1,
    "6"
  ],
  [
    130039,
    1,
    "7"
  ],
  [
    130040,
    1,
    "8"
  ],
  [
    130041,
    1,
    "9"
  ],
  [
    [
      130042,
      131069
    ],
    3
  ],
  [
    [
      131070,
      131071
    ],
    3
  ],
  [
    [
      131072,
      173782
    ],
    2
  ],
  [
    [
      173783,
      173789
    ],
    2
  ],
  [
    [
      173790,
      173791
    ],
    2
  ],
  [
    [
      173792,
      173823
    ],
    3
  ],
  [
    [
      173824,
      177972
    ],
    2
  ],
  [
    [
      177973,
      177976
    ],
    2
  ],
  [
    177977,
    2
  ],
  [
    [
      177978,
      177983
    ],
    3
  ],
  [
    [
      177984,
      178205
    ],
    2
  ],
  [
    [
      178206,
      178207
    ],
    3
  ],
  [
    [
      178208,
      183969
    ],
    2
  ],
  [
    [
      183970,
      183983
    ],
    3
  ],
  [
    [
      183984,
      191456
    ],
    2
  ],
  [
    [
      191457,
      191471
    ],
    3
  ],
  [
    [
      191472,
      192093
    ],
    2
  ],
  [
    [
      192094,
      194559
    ],
    3
  ],
  [
    194560,
    1,
    ""
  ],
  [
    194561,
    1,
    ""
  ],
  [
    194562,
    1,
    ""
  ],
  [
    194563,
    1,
    ""
  ],
  [
    194564,
    1,
    ""
  ],
  [
    194565,
    1,
    ""
  ],
  [
    194566,
    1,
    ""
  ],
  [
    194567,
    1,
    ""
  ],
  [
    194568,
    1,
    ""
  ],
  [
    194569,
    1,
    ""
  ],
  [
    194570,
    1,
    ""
  ],
  [
    194571,
    1,
    ""
  ],
  [
    194572,
    1,
    ""
  ],
  [
    194573,
    1,
    ""
  ],
  [
    194574,
    1,
    ""
  ],
  [
    194575,
    1,
    ""
  ],
  [
    194576,
    1,
    ""
  ],
  [
    194577,
    1,
    ""
  ],
  [
    194578,
    1,
    ""
  ],
  [
    194579,
    1,
    ""
  ],
  [
    194580,
    1,
    ""
  ],
  [
    194581,
    1,
    ""
  ],
  [
    194582,
    1,
    ""
  ],
  [
    194583,
    1,
    ""
  ],
  [
    194584,
    1,
    ""
  ],
  [
    194585,
    1,
    ""
  ],
  [
    194586,
    1,
    ""
  ],
  [
    194587,
    1,
    ""
  ],
  [
    194588,
    1,
    ""
  ],
  [
    194589,
    1,
    ""
  ],
  [
    194590,
    1,
    ""
  ],
  [
    194591,
    1,
    ""
  ],
  [
    194592,
    1,
    ""
  ],
  [
    194593,
    1,
    ""
  ],
  [
    194594,
    1,
    ""
  ],
  [
    194595,
    1,
    ""
  ],
  [
    194596,
    1,
    ""
  ],
  [
    194597,
    1,
    ""
  ],
  [
    194598,
    1,
    ""
  ],
  [
    194599,
    1,
    ""
  ],
  [
    194600,
    1,
    ""
  ],
  [
    194601,
    1,
    ""
  ],
  [
    194602,
    1,
    ""
  ],
  [
    194603,
    1,
    ""
  ],
  [
    194604,
    1,
    ""
  ],
  [
    194605,
    1,
    ""
  ],
  [
    194606,
    1,
    ""
  ],
  [
    194607,
    1,
    ""
  ],
  [
    194608,
    1,
    ""
  ],
  [
    [
      194609,
      194611
    ],
    1,
    ""
  ],
  [
    194612,
    1,
    ""
  ],
  [
    194613,
    1,
    ""
  ],
  [
    194614,
    1,
    ""
  ],
  [
    194615,
    1,
    ""
  ],
  [
    194616,
    1,
    ""
  ],
  [
    194617,
    1,
    ""
  ],
  [
    194618,
    1,
    ""
  ],
  [
    194619,
    1,
    ""
  ],
  [
    194620,
    1,
    ""
  ],
  [
    194621,
    1,
    ""
  ],
  [
    194622,
    1,
    ""
  ],
  [
    194623,
    1,
    ""
  ],
  [
    194624,
    1,
    ""
  ],
  [
    194625,
    1,
    ""
  ],
  [
    194626,
    1,
    ""
  ],
  [
    194627,
    1,
    ""
  ],
  [
    194628,
    1,
    ""
  ],
  [
    [
      194629,
      194630
    ],
    1,
    ""
  ],
  [
    194631,
    1,
    ""
  ],
  [
    194632,
    1,
    ""
  ],
  [
    194633,
    1,
    ""
  ],
  [
    194634,
    1,
    ""
  ],
  [
    194635,
    1,
    ""
  ],
  [
    194636,
    1,
    ""
  ],
  [
    194637,
    1,
    ""
  ],
  [
    194638,
    1,
    ""
  ],
  [
    194639,
    1,
    ""
  ],
  [
    194640,
    1,
    ""
  ],
  [
    194641,
    1,
    ""
  ],
  [
    194642,
    1,
    ""
  ],
  [
    194643,
    1,
    ""
  ],
  [
    194644,
    1,
    ""
  ],
  [
    194645,
    1,
    ""
  ],
  [
    194646,
    1,
    ""
  ],
  [
    194647,
    1,
    ""
  ],
  [
    194648,
    1,
    ""
  ],
  [
    194649,
    1,
    ""
  ],
  [
    194650,
    1,
    ""
  ],
  [
    194651,
    1,
    ""
  ],
  [
    194652,
    1,
    ""
  ],
  [
    194653,
    1,
    ""
  ],
  [
    194654,
    1,
    ""
  ],
  [
    194655,
    1,
    ""
  ],
  [
    194656,
    1,
    ""
  ],
  [
    194657,
    1,
    ""
  ],
  [
    194658,
    1,
    ""
  ],
  [
    194659,
    1,
    ""
  ],
  [
    194660,
    1,
    ""
  ],
  [
    194661,
    1,
    ""
  ],
  [
    194662,
    1,
    ""
  ],
  [
    194663,
    1,
    ""
  ],
  [
    194664,
    3
  ],
  [
    194665,
    1,
    ""
  ],
  [
    [
      194666,
      194667
    ],
    1,
    ""
  ],
  [
    194668,
    1,
    ""
  ],
  [
    194669,
    1,
    ""
  ],
  [
    194670,
    1,
    ""
  ],
  [
    194671,
    1,
    ""
  ],
  [
    194672,
    1,
    ""
  ],
  [
    194673,
    1,
    ""
  ],
  [
    194674,
    1,
    ""
  ],
  [
    194675,
    1,
    ""
  ],
  [
    194676,
    3
  ],
  [
    194677,
    1,
    ""
  ],
  [
    194678,
    1,
    ""
  ],
  [
    194679,
    1,
    ""
  ],
  [
    194680,
    1,
    ""
  ],
  [
    194681,
    1,
    ""
  ],
  [
    194682,
    1,
    ""
  ],
  [
    194683,
    1,
    ""
  ],
  [
    194684,
    1,
    ""
  ],
  [
    194685,
    1,
    ""
  ],
  [
    194686,
    1,
    ""
  ],
  [
    194687,
    1,
    ""
  ],
  [
    194688,
    1,
    ""
  ],
  [
    194689,
    1,
    ""
  ],
  [
    194690,
    1,
    ""
  ],
  [
    194691,
    1,
    ""
  ],
  [
    194692,
    1,
    ""
  ],
  [
    194693,
    1,
    ""
  ],
  [
    194694,
    1,
    ""
  ],
  [
    194695,
    1,
    ""
  ],
  [
    194696,
    1,
    ""
  ],
  [
    194697,
    1,
    ""
  ],
  [
    194698,
    1,
    ""
  ],
  [
    194699,
    1,
    ""
  ],
  [
    194700,
    1,
    ""
  ],
  [
    194701,
    1,
    ""
  ],
  [
    194702,
    1,
    ""
  ],
  [
    194703,
    1,
    ""
  ],
  [
    194704,
    1,
    ""
  ],
  [
    [
      194705,
      194706
    ],
    1,
    ""
  ],
  [
    194707,
    1,
    ""
  ],
  [
    [
      194708,
      194709
    ],
    1,
    ""
  ],
  [
    194710,
    1,
    ""
  ],
  [
    194711,
    1,
    ""
  ],
  [
    194712,
    1,
    ""
  ],
  [
    194713,
    1,
    ""
  ],
  [
    194714,
    1,
    ""
  ],
  [
    194715,
    1,
    ""
  ],
  [
    194716,
    1,
    ""
  ],
  [
    194717,
    1,
    ""
  ],
  [
    194718,
    1,
    ""
  ],
  [
    194719,
    1,
    ""
  ],
  [
    194720,
    1,
    ""
  ],
  [
    194721,
    1,
    ""
  ],
  [
    194722,
    1,
    ""
  ],
  [
    194723,
    1,
    ""
  ],
  [
    194724,
    1,
    ""
  ],
  [
    194725,
    1,
    ""
  ],
  [
    194726,
    1,
    ""
  ],
  [
    194727,
    1,
    ""
  ],
  [
    194728,
    1,
    ""
  ],
  [
    194729,
    1,
    ""
  ],
  [
    194730,
    1,
    ""
  ],
  [
    194731,
    1,
    ""
  ],
  [
    194732,
    1,
    ""
  ],
  [
    194733,
    1,
    ""
  ],
  [
    194734,
    1,
    ""
  ],
  [
    194735,
    1,
    ""
  ],
  [
    194736,
    1,
    ""
  ],
  [
    194737,
    1,
    ""
  ],
  [
    194738,
    1,
    ""
  ],
  [
    194739,
    1,
    ""
  ],
  [
    194740,
    1,
    ""
  ],
  [
    194741,
    1,
    ""
  ],
  [
    194742,
    1,
    ""
  ],
  [
    194743,
    1,
    ""
  ],
  [
    194744,
    1,
    ""
  ],
  [
    194745,
    1,
    ""
  ],
  [
    194746,
    1,
    ""
  ],
  [
    194747,
    1,
    ""
  ],
  [
    194748,
    1,
    ""
  ],
  [
    194749,
    1,
    ""
  ],
  [
    194750,
    1,
    ""
  ],
  [
    194751,
    1,
    ""
  ],
  [
    194752,
    1,
    ""
  ],
  [
    194753,
    1,
    ""
  ],
  [
    194754,
    1,
    ""
  ],
  [
    194755,
    1,
    ""
  ],
  [
    194756,
    1,
    ""
  ],
  [
    194757,
    1,
    ""
  ],
  [
    194758,
    1,
    ""
  ],
  [
    194759,
    1,
    ""
  ],
  [
    194760,
    1,
    ""
  ],
  [
    194761,
    1,
    ""
  ],
  [
    194762,
    1,
    ""
  ],
  [
    194763,
    1,
    ""
  ],
  [
    194764,
    1,
    ""
  ],
  [
    194765,
    1,
    ""
  ],
  [
    194766,
    1,
    ""
  ],
  [
    194767,
    1,
    ""
  ],
  [
    194768,
    1,
    ""
  ],
  [
    194769,
    1,
    ""
  ],
  [
    194770,
    1,
    ""
  ],
  [
    194771,
    1,
    ""
  ],
  [
    194772,
    1,
    ""
  ],
  [
    194773,
    1,
    ""
  ],
  [
    194774,
    1,
    ""
  ],
  [
    194775,
    1,
    ""
  ],
  [
    194776,
    1,
    ""
  ],
  [
    194777,
    1,
    ""
  ],
  [
    194778,
    1,
    ""
  ],
  [
    194779,
    1,
    ""
  ],
  [
    194780,
    1,
    ""
  ],
  [
    194781,
    1,
    ""
  ],
  [
    194782,
    1,
    ""
  ],
  [
    194783,
    1,
    ""
  ],
  [
    194784,
    1,
    ""
  ],
  [
    194785,
    1,
    ""
  ],
  [
    194786,
    1,
    ""
  ],
  [
    194787,
    1,
    ""
  ],
  [
    194788,
    1,
    ""
  ],
  [
    194789,
    1,
    ""
  ],
  [
    194790,
    1,
    ""
  ],
  [
    194791,
    1,
    ""
  ],
  [
    194792,
    1,
    ""
  ],
  [
    194793,
    1,
    ""
  ],
  [
    194794,
    1,
    ""
  ],
  [
    194795,
    1,
    ""
  ],
  [
    194796,
    1,
    ""
  ],
  [
    194797,
    1,
    ""
  ],
  [
    194798,
    1,
    ""
  ],
  [
    194799,
    1,
    ""
  ],
  [
    194800,
    1,
    ""
  ],
  [
    194801,
    1,
    ""
  ],
  [
    194802,
    1,
    ""
  ],
  [
    194803,
    1,
    ""
  ],
  [
    194804,
    1,
    ""
  ],
  [
    194805,
    1,
    ""
  ],
  [
    194806,
    1,
    ""
  ],
  [
    194807,
    1,
    ""
  ],
  [
    194808,
    1,
    ""
  ],
  [
    194809,
    1,
    ""
  ],
  [
    194810,
    1,
    ""
  ],
  [
    194811,
    1,
    ""
  ],
  [
    194812,
    1,
    ""
  ],
  [
    194813,
    1,
    ""
  ],
  [
    194814,
    1,
    ""
  ],
  [
    194815,
    1,
    ""
  ],
  [
    194816,
    1,
    ""
  ],
  [
    194817,
    1,
    ""
  ],
  [
    194818,
    1,
    ""
  ],
  [
    194819,
    1,
    ""
  ],
  [
    194820,
    1,
    ""
  ],
  [
    194821,
    1,
    ""
  ],
  [
    194822,
    1,
    ""
  ],
  [
    194823,
    1,
    ""
  ],
  [
    194824,
    1,
    ""
  ],
  [
    194825,
    1,
    ""
  ],
  [
    194826,
    1,
    ""
  ],
  [
    194827,
    1,
    ""
  ],
  [
    194828,
    1,
    ""
  ],
  [
    194829,
    1,
    ""
  ],
  [
    194830,
    1,
    ""
  ],
  [
    194831,
    1,
    ""
  ],
  [
    194832,
    1,
    ""
  ],
  [
    194833,
    1,
    ""
  ],
  [
    194834,
    1,
    ""
  ],
  [
    194835,
    1,
    ""
  ],
  [
    194836,
    1,
    ""
  ],
  [
    194837,
    1,
    ""
  ],
  [
    194838,
    1,
    ""
  ],
  [
    194839,
    1,
    ""
  ],
  [
    194840,
    1,
    ""
  ],
  [
    194841,
    1,
    ""
  ],
  [
    194842,
    1,
    ""
  ],
  [
    194843,
    1,
    ""
  ],
  [
    194844,
    1,
    ""
  ],
  [
    194845,
    1,
    ""
  ],
  [
    194846,
    1,
    ""
  ],
  [
    194847,
    3
  ],
  [
    194848,
    1,
    ""
  ],
  [
    194849,
    1,
    ""
  ],
  [
    194850,
    1,
    ""
  ],
  [
    194851,
    1,
    ""
  ],
  [
    194852,
    1,
    ""
  ],
  [
    194853,
    1,
    ""
  ],
  [
    194854,
    1,
    ""
  ],
  [
    194855,
    1,
    ""
  ],
  [
    194856,
    1,
    ""
  ],
  [
    194857,
    1,
    ""
  ],
  [
    194858,
    1,
    ""
  ],
  [
    194859,
    1,
    ""
  ],
  [
    [
      194860,
      194861
    ],
    1,
    ""
  ],
  [
    194862,
    1,
    ""
  ],
  [
    194863,
    1,
    ""
  ],
  [
    194864,
    1,
    ""
  ],
  [
    194865,
    1,
    ""
  ],
  [
    194866,
    1,
    ""
  ],
  [
    194867,
    1,
    ""
  ],
  [
    194868,
    1,
    ""
  ],
  [
    194869,
    1,
    ""
  ],
  [
    194870,
    1,
    ""
  ],
  [
    194871,
    1,
    ""
  ],
  [
    194872,
    1,
    ""
  ],
  [
    194873,
    1,
    ""
  ],
  [
    194874,
    1,
    ""
  ],
  [
    194875,
    1,
    ""
  ],
  [
    194876,
    1,
    ""
  ],
  [
    194877,
    1,
    ""
  ],
  [
    194878,
    1,
    ""
  ],
  [
    194879,
    1,
    ""
  ],
  [
    194880,
    1,
    ""
  ],
  [
    194881,
    1,
    ""
  ],
  [
    194882,
    1,
    ""
  ],
  [
    194883,
    1,
    ""
  ],
  [
    194884,
    1,
    ""
  ],
  [
    194885,
    1,
    ""
  ],
  [
    [
      194886,
      194887
    ],
    1,
    ""
  ],
  [
    194888,
    1,
    ""
  ],
  [
    194889,
    1,
    ""
  ],
  [
    194890,
    1,
    ""
  ],
  [
    194891,
    1,
    ""
  ],
  [
    194892,
    1,
    ""
  ],
  [
    194893,
    1,
    ""
  ],
  [
    194894,
    1,
    ""
  ],
  [
    194895,
    1,
    ""
  ],
  [
    194896,
    1,
    ""
  ],
  [
    194897,
    1,
    ""
  ],
  [
    194898,
    1,
    ""
  ],
  [
    194899,
    1,
    ""
  ],
  [
    194900,
    1,
    ""
  ],
  [
    194901,
    1,
    ""
  ],
  [
    194902,
    1,
    ""
  ],
  [
    194903,
    1,
    ""
  ],
  [
    194904,
    1,
    ""
  ],
  [
    194905,
    1,
    ""
  ],
  [
    194906,
    1,
    ""
  ],
  [
    194907,
    1,
    ""
  ],
  [
    194908,
    1,
    ""
  ],
  [
    [
      194909,
      194910
    ],
    1,
    ""
  ],
  [
    194911,
    3
  ],
  [
    194912,
    1,
    ""
  ],
  [
    194913,
    1,
    ""
  ],
  [
    194914,
    1,
    ""
  ],
  [
    194915,
    1,
    ""
  ],
  [
    194916,
    1,
    ""
  ],
  [
    194917,
    1,
    ""
  ],
  [
    194918,
    1,
    ""
  ],
  [
    194919,
    1,
    ""
  ],
  [
    194920,
    1,
    ""
  ],
  [
    194921,
    1,
    ""
  ],
  [
    194922,
    1,
    ""
  ],
  [
    194923,
    1,
    ""
  ],
  [
    194924,
    1,
    ""
  ],
  [
    194925,
    1,
    ""
  ],
  [
    194926,
    1,
    ""
  ],
  [
    194927,
    1,
    ""
  ],
  [
    194928,
    1,
    ""
  ],
  [
    194929,
    1,
    ""
  ],
  [
    194930,
    1,
    ""
  ],
  [
    194931,
    1,
    ""
  ],
  [
    194932,
    1,
    ""
  ],
  [
    194933,
    1,
    ""
  ],
  [
    194934,
    1,
    ""
  ],
  [
    194935,
    1,
    ""
  ],
  [
    194936,
    1,
    ""
  ],
  [
    194937,
    1,
    ""
  ],
  [
    194938,
    1,
    ""
  ],
  [
    194939,
    1,
    ""
  ],
  [
    194940,
    1,
    ""
  ],
  [
    194941,
    1,
    ""
  ],
  [
    194942,
    1,
    ""
  ],
  [
    194943,
    1,
    ""
  ],
  [
    194944,
    1,
    ""
  ],
  [
    194945,
    1,
    ""
  ],
  [
    194946,
    1,
    ""
  ],
  [
    194947,
    1,
    ""
  ],
  [
    194948,
    1,
    ""
  ],
  [
    194949,
    1,
    ""
  ],
  [
    194950,
    1,
    ""
  ],
  [
    194951,
    1,
    ""
  ],
  [
    194952,
    1,
    ""
  ],
  [
    194953,
    1,
    ""
  ],
  [
    194954,
    1,
    ""
  ],
  [
    194955,
    1,
    ""
  ],
  [
    194956,
    1,
    ""
  ],
  [
    194957,
    1,
    ""
  ],
  [
    194958,
    1,
    ""
  ],
  [
    194959,
    1,
    ""
  ],
  [
    194960,
    1,
    ""
  ],
  [
    194961,
    1,
    ""
  ],
  [
    194962,
    1,
    ""
  ],
  [
    194963,
    1,
    ""
  ],
  [
    194964,
    1,
    ""
  ],
  [
    194965,
    1,
    ""
  ],
  [
    194966,
    1,
    ""
  ],
  [
    194967,
    1,
    ""
  ],
  [
    194968,
    1,
    ""
  ],
  [
    194969,
    1,
    ""
  ],
  [
    194970,
    1,
    ""
  ],
  [
    194971,
    1,
    ""
  ],
  [
    194972,
    1,
    ""
  ],
  [
    194973,
    1,
    ""
  ],
  [
    194974,
    1,
    ""
  ],
  [
    194975,
    1,
    ""
  ],
  [
    194976,
    1,
    ""
  ],
  [
    194977,
    1,
    ""
  ],
  [
    194978,
    1,
    ""
  ],
  [
    194979,
    1,
    ""
  ],
  [
    194980,
    1,
    ""
  ],
  [
    194981,
    1,
    ""
  ],
  [
    194982,
    1,
    ""
  ],
  [
    194983,
    1,
    ""
  ],
  [
    194984,
    1,
    ""
  ],
  [
    194985,
    1,
    ""
  ],
  [
    194986,
    1,
    ""
  ],
  [
    194987,
    1,
    ""
  ],
  [
    194988,
    1,
    ""
  ],
  [
    194989,
    1,
    ""
  ],
  [
    194990,
    1,
    ""
  ],
  [
    194991,
    1,
    ""
  ],
  [
    194992,
    1,
    ""
  ],
  [
    194993,
    1,
    ""
  ],
  [
    194994,
    1,
    ""
  ],
  [
    194995,
    1,
    ""
  ],
  [
    194996,
    1,
    ""
  ],
  [
    194997,
    1,
    ""
  ],
  [
    194998,
    1,
    ""
  ],
  [
    194999,
    1,
    ""
  ],
  [
    195e3,
    1,
    ""
  ],
  [
    195001,
    1,
    ""
  ],
  [
    195002,
    1,
    ""
  ],
  [
    195003,
    1,
    ""
  ],
  [
    195004,
    1,
    ""
  ],
  [
    195005,
    1,
    ""
  ],
  [
    195006,
    1,
    ""
  ],
  [
    195007,
    3
  ],
  [
    195008,
    1,
    ""
  ],
  [
    195009,
    1,
    ""
  ],
  [
    195010,
    1,
    ""
  ],
  [
    195011,
    1,
    ""
  ],
  [
    195012,
    1,
    ""
  ],
  [
    195013,
    1,
    ""
  ],
  [
    195014,
    1,
    ""
  ],
  [
    195015,
    1,
    ""
  ],
  [
    195016,
    1,
    ""
  ],
  [
    195017,
    1,
    ""
  ],
  [
    195018,
    1,
    ""
  ],
  [
    195019,
    1,
    ""
  ],
  [
    195020,
    1,
    ""
  ],
  [
    195021,
    1,
    ""
  ],
  [
    195022,
    1,
    ""
  ],
  [
    195023,
    1,
    ""
  ],
  [
    195024,
    1,
    ""
  ],
  [
    195025,
    1,
    ""
  ],
  [
    195026,
    1,
    ""
  ],
  [
    195027,
    1,
    ""
  ],
  [
    195028,
    1,
    ""
  ],
  [
    195029,
    1,
    ""
  ],
  [
    195030,
    1,
    ""
  ],
  [
    195031,
    1,
    ""
  ],
  [
    195032,
    1,
    ""
  ],
  [
    195033,
    1,
    ""
  ],
  [
    195034,
    1,
    ""
  ],
  [
    195035,
    1,
    ""
  ],
  [
    195036,
    1,
    ""
  ],
  [
    195037,
    1,
    ""
  ],
  [
    195038,
    1,
    ""
  ],
  [
    195039,
    1,
    ""
  ],
  [
    195040,
    1,
    ""
  ],
  [
    195041,
    1,
    ""
  ],
  [
    195042,
    1,
    ""
  ],
  [
    195043,
    1,
    ""
  ],
  [
    195044,
    1,
    ""
  ],
  [
    195045,
    1,
    ""
  ],
  [
    195046,
    1,
    ""
  ],
  [
    195047,
    1,
    ""
  ],
  [
    195048,
    1,
    ""
  ],
  [
    195049,
    1,
    ""
  ],
  [
    195050,
    1,
    ""
  ],
  [
    195051,
    1,
    ""
  ],
  [
    195052,
    1,
    ""
  ],
  [
    195053,
    1,
    ""
  ],
  [
    195054,
    1,
    ""
  ],
  [
    195055,
    1,
    ""
  ],
  [
    195056,
    1,
    ""
  ],
  [
    195057,
    1,
    ""
  ],
  [
    195058,
    1,
    ""
  ],
  [
    195059,
    1,
    ""
  ],
  [
    195060,
    1,
    ""
  ],
  [
    195061,
    1,
    ""
  ],
  [
    195062,
    1,
    ""
  ],
  [
    195063,
    1,
    ""
  ],
  [
    195064,
    1,
    ""
  ],
  [
    195065,
    1,
    ""
  ],
  [
    195066,
    1,
    ""
  ],
  [
    195067,
    1,
    ""
  ],
  [
    195068,
    1,
    ""
  ],
  [
    195069,
    1,
    ""
  ],
  [
    [
      195070,
      195071
    ],
    1,
    ""
  ],
  [
    195072,
    1,
    ""
  ],
  [
    195073,
    1,
    ""
  ],
  [
    195074,
    1,
    ""
  ],
  [
    195075,
    1,
    ""
  ],
  [
    195076,
    1,
    ""
  ],
  [
    195077,
    1,
    ""
  ],
  [
    195078,
    1,
    ""
  ],
  [
    195079,
    1,
    ""
  ],
  [
    195080,
    1,
    ""
  ],
  [
    195081,
    1,
    ""
  ],
  [
    195082,
    1,
    ""
  ],
  [
    195083,
    1,
    ""
  ],
  [
    195084,
    1,
    ""
  ],
  [
    195085,
    1,
    ""
  ],
  [
    195086,
    1,
    ""
  ],
  [
    195087,
    1,
    ""
  ],
  [
    195088,
    1,
    ""
  ],
  [
    195089,
    1,
    ""
  ],
  [
    195090,
    1,
    ""
  ],
  [
    195091,
    1,
    ""
  ],
  [
    195092,
    1,
    ""
  ],
  [
    195093,
    1,
    ""
  ],
  [
    195094,
    1,
    ""
  ],
  [
    195095,
    1,
    ""
  ],
  [
    195096,
    1,
    ""
  ],
  [
    195097,
    1,
    ""
  ],
  [
    195098,
    1,
    ""
  ],
  [
    195099,
    1,
    ""
  ],
  [
    195100,
    1,
    ""
  ],
  [
    195101,
    1,
    ""
  ],
  [
    [
      195102,
      196605
    ],
    3
  ],
  [
    [
      196606,
      196607
    ],
    3
  ],
  [
    [
      196608,
      201546
    ],
    2
  ],
  [
    [
      201547,
      201551
    ],
    3
  ],
  [
    [
      201552,
      205743
    ],
    2
  ],
  [
    [
      205744,
      262141
    ],
    3
  ],
  [
    [
      262142,
      262143
    ],
    3
  ],
  [
    [
      262144,
      327677
    ],
    3
  ],
  [
    [
      327678,
      327679
    ],
    3
  ],
  [
    [
      327680,
      393213
    ],
    3
  ],
  [
    [
      393214,
      393215
    ],
    3
  ],
  [
    [
      393216,
      458749
    ],
    3
  ],
  [
    [
      458750,
      458751
    ],
    3
  ],
  [
    [
      458752,
      524285
    ],
    3
  ],
  [
    [
      524286,
      524287
    ],
    3
  ],
  [
    [
      524288,
      589821
    ],
    3
  ],
  [
    [
      589822,
      589823
    ],
    3
  ],
  [
    [
      589824,
      655357
    ],
    3
  ],
  [
    [
      655358,
      655359
    ],
    3
  ],
  [
    [
      655360,
      720893
    ],
    3
  ],
  [
    [
      720894,
      720895
    ],
    3
  ],
  [
    [
      720896,
      786429
    ],
    3
  ],
  [
    [
      786430,
      786431
    ],
    3
  ],
  [
    [
      786432,
      851965
    ],
    3
  ],
  [
    [
      851966,
      851967
    ],
    3
  ],
  [
    [
      851968,
      917501
    ],
    3
  ],
  [
    [
      917502,
      917503
    ],
    3
  ],
  [
    917504,
    3
  ],
  [
    917505,
    3
  ],
  [
    [
      917506,
      917535
    ],
    3
  ],
  [
    [
      917536,
      917631
    ],
    3
  ],
  [
    [
      917632,
      917759
    ],
    3
  ],
  [
    [
      917760,
      917999
    ],
    7
  ],
  [
    [
      918e3,
      983037
    ],
    3
  ],
  [
    [
      983038,
      983039
    ],
    3
  ],
  [
    [
      983040,
      1048573
    ],
    3
  ],
  [
    [
      1048574,
      1048575
    ],
    3
  ],
  [
    [
      1048576,
      1114109
    ],
    3
  ],
  [
    [
      1114110,
      1114111
    ],
    3
  ]
];
var statusMapping = {};
statusMapping.STATUS_MAPPING = {
  mapped: 1,
  valid: 2,
  disallowed: 3,
  disallowed_STD3_valid: 4,
  disallowed_STD3_mapped: 5,
  deviation: 6,
  ignored: 7
};
const punycode = require$$0;
const regexes = regexes$1;
const mappingTable = require$$2;
const { STATUS_MAPPING } = statusMapping;
function containsNonASCII(str) {
  return /[^\x00-\x7F]/u.test(str);
}
function findStatus(val, { useSTD3ASCIIRules }) {
  let start2 = 0;
  let end2 = mappingTable.length - 1;
  while (start2 <= end2) {
    const mid = Math.floor((start2 + end2) / 2);
    const target2 = mappingTable[mid];
    const min2 = Array.isArray(target2[0]) ? target2[0][0] : target2[0];
    const max2 = Array.isArray(target2[0]) ? target2[0][1] : target2[0];
    if (min2 <= val && max2 >= val) {
      if (useSTD3ASCIIRules && (target2[1] === STATUS_MAPPING.disallowed_STD3_valid || target2[1] === STATUS_MAPPING.disallowed_STD3_mapped)) {
        return [STATUS_MAPPING.disallowed, ...target2.slice(2)];
      } else if (target2[1] === STATUS_MAPPING.disallowed_STD3_valid) {
        return [STATUS_MAPPING.valid, ...target2.slice(2)];
      } else if (target2[1] === STATUS_MAPPING.disallowed_STD3_mapped) {
        return [STATUS_MAPPING.mapped, ...target2.slice(2)];
      }
      return target2.slice(1);
    } else if (min2 > val) {
      end2 = mid - 1;
    } else {
      start2 = mid + 1;
    }
  }
  return null;
}
function mapChars(domainName, { useSTD3ASCIIRules, transitionalProcessing }) {
  let processed = "";
  for (const ch of domainName) {
    const [status, mapping] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });
    switch (status) {
      case STATUS_MAPPING.disallowed:
        processed += ch;
        break;
      case STATUS_MAPPING.ignored:
        break;
      case STATUS_MAPPING.mapped:
        if (transitionalProcessing && ch === "") {
          processed += "ss";
        } else {
          processed += mapping;
        }
        break;
      case STATUS_MAPPING.deviation:
        if (transitionalProcessing) {
          processed += mapping;
        } else {
          processed += ch;
        }
        break;
      case STATUS_MAPPING.valid:
        processed += ch;
        break;
    }
  }
  return processed;
}
function validateLabel(label, {
  checkHyphens,
  checkBidi,
  checkJoiners,
  transitionalProcessing,
  useSTD3ASCIIRules,
  isBidi
}) {
  if (label.length === 0) {
    return true;
  }
  if (label.normalize("NFC") !== label) {
    return false;
  }
  const codePoints = Array.from(label);
  if (checkHyphens) {
    if (codePoints[2] === "-" && codePoints[3] === "-" || (label.startsWith("-") || label.endsWith("-"))) {
      return false;
    }
  }
  if (label.includes(".")) {
    return false;
  }
  if (regexes.combiningMarks.test(codePoints[0])) {
    return false;
  }
  for (const ch of codePoints) {
    const [status] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });
    if (transitionalProcessing) {
      if (status !== STATUS_MAPPING.valid) {
        return false;
      }
    } else if (status !== STATUS_MAPPING.valid && status !== STATUS_MAPPING.deviation) {
      return false;
    }
  }
  if (checkJoiners) {
    let last = 0;
    for (const [i, ch] of codePoints.entries()) {
      if (ch === "" || ch === "") {
        if (i > 0) {
          if (regexes.combiningClassVirama.test(codePoints[i - 1])) {
            continue;
          }
          if (ch === "") {
            const next = codePoints.indexOf("", i + 1);
            const test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);
            if (regexes.validZWNJ.test(test.join(""))) {
              last = i + 1;
              continue;
            }
          }
        }
        return false;
      }
    }
  }
  if (checkBidi && isBidi) {
    let rtl;
    if (regexes.bidiS1LTR.test(codePoints[0])) {
      rtl = false;
    } else if (regexes.bidiS1RTL.test(codePoints[0])) {
      rtl = true;
    } else {
      return false;
    }
    if (rtl) {
      if (!regexes.bidiS2.test(label) || !regexes.bidiS3.test(label) || regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label)) {
        return false;
      }
    } else if (!regexes.bidiS5.test(label) || !regexes.bidiS6.test(label)) {
      return false;
    }
  }
  return true;
}
function isBidiDomain(labels) {
  const domain = labels.map((label) => {
    if (label.startsWith("xn--")) {
      try {
        return punycode.decode(label.substring(4));
      } catch (err) {
        return "";
      }
    }
    return label;
  }).join(".");
  return regexes.bidiDomain.test(domain);
}
function processing(domainName, options2) {
  let string = mapChars(domainName, options2);
  string = string.normalize("NFC");
  const labels = string.split(".");
  const isBidi = isBidiDomain(labels);
  let error2 = false;
  for (const [i, origLabel] of labels.entries()) {
    let label = origLabel;
    let transitionalProcessingForThisLabel = options2.transitionalProcessing;
    if (label.startsWith("xn--")) {
      if (containsNonASCII(label)) {
        error2 = true;
        continue;
      }
      try {
        label = punycode.decode(label.substring(4));
      } catch {
        if (!options2.ignoreInvalidPunycode) {
          error2 = true;
          continue;
        }
      }
      labels[i] = label;
      transitionalProcessingForThisLabel = false;
    }
    if (error2) {
      continue;
    }
    const validation = validateLabel(label, {
      ...options2,
      transitionalProcessing: transitionalProcessingForThisLabel,
      isBidi
    });
    if (!validation) {
      error2 = true;
    }
  }
  return {
    string: labels.join("."),
    error: error2
  };
}
function toASCII(domainName, {
  checkHyphens = false,
  checkBidi = false,
  checkJoiners = false,
  useSTD3ASCIIRules = false,
  verifyDNSLength = false,
  transitionalProcessing = false,
  ignoreInvalidPunycode = false
} = {}) {
  const result = processing(domainName, {
    checkHyphens,
    checkBidi,
    checkJoiners,
    useSTD3ASCIIRules,
    transitionalProcessing,
    ignoreInvalidPunycode
  });
  let labels = result.string.split(".");
  labels = labels.map((l2) => {
    if (containsNonASCII(l2)) {
      try {
        return `xn--${punycode.encode(l2)}`;
      } catch (e2) {
        result.error = true;
      }
    }
    return l2;
  });
  if (verifyDNSLength) {
    const total = labels.join(".").length;
    if (total > 253 || total === 0) {
      result.error = true;
    }
    for (let i = 0; i < labels.length; ++i) {
      if (labels[i].length > 63 || labels[i].length === 0) {
        result.error = true;
        break;
      }
    }
  }
  if (result.error) {
    return null;
  }
  return labels.join(".");
}
function toUnicode(domainName, {
  checkHyphens = false,
  checkBidi = false,
  checkJoiners = false,
  useSTD3ASCIIRules = false,
  transitionalProcessing = false,
  ignoreInvalidPunycode = false
} = {}) {
  const result = processing(domainName, {
    checkHyphens,
    checkBidi,
    checkJoiners,
    useSTD3ASCIIRules,
    transitionalProcessing,
    ignoreInvalidPunycode
  });
  return {
    domain: result.string,
    error: result.error
  };
}
var tr46 = {
  toASCII,
  toUnicode
};
function isASCIIDigit(c) {
  return c >= 48 && c <= 57;
}
function isASCIIAlpha(c) {
  return c >= 65 && c <= 90 || c >= 97 && c <= 122;
}
function isASCIIAlphanumeric(c) {
  return isASCIIAlpha(c) || isASCIIDigit(c);
}
function isASCIIHex$1(c) {
  return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
}
var infra = {
  isASCIIDigit,
  isASCIIAlpha,
  isASCIIAlphanumeric,
  isASCIIHex: isASCIIHex$1
};
const utf8Encoder = new TextEncoder();
const utf8Decoder = new TextDecoder("utf-8", { ignoreBOM: true });
function utf8Encode$1(string) {
  return utf8Encoder.encode(string);
}
function utf8DecodeWithoutBOM(bytes) {
  return utf8Decoder.decode(bytes);
}
var encoding = {
  utf8Encode: utf8Encode$1,
  utf8DecodeWithoutBOM
};
const { isASCIIHex } = infra;
const { utf8Encode } = encoding;
function p(char) {
  return char.codePointAt(0);
}
function percentEncode(c) {
  let hex = c.toString(16).toUpperCase();
  if (hex.length === 1) {
    hex = `0${hex}`;
  }
  return `%${hex}`;
}
function percentDecodeBytes(input) {
  const output = new Uint8Array(input.byteLength);
  let outputIndex = 0;
  for (let i = 0; i < input.byteLength; ++i) {
    const byte = input[i];
    if (byte !== 37) {
      output[outputIndex++] = byte;
    } else if (byte === 37 && (!isASCIIHex(input[i + 1]) || !isASCIIHex(input[i + 2]))) {
      output[outputIndex++] = byte;
    } else {
      const bytePoint = parseInt(String.fromCodePoint(input[i + 1], input[i + 2]), 16);
      output[outputIndex++] = bytePoint;
      i += 2;
    }
  }
  return output.slice(0, outputIndex);
}
function percentDecodeString(input) {
  const bytes = utf8Encode(input);
  return percentDecodeBytes(bytes);
}
function isC0ControlPercentEncode(c) {
  return c <= 31 || c > 126;
}
const extraFragmentPercentEncodeSet = /* @__PURE__ */ new Set([p(" "), p('"'), p("<"), p(">"), p("`")]);
function isFragmentPercentEncode(c) {
  return isC0ControlPercentEncode(c) || extraFragmentPercentEncodeSet.has(c);
}
const extraQueryPercentEncodeSet = /* @__PURE__ */ new Set([p(" "), p('"'), p("#"), p("<"), p(">")]);
function isQueryPercentEncode(c) {
  return isC0ControlPercentEncode(c) || extraQueryPercentEncodeSet.has(c);
}
function isSpecialQueryPercentEncode(c) {
  return isQueryPercentEncode(c) || c === p("'");
}
const extraPathPercentEncodeSet = /* @__PURE__ */ new Set([p("?"), p("`"), p("{"), p("}")]);
function isPathPercentEncode(c) {
  return isQueryPercentEncode(c) || extraPathPercentEncodeSet.has(c);
}
const extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([p("/"), p(":"), p(";"), p("="), p("@"), p("["), p("\\"), p("]"), p("^"), p("|")]);
function isUserinfoPercentEncode(c) {
  return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
}
const extraComponentPercentEncodeSet = /* @__PURE__ */ new Set([p("$"), p("%"), p("&"), p("+"), p(",")]);
function isComponentPercentEncode(c) {
  return isUserinfoPercentEncode(c) || extraComponentPercentEncodeSet.has(c);
}
const extraURLEncodedPercentEncodeSet = /* @__PURE__ */ new Set([p("!"), p("'"), p("("), p(")"), p("~")]);
function isURLEncodedPercentEncode(c) {
  return isComponentPercentEncode(c) || extraURLEncodedPercentEncodeSet.has(c);
}
function utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate) {
  const bytes = utf8Encode(codePoint);
  let output = "";
  for (const byte of bytes) {
    if (!percentEncodePredicate(byte)) {
      output += String.fromCharCode(byte);
    } else {
      output += percentEncode(byte);
    }
  }
  return output;
}
function utf8PercentEncodeCodePoint(codePoint, percentEncodePredicate) {
  return utf8PercentEncodeCodePointInternal(String.fromCodePoint(codePoint), percentEncodePredicate);
}
function utf8PercentEncodeString(input, percentEncodePredicate, spaceAsPlus = false) {
  let output = "";
  for (const codePoint of input) {
    if (spaceAsPlus && codePoint === " ") {
      output += "+";
    } else {
      output += utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate);
    }
  }
  return output;
}
var percentEncoding$1 = {
  isC0ControlPercentEncode,
  isFragmentPercentEncode,
  isQueryPercentEncode,
  isSpecialQueryPercentEncode,
  isPathPercentEncode,
  isUserinfoPercentEncode,
  isURLEncodedPercentEncode,
  percentDecodeString,
  percentDecodeBytes,
  utf8PercentEncodeString,
  utf8PercentEncodeCodePoint
};
(function(module) {
  const tr46$1 = tr46;
  const infra$1 = infra;
  const { utf8DecodeWithoutBOM: utf8DecodeWithoutBOM2 } = encoding;
  const {
    percentDecodeString: percentDecodeString2,
    utf8PercentEncodeCodePoint: utf8PercentEncodeCodePoint2,
    utf8PercentEncodeString: utf8PercentEncodeString2,
    isC0ControlPercentEncode: isC0ControlPercentEncode2,
    isFragmentPercentEncode: isFragmentPercentEncode2,
    isQueryPercentEncode: isQueryPercentEncode2,
    isSpecialQueryPercentEncode: isSpecialQueryPercentEncode2,
    isPathPercentEncode: isPathPercentEncode2,
    isUserinfoPercentEncode: isUserinfoPercentEncode2
  } = percentEncoding$1;
  function p2(char) {
    return char.codePointAt(0);
  }
  const specialSchemes = {
    ftp: 21,
    file: null,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  const failure = Symbol("failure");
  function countSymbols(str) {
    return [...str].length;
  }
  function at(input, idx) {
    const c = input[idx];
    return isNaN(c) ? void 0 : String.fromCodePoint(c);
  }
  function isSingleDot(buffer2) {
    return buffer2 === "." || buffer2.toLowerCase() === "%2e";
  }
  function isDoubleDot(buffer2) {
    buffer2 = buffer2.toLowerCase();
    return buffer2 === ".." || buffer2 === "%2e." || buffer2 === ".%2e" || buffer2 === "%2e%2e";
  }
  function isWindowsDriveLetterCodePoints(cp1, cp2) {
    return infra$1.isASCIIAlpha(cp1) && (cp2 === p2(":") || cp2 === p2("|"));
  }
  function isWindowsDriveLetterString(string) {
    return string.length === 2 && infra$1.isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
  }
  function isNormalizedWindowsDriveLetterString(string) {
    return string.length === 2 && infra$1.isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
  }
  function containsForbiddenHostCodePoint(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|<|>|\?|@|\[|\\|\]|\^|\|/u) !== -1;
  }
  function containsForbiddenDomainCodePoint(string) {
    return containsForbiddenHostCodePoint(string) || string.search(/[\u0000-\u001F]|%|\u007F/u) !== -1;
  }
  function isSpecialScheme(scheme) {
    return specialSchemes[scheme] !== void 0;
  }
  function isSpecial(url) {
    return isSpecialScheme(url.scheme);
  }
  function isNotSpecial(url) {
    return !isSpecialScheme(url.scheme);
  }
  function defaultPort(scheme) {
    return specialSchemes[scheme];
  }
  function parseIPv4Number(input) {
    if (input === "") {
      return failure;
    }
    let R = 10;
    if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
      input = input.substring(2);
      R = 16;
    } else if (input.length >= 2 && input.charAt(0) === "0") {
      input = input.substring(1);
      R = 8;
    }
    if (input === "") {
      return 0;
    }
    let regex = /[^0-7]/u;
    if (R === 10) {
      regex = /[^0-9]/u;
    }
    if (R === 16) {
      regex = /[^0-9A-Fa-f]/u;
    }
    if (regex.test(input)) {
      return failure;
    }
    return parseInt(input, R);
  }
  function parseIPv4(input) {
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
      if (parts.length > 1) {
        parts.pop();
      }
    }
    if (parts.length > 4) {
      return failure;
    }
    const numbers = [];
    for (const part of parts) {
      const n2 = parseIPv4Number(part);
      if (n2 === failure) {
        return failure;
      }
      numbers.push(n2);
    }
    for (let i = 0; i < numbers.length - 1; ++i) {
      if (numbers[i] > 255) {
        return failure;
      }
    }
    if (numbers[numbers.length - 1] >= 256 ** (5 - numbers.length)) {
      return failure;
    }
    let ipv4 = numbers.pop();
    let counter = 0;
    for (const n2 of numbers) {
      ipv4 += n2 * 256 ** (3 - counter);
      ++counter;
    }
    return ipv4;
  }
  function serializeIPv4(address) {
    let output = "";
    let n2 = address;
    for (let i = 1; i <= 4; ++i) {
      output = String(n2 % 256) + output;
      if (i !== 4) {
        output = `.${output}`;
      }
      n2 = Math.floor(n2 / 256);
    }
    return output;
  }
  function parseIPv6(input) {
    const address = [0, 0, 0, 0, 0, 0, 0, 0];
    let pieceIndex = 0;
    let compress = null;
    let pointer = 0;
    input = Array.from(input, (c) => c.codePointAt(0));
    if (input[pointer] === p2(":")) {
      if (input[pointer + 1] !== p2(":")) {
        return failure;
      }
      pointer += 2;
      ++pieceIndex;
      compress = pieceIndex;
    }
    while (pointer < input.length) {
      if (pieceIndex === 8) {
        return failure;
      }
      if (input[pointer] === p2(":")) {
        if (compress !== null) {
          return failure;
        }
        ++pointer;
        ++pieceIndex;
        compress = pieceIndex;
        continue;
      }
      let value2 = 0;
      let length2 = 0;
      while (length2 < 4 && infra$1.isASCIIHex(input[pointer])) {
        value2 = value2 * 16 + parseInt(at(input, pointer), 16);
        ++pointer;
        ++length2;
      }
      if (input[pointer] === p2(".")) {
        if (length2 === 0) {
          return failure;
        }
        pointer -= length2;
        if (pieceIndex > 6) {
          return failure;
        }
        let numbersSeen = 0;
        while (input[pointer] !== void 0) {
          let ipv4Piece = null;
          if (numbersSeen > 0) {
            if (input[pointer] === p2(".") && numbersSeen < 4) {
              ++pointer;
            } else {
              return failure;
            }
          }
          if (!infra$1.isASCIIDigit(input[pointer])) {
            return failure;
          }
          while (infra$1.isASCIIDigit(input[pointer])) {
            const number = parseInt(at(input, pointer));
            if (ipv4Piece === null) {
              ipv4Piece = number;
            } else if (ipv4Piece === 0) {
              return failure;
            } else {
              ipv4Piece = ipv4Piece * 10 + number;
            }
            if (ipv4Piece > 255) {
              return failure;
            }
            ++pointer;
          }
          address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
          ++numbersSeen;
          if (numbersSeen === 2 || numbersSeen === 4) {
            ++pieceIndex;
          }
        }
        if (numbersSeen !== 4) {
          return failure;
        }
        break;
      } else if (input[pointer] === p2(":")) {
        ++pointer;
        if (input[pointer] === void 0) {
          return failure;
        }
      } else if (input[pointer] !== void 0) {
        return failure;
      }
      address[pieceIndex] = value2;
      ++pieceIndex;
    }
    if (compress !== null) {
      let swaps = pieceIndex - compress;
      pieceIndex = 7;
      while (pieceIndex !== 0 && swaps > 0) {
        const temp = address[compress + swaps - 1];
        address[compress + swaps - 1] = address[pieceIndex];
        address[pieceIndex] = temp;
        --pieceIndex;
        --swaps;
      }
    } else if (compress === null && pieceIndex !== 8) {
      return failure;
    }
    return address;
  }
  function serializeIPv6(address) {
    let output = "";
    const compress = findLongestZeroSequence(address);
    let ignore0 = false;
    for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
      if (ignore0 && address[pieceIndex] === 0) {
        continue;
      } else if (ignore0) {
        ignore0 = false;
      }
      if (compress === pieceIndex) {
        const separator = pieceIndex === 0 ? "::" : ":";
        output += separator;
        ignore0 = true;
        continue;
      }
      output += address[pieceIndex].toString(16);
      if (pieceIndex !== 7) {
        output += ":";
      }
    }
    return output;
  }
  function parseHost(input, isNotSpecialArg = false) {
    if (input[0] === "[") {
      if (input[input.length - 1] !== "]") {
        return failure;
      }
      return parseIPv6(input.substring(1, input.length - 1));
    }
    if (isNotSpecialArg) {
      return parseOpaqueHost(input);
    }
    const domain = utf8DecodeWithoutBOM2(percentDecodeString2(input));
    const asciiDomain = domainToASCII(domain);
    if (asciiDomain === failure) {
      return failure;
    }
    if (containsForbiddenDomainCodePoint(asciiDomain)) {
      return failure;
    }
    if (endsInANumber(asciiDomain)) {
      return parseIPv4(asciiDomain);
    }
    return asciiDomain;
  }
  function endsInANumber(input) {
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
      if (parts.length === 1) {
        return false;
      }
      parts.pop();
    }
    const last = parts[parts.length - 1];
    if (parseIPv4Number(last) !== failure) {
      return true;
    }
    if (/^[0-9]+$/u.test(last)) {
      return true;
    }
    return false;
  }
  function parseOpaqueHost(input) {
    if (containsForbiddenHostCodePoint(input)) {
      return failure;
    }
    return utf8PercentEncodeString2(input, isC0ControlPercentEncode2);
  }
  function findLongestZeroSequence(arr) {
    let maxIdx = null;
    let maxLen = 1;
    let currStart = null;
    let currLen = 0;
    for (let i = 0; i < arr.length; ++i) {
      if (arr[i] !== 0) {
        if (currLen > maxLen) {
          maxIdx = currStart;
          maxLen = currLen;
        }
        currStart = null;
        currLen = 0;
      } else {
        if (currStart === null) {
          currStart = i;
        }
        ++currLen;
      }
    }
    if (currLen > maxLen) {
      return currStart;
    }
    return maxIdx;
  }
  function serializeHost(host2) {
    if (typeof host2 === "number") {
      return serializeIPv4(host2);
    }
    if (host2 instanceof Array) {
      return `[${serializeIPv6(host2)}]`;
    }
    return host2;
  }
  function domainToASCII(domain, beStrict = false) {
    const result = tr46$1.toASCII(domain, {
      checkBidi: true,
      checkHyphens: false,
      checkJoiners: true,
      useSTD3ASCIIRules: beStrict,
      verifyDNSLength: beStrict
    });
    if (result === null || result === "") {
      return failure;
    }
    return result;
  }
  function trimControlChars(url) {
    return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/ug, "");
  }
  function trimTabAndNewline(url) {
    return url.replace(/\u0009|\u000A|\u000D/ug, "");
  }
  function shortenPath(url) {
    const { path } = url;
    if (path.length === 0) {
      return;
    }
    if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
      return;
    }
    path.pop();
  }
  function includesCredentials(url) {
    return url.username !== "" || url.password !== "";
  }
  function cannotHaveAUsernamePasswordPort(url) {
    return url.host === null || url.host === "" || url.scheme === "file";
  }
  function hasAnOpaquePath(url) {
    return typeof url.path === "string";
  }
  function isNormalizedWindowsDriveLetter(string) {
    return /^[A-Za-z]:$/u.test(string);
  }
  function URLStateMachine(input, base2, encodingOverride, url, stateOverride) {
    this.pointer = 0;
    this.input = input;
    this.base = base2 || null;
    this.encodingOverride = encodingOverride || "utf-8";
    this.stateOverride = stateOverride;
    this.url = url;
    this.failure = false;
    this.parseError = false;
    if (!this.url) {
      this.url = {
        scheme: "",
        username: "",
        password: "",
        host: null,
        port: null,
        path: [],
        query: null,
        fragment: null
      };
      const res2 = trimControlChars(this.input);
      if (res2 !== this.input) {
        this.parseError = true;
      }
      this.input = res2;
    }
    const res = trimTabAndNewline(this.input);
    if (res !== this.input) {
      this.parseError = true;
    }
    this.input = res;
    this.state = stateOverride || "scheme start";
    this.buffer = "";
    this.atFlag = false;
    this.arrFlag = false;
    this.passwordTokenSeenFlag = false;
    this.input = Array.from(this.input, (c) => c.codePointAt(0));
    for (; this.pointer <= this.input.length; ++this.pointer) {
      const c = this.input[this.pointer];
      const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
      const ret = this[`parse ${this.state}`](c, cStr);
      if (!ret) {
        break;
      } else if (ret === failure) {
        this.failure = true;
        break;
      }
    }
  }
  URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
    if (infra$1.isASCIIAlpha(c)) {
      this.buffer += cStr.toLowerCase();
      this.state = "scheme";
    } else if (!this.stateOverride) {
      this.state = "no scheme";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
    if (infra$1.isASCIIAlphanumeric(c) || c === p2("+") || c === p2("-") || c === p2(".")) {
      this.buffer += cStr.toLowerCase();
    } else if (c === p2(":")) {
      if (this.stateOverride) {
        if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
          return false;
        }
        if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
          return false;
        }
        if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
          return false;
        }
        if (this.url.scheme === "file" && this.url.host === "") {
          return false;
        }
      }
      this.url.scheme = this.buffer;
      if (this.stateOverride) {
        if (this.url.port === defaultPort(this.url.scheme)) {
          this.url.port = null;
        }
        return false;
      }
      this.buffer = "";
      if (this.url.scheme === "file") {
        if (this.input[this.pointer + 1] !== p2("/") || this.input[this.pointer + 2] !== p2("/")) {
          this.parseError = true;
        }
        this.state = "file";
      } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
        this.state = "special relative or authority";
      } else if (isSpecial(this.url)) {
        this.state = "special authority slashes";
      } else if (this.input[this.pointer + 1] === p2("/")) {
        this.state = "path or authority";
        ++this.pointer;
      } else {
        this.url.path = "";
        this.state = "opaque path";
      }
    } else if (!this.stateOverride) {
      this.buffer = "";
      this.state = "no scheme";
      this.pointer = -1;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
    if (this.base === null || hasAnOpaquePath(this.base) && c !== p2("#")) {
      return failure;
    } else if (hasAnOpaquePath(this.base) && c === p2("#")) {
      this.url.scheme = this.base.scheme;
      this.url.path = this.base.path;
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.state = "fragment";
    } else if (this.base.scheme === "file") {
      this.state = "file";
      --this.pointer;
    } else {
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
    if (c === p2("/") && this.input[this.pointer + 1] === p2("/")) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
    if (c === p2("/")) {
      this.state = "authority";
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
    this.url.scheme = this.base.scheme;
    if (c === p2("/")) {
      this.state = "relative slash";
    } else if (isSpecial(this.url) && c === p2("\\")) {
      this.parseError = true;
      this.state = "relative slash";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      if (c === p2("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (c === p2("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (!isNaN(c)) {
        this.url.query = null;
        this.url.path.pop();
        this.state = "path";
        --this.pointer;
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
    if (isSpecial(this.url) && (c === p2("/") || c === p2("\\"))) {
      if (c === p2("\\")) {
        this.parseError = true;
      }
      this.state = "special authority ignore slashes";
    } else if (c === p2("/")) {
      this.state = "authority";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
    if (c === p2("/") && this.input[this.pointer + 1] === p2("/")) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "special authority ignore slashes";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
    if (c !== p2("/") && c !== p2("\\")) {
      this.state = "authority";
      --this.pointer;
    } else {
      this.parseError = true;
    }
    return true;
  };
  URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
    if (c === p2("@")) {
      this.parseError = true;
      if (this.atFlag) {
        this.buffer = `%40${this.buffer}`;
      }
      this.atFlag = true;
      const len = countSymbols(this.buffer);
      for (let pointer = 0; pointer < len; ++pointer) {
        const codePoint = this.buffer.codePointAt(pointer);
        if (codePoint === p2(":") && !this.passwordTokenSeenFlag) {
          this.passwordTokenSeenFlag = true;
          continue;
        }
        const encodedCodePoints = utf8PercentEncodeCodePoint2(codePoint, isUserinfoPercentEncode2);
        if (this.passwordTokenSeenFlag) {
          this.url.password += encodedCodePoints;
        } else {
          this.url.username += encodedCodePoints;
        }
      }
      this.buffer = "";
    } else if (isNaN(c) || c === p2("/") || c === p2("?") || c === p2("#") || isSpecial(this.url) && c === p2("\\")) {
      if (this.atFlag && this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      this.pointer -= countSymbols(this.buffer) + 1;
      this.buffer = "";
      this.state = "host";
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
    if (this.stateOverride && this.url.scheme === "file") {
      --this.pointer;
      this.state = "file host";
    } else if (c === p2(":") && !this.arrFlag) {
      if (this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      if (this.stateOverride === "hostname") {
        return false;
      }
      const host2 = parseHost(this.buffer, isNotSpecial(this.url));
      if (host2 === failure) {
        return failure;
      }
      this.url.host = host2;
      this.buffer = "";
      this.state = "port";
    } else if (isNaN(c) || c === p2("/") || c === p2("?") || c === p2("#") || isSpecial(this.url) && c === p2("\\")) {
      --this.pointer;
      if (isSpecial(this.url) && this.buffer === "") {
        this.parseError = true;
        return failure;
      } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
        this.parseError = true;
        return false;
      }
      const host2 = parseHost(this.buffer, isNotSpecial(this.url));
      if (host2 === failure) {
        return failure;
      }
      this.url.host = host2;
      this.buffer = "";
      this.state = "path start";
      if (this.stateOverride) {
        return false;
      }
    } else {
      if (c === p2("[")) {
        this.arrFlag = true;
      } else if (c === p2("]")) {
        this.arrFlag = false;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
    if (infra$1.isASCIIDigit(c)) {
      this.buffer += cStr;
    } else if (isNaN(c) || c === p2("/") || c === p2("?") || c === p2("#") || isSpecial(this.url) && c === p2("\\") || this.stateOverride) {
      if (this.buffer !== "") {
        const port = parseInt(this.buffer);
        if (port > 2 ** 16 - 1) {
          this.parseError = true;
          return failure;
        }
        this.url.port = port === defaultPort(this.url.scheme) ? null : port;
        this.buffer = "";
      }
      if (this.stateOverride) {
        return false;
      }
      this.state = "path start";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  const fileOtherwiseCodePoints = /* @__PURE__ */ new Set([p2("/"), p2("\\"), p2("?"), p2("#")]);
  function startsWithWindowsDriveLetter(input, pointer) {
    const length2 = input.length - pointer;
    return length2 >= 2 && isWindowsDriveLetterCodePoints(input[pointer], input[pointer + 1]) && (length2 === 2 || fileOtherwiseCodePoints.has(input[pointer + 2]));
  }
  URLStateMachine.prototype["parse file"] = function parseFile(c) {
    this.url.scheme = "file";
    this.url.host = "";
    if (c === p2("/") || c === p2("\\")) {
      if (c === p2("\\")) {
        this.parseError = true;
      }
      this.state = "file slash";
    } else if (this.base !== null && this.base.scheme === "file") {
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      if (c === p2("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (c === p2("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (!isNaN(c)) {
        this.url.query = null;
        if (!startsWithWindowsDriveLetter(this.input, this.pointer)) {
          shortenPath(this.url);
        } else {
          this.parseError = true;
          this.url.path = [];
        }
        this.state = "path";
        --this.pointer;
      }
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
    if (c === p2("/") || c === p2("\\")) {
      if (c === p2("\\")) {
        this.parseError = true;
      }
      this.state = "file host";
    } else {
      if (this.base !== null && this.base.scheme === "file") {
        if (!startsWithWindowsDriveLetter(this.input, this.pointer) && isNormalizedWindowsDriveLetterString(this.base.path[0])) {
          this.url.path.push(this.base.path[0]);
        }
        this.url.host = this.base.host;
      }
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
    if (isNaN(c) || c === p2("/") || c === p2("\\") || c === p2("?") || c === p2("#")) {
      --this.pointer;
      if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
        this.parseError = true;
        this.state = "path";
      } else if (this.buffer === "") {
        this.url.host = "";
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
      } else {
        let host2 = parseHost(this.buffer, isNotSpecial(this.url));
        if (host2 === failure) {
          return failure;
        }
        if (host2 === "localhost") {
          host2 = "";
        }
        this.url.host = host2;
        if (this.stateOverride) {
          return false;
        }
        this.buffer = "";
        this.state = "path start";
      }
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
    if (isSpecial(this.url)) {
      if (c === p2("\\")) {
        this.parseError = true;
      }
      this.state = "path";
      if (c !== p2("/") && c !== p2("\\")) {
        --this.pointer;
      }
    } else if (!this.stateOverride && c === p2("?")) {
      this.url.query = "";
      this.state = "query";
    } else if (!this.stateOverride && c === p2("#")) {
      this.url.fragment = "";
      this.state = "fragment";
    } else if (c !== void 0) {
      this.state = "path";
      if (c !== p2("/")) {
        --this.pointer;
      }
    } else if (this.stateOverride && this.url.host === null) {
      this.url.path.push("");
    }
    return true;
  };
  URLStateMachine.prototype["parse path"] = function parsePath(c) {
    if (isNaN(c) || c === p2("/") || isSpecial(this.url) && c === p2("\\") || !this.stateOverride && (c === p2("?") || c === p2("#"))) {
      if (isSpecial(this.url) && c === p2("\\")) {
        this.parseError = true;
      }
      if (isDoubleDot(this.buffer)) {
        shortenPath(this.url);
        if (c !== p2("/") && !(isSpecial(this.url) && c === p2("\\"))) {
          this.url.path.push("");
        }
      } else if (isSingleDot(this.buffer) && c !== p2("/") && !(isSpecial(this.url) && c === p2("\\"))) {
        this.url.path.push("");
      } else if (!isSingleDot(this.buffer)) {
        if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
          this.buffer = `${this.buffer[0]}:`;
        }
        this.url.path.push(this.buffer);
      }
      this.buffer = "";
      if (c === p2("?")) {
        this.url.query = "";
        this.state = "query";
      }
      if (c === p2("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else {
      if (c === p2("%") && (!infra$1.isASCIIHex(this.input[this.pointer + 1]) || !infra$1.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += utf8PercentEncodeCodePoint2(c, isPathPercentEncode2);
    }
    return true;
  };
  URLStateMachine.prototype["parse opaque path"] = function parseOpaquePath(c) {
    if (c === p2("?")) {
      this.url.query = "";
      this.state = "query";
    } else if (c === p2("#")) {
      this.url.fragment = "";
      this.state = "fragment";
    } else {
      if (!isNaN(c) && c !== p2("%")) {
        this.parseError = true;
      }
      if (c === p2("%") && (!infra$1.isASCIIHex(this.input[this.pointer + 1]) || !infra$1.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      if (!isNaN(c)) {
        this.url.path += utf8PercentEncodeCodePoint2(c, isC0ControlPercentEncode2);
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
    if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
      this.encodingOverride = "utf-8";
    }
    if (!this.stateOverride && c === p2("#") || isNaN(c)) {
      const queryPercentEncodePredicate = isSpecial(this.url) ? isSpecialQueryPercentEncode2 : isQueryPercentEncode2;
      this.url.query += utf8PercentEncodeString2(this.buffer, queryPercentEncodePredicate);
      this.buffer = "";
      if (c === p2("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else if (!isNaN(c)) {
      if (c === p2("%") && (!infra$1.isASCIIHex(this.input[this.pointer + 1]) || !infra$1.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
    if (!isNaN(c)) {
      if (c === p2("%") && (!infra$1.isASCIIHex(this.input[this.pointer + 1]) || !infra$1.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.url.fragment += utf8PercentEncodeCodePoint2(c, isFragmentPercentEncode2);
    }
    return true;
  };
  function serializeURL(url, excludeFragment) {
    let output = `${url.scheme}:`;
    if (url.host !== null) {
      output += "//";
      if (url.username !== "" || url.password !== "") {
        output += url.username;
        if (url.password !== "") {
          output += `:${url.password}`;
        }
        output += "@";
      }
      output += serializeHost(url.host);
      if (url.port !== null) {
        output += `:${url.port}`;
      }
    }
    if (url.host === null && !hasAnOpaquePath(url) && url.path.length > 1 && url.path[0] === "") {
      output += "/.";
    }
    output += serializePath(url);
    if (url.query !== null) {
      output += `?${url.query}`;
    }
    if (!excludeFragment && url.fragment !== null) {
      output += `#${url.fragment}`;
    }
    return output;
  }
  function serializeOrigin(tuple) {
    let result = `${tuple.scheme}://`;
    result += serializeHost(tuple.host);
    if (tuple.port !== null) {
      result += `:${tuple.port}`;
    }
    return result;
  }
  function serializePath(url) {
    if (hasAnOpaquePath(url)) {
      return url.path;
    }
    let output = "";
    for (const segment of url.path) {
      output += `/${segment}`;
    }
    return output;
  }
  module.exports.serializeURL = serializeURL;
  module.exports.serializePath = serializePath;
  module.exports.serializeURLOrigin = function(url) {
    switch (url.scheme) {
      case "blob": {
        const pathURL = module.exports.parseURL(serializePath(url));
        if (pathURL === null) {
          return "null";
        }
        if (pathURL.scheme !== "http" && pathURL.scheme !== "https") {
          return "null";
        }
        return module.exports.serializeURLOrigin(pathURL);
      }
      case "ftp":
      case "http":
      case "https":
      case "ws":
      case "wss":
        return serializeOrigin({
          scheme: url.scheme,
          host: url.host,
          port: url.port
        });
      case "file":
        return "null";
      default:
        return "null";
    }
  };
  module.exports.basicURLParse = function(input, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    const usm = new URLStateMachine(input, options2.baseURL, options2.encodingOverride, options2.url, options2.stateOverride);
    if (usm.failure) {
      return null;
    }
    return usm.url;
  };
  module.exports.setTheUsername = function(url, username) {
    url.username = utf8PercentEncodeString2(username, isUserinfoPercentEncode2);
  };
  module.exports.setThePassword = function(url, password) {
    url.password = utf8PercentEncodeString2(password, isUserinfoPercentEncode2);
  };
  module.exports.serializeHost = serializeHost;
  module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
  module.exports.hasAnOpaquePath = hasAnOpaquePath;
  module.exports.serializeInteger = function(integer) {
    return String(integer);
  };
  module.exports.parseURL = function(input, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return module.exports.basicURLParse(input, { baseURL: options2.baseURL, encodingOverride: options2.encodingOverride });
  };
})(urlStateMachine$1);
var urlStateMachineExports = urlStateMachine$1.exports;
var urlencoded;
var hasRequiredUrlencoded;
function requireUrlencoded() {
  if (hasRequiredUrlencoded) return urlencoded;
  hasRequiredUrlencoded = 1;
  const { utf8Encode: utf8Encode2, utf8DecodeWithoutBOM: utf8DecodeWithoutBOM2 } = encoding;
  const { percentDecodeBytes: percentDecodeBytes2, utf8PercentEncodeString: utf8PercentEncodeString2, isURLEncodedPercentEncode: isURLEncodedPercentEncode2 } = percentEncoding$1;
  function p2(char) {
    return char.codePointAt(0);
  }
  function parseUrlencoded(input) {
    const sequences = strictlySplitByteSequence(input, p2("&"));
    const output = [];
    for (const bytes of sequences) {
      if (bytes.length === 0) {
        continue;
      }
      let name2, value2;
      const indexOfEqual = bytes.indexOf(p2("="));
      if (indexOfEqual >= 0) {
        name2 = bytes.slice(0, indexOfEqual);
        value2 = bytes.slice(indexOfEqual + 1);
      } else {
        name2 = bytes;
        value2 = new Uint8Array(0);
      }
      name2 = replaceByteInByteSequence(name2, 43, 32);
      value2 = replaceByteInByteSequence(value2, 43, 32);
      const nameString = utf8DecodeWithoutBOM2(percentDecodeBytes2(name2));
      const valueString = utf8DecodeWithoutBOM2(percentDecodeBytes2(value2));
      output.push([nameString, valueString]);
    }
    return output;
  }
  function parseUrlencodedString(input) {
    return parseUrlencoded(utf8Encode2(input));
  }
  function serializeUrlencoded(tuples, encodingOverride = void 0) {
    let encoding2 = "utf-8";
    if (encodingOverride !== void 0) {
      encoding2 = encodingOverride;
    }
    let output = "";
    for (const [i, tuple] of tuples.entries()) {
      const name2 = utf8PercentEncodeString2(tuple[0], isURLEncodedPercentEncode2, true);
      let value2 = tuple[1];
      if (tuple.length > 2 && tuple[2] !== void 0) {
        if (tuple[2] === "hidden" && name2 === "_charset_") {
          value2 = encoding2;
        } else if (tuple[2] === "file") {
          value2 = value2.name;
        }
      }
      value2 = utf8PercentEncodeString2(value2, isURLEncodedPercentEncode2, true);
      if (i !== 0) {
        output += "&";
      }
      output += `${name2}=${value2}`;
    }
    return output;
  }
  function strictlySplitByteSequence(buf, cp) {
    const list2 = [];
    let last = 0;
    let i = buf.indexOf(cp);
    while (i >= 0) {
      list2.push(buf.slice(last, i));
      last = i + 1;
      i = buf.indexOf(cp, last);
    }
    if (last !== buf.length) {
      list2.push(buf.slice(last));
    }
    return list2;
  }
  function replaceByteInByteSequence(buf, from, to) {
    let i = buf.indexOf(from);
    while (i >= 0) {
      buf[i] = to;
      i = buf.indexOf(from, i + 1);
    }
    return buf;
  }
  urlencoded = {
    parseUrlencodedString,
    serializeUrlencoded
  };
  return urlencoded;
}
var URLSearchParams$2 = {};
var _Function = {};
const conversions = lib;
const utils$1 = utilsExports;
_Function.convert = (globalObject, value2, { context = "The provided value" } = {}) => {
  if (typeof value2 !== "function") {
    throw new globalObject.TypeError(context + " is not a function");
  }
  function invokeTheCallbackFunction(...args) {
    const thisArg = utils$1.tryWrapperForImpl(this);
    let callResult;
    for (let i = 0; i < args.length; i++) {
      args[i] = utils$1.tryWrapperForImpl(args[i]);
    }
    callResult = Reflect.apply(value2, thisArg, args);
    callResult = conversions["any"](callResult, { context, globals: globalObject });
    return callResult;
  }
  invokeTheCallbackFunction.construct = (...args) => {
    for (let i = 0; i < args.length; i++) {
      args[i] = utils$1.tryWrapperForImpl(args[i]);
    }
    let callResult = Reflect.construct(value2, args);
    callResult = conversions["any"](callResult, { context, globals: globalObject });
    return callResult;
  };
  invokeTheCallbackFunction[utils$1.wrapperSymbol] = value2;
  invokeTheCallbackFunction.objectReference = value2;
  return invokeTheCallbackFunction;
};
var URLSearchParamsImpl = {};
var hasRequiredURLSearchParamsImpl;
function requireURLSearchParamsImpl() {
  if (hasRequiredURLSearchParamsImpl) return URLSearchParamsImpl;
  hasRequiredURLSearchParamsImpl = 1;
  const urlencoded2 = requireUrlencoded();
  URLSearchParamsImpl.implementation = class URLSearchParamsImpl {
    constructor(globalObject, constructorArgs, { doNotStripQMark = false }) {
      let init = constructorArgs[0];
      this._list = [];
      this._url = null;
      if (!doNotStripQMark && typeof init === "string" && init[0] === "?") {
        init = init.slice(1);
      }
      if (Array.isArray(init)) {
        for (const pair of init) {
          if (pair.length !== 2) {
            throw new TypeError("Failed to construct 'URLSearchParams': parameter 1 sequence's element does not contain exactly two elements.");
          }
          this._list.push([pair[0], pair[1]]);
        }
      } else if (typeof init === "object" && Object.getPrototypeOf(init) === null) {
        for (const name2 of Object.keys(init)) {
          const value2 = init[name2];
          this._list.push([name2, value2]);
        }
      } else {
        this._list = urlencoded2.parseUrlencodedString(init);
      }
    }
    _updateSteps() {
      if (this._url !== null) {
        let serializedQuery = urlencoded2.serializeUrlencoded(this._list);
        if (serializedQuery === "") {
          serializedQuery = null;
        }
        this._url._url.query = serializedQuery;
        if (serializedQuery === null) {
          this._url._potentiallyStripTrailingSpacesFromAnOpaquePath();
        }
      }
    }
    get size() {
      return this._list.length;
    }
    append(name2, value2) {
      this._list.push([name2, value2]);
      this._updateSteps();
    }
    delete(name2, value2) {
      let i = 0;
      while (i < this._list.length) {
        if (this._list[i][0] === name2 && (value2 === void 0 || this._list[i][1] === value2)) {
          this._list.splice(i, 1);
        } else {
          i++;
        }
      }
      this._updateSteps();
    }
    get(name2) {
      for (const tuple of this._list) {
        if (tuple[0] === name2) {
          return tuple[1];
        }
      }
      return null;
    }
    getAll(name2) {
      const output = [];
      for (const tuple of this._list) {
        if (tuple[0] === name2) {
          output.push(tuple[1]);
        }
      }
      return output;
    }
    has(name2, value2) {
      for (const tuple of this._list) {
        if (tuple[0] === name2 && (value2 === void 0 || tuple[1] === value2)) {
          return true;
        }
      }
      return false;
    }
    set(name2, value2) {
      let found = false;
      let i = 0;
      while (i < this._list.length) {
        if (this._list[i][0] === name2) {
          if (found) {
            this._list.splice(i, 1);
          } else {
            found = true;
            this._list[i][1] = value2;
            i++;
          }
        } else {
          i++;
        }
      }
      if (!found) {
        this._list.push([name2, value2]);
      }
      this._updateSteps();
    }
    sort() {
      this._list.sort((a, b) => {
        if (a[0] < b[0]) {
          return -1;
        }
        if (a[0] > b[0]) {
          return 1;
        }
        return 0;
      });
      this._updateSteps();
    }
    [Symbol.iterator]() {
      return this._list[Symbol.iterator]();
    }
    toString() {
      return urlencoded2.serializeUrlencoded(this._list);
    }
  };
  return URLSearchParamsImpl;
}
(function(exports) {
  const conversions2 = lib;
  const utils2 = utilsExports;
  const Function3 = _Function;
  const newObjectInRealm = utils2.newObjectInRealm;
  const implSymbol = utils2.implSymbol;
  const ctorRegistrySymbol = utils2.ctorRegistrySymbol;
  const interfaceName = "URLSearchParams";
  exports.is = (value2) => {
    return utils2.isObject(value2) && utils2.hasOwn(value2, implSymbol) && value2[implSymbol] instanceof Impl.implementation;
  };
  exports.isImpl = (value2) => {
    return utils2.isObject(value2) && value2 instanceof Impl.implementation;
  };
  exports.convert = (globalObject, value2, { context = "The provided value" } = {}) => {
    if (exports.is(value2)) {
      return utils2.implForWrapper(value2);
    }
    throw new globalObject.TypeError(`${context} is not of type 'URLSearchParams'.`);
  };
  exports.createDefaultIterator = (globalObject, target2, kind) => {
    const ctorRegistry = globalObject[ctorRegistrySymbol];
    const iteratorPrototype = ctorRegistry["URLSearchParams Iterator"];
    const iterator = Object.create(iteratorPrototype);
    Object.defineProperty(iterator, utils2.iterInternalSymbol, {
      value: { target: target2, kind, index: 0 },
      configurable: true
    });
    return iterator;
  };
  function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== void 0) {
      proto = newTarget.prototype;
    }
    if (!utils2.isObject(proto)) {
      proto = globalObject[ctorRegistrySymbol]["URLSearchParams"].prototype;
    }
    return Object.create(proto);
  }
  exports.create = (globalObject, constructorArgs, privateData) => {
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
  };
  exports.createImpl = (globalObject, constructorArgs, privateData) => {
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils2.implForWrapper(wrapper);
  };
  exports._internalSetup = (wrapper, globalObject) => {
  };
  exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
      value: new Impl.implementation(globalObject, constructorArgs, privateData),
      configurable: true
    });
    wrapper[implSymbol][utils2.wrapperSymbol] = wrapper;
    if (Impl.init) {
      Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
  };
  exports.new = (globalObject, newTarget) => {
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
      value: Object.create(Impl.implementation.prototype),
      configurable: true
    });
    wrapper[implSymbol][utils2.wrapperSymbol] = wrapper;
    if (Impl.init) {
      Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
  };
  const exposed = /* @__PURE__ */ new Set(["Window", "Worker"]);
  exports.install = (globalObject, globalNames) => {
    if (!globalNames.some((globalName) => exposed.has(globalName))) {
      return;
    }
    const ctorRegistry = utils2.initCtorRegistry(globalObject);
    class URLSearchParams2 {
      constructor() {
        const args = [];
        {
          let curArg = arguments[0];
          if (curArg !== void 0) {
            if (utils2.isObject(curArg)) {
              if (curArg[Symbol.iterator] !== void 0) {
                if (!utils2.isObject(curArg)) {
                  throw new globalObject.TypeError(
                    "Failed to construct 'URLSearchParams': parameter 1 sequence is not an iterable object."
                  );
                } else {
                  const V = [];
                  const tmp = curArg;
                  for (let nextItem of tmp) {
                    if (!utils2.isObject(nextItem)) {
                      throw new globalObject.TypeError(
                        "Failed to construct 'URLSearchParams': parameter 1 sequence's element is not an iterable object."
                      );
                    } else {
                      const V2 = [];
                      const tmp2 = nextItem;
                      for (let nextItem2 of tmp2) {
                        nextItem2 = conversions2["USVString"](nextItem2, {
                          context: "Failed to construct 'URLSearchParams': parameter 1 sequence's element's element",
                          globals: globalObject
                        });
                        V2.push(nextItem2);
                      }
                      nextItem = V2;
                    }
                    V.push(nextItem);
                  }
                  curArg = V;
                }
              } else {
                if (!utils2.isObject(curArg)) {
                  throw new globalObject.TypeError(
                    "Failed to construct 'URLSearchParams': parameter 1 record is not an object."
                  );
                } else {
                  const result = /* @__PURE__ */ Object.create(null);
                  for (const key of Reflect.ownKeys(curArg)) {
                    const desc = Object.getOwnPropertyDescriptor(curArg, key);
                    if (desc && desc.enumerable) {
                      let typedKey = key;
                      typedKey = conversions2["USVString"](typedKey, {
                        context: "Failed to construct 'URLSearchParams': parameter 1 record's key",
                        globals: globalObject
                      });
                      let typedValue = curArg[key];
                      typedValue = conversions2["USVString"](typedValue, {
                        context: "Failed to construct 'URLSearchParams': parameter 1 record's value",
                        globals: globalObject
                      });
                      result[typedKey] = typedValue;
                    }
                  }
                  curArg = result;
                }
              }
            } else {
              curArg = conversions2["USVString"](curArg, {
                context: "Failed to construct 'URLSearchParams': parameter 1",
                globals: globalObject
              });
            }
          } else {
            curArg = "";
          }
          args.push(curArg);
        }
        return exports.setup(Object.create(new.target.prototype), globalObject, args);
      }
      append(name2, value2) {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError(
            "'append' called on an object that is not a valid instance of URLSearchParams."
          );
        }
        if (arguments.length < 2) {
          throw new globalObject.TypeError(
            `Failed to execute 'append' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`
          );
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions2["USVString"](curArg, {
            context: "Failed to execute 'append' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          curArg = conversions2["USVString"](curArg, {
            context: "Failed to execute 'append' on 'URLSearchParams': parameter 2",
            globals: globalObject
          });
          args.push(curArg);
        }
        return utils2.tryWrapperForImpl(esValue[implSymbol].append(...args));
      }
      delete(name2) {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError(
            "'delete' called on an object that is not a valid instance of URLSearchParams."
          );
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(
            `Failed to execute 'delete' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
          );
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions2["USVString"](curArg, {
            context: "Failed to execute 'delete' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          if (curArg !== void 0) {
            curArg = conversions2["USVString"](curArg, {
              context: "Failed to execute 'delete' on 'URLSearchParams': parameter 2",
              globals: globalObject
            });
          }
          args.push(curArg);
        }
        return utils2.tryWrapperForImpl(esValue[implSymbol].delete(...args));
      }
      get(name2) {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(
            `Failed to execute 'get' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
          );
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions2["USVString"](curArg, {
            context: "Failed to execute 'get' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        return esValue[implSymbol].get(...args);
      }
      getAll(name2) {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError(
            "'getAll' called on an object that is not a valid instance of URLSearchParams."
          );
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(
            `Failed to execute 'getAll' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
          );
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions2["USVString"](curArg, {
            context: "Failed to execute 'getAll' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        return utils2.tryWrapperForImpl(esValue[implSymbol].getAll(...args));
      }
      has(name2) {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'has' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(
            `Failed to execute 'has' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
          );
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions2["USVString"](curArg, {
            context: "Failed to execute 'has' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          if (curArg !== void 0) {
            curArg = conversions2["USVString"](curArg, {
              context: "Failed to execute 'has' on 'URLSearchParams': parameter 2",
              globals: globalObject
            });
          }
          args.push(curArg);
        }
        return esValue[implSymbol].has(...args);
      }
      set(name2, value2) {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 2) {
          throw new globalObject.TypeError(
            `Failed to execute 'set' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`
          );
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions2["USVString"](curArg, {
            context: "Failed to execute 'set' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          curArg = conversions2["USVString"](curArg, {
            context: "Failed to execute 'set' on 'URLSearchParams': parameter 2",
            globals: globalObject
          });
          args.push(curArg);
        }
        return utils2.tryWrapperForImpl(esValue[implSymbol].set(...args));
      }
      sort() {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'sort' called on an object that is not a valid instance of URLSearchParams.");
        }
        return utils2.tryWrapperForImpl(esValue[implSymbol].sort());
      }
      toString() {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError(
            "'toString' called on an object that is not a valid instance of URLSearchParams."
          );
        }
        return esValue[implSymbol].toString();
      }
      keys() {
        if (!exports.is(this)) {
          throw new globalObject.TypeError("'keys' called on an object that is not a valid instance of URLSearchParams.");
        }
        return exports.createDefaultIterator(globalObject, this, "key");
      }
      values() {
        if (!exports.is(this)) {
          throw new globalObject.TypeError(
            "'values' called on an object that is not a valid instance of URLSearchParams."
          );
        }
        return exports.createDefaultIterator(globalObject, this, "value");
      }
      entries() {
        if (!exports.is(this)) {
          throw new globalObject.TypeError(
            "'entries' called on an object that is not a valid instance of URLSearchParams."
          );
        }
        return exports.createDefaultIterator(globalObject, this, "key+value");
      }
      forEach(callback) {
        if (!exports.is(this)) {
          throw new globalObject.TypeError(
            "'forEach' called on an object that is not a valid instance of URLSearchParams."
          );
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(
            "Failed to execute 'forEach' on 'iterable': 1 argument required, but only 0 present."
          );
        }
        callback = Function3.convert(globalObject, callback, {
          context: "Failed to execute 'forEach' on 'iterable': The callback provided as parameter 1"
        });
        const thisArg = arguments[1];
        let pairs = Array.from(this[implSymbol]);
        let i = 0;
        while (i < pairs.length) {
          const [key, value2] = pairs[i].map(utils2.tryWrapperForImpl);
          callback.call(thisArg, value2, key, this);
          pairs = Array.from(this[implSymbol]);
          i++;
        }
      }
      get size() {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError(
            "'get size' called on an object that is not a valid instance of URLSearchParams."
          );
        }
        return esValue[implSymbol]["size"];
      }
    }
    Object.defineProperties(URLSearchParams2.prototype, {
      append: { enumerable: true },
      delete: { enumerable: true },
      get: { enumerable: true },
      getAll: { enumerable: true },
      has: { enumerable: true },
      set: { enumerable: true },
      sort: { enumerable: true },
      toString: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true },
      forEach: { enumerable: true },
      size: { enumerable: true },
      [Symbol.toStringTag]: { value: "URLSearchParams", configurable: true },
      [Symbol.iterator]: { value: URLSearchParams2.prototype.entries, configurable: true, writable: true }
    });
    ctorRegistry[interfaceName] = URLSearchParams2;
    ctorRegistry["URLSearchParams Iterator"] = Object.create(ctorRegistry["%IteratorPrototype%"], {
      [Symbol.toStringTag]: {
        configurable: true,
        value: "URLSearchParams Iterator"
      }
    });
    utils2.define(ctorRegistry["URLSearchParams Iterator"], {
      next() {
        const internal = this && this[utils2.iterInternalSymbol];
        if (!internal) {
          throw new globalObject.TypeError("next() called on a value that is not a URLSearchParams iterator object");
        }
        const { target: target2, kind, index } = internal;
        const values = Array.from(target2[implSymbol]);
        const len = values.length;
        if (index >= len) {
          return newObjectInRealm(globalObject, { value: void 0, done: true });
        }
        const pair = values[index];
        internal.index = index + 1;
        return newObjectInRealm(globalObject, utils2.iteratorResult(pair.map(utils2.tryWrapperForImpl), kind));
      }
    });
    Object.defineProperty(globalObject, interfaceName, {
      configurable: true,
      writable: true,
      value: URLSearchParams2
    });
  };
  const Impl = requireURLSearchParamsImpl();
})(URLSearchParams$2);
var hasRequiredURLImpl;
function requireURLImpl() {
  if (hasRequiredURLImpl) return URLImpl;
  hasRequiredURLImpl = 1;
  const usm = urlStateMachineExports;
  const urlencoded2 = requireUrlencoded();
  const URLSearchParams2 = URLSearchParams$2;
  URLImpl.implementation = class URLImpl {
    // Unlike the spec, we duplicate some code between the constructor and canParse, because we want to give useful error
    // messages in the constructor that distinguish between the different causes of failure.
    constructor(globalObject, constructorArgs) {
      const url = constructorArgs[0];
      const base2 = constructorArgs[1];
      let parsedBase = null;
      if (base2 !== void 0) {
        parsedBase = usm.basicURLParse(base2);
        if (parsedBase === null) {
          throw new TypeError(`Invalid base URL: ${base2}`);
        }
      }
      const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
      if (parsedURL === null) {
        throw new TypeError(`Invalid URL: ${url}`);
      }
      const query2 = parsedURL.query !== null ? parsedURL.query : "";
      this._url = parsedURL;
      this._query = URLSearchParams2.createImpl(globalObject, [query2], { doNotStripQMark: true });
      this._query._url = this;
    }
    static canParse(url, base2) {
      let parsedBase = null;
      if (base2 !== void 0) {
        parsedBase = usm.basicURLParse(base2);
        if (parsedBase === null) {
          return false;
        }
      }
      const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
      if (parsedURL === null) {
        return false;
      }
      return true;
    }
    get href() {
      return usm.serializeURL(this._url);
    }
    set href(v2) {
      const parsedURL = usm.basicURLParse(v2);
      if (parsedURL === null) {
        throw new TypeError(`Invalid URL: ${v2}`);
      }
      this._url = parsedURL;
      this._query._list.splice(0);
      const { query: query2 } = parsedURL;
      if (query2 !== null) {
        this._query._list = urlencoded2.parseUrlencodedString(query2);
      }
    }
    get origin() {
      return usm.serializeURLOrigin(this._url);
    }
    get protocol() {
      return `${this._url.scheme}:`;
    }
    set protocol(v2) {
      usm.basicURLParse(`${v2}:`, { url: this._url, stateOverride: "scheme start" });
    }
    get username() {
      return this._url.username;
    }
    set username(v2) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setTheUsername(this._url, v2);
    }
    get password() {
      return this._url.password;
    }
    set password(v2) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setThePassword(this._url, v2);
    }
    get host() {
      const url = this._url;
      if (url.host === null) {
        return "";
      }
      if (url.port === null) {
        return usm.serializeHost(url.host);
      }
      return `${usm.serializeHost(url.host)}:${usm.serializeInteger(url.port)}`;
    }
    set host(v2) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }
      usm.basicURLParse(v2, { url: this._url, stateOverride: "host" });
    }
    get hostname() {
      if (this._url.host === null) {
        return "";
      }
      return usm.serializeHost(this._url.host);
    }
    set hostname(v2) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }
      usm.basicURLParse(v2, { url: this._url, stateOverride: "hostname" });
    }
    get port() {
      if (this._url.port === null) {
        return "";
      }
      return usm.serializeInteger(this._url.port);
    }
    set port(v2) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      if (v2 === "") {
        this._url.port = null;
      } else {
        usm.basicURLParse(v2, { url: this._url, stateOverride: "port" });
      }
    }
    get pathname() {
      return usm.serializePath(this._url);
    }
    set pathname(v2) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }
      this._url.path = [];
      usm.basicURLParse(v2, { url: this._url, stateOverride: "path start" });
    }
    get search() {
      if (this._url.query === null || this._url.query === "") {
        return "";
      }
      return `?${this._url.query}`;
    }
    set search(v2) {
      const url = this._url;
      if (v2 === "") {
        url.query = null;
        this._query._list = [];
        this._potentiallyStripTrailingSpacesFromAnOpaquePath();
        return;
      }
      const input = v2[0] === "?" ? v2.substring(1) : v2;
      url.query = "";
      usm.basicURLParse(input, { url, stateOverride: "query" });
      this._query._list = urlencoded2.parseUrlencodedString(input);
    }
    get searchParams() {
      return this._query;
    }
    get hash() {
      if (this._url.fragment === null || this._url.fragment === "") {
        return "";
      }
      return `#${this._url.fragment}`;
    }
    set hash(v2) {
      if (v2 === "") {
        this._url.fragment = null;
        this._potentiallyStripTrailingSpacesFromAnOpaquePath();
        return;
      }
      const input = v2[0] === "#" ? v2.substring(1) : v2;
      this._url.fragment = "";
      usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
    }
    toJSON() {
      return this.href;
    }
    _potentiallyStripTrailingSpacesFromAnOpaquePath() {
      if (!usm.hasAnOpaquePath(this._url)) {
        return;
      }
      if (this._url.fragment !== null) {
        return;
      }
      if (this._url.query !== null) {
        return;
      }
      this._url.path = this._url.path.replace(/\u0020+$/u, "");
    }
  };
  return URLImpl;
}
(function(exports) {
  const conversions2 = lib;
  const utils2 = utilsExports;
  const implSymbol = utils2.implSymbol;
  const ctorRegistrySymbol = utils2.ctorRegistrySymbol;
  const interfaceName = "URL";
  exports.is = (value2) => {
    return utils2.isObject(value2) && utils2.hasOwn(value2, implSymbol) && value2[implSymbol] instanceof Impl.implementation;
  };
  exports.isImpl = (value2) => {
    return utils2.isObject(value2) && value2 instanceof Impl.implementation;
  };
  exports.convert = (globalObject, value2, { context = "The provided value" } = {}) => {
    if (exports.is(value2)) {
      return utils2.implForWrapper(value2);
    }
    throw new globalObject.TypeError(`${context} is not of type 'URL'.`);
  };
  function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== void 0) {
      proto = newTarget.prototype;
    }
    if (!utils2.isObject(proto)) {
      proto = globalObject[ctorRegistrySymbol]["URL"].prototype;
    }
    return Object.create(proto);
  }
  exports.create = (globalObject, constructorArgs, privateData) => {
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
  };
  exports.createImpl = (globalObject, constructorArgs, privateData) => {
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils2.implForWrapper(wrapper);
  };
  exports._internalSetup = (wrapper, globalObject) => {
  };
  exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
      value: new Impl.implementation(globalObject, constructorArgs, privateData),
      configurable: true
    });
    wrapper[implSymbol][utils2.wrapperSymbol] = wrapper;
    if (Impl.init) {
      Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
  };
  exports.new = (globalObject, newTarget) => {
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
      value: Object.create(Impl.implementation.prototype),
      configurable: true
    });
    wrapper[implSymbol][utils2.wrapperSymbol] = wrapper;
    if (Impl.init) {
      Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
  };
  const exposed = /* @__PURE__ */ new Set(["Window", "Worker"]);
  exports.install = (globalObject, globalNames) => {
    if (!globalNames.some((globalName) => exposed.has(globalName))) {
      return;
    }
    const ctorRegistry = utils2.initCtorRegistry(globalObject);
    class URL21 {
      constructor(url) {
        if (arguments.length < 1) {
          throw new globalObject.TypeError(
            `Failed to construct 'URL': 1 argument required, but only ${arguments.length} present.`
          );
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions2["USVString"](curArg, {
            context: "Failed to construct 'URL': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          if (curArg !== void 0) {
            curArg = conversions2["USVString"](curArg, {
              context: "Failed to construct 'URL': parameter 2",
              globals: globalObject
            });
          }
          args.push(curArg);
        }
        return exports.setup(Object.create(new.target.prototype), globalObject, args);
      }
      toJSON() {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'toJSON' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol].toJSON();
      }
      get href() {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get href' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["href"];
      }
      set href(V) {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set href' called on an object that is not a valid instance of URL.");
        }
        V = conversions2["USVString"](V, {
          context: "Failed to set the 'href' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["href"] = V;
      }
      toString() {
        const esValue = this;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["href"];
      }
      get origin() {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get origin' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["origin"];
      }
      get protocol() {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get protocol' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["protocol"];
      }
      set protocol(V) {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set protocol' called on an object that is not a valid instance of URL.");
        }
        V = conversions2["USVString"](V, {
          context: "Failed to set the 'protocol' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["protocol"] = V;
      }
      get username() {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get username' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["username"];
      }
      set username(V) {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set username' called on an object that is not a valid instance of URL.");
        }
        V = conversions2["USVString"](V, {
          context: "Failed to set the 'username' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["username"] = V;
      }
      get password() {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get password' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["password"];
      }
      set password(V) {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set password' called on an object that is not a valid instance of URL.");
        }
        V = conversions2["USVString"](V, {
          context: "Failed to set the 'password' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["password"] = V;
      }
      get host() {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get host' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["host"];
      }
      set host(V) {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set host' called on an object that is not a valid instance of URL.");
        }
        V = conversions2["USVString"](V, {
          context: "Failed to set the 'host' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["host"] = V;
      }
      get hostname() {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get hostname' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["hostname"];
      }
      set hostname(V) {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set hostname' called on an object that is not a valid instance of URL.");
        }
        V = conversions2["USVString"](V, {
          context: "Failed to set the 'hostname' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["hostname"] = V;
      }
      get port() {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get port' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["port"];
      }
      set port(V) {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set port' called on an object that is not a valid instance of URL.");
        }
        V = conversions2["USVString"](V, {
          context: "Failed to set the 'port' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["port"] = V;
      }
      get pathname() {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get pathname' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["pathname"];
      }
      set pathname(V) {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set pathname' called on an object that is not a valid instance of URL.");
        }
        V = conversions2["USVString"](V, {
          context: "Failed to set the 'pathname' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["pathname"] = V;
      }
      get search() {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get search' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["search"];
      }
      set search(V) {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set search' called on an object that is not a valid instance of URL.");
        }
        V = conversions2["USVString"](V, {
          context: "Failed to set the 'search' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["search"] = V;
      }
      get searchParams() {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get searchParams' called on an object that is not a valid instance of URL.");
        }
        return utils2.getSameObject(this, "searchParams", () => {
          return utils2.tryWrapperForImpl(esValue[implSymbol]["searchParams"]);
        });
      }
      get hash() {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get hash' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["hash"];
      }
      set hash(V) {
        const esValue = this !== null && this !== void 0 ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set hash' called on an object that is not a valid instance of URL.");
        }
        V = conversions2["USVString"](V, {
          context: "Failed to set the 'hash' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["hash"] = V;
      }
      static canParse(url) {
        if (arguments.length < 1) {
          throw new globalObject.TypeError(
            `Failed to execute 'canParse' on 'URL': 1 argument required, but only ${arguments.length} present.`
          );
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions2["USVString"](curArg, {
            context: "Failed to execute 'canParse' on 'URL': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          if (curArg !== void 0) {
            curArg = conversions2["USVString"](curArg, {
              context: "Failed to execute 'canParse' on 'URL': parameter 2",
              globals: globalObject
            });
          }
          args.push(curArg);
        }
        return Impl.implementation.canParse(...args);
      }
    }
    Object.defineProperties(URL21.prototype, {
      toJSON: { enumerable: true },
      href: { enumerable: true },
      toString: { enumerable: true },
      origin: { enumerable: true },
      protocol: { enumerable: true },
      username: { enumerable: true },
      password: { enumerable: true },
      host: { enumerable: true },
      hostname: { enumerable: true },
      port: { enumerable: true },
      pathname: { enumerable: true },
      search: { enumerable: true },
      searchParams: { enumerable: true },
      hash: { enumerable: true },
      [Symbol.toStringTag]: { value: "URL", configurable: true }
    });
    Object.defineProperties(URL21, { canParse: { enumerable: true } });
    ctorRegistry[interfaceName] = URL21;
    Object.defineProperty(globalObject, interfaceName, {
      configurable: true,
      writable: true,
      value: URL21
    });
    if (globalNames.includes("Window")) {
      Object.defineProperty(globalObject, "webkitURL", {
        configurable: true,
        writable: true,
        value: URL21
      });
    }
  };
  const Impl = requireURLImpl();
})(URL$4);
const URL$3 = URL$4;
const URLSearchParams$1 = URLSearchParams$2;
webidl2jsWrapper.URL = URL$3;
webidl2jsWrapper.URLSearchParams = URLSearchParams$1;
const { URL: URL$2, URLSearchParams } = webidl2jsWrapper;
const urlStateMachine = urlStateMachineExports;
const percentEncoding = percentEncoding$1;
const sharedGlobalObject = { Array, Object, Promise, String, TypeError };
URL$2.install(sharedGlobalObject, ["Window"]);
URLSearchParams.install(sharedGlobalObject, ["Window"]);
var URL_1 = sharedGlobalObject.URL;
var URLSearchParams_1 = sharedGlobalObject.URLSearchParams;
urlStateMachine.parseURL;
urlStateMachine.basicURLParse;
urlStateMachine.serializeURL;
urlStateMachine.serializePath;
urlStateMachine.serializeHost;
urlStateMachine.serializeInteger;
urlStateMachine.serializeURLOrigin;
urlStateMachine.setTheUsername;
urlStateMachine.setThePassword;
urlStateMachine.cannotHaveAUsernamePasswordPort;
urlStateMachine.hasAnOpaquePath;
percentEncoding.percentDecodeString;
percentEncoding.percentDecodeBytes;
const activeElement = Symbol("activeElement");
const appendFormControlItem = Symbol("appendFormControlItem");
const appendNamedItem = Symbol("appendNamedItem");
const asyncTaskManager = Symbol("asyncTaskManager");
const buffer = Symbol("buffer");
const cacheID = Symbol("cacheID");
const callbacks = Symbol("callbacks");
const captureEventListenerCount = Symbol("captureEventListenerCount");
const checked = Symbol("checked");
const childNodes = Symbol("childNodes");
const children = Symbol("children");
const classList = Symbol("classList");
const computedStyle = Symbol("computedStyle");
const connectToNode = Symbol("connectToNode");
const cssText = Symbol("cssText");
const currentScript = Symbol("currentScript");
const currentTarget = Symbol("currentTarget");
const data = Symbol("data");
const defaultView = Symbol("defaultView");
const destroy = Symbol("destroy");
const dirtyness = Symbol("dirtyness");
const end = Symbol("end");
const evaluateCSS = Symbol("evaluateCSS");
const evaluateScript = Symbol("evaluateScript");
const exceptionObserver = Symbol("exceptionObserver");
const formNode = Symbol("formNode");
const getAttributeName = Symbol("getAttributeName");
const happyDOMSettingsID = Symbol("happyDOMSettingsID");
const height = Symbol("height");
const immediatePropagationStopped = Symbol("immediatePropagationStopped");
const isFirstWrite = Symbol("isFirstWrite");
const isFirstWriteAfterOpen = Symbol("isFirstWriteAfterOpen");
const isInPassiveEventListener = Symbol("isInPassiveEventListener");
const isValidPropertyName = Symbol("isValidPropertyName");
const isValue = Symbol("isValue");
const listenerOptions = Symbol("listenerOptions");
const listeners = Symbol("listeners");
const namedItems = Symbol("namedItems");
const nextActiveElement = Symbol("nextActiveElement");
const observe = Symbol("observe");
const observedAttributes = Symbol("observedAttributes");
const observers = Symbol("observers");
const ownerDocument = Symbol("ownerDocument");
const ownerElement = Symbol("ownerElement");
const propagationStopped = Symbol("propagationStopped");
const readyStateManager = Symbol("readyStateManager");
const referrer = Symbol("referrer");
const registry = Symbol("registry");
const relList = Symbol("relList");
const removeFormControlItem = Symbol("removeFormControlItem");
const removeNamedItem = Symbol("removeNamedItem");
const removeNamedItemIndex = Symbol("removeNamedItemIndex");
const removeNamedItemWithoutConsequences = Symbol("removeNamedItemWithoutConsequences");
const resetSelection = Symbol("resetSelection");
const rootNode = Symbol("rootNode");
const selectNode = Symbol("selectNode");
const selectedness = Symbol("selectedness");
const selection = Symbol("selection");
const setNamedItemWithoutConsequences = Symbol("setNamedItemWithoutConsequences");
const setupVMContext = Symbol("setupVMContext");
const shadowRoot = Symbol("shadowRoot");
const start = Symbol("start");
const style = Symbol("style");
const target = Symbol("target");
const textAreaNode = Symbol("textAreaNode");
const unobserve = Symbol("unobserve");
const updateIndices = Symbol("updateIndices");
const updateOptionItems = Symbol("updateOptionItems");
const value = Symbol("value");
const width = Symbol("width");
const window$1 = Symbol("window");
const windowResizeListener = Symbol("windowResizeListener");
const mutationObservers = Symbol("mutationObservers");
const openerFrame = Symbol("openerFrame");
const openerWindow = Symbol("openerFrame");
const popup = Symbol("popup");
const isConnected = Symbol("isConnected");
const parentNode = Symbol("parentNode");
const nodeType = Symbol("nodeType");
const tagName = Symbol("tagName");
const prefix = Symbol("prefix");
const scrollHeight = Symbol("scrollHeight");
const scrollWidth = Symbol("scrollWidth");
const scrollTop = Symbol("scrollTop");
const scrollLeft = Symbol("scrollLeft");
const attributes = Symbol("attributes");
const namespaceURI = Symbol("namespaceURI");
const accessKey = Symbol("accessKey");
const contentEditable = Symbol("contentEditable");
const isContentEditable = Symbol("isContentEditable");
const offsetHeight = Symbol("offsetHeight");
const offsetWidth = Symbol("offsetWidth");
const offsetLeft = Symbol("offsetLeft");
const offsetTop = Symbol("offsetTop");
const clientHeight = Symbol("clientHeight");
const clientWidth = Symbol("clientWidth");
const clientLeft = Symbol("clientLeft");
const clientTop = Symbol("clientTop");
const name = Symbol("name");
const specified = Symbol("specified");
const adoptedStyleSheets = Symbol("adoptedStyleSheets");
const implementation = Symbol("implementation");
const readyState = Symbol("readyState");
const ownerWindow = Symbol("ownerWindow");
const publicId = Symbol("publicId");
const systemId = Symbol("systemId");
const validationMessage = Symbol("validationMessage");
const validity = Symbol("validity");
const returnValue = Symbol("returnValue");
const elements = Symbol("elements");
const length$1 = Symbol("length");
const complete = Symbol("complete");
const naturalHeight = Symbol("naturalHeight");
const naturalWidth = Symbol("naturalWidth");
const loading = Symbol("loading");
const x = Symbol("x");
const y = Symbol("y");
const defaultChecked = Symbol("defaultChecked");
const files = Symbol("files");
const sheet = Symbol("sheet");
const volume = Symbol("volume");
const paused = Symbol("paused");
const currentTime = Symbol("currentTime");
const playbackRate = Symbol("playbackRate");
const defaultPlaybackRate = Symbol("defaultPlaybackRate");
const muted = Symbol("muted");
const defaultMuted = Symbol("defaultMuted");
const preservesPitch = Symbol("preservesPitch");
const buffered = Symbol("buffered");
const duration = Symbol("duration");
const error = Symbol("error");
const ended = Symbol("ended");
const networkState = Symbol("networkState");
const textTracks = Symbol("textTracks");
const videoTracks = Symbol("videoTracks");
const seeking = Symbol("seeking");
const seekable = Symbol("seekable");
const played = Symbol("played");
const options = Symbol("options");
const content = Symbol("content");
const mode = Symbol("mode");
const host = Symbol("host");
const setURL = Symbol("setURL");
const localName = Symbol("localName");
const registedClass = Symbol("registedClass");
const location = Symbol("location");
const history = Symbol("history");
const navigator$1 = Symbol("navigator");
const screen = Symbol("screen");
const sessionStorage = Symbol("sessionStorage");
const localStorage = Symbol("localStorage");
const sandbox = Symbol("sandbox");
const cloneNode = Symbol("cloneNode");
const appendChild = Symbol("appendChild");
const removeChild = Symbol("removeChild");
const insertBefore = Symbol("insertBefore");
const replaceChild = Symbol("replaceChild");
const styleNode = Symbol("styleNode");
const updateSheet = Symbol("updateSheet");
class CookieExpireUtility {
  /**
   * Returns "true" if cookie has expired.
   *
   * @param cookie Cookie.
   * @returns "true" if cookie has expired.
   */
  static hasExpired(cookie) {
    return cookie.expires && cookie.expires.getTime() < Date.now();
  }
}
var CookieSameSiteEnum;
(function(CookieSameSiteEnum2) {
  CookieSameSiteEnum2["strict"] = "Strict";
  CookieSameSiteEnum2["lax"] = "Lax";
  CookieSameSiteEnum2["none"] = "None";
})(CookieSameSiteEnum || (CookieSameSiteEnum = {}));
const CookieSameSiteEnum$1 = CookieSameSiteEnum;
class CookieURLUtility {
  /**
   * Returns "true" if cookie matches URL.
   *
   * @param cookie Cookie.
   * @param url URL.
   * @returns "true" if cookie matches URL.
   */
  static cookieMatchesURL(cookie, url) {
    return (!cookie.secure || url.protocol === "https:") && (!cookie.domain || url.hostname.endsWith(cookie.domain)) && (!cookie.path || url.pathname.startsWith(cookie.path)) && // @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#samesitesamesite-value
    (cookie.sameSite === CookieSameSiteEnum$1.none && cookie.secure || cookie.originURL.hostname === url.hostname);
  }
}
var __classPrivateFieldGet$N = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CookieContainer_cookies;
class CookieContainer {
  constructor() {
    _CookieContainer_cookies.set(this, []);
  }
  /**
   * Adds cookies.
   *
   * @param cookies Cookies.
   */
  addCookies(cookies) {
    const indexMap = {};
    const getKey = (cookie) => `${cookie.key}-${cookie.originURL.hostname}-${cookie.path}-${typeof cookie.value}`;
    for (let i = 0, max2 = __classPrivateFieldGet$N(this, _CookieContainer_cookies, "f").length; i < max2; i++) {
      indexMap[getKey(__classPrivateFieldGet$N(this, _CookieContainer_cookies, "f")[i])] = i;
    }
    for (const cookie of cookies) {
      if (cookie == null ? void 0 : cookie.key) {
        const index = indexMap[getKey(cookie)];
        if (index !== void 0) {
          __classPrivateFieldGet$N(this, _CookieContainer_cookies, "f").splice(index, 1);
        }
        if (!CookieExpireUtility.hasExpired(cookie)) {
          indexMap[getKey(cookie)] = __classPrivateFieldGet$N(this, _CookieContainer_cookies, "f").length;
          __classPrivateFieldGet$N(this, _CookieContainer_cookies, "f").push(cookie);
        }
      }
    }
  }
  /**
   * Returns cookies.
   *
   * @param [url] URL.
   * @param [httpOnly] "true" if only http cookies should be returned.
   * @returns Cookies.
   */
  getCookies(url = null, httpOnly = false) {
    const cookies = [];
    for (const cookie of __classPrivateFieldGet$N(this, _CookieContainer_cookies, "f")) {
      if (!CookieExpireUtility.hasExpired(cookie) && (!httpOnly || !cookie.httpOnly) && (!url || CookieURLUtility.cookieMatchesURL(cookie, url || cookie.originURL))) {
        cookies.push(cookie);
      }
    }
    return cookies;
  }
}
_CookieContainer_cookies = /* @__PURE__ */ new WeakMap();
let NotSupported$c = class NotSupported {
};
var VirtualConsoleLogLevelEnum;
(function(VirtualConsoleLogLevelEnum2) {
  VirtualConsoleLogLevelEnum2[VirtualConsoleLogLevelEnum2["log"] = 0] = "log";
  VirtualConsoleLogLevelEnum2[VirtualConsoleLogLevelEnum2["info"] = 1] = "info";
  VirtualConsoleLogLevelEnum2[VirtualConsoleLogLevelEnum2["warn"] = 2] = "warn";
  VirtualConsoleLogLevelEnum2[VirtualConsoleLogLevelEnum2["error"] = 3] = "error";
})(VirtualConsoleLogLevelEnum || (VirtualConsoleLogLevelEnum = {}));
const VirtualConsoleLogLevelEnum$1 = VirtualConsoleLogLevelEnum;
var NodeTypeEnum;
(function(NodeTypeEnum2) {
  NodeTypeEnum2[NodeTypeEnum2["elementNode"] = 1] = "elementNode";
  NodeTypeEnum2[NodeTypeEnum2["attributeNode"] = 2] = "attributeNode";
  NodeTypeEnum2[NodeTypeEnum2["textNode"] = 3] = "textNode";
  NodeTypeEnum2[NodeTypeEnum2["cdataSectionNode"] = 4] = "cdataSectionNode";
  NodeTypeEnum2[NodeTypeEnum2["commentNode"] = 8] = "commentNode";
  NodeTypeEnum2[NodeTypeEnum2["documentNode"] = 9] = "documentNode";
  NodeTypeEnum2[NodeTypeEnum2["documentTypeNode"] = 10] = "documentTypeNode";
  NodeTypeEnum2[NodeTypeEnum2["documentFragmentNode"] = 11] = "documentFragmentNode";
  NodeTypeEnum2[NodeTypeEnum2["processingInstructionNode"] = 7] = "processingInstructionNode";
})(NodeTypeEnum || (NodeTypeEnum = {}));
const NodeTypeEnum$1 = NodeTypeEnum;
var EventPhaseEnum;
(function(EventPhaseEnum2) {
  EventPhaseEnum2[EventPhaseEnum2["none"] = 0] = "none";
  EventPhaseEnum2[EventPhaseEnum2["capturing"] = 1] = "capturing";
  EventPhaseEnum2[EventPhaseEnum2["atTarget"] = 2] = "atTarget";
  EventPhaseEnum2[EventPhaseEnum2["bubbling"] = 3] = "bubbling";
})(EventPhaseEnum || (EventPhaseEnum = {}));
const EventPhaseEnum$1 = EventPhaseEnum;
var _a$J, _b$q, _c$l, _d$e, _e$c;
class Event {
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type, eventInit = null) {
    this.defaultPrevented = false;
    this.eventPhase = EventPhaseEnum$1.none;
    this.timeStamp = performance.now();
    this.NONE = EventPhaseEnum$1.none;
    this.CAPTURING_PHASE = EventPhaseEnum$1.capturing;
    this.AT_TARGET = EventPhaseEnum$1.atTarget;
    this.BUBBLING_PHASE = EventPhaseEnum$1.bubbling;
    this[_a$J] = false;
    this[_b$q] = false;
    this[_c$l] = null;
    this[_d$e] = null;
    this[_e$c] = false;
    this.type = type;
    this.bubbles = (eventInit == null ? void 0 : eventInit.bubbles) ?? false;
    this.cancelable = (eventInit == null ? void 0 : eventInit.cancelable) ?? false;
    this.composed = (eventInit == null ? void 0 : eventInit.composed) ?? false;
  }
  /**
   * Returns target.
   *
   * @returns Target.
   */
  get target() {
    return this[target];
  }
  /**
   * Returns target.
   *
   * @returns Target.
   */
  get currentTarget() {
    return this[currentTarget];
  }
  /**
   * Returns "true" if propagation has been stopped.
   *
   * @returns "true" if propagation has been stopped.
   */
  get cancelBubble() {
    return this[propagationStopped];
  }
  /**
   * Returns composed path.
   *
   * @returns Composed path.
   */
  composedPath() {
    if (!this[target]) {
      return [];
    }
    const composedPath = [];
    let eventTarget = this[target];
    while (eventTarget) {
      composedPath.push(eventTarget);
      if (eventTarget.parentNode) {
        eventTarget = eventTarget.parentNode;
      } else if (this.composed && eventTarget[nodeType] === NodeTypeEnum$1.documentFragmentNode && eventTarget.host) {
        eventTarget = eventTarget.host;
      } else if (eventTarget[nodeType] === NodeTypeEnum$1.documentNode) {
        eventTarget = eventTarget[ownerWindow];
      } else {
        break;
      }
    }
    return composedPath;
  }
  /**
   * Init event.
   *
   * @deprecated
   * @param type Type.
   * @param [bubbles=false] "true" if it bubbles.
   * @param [cancelable=false] "true" if it cancelable.
   */
  initEvent(type, bubbles = false, cancelable = false) {
    this.type = type;
    this.bubbles = bubbles;
    this.cancelable = cancelable;
  }
  /**
   * Prevents default.
   */
  preventDefault() {
    if (!this[isInPassiveEventListener]) {
      this.defaultPrevented = true;
    }
  }
  /**
   * Stops immediate propagation.
   */
  stopImmediatePropagation() {
    this[immediatePropagationStopped] = true;
  }
  /**
   * Stops propagation.
   */
  stopPropagation() {
    this[propagationStopped] = true;
  }
}
_a$J = immediatePropagationStopped, _b$q = propagationStopped, _c$l = target, _d$e = currentTarget, _e$c = isInPassiveEventListener;
var VirtualConsoleLogTypeEnum;
(function(VirtualConsoleLogTypeEnum2) {
  VirtualConsoleLogTypeEnum2["log"] = "log";
  VirtualConsoleLogTypeEnum2["table"] = "table";
  VirtualConsoleLogTypeEnum2["trace"] = "trace";
  VirtualConsoleLogTypeEnum2["dir"] = "dir";
  VirtualConsoleLogTypeEnum2["dirxml"] = "dirxml";
  VirtualConsoleLogTypeEnum2["group"] = "group";
  VirtualConsoleLogTypeEnum2["groupCollapsed"] = "groupCollapsed";
  VirtualConsoleLogTypeEnum2["debug"] = "debug";
  VirtualConsoleLogTypeEnum2["timeLog"] = "timeLog";
  VirtualConsoleLogTypeEnum2["info"] = "info";
  VirtualConsoleLogTypeEnum2["count"] = "count";
  VirtualConsoleLogTypeEnum2["timeEnd"] = "timeEnd";
  VirtualConsoleLogTypeEnum2["warn"] = "warn";
  VirtualConsoleLogTypeEnum2["countReset"] = "countReset";
  VirtualConsoleLogTypeEnum2["error"] = "error";
  VirtualConsoleLogTypeEnum2["assert"] = "assert";
})(VirtualConsoleLogTypeEnum || (VirtualConsoleLogTypeEnum = {}));
const VirtualConsoleLogTypeEnum$1 = VirtualConsoleLogTypeEnum;
class VirtualConsoleLogEntryStringifier {
  /**
   * Stringifies a log entry.
   *
   * @param logEntry Log entry.
   * @returns Stringified message.
   */
  static toString(logEntry) {
    if (this.isLogEntryCollapsed(logEntry)) {
      return "";
    }
    const tabbing = this.getLogEntryGroupTabbing(logEntry);
    let output = tabbing;
    for (const part of logEntry.message) {
      output += output !== "" && output !== tabbing ? " " : "";
      if (typeof part === "object" && (part === null || part.constructor.name === "Object" || Array.isArray(part))) {
        try {
          output += JSON.stringify(part);
        } catch (error2) {
          output += new Error("Failed to JSON stringify object in log entry.").stack.replace(/\n    at/gm, "\n    " + tabbing + "at");
        }
      } else if (typeof part === "object" && part["message"] && part["stack"]) {
        output += part["stack"].replace(/\n    at/gm, "\n    " + tabbing + "at");
      } else {
        output += this.getLogEntryIcon(logEntry) + String(part);
      }
    }
    return output + "\n";
  }
  /**
   * Gets the log entry icon.
   *
   * @param logEntry Log entry.
   * @returns Icon.
   */
  static getLogEntryIcon(logEntry) {
    switch (logEntry.type) {
      case VirtualConsoleLogTypeEnum$1.group:
        return " ";
      case VirtualConsoleLogTypeEnum$1.groupCollapsed:
        return " ";
    }
    return "";
  }
  /**
   * Gets the log entry group tabbing.
   *
   * @param logEntry Log entry.
   * @returns Tabbing.
   */
  static getLogEntryGroupTabbing(logEntry) {
    var _a2;
    let tabs = "";
    let group = logEntry.type === VirtualConsoleLogTypeEnum$1.group || logEntry.type === VirtualConsoleLogTypeEnum$1.groupCollapsed ? (_a2 = logEntry.group) == null ? void 0 : _a2.parent : logEntry.group;
    while (group) {
      tabs += "  ";
      group = group.parent;
    }
    return tabs;
  }
  /**
   * Checks if the log entry content is collapsed.
   *
   * @param logEntry Log entry.
   * @returns True if collapsed.
   */
  static isLogEntryCollapsed(logEntry) {
    var _a2;
    let group = logEntry.type === VirtualConsoleLogTypeEnum$1.group || logEntry.type === VirtualConsoleLogTypeEnum$1.groupCollapsed ? (_a2 = logEntry.group) == null ? void 0 : _a2.parent : logEntry.group;
    while (group) {
      if (group.collapsed) {
        return true;
      }
      group = group.parent;
    }
    return false;
  }
}
var __classPrivateFieldGet$M = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$H = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var _VirtualConsolePrinter_logEntries, _VirtualConsolePrinter_listeners;
class VirtualConsolePrinter {
  constructor() {
    _VirtualConsolePrinter_logEntries.set(this, []);
    _VirtualConsolePrinter_listeners.set(this, { print: [], clear: [] });
  }
  /**
   * Writes to the output.
   *
   * @param logEntry Log entry.
   */
  print(logEntry) {
    __classPrivateFieldGet$M(this, _VirtualConsolePrinter_logEntries, "f").push(logEntry);
    this.dispatchEvent(new Event("print"));
  }
  /**
   * Clears the output.
   */
  clear() {
    __classPrivateFieldSet$H(this, _VirtualConsolePrinter_logEntries, [], "f");
    this.dispatchEvent(new Event("clear"));
  }
  /**
   * Adds an event listener.
   *
   * @param eventType Event type ("print" or "clear").
   * @param listener Listener.
   */
  addEventListener(eventType, listener) {
    if (!__classPrivateFieldGet$M(this, _VirtualConsolePrinter_listeners, "f")[eventType]) {
      throw new Error(`Event type "${eventType}" is not supported.`);
    }
    __classPrivateFieldGet$M(this, _VirtualConsolePrinter_listeners, "f")[eventType].push(listener);
  }
  /**
   * Removes an event listener.
   *
   * @param eventType Event type ("print" or "clear").
   * @param listener Listener.
   */
  removeEventListener(eventType, listener) {
    if (!__classPrivateFieldGet$M(this, _VirtualConsolePrinter_listeners, "f")[eventType]) {
      throw new Error(`Event type "${eventType}" is not supported.`);
    }
    const index = __classPrivateFieldGet$M(this, _VirtualConsolePrinter_listeners, "f")[eventType].indexOf(listener);
    if (index !== -1) {
      __classPrivateFieldGet$M(this, _VirtualConsolePrinter_listeners, "f")[eventType].splice(index, 1);
    }
  }
  /**
   * Dispatches an event.
   *
   * @param event Event.
   */
  dispatchEvent(event) {
    if (!__classPrivateFieldGet$M(this, _VirtualConsolePrinter_listeners, "f")[event.type]) {
      throw new Error(`Event type "${event.type}" is not supported.`);
    }
    for (const listener of __classPrivateFieldGet$M(this, _VirtualConsolePrinter_listeners, "f")[event.type]) {
      listener(event);
    }
  }
  /**
   * Reads the buffer.
   *
   * @returns Console log entries.
   */
  read() {
    const logEntries = __classPrivateFieldGet$M(this, _VirtualConsolePrinter_logEntries, "f");
    __classPrivateFieldSet$H(this, _VirtualConsolePrinter_logEntries, [], "f");
    return logEntries;
  }
  /**
   * Returns the buffer as a string.
   *
   * @param [logLevel] Log level.
   * @returns Buffer as a string of concatenated log entries.
   */
  readAsString(logLevel = VirtualConsoleLogLevelEnum$1.log) {
    const logEntries = this.read();
    let output = "";
    for (const logEntry of logEntries) {
      if (logEntry.level >= logLevel) {
        output += VirtualConsoleLogEntryStringifier.toString(logEntry);
      }
    }
    return output;
  }
}
_VirtualConsolePrinter_logEntries = /* @__PURE__ */ new WeakMap(), _VirtualConsolePrinter_listeners = /* @__PURE__ */ new WeakMap();
const TIMER$1 = {
  setTimeout: globalThis.setTimeout.bind(globalThis),
  clearTimeout: globalThis.clearTimeout.bind(globalThis),
  clearImmediate: globalThis.clearTimeout.bind(globalThis)
};
class AsyncTaskManager {
  constructor() {
    this.runningTasks = {};
    this.runningTaskCount = 0;
    this.runningTimers = [];
    this.runningImmediates = [];
    this.waitUntilCompleteTimer = null;
    this.waitUntilCompleteResolvers = [];
  }
  /**
   * Returns a promise that is resolved when async tasks are complete.
   *
   * @returns Promise.
   */
  waitUntilComplete() {
    return new Promise((resolve3) => {
      this.waitUntilCompleteResolvers.push(resolve3);
      this.endTask(this.startTask());
    });
  }
  /**
   * Aborts all tasks.
   */
  abort() {
    return this.abortAll(false);
  }
  /**
   * Destroys the manager.
   */
  destroy() {
    return this.abortAll(true);
  }
  /**
   * Starts a timer.
   *
   * @param timerID Timer ID.
   */
  startTimer(timerID) {
    if (this.waitUntilCompleteTimer) {
      TIMER$1.clearTimeout(this.waitUntilCompleteTimer);
      this.waitUntilCompleteTimer = null;
    }
    this.runningTimers.push(timerID);
  }
  /**
   * Ends a timer.
   *
   * @param timerID Timer ID.
   */
  endTimer(timerID) {
    if (this.waitUntilCompleteTimer) {
      TIMER$1.clearTimeout(this.waitUntilCompleteTimer);
      this.waitUntilCompleteTimer = null;
    }
    const index = this.runningTimers.indexOf(timerID);
    if (index !== -1) {
      this.runningTimers.splice(index, 1);
    }
    if (!this.runningTaskCount && !this.runningTimers.length && !this.runningImmediates.length) {
      this.resolveWhenComplete();
    }
  }
  /**
   * Starts an immediate.
   *
   * @param immediateID Immediate ID.
   */
  startImmediate(immediateID) {
    if (this.waitUntilCompleteTimer) {
      TIMER$1.clearTimeout(this.waitUntilCompleteTimer);
      this.waitUntilCompleteTimer = null;
    }
    this.runningImmediates.push(immediateID);
  }
  /**
   * Ends an immediate.
   *
   * @param immediateID Immediate ID.
   */
  endImmediate(immediateID) {
    if (this.waitUntilCompleteTimer) {
      TIMER$1.clearTimeout(this.waitUntilCompleteTimer);
      this.waitUntilCompleteTimer = null;
    }
    const index = this.runningImmediates.indexOf(immediateID);
    if (index !== -1) {
      this.runningImmediates.splice(index, 1);
    }
    if (!this.runningTaskCount && !this.runningTimers.length && !this.runningImmediates.length) {
      this.resolveWhenComplete();
    }
  }
  /**
   * Starts an async task.
   *
   * @param abortHandler Abort handler.
   * @returns Task ID.
   */
  startTask(abortHandler) {
    if (this.waitUntilCompleteTimer) {
      TIMER$1.clearTimeout(this.waitUntilCompleteTimer);
      this.waitUntilCompleteTimer = null;
    }
    const taskID = this.newTaskID();
    this.runningTasks[taskID] = abortHandler ? abortHandler : () => {
    };
    this.runningTaskCount++;
    return taskID;
  }
  /**
   * Ends an async task.
   *
   * @param taskID Task ID.
   */
  endTask(taskID) {
    if (this.waitUntilCompleteTimer) {
      TIMER$1.clearTimeout(this.waitUntilCompleteTimer);
      this.waitUntilCompleteTimer = null;
    }
    if (this.runningTasks[taskID]) {
      delete this.runningTasks[taskID];
      this.runningTaskCount--;
    }
    if (!this.runningTaskCount && !this.runningTimers.length && !this.runningImmediates.length) {
      this.resolveWhenComplete();
    }
  }
  /**
   * Returns the amount of running tasks.
   *
   * @returns Count.
   */
  getTaskCount() {
    return this.runningTaskCount;
  }
  /**
   * Returns a new task ID.
   *
   * @returns Task ID.
   */
  newTaskID() {
    this.constructor.taskID++;
    return this.constructor.taskID;
  }
  /**
   * Resolves when complete.
   */
  resolveWhenComplete() {
    if (this.runningTaskCount || this.runningTimers.length || this.runningImmediates.length) {
      return;
    }
    if (this.waitUntilCompleteTimer) {
      TIMER$1.clearTimeout(this.waitUntilCompleteTimer);
      this.waitUntilCompleteTimer = null;
    }
    this.waitUntilCompleteTimer = TIMER$1.setTimeout(() => {
      this.waitUntilCompleteTimer = null;
      if (!this.runningTaskCount && !this.runningTimers.length && !this.runningImmediates.length) {
        const resolvers = this.waitUntilCompleteResolvers;
        this.waitUntilCompleteResolvers = [];
        for (const resolver of resolvers) {
          resolver();
        }
      }
    });
  }
  /**
   * Aborts all tasks.
   *
   * @param destroy Destroy.
   */
  abortAll(destroy2) {
    const runningTimers = this.runningTimers;
    const runningImmediates = this.runningImmediates;
    const runningTasks = this.runningTasks;
    this.runningTasks = {};
    this.runningTaskCount = 0;
    this.runningImmediates = [];
    this.runningTimers = [];
    if (this.waitUntilCompleteTimer) {
      TIMER$1.clearTimeout(this.waitUntilCompleteTimer);
      this.waitUntilCompleteTimer = null;
    }
    for (const immediate of runningImmediates) {
      TIMER$1.clearImmediate(immediate);
    }
    for (const timer of runningTimers) {
      TIMER$1.clearTimeout(timer);
    }
    const taskPromises = [];
    for (const key of Object.keys(runningTasks)) {
      const returnValue2 = runningTasks[key](destroy2);
      if (returnValue2 instanceof Promise) {
        taskPromises.push(returnValue2);
      }
    }
    if (taskPromises.length) {
      return Promise.all(taskPromises).then(() => this.waitUntilComplete()).catch((error2) => {
        console.error(error2);
        throw error2;
      });
    }
    return this.waitUntilComplete();
  }
}
AsyncTaskManager.taskID = 0;
var DOMExceptionNameEnum;
(function(DOMExceptionNameEnum2) {
  DOMExceptionNameEnum2["invalidStateError"] = "InvalidStateError";
  DOMExceptionNameEnum2["indexSizeError"] = "IndexSizeError";
  DOMExceptionNameEnum2["syntaxError"] = "SyntaxError";
  DOMExceptionNameEnum2["hierarchyRequestError"] = "HierarchyRequestError";
  DOMExceptionNameEnum2["notSupportedError"] = "NotSupportedError";
  DOMExceptionNameEnum2["wrongDocumentError"] = "WrongDocumentError";
  DOMExceptionNameEnum2["invalidNodeTypeError"] = "InvalidNodeTypeError";
  DOMExceptionNameEnum2["invalidCharacterError"] = "InvalidCharacterError";
  DOMExceptionNameEnum2["notFoundError"] = "NotFoundError";
  DOMExceptionNameEnum2["securityError"] = "SecurityError";
  DOMExceptionNameEnum2["networkError"] = "NetworkError";
  DOMExceptionNameEnum2["domException"] = "DOMException";
  DOMExceptionNameEnum2["invalidAccessError"] = "InvalidAccessError";
  DOMExceptionNameEnum2["unknownError"] = "UnknownError";
  DOMExceptionNameEnum2["abortError"] = "AbortError";
  DOMExceptionNameEnum2["encodingError"] = "EncodingError";
  DOMExceptionNameEnum2["uriMismatchError"] = "URIMismatchError";
})(DOMExceptionNameEnum || (DOMExceptionNameEnum = {}));
const DOMExceptionNameEnum$1 = DOMExceptionNameEnum;
class DOMException extends Error {
  /**
   * Constructor.
   *
   * @param message Message.
   * @param name Name.
   */
  constructor(message, name2 = null) {
    super(message);
    this.name = name2 || DOMExceptionNameEnum$1.domException;
  }
}
const NamespaceURI = {
  html: "http://www.w3.org/1999/xhtml",
  svg: "http://www.w3.org/2000/svg",
  mathML: "http://www.w3.org/1998/Math/MathML",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
var __classPrivateFieldSet$G = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$L = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CustomElementRegistry_instances, _CustomElementRegistry_window, _CustomElementRegistry_isValidCustomElementName, _a$I, _b$p, _c$k;
class CustomElementRegistry {
  /**
   * Constructor.
   *
   * @param window Window.
   */
  constructor(window2) {
    _CustomElementRegistry_instances.add(this);
    this[_a$I] = {};
    this[_b$p] = /* @__PURE__ */ new Map();
    this[_c$k] = {};
    _CustomElementRegistry_window.set(this, void 0);
    __classPrivateFieldSet$G(this, _CustomElementRegistry_window, window2, "f");
  }
  /**
   * Defines a custom element class.
   *
   * @param name Tag name of element.
   * @param elementClass Element class.
   * @param [options] Options.
   * @param [options.extends] Extends tag name.
   */
  define(name2, elementClass, options2) {
    if (!__classPrivateFieldGet$L(this, _CustomElementRegistry_instances, "m", _CustomElementRegistry_isValidCustomElementName).call(this, name2)) {
      throw new DOMException(`Failed to execute 'define' on 'CustomElementRegistry': "${name2}" is not a valid custom element name`);
    }
    if (this[registry][name2]) {
      throw new DOMException(`Failed to execute 'define' on 'CustomElementRegistry': the name "${name2}" has already been used with this registry`);
    }
    if (this[registedClass].has(elementClass)) {
      throw new DOMException("Failed to execute 'define' on 'CustomElementRegistry': this constructor has already been used with this registry");
    }
    const tagName$12 = name2.toUpperCase();
    elementClass[ownerDocument] = __classPrivateFieldGet$L(this, _CustomElementRegistry_window, "f").document;
    elementClass[tagName] = tagName$12;
    elementClass[localName] = name2;
    elementClass[namespaceURI] = NamespaceURI.html;
    this[registry][name2] = {
      elementClass,
      extends: options2 && options2.extends ? options2.extends.toLowerCase() : null
    };
    this[registedClass].set(elementClass, name2);
    if (elementClass.prototype.attributeChangedCallback) {
      elementClass[observedAttributes] = elementClass.observedAttributes;
    }
    if (this[callbacks][name2]) {
      const callbacks$1 = this[callbacks][name2];
      delete this[callbacks][name2];
      for (const callback of callbacks$1) {
        callback();
      }
    }
  }
  /**
   * Returns a defined element class.
   *
   * @param name Tag name of element.
   * @returns HTMLElement Class defined or undefined.
   */
  get(name2) {
    var _a2;
    return (_a2 = this[registry][name2]) == null ? void 0 : _a2.elementClass;
  }
  /**
   * Upgrades a custom element directly, even before it is connected to its shadow root.
   *
   * Not implemented yet.
   *
   * @param _root Root node.
   */
  upgrade(_root) {
  }
  /**
   * When defined.
   *
   * @param name Tag name of element.
   */
  whenDefined(name2) {
    if (!__classPrivateFieldGet$L(this, _CustomElementRegistry_instances, "m", _CustomElementRegistry_isValidCustomElementName).call(this, name2)) {
      return Promise.reject(new DOMException(`Invalid custom element name: "${name2}"`));
    }
    if (this.get(name2)) {
      return Promise.resolve();
    }
    return new Promise((resolve3) => {
      this[callbacks][name2] = this[callbacks][name2] || [];
      this[callbacks][name2].push(resolve3);
    });
  }
  /**
   * Reverse lookup searching for name by given element class.
   *
   * @param elementClass Class constructor.
   * @returns Found tag name or `null`.
   */
  getName(elementClass) {
    return this[registedClass].get(elementClass) || null;
  }
  /**
   * Destroys the registry.
   */
  [(_CustomElementRegistry_window = /* @__PURE__ */ new WeakMap(), _CustomElementRegistry_instances = /* @__PURE__ */ new WeakSet(), _a$I = registry, _b$p = registedClass, _c$k = callbacks, destroy)]() {
    for (const entity of Object.values(this[registry])) {
      entity.elementClass[ownerDocument] = null;
    }
    this[registry] = {};
    this[registedClass] = /* @__PURE__ */ new Map();
    this[callbacks] = {};
  }
}
_CustomElementRegistry_isValidCustomElementName = function _CustomElementRegistry_isValidCustomElementName2(name2) {
  const PCENChar = "[-_.]|[0-9]|[a-z]||[-]|[-]|[-]|[-]|[-]|[-]|[-]|[-]|[-]|[-]|[-]|[-]";
  const PCEN = new RegExp(`^[a-z](${PCENChar})*-(${PCENChar})*$`, "u");
  const reservedNames = [
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ];
  return PCEN.test(name2) && !reservedNames.includes(name2);
};
class UIEvent extends Event {
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type, eventInit = null) {
    super(type, eventInit);
    this.layerX = 0;
    this.layerY = 0;
    this.pageX = 0;
    this.pageY = 0;
    this.detail = (eventInit == null ? void 0 : eventInit.detail) ?? 0;
    this.view = (eventInit == null ? void 0 : eventInit.view) ?? null;
  }
}
UIEvent.NONE = 0;
UIEvent.CAPTURING_PHASE = 1;
UIEvent.AT_TARGET = 2;
UIEvent.BUBBLING_PHASE = 3;
class ErrorEvent extends UIEvent {
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type, eventInit = null) {
    super(type, eventInit);
    this.message = (eventInit == null ? void 0 : eventInit.message) ?? "";
    this.filename = (eventInit == null ? void 0 : eventInit.filename) ?? "";
    this.lineno = (eventInit == null ? void 0 : eventInit.lineno) ?? 0;
    this.colno = (eventInit == null ? void 0 : eventInit.colno) ?? 0;
    this.error = (eventInit == null ? void 0 : eventInit.error) ?? null;
  }
}
class WindowErrorUtility {
  /**
   * Calls a function synchronously wrapped in a try/catch block to capture errors and dispatch error events.
   * If the callback returns a Promise, it will catch errors from the promise.
   *
   * It will also output the errors to the console.
   *
   * @param elementOrWindow Element or Window.
   * @param callback Callback.
   * @param [cleanup] Cleanup callback on error.
   * @returns Result.
   */
  static captureError(elementOrWindow, callback, cleanup) {
    let result = null;
    try {
      result = callback();
    } catch (error2) {
      this.dispatchError(elementOrWindow, error2);
      if (cleanup) {
        cleanup();
      }
    }
    if (result && result instanceof Promise) {
      result.catch((error2) => {
        this.dispatchError(elementOrWindow, error2);
        if (cleanup) {
          cleanup();
        }
      });
    }
    return result;
  }
  /**
   * Dispatches an error event and outputs it to the console.
   *
   * @param elementOrWindow Element or Window.
   * @param error Error.
   */
  static dispatchError(elementOrWindow, error2) {
    if (elementOrWindow.console) {
      elementOrWindow.console.error(error2);
      elementOrWindow.dispatchEvent(new ErrorEvent("error", { message: error2.message, error: error2 }));
    } else {
      elementOrWindow[ownerDocument][defaultView].console.error(error2);
      elementOrWindow.dispatchEvent(new ErrorEvent("error", { message: error2.message, error: error2 }));
    }
  }
}
var __classPrivateFieldGet$K = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _a$H, _WindowBrowserSettingsReader_settings;
class WindowBrowserSettingsReader {
  /**
   * Returns browser settings.
   *
   * @param window Window.
   * @returns Settings.
   */
  static getSettings(window2) {
    const id = window2[happyDOMSettingsID];
    if (id === void 0 || !__classPrivateFieldGet$K(this, _a$H, "f", _WindowBrowserSettingsReader_settings)[id]) {
      return null;
    }
    return __classPrivateFieldGet$K(this, _a$H, "f", _WindowBrowserSettingsReader_settings)[id];
  }
  /**
   * Sets browser settings.
   *
   * @param window Window.
   * @param settings Settings.
   */
  static setSettings(window2, settings) {
    if (window2[happyDOMSettingsID] !== void 0) {
      return;
    }
    window2[happyDOMSettingsID] = __classPrivateFieldGet$K(this, _a$H, "f", _WindowBrowserSettingsReader_settings).length;
    __classPrivateFieldGet$K(this, _a$H, "f", _WindowBrowserSettingsReader_settings).push(settings);
  }
  /**
   * Removes browser settings.
   *
   * @param window Window.
   */
  static removeSettings(window2) {
    const id = window2[happyDOMSettingsID];
    if (id !== void 0 && __classPrivateFieldGet$K(this, _a$H, "f", _WindowBrowserSettingsReader_settings)[id]) {
      delete __classPrivateFieldGet$K(this, _a$H, "f", _WindowBrowserSettingsReader_settings)[id];
    }
    delete window2[happyDOMSettingsID];
  }
}
_a$H = WindowBrowserSettingsReader;
_WindowBrowserSettingsReader_settings = { value: [] };
var BrowserErrorCaptureEnum;
(function(BrowserErrorCaptureEnum2) {
  BrowserErrorCaptureEnum2["tryAndCatch"] = "tryAndCatch";
  BrowserErrorCaptureEnum2["processLevel"] = "processLevel";
  BrowserErrorCaptureEnum2["disabled"] = "disabled";
})(BrowserErrorCaptureEnum || (BrowserErrorCaptureEnum = {}));
const BrowserErrorCaptureEnum$1 = BrowserErrorCaptureEnum;
var __classPrivateFieldGet$J = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EventTarget_instances, _EventTarget_getWindow, _a$G, _b$o;
class EventTarget {
  constructor() {
    _EventTarget_instances.add(this);
    this[_a$G] = {};
    this[_b$o] = {};
  }
  /**
   * Return a default description for the EventTarget class.
   */
  get [(_EventTarget_instances = /* @__PURE__ */ new WeakSet(), _a$G = listeners, _b$o = listenerOptions, Symbol.toStringTag)]() {
    return "EventTarget";
  }
  /**
   * Adds an event listener.
   *
   * @param type Event type.
   * @param listener Listener.
   * @param options An object that specifies characteristics about the event listener.(currently only once)
   * @param options.once
   */
  addEventListener(type, listener, options2) {
    const listenerOptions$1 = typeof options2 === "boolean" ? { capture: options2 } : options2 || null;
    this[listeners][type] = this[listeners][type] || [];
    this[listenerOptions][type] = this[listenerOptions][type] || [];
    if (this[listeners][type].includes(listener)) {
      return;
    }
    this[listeners][type].push(listener);
    this[listenerOptions][type].push(listenerOptions$1);
    if (listenerOptions$1 && listenerOptions$1.capture) {
      const window2 = __classPrivateFieldGet$J(this, _EventTarget_instances, "m", _EventTarget_getWindow).call(this);
      if (window2) {
        window2[captureEventListenerCount][type] = window2[captureEventListenerCount][type] ?? 0;
        window2[captureEventListenerCount][type]++;
      }
    }
  }
  /**
   * Adds an event listener.
   *
   * @param type Event type.
   * @param listener Listener.
   */
  removeEventListener(type, listener) {
    if (this[listeners][type]) {
      const index = this[listeners][type].indexOf(listener);
      if (index !== -1) {
        if (this[listenerOptions][type][index] && this[listenerOptions][type][index].capture) {
          const window2 = __classPrivateFieldGet$J(this, _EventTarget_instances, "m", _EventTarget_getWindow).call(this);
          if (window2 && window2[captureEventListenerCount][type]) {
            window2[captureEventListenerCount][type]--;
          }
        }
        this[listeners][type].splice(index, 1);
        this[listenerOptions][type].splice(index, 1);
      }
    }
  }
  /**
   * Dispatches an event.
   *
   * @see https://www.w3.org/TR/DOM-Level-3-Events/#event-flow
   * @see https://www.quirksmode.org/js/events_order.html#link4
   * @param event Event.
   * @returns The return value is false if event is cancelable and at least one of the event handlers which handled this event called Event.preventDefault().
   */
  dispatchEvent(event) {
    const window2 = __classPrivateFieldGet$J(this, _EventTarget_instances, "m", _EventTarget_getWindow).call(this);
    if (event.eventPhase === EventPhaseEnum$1.none) {
      event[target] = this;
      const composedPath = event.composedPath();
      if (window2 && window2[captureEventListenerCount][event.type]) {
        event.eventPhase = EventPhaseEnum$1.capturing;
        for (let i = composedPath.length - 1; i >= 0; i--) {
          composedPath[i].dispatchEvent(event);
          if (event[propagationStopped] || event[immediatePropagationStopped]) {
            break;
          }
        }
      }
      event.eventPhase = EventPhaseEnum$1.atTarget;
      this.dispatchEvent(event);
      if (event.bubbles && !event[propagationStopped] && !event[immediatePropagationStopped]) {
        event.eventPhase = EventPhaseEnum$1.bubbling;
        for (let i = 1; i < composedPath.length; i++) {
          composedPath[i].dispatchEvent(event);
          if (event[propagationStopped] || event[immediatePropagationStopped]) {
            break;
          }
        }
      }
      event.eventPhase = EventPhaseEnum$1.none;
      return !(event.cancelable && event.defaultPrevented);
    }
    event[currentTarget] = this;
    const browserSettings = window2 ? WindowBrowserSettingsReader.getSettings(window2) : null;
    if (event.eventPhase !== EventPhaseEnum$1.capturing) {
      const onEventName = "on" + event.type.toLowerCase();
      if (typeof this[onEventName] === "function") {
        if (window2 && (this !== window2 || event.type !== "error") && !(browserSettings == null ? void 0 : browserSettings.disableErrorCapturing) && (browserSettings == null ? void 0 : browserSettings.errorCapture) === BrowserErrorCaptureEnum$1.tryAndCatch) {
          WindowErrorUtility.captureError(window2, this[onEventName].bind(this, event));
        } else {
          this[onEventName].call(this, event);
        }
      }
    }
    if (this[listeners][event.type]) {
      const listeners$1 = this[listeners][event.type].slice();
      const listenerOptions$1 = this[listenerOptions][event.type].slice();
      for (let i = 0, max2 = listeners$1.length; i < max2; i++) {
        const listener = listeners$1[i];
        const options2 = listenerOptions$1[i];
        if ((options2 == null ? void 0 : options2.capture) && event.eventPhase !== EventPhaseEnum$1.capturing || !(options2 == null ? void 0 : options2.capture) && event.eventPhase === EventPhaseEnum$1.capturing) {
          continue;
        }
        if (options2 == null ? void 0 : options2.passive) {
          event[isInPassiveEventListener] = true;
        }
        if (window2 && (this !== window2 || event.type !== "error") && !(browserSettings == null ? void 0 : browserSettings.disableErrorCapturing) && (browserSettings == null ? void 0 : browserSettings.errorCapture) === BrowserErrorCaptureEnum$1.tryAndCatch) {
          if (listener.handleEvent) {
            WindowErrorUtility.captureError(window2, listener.handleEvent.bind(listener, event));
          } else {
            WindowErrorUtility.captureError(window2, listener.bind(this, event));
          }
        } else {
          if (listener.handleEvent) {
            listener.handleEvent(event);
          } else {
            listener.call(this, event);
          }
        }
        event[isInPassiveEventListener] = false;
        if (options2 == null ? void 0 : options2.once) {
          listeners$1.splice(i, 1);
          listenerOptions$1.splice(i, 1);
          this.removeEventListener(event.type, listener);
          i--;
          max2--;
        }
        if (event[immediatePropagationStopped]) {
          return !(event.cancelable && event.defaultPrevented);
        }
      }
    }
    return !(event.cancelable && event.defaultPrevented);
  }
  /**
   * Adds an event listener.
   *
   * TODO:
   * Was used by with IE8- and Opera. React believed Happy DOM was a legacy browser and used them, but that is no longer the case, so we should remove this method after that this is verified.
   *
   * @deprecated
   * @param type Event type.
   * @param listener Listener.
   */
  attachEvent(type, listener) {
    this.addEventListener(type.replace("on", ""), listener);
  }
  /**
   * Removes an event listener.
   *
   * TODO:
   * Was used by IE8- and Opera. React believed Happy DOM was a legacy browser and used them, but that is no longer the case, so we should remove this method after that this is verified.
   *
   * @deprecated
   * @param type Event type.
   * @param listener Listener.
   */
  detachEvent(type, listener) {
    this.removeEventListener(type.replace("on", ""), listener);
  }
}
_EventTarget_getWindow = function _EventTarget_getWindow2() {
  if (this[ownerDocument]) {
    return this[ownerDocument][ownerWindow];
  }
  if (this[ownerWindow]) {
    return this[ownerWindow];
  }
  if (this.document) {
    return this;
  }
  return null;
};
var NodeDocumentPositionEnum;
(function(NodeDocumentPositionEnum2) {
  NodeDocumentPositionEnum2[NodeDocumentPositionEnum2["disconnect"] = 1] = "disconnect";
  NodeDocumentPositionEnum2[NodeDocumentPositionEnum2["preceding"] = 2] = "preceding";
  NodeDocumentPositionEnum2[NodeDocumentPositionEnum2["following"] = 4] = "following";
  NodeDocumentPositionEnum2[NodeDocumentPositionEnum2["contains"] = 8] = "contains";
  NodeDocumentPositionEnum2[NodeDocumentPositionEnum2["containedBy"] = 16] = "containedBy";
  NodeDocumentPositionEnum2[NodeDocumentPositionEnum2["implementationSpecific"] = 32] = "implementationSpecific";
})(NodeDocumentPositionEnum || (NodeDocumentPositionEnum = {}));
const NodeDocumentPositionEnum$1 = NodeDocumentPositionEnum;
class MutationRecord {
  /**
   * Constructor.
   *
   * @param init Options to initialize the mutation record.
   */
  constructor(init) {
    this.type = null;
    this.target = null;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
    Object.assign(this, init);
  }
}
var MutationTypeEnum;
(function(MutationTypeEnum2) {
  MutationTypeEnum2["attributes"] = "attributes";
  MutationTypeEnum2["characterData"] = "characterData";
  MutationTypeEnum2["childList"] = "childList";
})(MutationTypeEnum || (MutationTypeEnum = {}));
const MutationTypeEnum$1 = MutationTypeEnum;
class NodeUtility {
  /**
   * Append a child node to childNodes.
   *
   * @param ancestorNode Ancestor node.
   * @param node Node to append.
   * @param [options] Options.
   * @param [options.disableAncestorValidation] Disables validation for checking if the node is an ancestor of the ancestorNode.
   * @returns Appended node.
   */
  static appendChild(ancestorNode, node2, options2) {
    var _a2, _b2;
    if (node2 === ancestorNode) {
      throw new DOMException("Failed to execute 'appendChild' on 'Node': Not possible to append a node as a child of itself.");
    }
    if (!(options2 == null ? void 0 : options2.disableAncestorValidation) && this.isInclusiveAncestor(node2, ancestorNode, true)) {
      throw new DOMException("Failed to execute 'appendChild' on 'Node': The new node is a parent of the node to insert to.", DOMExceptionNameEnum$1.domException);
    }
    if (node2[nodeType] === NodeTypeEnum$1.documentFragmentNode) {
      for (const child of node2[childNodes].slice()) {
        ancestorNode.appendChild(child);
      }
      return node2;
    }
    if (node2[parentNode]) {
      const index = node2[parentNode][childNodes].indexOf(node2);
      if (index !== -1) {
        node2[parentNode][childNodes].splice(index, 1);
      }
    }
    if (ancestorNode[isConnected]) {
      (ancestorNode[ownerDocument] || this)[cacheID]++;
    }
    ancestorNode[childNodes].push(node2);
    node2[connectToNode](ancestorNode);
    if (ancestorNode[observers].length > 0) {
      const record = new MutationRecord({
        target: ancestorNode,
        type: MutationTypeEnum$1.childList,
        addedNodes: [node2]
      });
      for (const observer of ancestorNode[observers]) {
        if ((_a2 = observer.options) == null ? void 0 : _a2.subtree) {
          node2[observe](observer);
        }
        if ((_b2 = observer.options) == null ? void 0 : _b2.childList) {
          observer.report(record);
        }
      }
    }
    return node2;
  }
  /**
   * Remove Child element from childNodes array.
   *
   * @param ancestorNode Ancestor node.
   * @param node Node to remove.
   * @returns Removed node.
   */
  static removeChild(ancestorNode, node2) {
    var _a2, _b2;
    const index = ancestorNode[childNodes].indexOf(node2);
    if (index === -1) {
      throw new DOMException("Failed to remove node. Node is not child of parent.");
    }
    if (ancestorNode[isConnected]) {
      (ancestorNode[ownerDocument] || this)[cacheID]++;
    }
    ancestorNode[childNodes].splice(index, 1);
    node2[connectToNode](null);
    if (ancestorNode[observers].length > 0) {
      const record = new MutationRecord({
        target: ancestorNode,
        type: MutationTypeEnum$1.childList,
        removedNodes: [node2]
      });
      for (const observer of ancestorNode[observers]) {
        if ((_a2 = observer.options) == null ? void 0 : _a2.subtree) {
          node2[unobserve](observer);
        }
        if ((_b2 = observer.options) == null ? void 0 : _b2.childList) {
          observer.report(record);
        }
      }
    }
    return node2;
  }
  /**
   * Inserts a node before another.
   *
   * @param ancestorNode Ancestor node.
   * @param newNode Node to insert.
   * @param referenceNode Node to insert before.
   * @param [options] Options.
   * @param [options.disableAncestorValidation] Disables validation for checking if the node is an ancestor of the ancestorNode.
   * @returns Inserted node.
   */
  static insertBefore(ancestorNode, newNode, referenceNode, options2) {
    var _a2, _b2;
    if (!(options2 == null ? void 0 : options2.disableAncestorValidation) && this.isInclusiveAncestor(newNode, ancestorNode, true)) {
      throw new DOMException("Failed to execute 'insertBefore' on 'Node': The new node is a parent of the node to insert to.", DOMExceptionNameEnum$1.domException);
    }
    if (newNode[nodeType] === NodeTypeEnum$1.documentFragmentNode) {
      for (const child of newNode[childNodes].slice()) {
        ancestorNode.insertBefore(child, referenceNode);
      }
      return newNode;
    }
    if (!referenceNode) {
      ancestorNode.appendChild(newNode);
      return newNode;
    }
    if (ancestorNode[childNodes].indexOf(referenceNode) === -1) {
      throw new DOMException("Failed to execute 'insertBefore' on 'Node': The node before which the new node is to be inserted is not a child of this node.");
    }
    if (ancestorNode[isConnected]) {
      (ancestorNode[ownerDocument] || this)[cacheID]++;
    }
    if (newNode[parentNode]) {
      const index = newNode[parentNode][childNodes].indexOf(newNode);
      if (index !== -1) {
        newNode[parentNode][childNodes].splice(index, 1);
      }
    }
    ancestorNode[childNodes].splice(ancestorNode[childNodes].indexOf(referenceNode), 0, newNode);
    newNode[connectToNode](ancestorNode);
    if (ancestorNode[observers].length > 0) {
      const record = new MutationRecord({
        target: ancestorNode,
        type: MutationTypeEnum$1.childList,
        addedNodes: [newNode]
      });
      for (const observer of ancestorNode[observers]) {
        if ((_a2 = observer.options) == null ? void 0 : _a2.subtree) {
          newNode[observe](observer);
        }
        if ((_b2 = observer.options) == null ? void 0 : _b2.childList) {
          observer.report(record);
        }
      }
    }
    return newNode;
  }
  /**
   * Returns whether the passed node is a text node, and narrows its type.
   *
   * @param node The node to be tested.
   * @returns "true" if the node is a text node.
   */
  static isTextNode(node2) {
    return (node2 == null ? void 0 : node2[nodeType]) === NodeTypeEnum$1.textNode;
  }
  /**
   * Returns boolean indicating if "ancestorNode" is an inclusive ancestor of "referenceNode".
   *
   * Based on:
   * https://github.com/jsdom/jsdom/blob/master/lib/jsdom/living/helpers/node.js
   *
   * @see https://dom.spec.whatwg.org/#concept-tree-inclusive-ancestor
   * @param ancestorNode Ancestor node.
   * @param referenceNode Reference node.
   * @param [includeShadowRoots = false] Include shadow roots.
   * @returns "true" if inclusive ancestor.
   */
  static isInclusiveAncestor(ancestorNode, referenceNode, includeShadowRoots = false) {
    if (ancestorNode === null || referenceNode === null) {
      return false;
    }
    if (ancestorNode === referenceNode) {
      return true;
    }
    if (!ancestorNode[childNodes].length) {
      return false;
    }
    if (includeShadowRoots && referenceNode[isConnected] !== ancestorNode[isConnected]) {
      return false;
    }
    if (includeShadowRoots && ancestorNode === referenceNode[ownerDocument] && referenceNode[isConnected]) {
      return true;
    }
    let parent = referenceNode[parentNode];
    while (parent) {
      if (ancestorNode === parent) {
        return true;
      }
      parent = parent[parentNode] ? parent[parentNode] : includeShadowRoots && parent.host ? parent.host : null;
    }
    return false;
  }
  /**
   * Returns boolean indicating if nodeB is following nodeA in the document tree.
   *
   * Based on:
   * https://github.com/jsdom/jsdom/blob/master/lib/jsdom/living/helpers/node.js
   *
   * @see https://dom.spec.whatwg.org/#concept-tree-following
   * @param nodeA Node A.
   * @param nodeB Node B.
   * @returns "true" if following.
   */
  static isFollowing(nodeA, nodeB) {
    if (nodeA === nodeB) {
      return false;
    }
    let current = nodeB;
    while (current) {
      current = this.following(current);
      if (current === nodeA) {
        return true;
      }
    }
    return false;
  }
  /**
   * Node length.
   *
   * Based on:
   * https://github.com/jsdom/jsdom/blob/master/lib/jsdom/living/helpers/node.js
   *
   * @see https://dom.spec.whatwg.org/#concept-node-length
   * @param node Node.
   * @returns Node length.
   */
  static getNodeLength(node2) {
    switch (node2[nodeType]) {
      case NodeTypeEnum$1.documentTypeNode:
        return 0;
      case NodeTypeEnum$1.textNode:
      case NodeTypeEnum$1.processingInstructionNode:
      case NodeTypeEnum$1.commentNode:
        return node2.data.length;
      default:
        return node2[childNodes].length;
    }
  }
  /**
   * Returns boolean indicating if nodeB is following nodeA in the document tree.
   *
   * Based on:
   * https://github.com/jsdom/js-symbol-tree/blob/master/lib/SymbolTree.js#L220
   *
   * @param node Node.
   * @param [root] Root.
   * @returns Following node.
   */
  static following(node2, root) {
    const firstChild = node2.firstChild;
    if (firstChild) {
      return firstChild;
    }
    let current = node2;
    while (current) {
      if (current === root) {
        return null;
      }
      const nextSibling = current.nextSibling;
      if (nextSibling) {
        return nextSibling;
      }
      current = current[parentNode];
    }
    return null;
  }
  /**
   * Returns the next sibling or parents sibling.
   *
   * @param node Node.
   * @returns Next descendant node.
   */
  static nextDescendantNode(node2) {
    while (node2 && !node2.nextSibling) {
      node2 = node2[parentNode];
    }
    if (!node2) {
      return null;
    }
    return node2.nextSibling;
  }
  /**
   * Needed by https://dom.spec.whatwg.org/#concept-node-equals
   *
   * @param elementA
   * @param elementB
   */
  static attributeListsEqual(elementA, elementB) {
    for (let i = 0, max2 = elementA[attributes].length; i < max2; i++) {
      const attributeA = elementA[attributes][i];
      const attributeB = elementB[attributes].getNamedItemNS(attributeA[namespaceURI], attributeA.localName);
      if (!attributeB || attributeB[value] !== attributeA[value]) {
        return false;
      }
    }
    return true;
  }
  /**
   * Check if node nodeA equals node nodeB.
   * Reference: https://dom.spec.whatwg.org/#concept-node-equals
   *
   * @param nodeA Node A.
   * @param nodeB Node B.
   */
  static isEqualNode(nodeA, nodeB) {
    if (nodeA[nodeType] !== nodeB[nodeType]) {
      return false;
    }
    switch (nodeA[nodeType]) {
      case NodeTypeEnum$1.documentTypeNode:
        const documentTypeA = nodeA;
        const documentTypeB = nodeB;
        if (documentTypeA.name !== documentTypeB.name || documentTypeA.publicId !== documentTypeB.publicId || documentTypeA.systemId !== documentTypeB.systemId) {
          return false;
        }
        break;
      case NodeTypeEnum$1.elementNode:
        const elementA = nodeA;
        const elementB = nodeB;
        if (elementA[namespaceURI] !== elementB[namespaceURI] || elementA[prefix] !== elementB[prefix] || elementA.localName !== elementB.localName || elementA[attributes].length !== elementB[attributes].length) {
          return false;
        }
        break;
      case NodeTypeEnum$1.attributeNode:
        const attributeA = nodeA;
        const attributeB = nodeB;
        if (attributeA[namespaceURI] !== attributeB[namespaceURI] || attributeA.localName !== attributeB.localName || attributeA[value] !== attributeB[value]) {
          return false;
        }
        break;
      case NodeTypeEnum$1.processingInstructionNode:
        const processingInstructionA = nodeA;
        const processingInstructionB = nodeB;
        if (processingInstructionA.target !== processingInstructionB.target || processingInstructionA.data !== processingInstructionB.data) {
          return false;
        }
        break;
      case NodeTypeEnum$1.textNode:
      case NodeTypeEnum$1.commentNode:
        const textOrCommentA = nodeA;
        const textOrCommentB = nodeB;
        if (textOrCommentA.data !== textOrCommentB.data) {
          return false;
        }
        break;
    }
    if (nodeA[nodeType] === NodeTypeEnum$1.elementNode && !NodeUtility.attributeListsEqual(nodeA, nodeB)) {
      return false;
    }
    if (nodeA[childNodes].length !== nodeB[childNodes].length) {
      return false;
    }
    for (let i = 0; i < nodeA[childNodes].length; i++) {
      const childNodeA = nodeA[childNodes][i];
      const childNodeB = nodeB[childNodes][i];
      if (!NodeUtility.isEqualNode(childNodeA, childNodeB)) {
        return false;
      }
    }
    return true;
  }
}
class NodeList extends Array {
  /**
   * Returns `Symbol.toStringTag`.
   *
   * @returns `Symbol.toStringTag`.
   */
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  /**
   * Returns item by index.
   *
   * @param index Index.
   */
  item(index) {
    return index >= 0 && this[index] ? this[index] : null;
  }
}
class NodeFactory {
  /**
   * Creates a node instance with the given owner document.
   *
   * @param ownerDocument Owner document.
   * @param nodeClass Node class.
   * @param [args] Node arguments.
   * @returns Node instance.
   */
  static createNode(ownerDocument2, nodeClass, ...args) {
    this.ownerDocuments.push(ownerDocument2);
    return new nodeClass(...args);
  }
  /**
   * Pulls an owner document from the queue.
   *
   * @returns Document.
   */
  static pullOwnerDocument() {
    return this.ownerDocuments.pop();
  }
}
NodeFactory.ownerDocuments = [];
var _a$F, _b$n, _c$j, _d$d, _e$b, _f$9, _g$6, _h$5, _j$5;
class Node2 extends EventTarget {
  /**
   * Constructor.
   */
  constructor() {
    super();
    this[_a$F] = false;
    this[_b$n] = null;
    this[_c$j] = null;
    this[_d$d] = null;
    this[_e$b] = null;
    this[_f$9] = null;
    this[_g$6] = null;
    this[_h$5] = [];
    this[_j$5] = new NodeList();
    if (this.constructor[ownerDocument] !== void 0) {
      this[ownerDocument] = this.constructor[ownerDocument];
    } else {
      const ownerDocument$1 = NodeFactory.pullOwnerDocument();
      if (!ownerDocument$1) {
        throw new Error('Failed to construct "Node": No owner document in queue. Please use "NodeFactory" to create instances of a Node.');
      }
      this[ownerDocument] = ownerDocument$1;
    }
  }
  /**
   * Returns `Symbol.toStringTag`.
   *
   * @returns `Symbol.toStringTag`.
   */
  get [(_a$F = isConnected, _b$n = parentNode, _c$j = rootNode, _d$d = formNode, _e$b = selectNode, _f$9 = textAreaNode, _g$6 = styleNode, _h$5 = observers, _j$5 = childNodes, Symbol.toStringTag)]() {
    return this.constructor.name;
  }
  /**
   * Returns connected state.
   *
   * @returns Connected state.
   */
  get isConnected() {
    return this[isConnected];
  }
  /**
   * Returns owner document.
   *
   * @returns Owner document.
   */
  get ownerDocument() {
    return this[ownerDocument];
  }
  /**
   * Returns parent node.
   *
   * @returns Parent node.
   */
  get parentNode() {
    return this[parentNode];
  }
  /**
   * Returns node type.
   *
   * @returns Node type.
   */
  get nodeType() {
    return this[nodeType];
  }
  /**
   * Get child nodes.
   *
   * @returns Child nodes list.
   */
  get childNodes() {
    return this[childNodes];
  }
  /**
   * Get text value of children.
   *
   * @returns Text content.
   */
  get textContent() {
    return null;
  }
  /**
   * Sets text content.
   *
   * @param _textContent Text content.
   */
  set textContent(_textContent) {
  }
  /**
   * Node value.
   *
   * @returns Node value.
   */
  get nodeValue() {
    return null;
  }
  /**
   * Sets node value.
   */
  set nodeValue(_nodeValue) {
  }
  /**
   * Node name.
   *
   * @returns Node name.
   */
  get nodeName() {
    return "";
  }
  /**
   * Previous sibling.
   *
   * @returns Node.
   */
  get previousSibling() {
    if (this[parentNode]) {
      const index = this[parentNode][childNodes].indexOf(this);
      if (index > 0) {
        return this[parentNode][childNodes][index - 1];
      }
    }
    return null;
  }
  /**
   * Next sibling.
   *
   * @returns Node.
   */
  get nextSibling() {
    if (this[parentNode]) {
      const index = this[parentNode][childNodes].indexOf(this);
      if (index > -1 && index + 1 < this[parentNode][childNodes].length) {
        return this[parentNode][childNodes][index + 1];
      }
    }
    return null;
  }
  /**
   * First child.
   *
   * @returns Node.
   */
  get firstChild() {
    if (this[childNodes].length > 0) {
      return this[childNodes][0];
    }
    return null;
  }
  /**
   * Last child.
   *
   * @returns Node.
   */
  get lastChild() {
    if (this[childNodes].length > 0) {
      return this[childNodes][this[childNodes].length - 1];
    }
    return null;
  }
  /**
   * Returns parent element.
   *
   * @returns Element.
   */
  get parentElement() {
    let parent = this[parentNode];
    while (parent && parent[nodeType] !== NodeTypeEnum$1.elementNode) {
      parent = parent[parentNode];
    }
    return parent;
  }
  /**
   * Returns base URI.
   *
   * @returns Base URI.
   */
  get baseURI() {
    const base2 = this[ownerDocument].querySelector("base");
    if (base2) {
      return base2.href;
    }
    return this[ownerDocument][ownerWindow].location.href;
  }
  /**
   * Returns "true" if the node has child nodes.
   *
   * @returns "true" if the node has child nodes.
   */
  hasChildNodes() {
    return this[childNodes].length > 0;
  }
  /**
   * Returns "true" if this node contains the other node.
   *
   * @param otherNode Node to test with.
   * @returns "true" if this node contains the other node.
   */
  contains(otherNode) {
    if (otherNode === void 0) {
      return false;
    }
    return NodeUtility.isInclusiveAncestor(this, otherNode);
  }
  /**
   * Returns closest root node (Document or ShadowRoot).
   *
   * @param options Options.
   * @param options.composed A Boolean that indicates whether the shadow root should be returned (false, the default), or a root node beyond shadow root (true).
   * @returns Node.
   */
  getRootNode(options2) {
    if (!this[isConnected]) {
      return this;
    }
    if (this[rootNode] && !(options2 == null ? void 0 : options2.composed)) {
      return this[rootNode];
    }
    return this[ownerDocument];
  }
  /**
   * Clones a node.
   *
   * @param [deep=false] "true" to clone deep.
   * @returns Cloned node.
   */
  cloneNode(deep = false) {
    return this[cloneNode](deep);
  }
  /**
   * Append a child node to childNodes.
   *
   * @param  node Node to append.
   * @returns Appended node.
   */
  appendChild(node2) {
    return this[appendChild](node2);
  }
  /**
   * Remove Child element from childNodes array.
   *
   * @param node Node to remove.
   * @returns Removed node.
   */
  removeChild(node2) {
    return this[removeChild](node2);
  }
  /**
   * Inserts a node before another.
   *
   * @param newNode Node to insert.
   * @param referenceNode Node to insert before.
   * @returns Inserted node.
   */
  insertBefore(newNode, referenceNode) {
    if (arguments.length < 2) {
      throw new TypeError(`Failed to execute 'insertBefore' on 'Node': 2 arguments required, but only ${arguments.length} present.`);
    }
    return this[insertBefore](newNode, referenceNode);
  }
  /**
   * Replaces a node with another.
   *
   * @param newChild New child.
   * @param oldChild Old child.
   * @returns Replaced node.
   */
  replaceChild(newChild, oldChild) {
    return this[replaceChild](newChild, oldChild);
  }
  /**
   * Clones a node.
   *
   * @param [deep=false] "true" to clone deep.
   * @returns Cloned node.
   */
  [cloneNode](deep = false) {
    const clone2 = NodeFactory.createNode(this[ownerDocument], this.constructor);
    if (clone2[childNodes].length) {
      for (const node2 of clone2[childNodes].slice()) {
        node2[parentNode].removeChild(node2);
      }
    }
    if (deep) {
      for (const childNode of this[childNodes]) {
        const childClone = childNode.cloneNode(true);
        childClone[parentNode] = clone2;
        clone2[childNodes].push(childClone);
      }
    }
    return clone2;
  }
  /**
   * Append a child node to childNodes.
   *
   * @param  node Node to append.
   * @returns Appended node.
   */
  [appendChild](node2) {
    return NodeUtility.appendChild(this, node2);
  }
  /**
   * Remove Child element from childNodes array.
   *
   * @param node Node to remove.
   * @returns Removed node.
   */
  [removeChild](node2) {
    return NodeUtility.removeChild(this, node2);
  }
  /**
   * Inserts a node before another.
   *
   * @param newNode Node to insert.
   * @param referenceNode Node to insert before.
   * @returns Inserted node.
   */
  [insertBefore](newNode, referenceNode) {
    return NodeUtility.insertBefore(this, newNode, referenceNode);
  }
  /**
   * Replaces a node with another.
   *
   * @param newChild New child.
   * @param oldChild Old child.
   * @returns Replaced node.
   */
  [replaceChild](newChild, oldChild) {
    this.insertBefore(newChild, oldChild);
    this.removeChild(oldChild);
    return oldChild;
  }
  /**
   * Compares two nodes.
   * Two nodes are equal if they have the same type, defining the same attributes, and so on.
   *
   * @param node  Node to compare.
   * @returns boolean - `true` if two nodes are equal.
   */
  isEqualNode(node2) {
    return NodeUtility.isEqualNode(this, node2);
  }
  /**
   * Converts the node to a string.
   *
   * @param listener Listener.
   */
  toString() {
    return `[object ${this.constructor.name}]`;
  }
  /**
   * Observeres the node.
   * Used by MutationObserver, but it is not part of the HTML standard.
   *
   * @param listener Listener.
   */
  [observe](listener) {
    this[observers].push(listener);
    if (listener.options.subtree) {
      for (const node2 of this[childNodes]) {
        node2[observe](listener);
      }
    }
  }
  /**
   * Stops observing the node.
   * Used by MutationObserver, but it is not part of the HTML standard.
   *
   * @param listener Listener.
   */
  [unobserve](listener) {
    const index = this[observers].indexOf(listener);
    if (index !== -1) {
      this[observers].splice(index, 1);
    }
    if (listener.options.subtree) {
      for (const node2 of this[childNodes]) {
        node2[unobserve](listener);
      }
    }
  }
  /**
   * Connects this element to another element.
   *
   * @param parentNode Parent node.
   */
  [connectToNode](parentNode$1 = null) {
    const isConnected$1 = !!parentNode$1 && parentNode$1[isConnected];
    const formNode$1 = this[formNode];
    const selectNode$1 = this[selectNode];
    const textAreaNode$1 = this[textAreaNode];
    const styleNode$1 = this[styleNode];
    if (this[nodeType] !== NodeTypeEnum$1.documentFragmentNode) {
      this[parentNode] = parentNode$1;
      this[rootNode] = isConnected$1 && parentNode$1 ? parentNode$1[rootNode] : null;
      if (this["tagName"] !== "FORM") {
        this[formNode] = parentNode$1 ? parentNode$1[formNode] : null;
      }
      if (this["tagName"] !== "SELECT") {
        this[selectNode] = parentNode$1 ? parentNode$1[selectNode] : null;
      }
      if (this["tagName"] !== "TEXTAREA") {
        this[textAreaNode] = parentNode$1 ? parentNode$1[textAreaNode] : null;
      }
      if (this["tagName"] !== "STYLE") {
        this[styleNode] = parentNode$1 ? parentNode$1[styleNode] : null;
      }
    }
    if (this[isConnected] !== isConnected$1) {
      this[isConnected] = isConnected$1;
      if (!isConnected$1) {
        if (this[ownerDocument][activeElement] === this) {
          this[ownerDocument][activeElement] = null;
        }
      }
      if (isConnected$1 && this.connectedCallback) {
        const result = this.connectedCallback();
        if (result instanceof Promise) {
          const asyncTaskManager$1 = this[ownerDocument][ownerWindow][asyncTaskManager];
          const taskID = asyncTaskManager$1.startTask();
          result.then(() => asyncTaskManager$1.endTask(taskID)).catch(() => asyncTaskManager$1.endTask(taskID));
        }
      } else if (!isConnected$1 && this.disconnectedCallback) {
        this.disconnectedCallback();
      }
      for (const child of this[childNodes]) {
        child[connectToNode](this);
      }
      if (this[shadowRoot]) {
        this[shadowRoot][connectToNode](this);
      }
    } else if (formNode$1 !== this[formNode] || selectNode$1 !== this[selectNode] || textAreaNode$1 !== this[textAreaNode] || styleNode$1 !== this[styleNode]) {
      for (const child of this[childNodes]) {
        child[connectToNode](this);
      }
    }
  }
  /**
   * Reports the position of its argument node relative to the node on which it is called.
   *
   * @see https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
   * @param otherNode Other node.
   */
  compareDocumentPosition(otherNode) {
    if (this === otherNode) {
      return 0;
    }
    let node1 = otherNode;
    let node2 = this;
    let attr1 = null;
    let attr2 = null;
    if (node1[nodeType] === NodeTypeEnum$1.attributeNode) {
      attr1 = node1;
      node1 = attr1[ownerElement];
    }
    if (node2[nodeType] === NodeTypeEnum$1.attributeNode) {
      attr2 = node2;
      node2 = attr2[ownerElement];
      if (attr1 !== null && node1 !== null && node2 === node1) {
        for (const attr of Object.values(node2[attributes])) {
          if (NodeUtility.isEqualNode(attr, attr1)) {
            return Node2.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node2.DOCUMENT_POSITION_PRECEDING;
          }
          if (NodeUtility.isEqualNode(attr, attr2)) {
            return Node2.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node2.DOCUMENT_POSITION_FOLLOWING;
          }
        }
      }
    }
    const node2Ancestors = [];
    let node2Ancestor = node2;
    while (node2Ancestor) {
      if (node2Ancestor === node1) {
        return Node2.DOCUMENT_POSITION_CONTAINS | Node2.DOCUMENT_POSITION_PRECEDING;
      }
      node2Ancestors.push(node2Ancestor);
      node2Ancestor = node2Ancestor[parentNode];
    }
    const node1Ancestors = [];
    let node1Ancestor = node1;
    while (node1Ancestor) {
      if (node1Ancestor === node2) {
        return Node2.DOCUMENT_POSITION_CONTAINED_BY | Node2.DOCUMENT_POSITION_FOLLOWING;
      }
      node1Ancestors.push(node1Ancestor);
      node1Ancestor = node1Ancestor[parentNode];
    }
    const reverseArrayIndex = (array, reverseIndex) => {
      return array[array.length - 1 - reverseIndex];
    };
    const root = reverseArrayIndex(node2Ancestors, 0);
    if (!root || root !== reverseArrayIndex(node1Ancestors, 0)) {
      return Node2.DOCUMENT_POSITION_DISCONNECTED | Node2.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node2.DOCUMENT_POSITION_FOLLOWING;
    }
    let commonAncestorIndex = 0;
    const ancestorsMinLength = Math.min(node2Ancestors.length, node1Ancestors.length);
    for (let i = 0; i < ancestorsMinLength; ++i) {
      const node2Ancestor2 = reverseArrayIndex(node2Ancestors, i);
      const node1Ancestor2 = reverseArrayIndex(node1Ancestors, i);
      if (node2Ancestor2 !== node1Ancestor2) {
        break;
      }
      commonAncestorIndex = i;
    }
    const commonAncestor = reverseArrayIndex(node2Ancestors, commonAncestorIndex);
    let indexes = 0;
    let node2Index = -1;
    let node1Index = -1;
    const node2Node = reverseArrayIndex(node2Ancestors, commonAncestorIndex + 1);
    const node1Node = reverseArrayIndex(node1Ancestors, commonAncestorIndex + 1);
    const computeNodeIndexes = (nodes) => {
      for (const childNode of nodes) {
        computeNodeIndexes(childNode[childNodes]);
        if (childNode === node2Node) {
          node2Index = indexes;
        } else if (childNode === node1Node) {
          node1Index = indexes;
        }
        if (node2Index !== -1 && node1Index !== -1) {
          break;
        }
        indexes++;
      }
    };
    computeNodeIndexes(commonAncestor[childNodes]);
    return node1Index < node2Index ? Node2.DOCUMENT_POSITION_PRECEDING : Node2.DOCUMENT_POSITION_FOLLOWING;
  }
  /**
   * Normalizes the sub-tree of the node, i.e. joins adjacent text nodes, and
   * removes all empty text nodes.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/normalize
   */
  normalize() {
    let child = this.firstChild;
    while (child) {
      if (NodeUtility.isTextNode(child)) {
        while (NodeUtility.isTextNode(child.nextSibling)) {
          child.data += child.nextSibling.data;
          child.nextSibling.remove();
        }
        if (!child.data.length) {
          const node2 = child;
          child = child.nextSibling;
          node2.remove();
          continue;
        }
      } else {
        child.normalize();
      }
      child = child.nextSibling;
    }
  }
  /**
   * Determines whether the given node is equal to the current node.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/isSameNode
   * @param node Node to check.
   * @returns True if the given node is equal to the current node, otherwise false.
   */
  isSameNode(node2) {
    return this === node2;
  }
}
Node2.ELEMENT_NODE = NodeTypeEnum$1.elementNode;
Node2.ATTRIBUTE_NODE = NodeTypeEnum$1.attributeNode;
Node2.TEXT_NODE = NodeTypeEnum$1.textNode;
Node2.CDATA_SECTION_NODE = NodeTypeEnum$1.cdataSectionNode;
Node2.COMMENT_NODE = NodeTypeEnum$1.commentNode;
Node2.DOCUMENT_NODE = NodeTypeEnum$1.documentNode;
Node2.DOCUMENT_TYPE_NODE = NodeTypeEnum$1.documentTypeNode;
Node2.DOCUMENT_FRAGMENT_NODE = NodeTypeEnum$1.documentFragmentNode;
Node2.PROCESSING_INSTRUCTION_NODE = NodeTypeEnum$1.processingInstructionNode;
Node2.DOCUMENT_POSITION_CONTAINED_BY = NodeDocumentPositionEnum$1.containedBy;
Node2.DOCUMENT_POSITION_CONTAINS = NodeDocumentPositionEnum$1.contains;
Node2.DOCUMENT_POSITION_DISCONNECTED = NodeDocumentPositionEnum$1.disconnect;
Node2.DOCUMENT_POSITION_FOLLOWING = NodeDocumentPositionEnum$1.following;
Node2.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = NodeDocumentPositionEnum$1.implementationSpecific;
Node2.DOCUMENT_POSITION_PRECEDING = NodeDocumentPositionEnum$1.preceding;
Node2.prototype.ELEMENT_NODE = NodeTypeEnum$1.elementNode;
Node2.prototype.ATTRIBUTE_NODE = NodeTypeEnum$1.attributeNode;
Node2.prototype.TEXT_NODE = NodeTypeEnum$1.textNode;
Node2.prototype.CDATA_SECTION_NODE = NodeTypeEnum$1.cdataSectionNode;
Node2.prototype.COMMENT_NODE = NodeTypeEnum$1.commentNode;
Node2.prototype.DOCUMENT_NODE = NodeTypeEnum$1.documentNode;
Node2.prototype.DOCUMENT_TYPE_NODE = NodeTypeEnum$1.documentTypeNode;
Node2.prototype.DOCUMENT_FRAGMENT_NODE = NodeTypeEnum$1.documentFragmentNode;
Node2.prototype.PROCESSING_INSTRUCTION_NODE = NodeTypeEnum$1.processingInstructionNode;
Node2.prototype.DOCUMENT_POSITION_CONTAINED_BY = NodeDocumentPositionEnum$1.containedBy;
Node2.prototype.DOCUMENT_POSITION_CONTAINS = NodeDocumentPositionEnum$1.contains;
Node2.prototype.DOCUMENT_POSITION_DISCONNECTED = NodeDocumentPositionEnum$1.disconnect;
Node2.prototype.DOCUMENT_POSITION_FOLLOWING = NodeDocumentPositionEnum$1.following;
Node2.prototype.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = NodeDocumentPositionEnum$1.implementationSpecific;
Node2.prototype.DOCUMENT_POSITION_PRECEDING = NodeDocumentPositionEnum$1.preceding;
var _a$E, _b$m, _c$i, _d$c;
class DOMRectReadOnly {
  /**
   * Constructor.
   *
   * @param [x] X position.
   * @param [y] Y position.
   * @param [width] Width.
   * @param [height] Height.
   */
  constructor(x$1, y$1, width$1, height$1) {
    this[_a$E] = 0;
    this[_b$m] = 0;
    this[_c$i] = 0;
    this[_d$c] = 0;
    this[x] = x$1 !== void 0 && x$1 !== null ? Number(x$1) : 0;
    this[y] = y$1 !== void 0 && y$1 !== null ? Number(y$1) : 0;
    this[width] = width$1 !== void 0 && width$1 !== null ? Number(width$1) : 0;
    this[height] = height$1 !== void 0 && height$1 !== null ? Number(height$1) : 0;
  }
  get x() {
    return this[x];
  }
  get y() {
    return this[y];
  }
  get width() {
    return this[width];
  }
  get height() {
    return this[height];
  }
  get top() {
    return Math.min(this[y], this[y] + this[height]);
  }
  get right() {
    return Math.max(this[x], this[x] + this[width]);
  }
  get bottom() {
    return Math.max(this[y], this[y] + this[height]);
  }
  get left() {
    return Math.min(this[x], this[x] + this[width]);
  }
  toJSON() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height,
      top: this.top,
      right: this.right,
      bottom: this.bottom,
      left: this.left
    };
  }
  static fromRect(other) {
    return new DOMRectReadOnly(other.x, other.y, other.width, other.height);
  }
}
_a$E = x, _b$m = y, _c$i = width, _d$c = height;
class DOMRect extends DOMRectReadOnly {
  set x(value2) {
    this[x] = value2;
  }
  get x() {
    return this[x];
  }
  set y(value2) {
    this[y] = value2;
  }
  get y() {
    return this[y];
  }
  set width(value2) {
    this[width] = value2;
  }
  get width() {
    return this[width];
  }
  set height(value2) {
    this[height] = value2;
  }
  get height() {
    return this[height];
  }
  static fromRect(other) {
    return new DOMRect(other.x, other.y, other.width, other.height);
  }
}
var __classPrivateFieldSet$F = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$I = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DOMTokenList_instances, _DOMTokenList_length, _DOMTokenList_ownerElement, _DOMTokenList_attributeName, _DOMTokenList_getTokenList;
const ATTRIBUTE_SPLIT_REGEXP = /[\t\f\n\r ]+/;
class DOMTokenList {
  /**
   * Constructor.
   *
   * @param ownerElement Owner element.
   * @param attributeName Attribute name.
   */
  constructor(ownerElement2, attributeName) {
    _DOMTokenList_instances.add(this);
    _DOMTokenList_length.set(this, 0);
    _DOMTokenList_ownerElement.set(this, void 0);
    _DOMTokenList_attributeName.set(this, void 0);
    __classPrivateFieldSet$F(this, _DOMTokenList_ownerElement, ownerElement2, "f");
    __classPrivateFieldSet$F(this, _DOMTokenList_attributeName, attributeName, "f");
    this[updateIndices]();
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get length() {
    return __classPrivateFieldGet$I(this, _DOMTokenList_length, "f");
  }
  /**
   * Set value.
   *
   * @param value Value.
   */
  set value(value2) {
    __classPrivateFieldGet$I(this, _DOMTokenList_ownerElement, "f").setAttribute(__classPrivateFieldGet$I(this, _DOMTokenList_attributeName, "f"), value2);
  }
  /**
   * Get value.
   */
  get value() {
    return __classPrivateFieldGet$I(this, _DOMTokenList_ownerElement, "f").getAttribute(__classPrivateFieldGet$I(this, _DOMTokenList_attributeName, "f"));
  }
  /**
   * Returns an iterator, allowing you to go through all values of the key/value pairs contained in this object.
   */
  [(_DOMTokenList_length = /* @__PURE__ */ new WeakMap(), _DOMTokenList_ownerElement = /* @__PURE__ */ new WeakMap(), _DOMTokenList_attributeName = /* @__PURE__ */ new WeakMap(), _DOMTokenList_instances = /* @__PURE__ */ new WeakSet(), Symbol.iterator)]() {
    return __classPrivateFieldGet$I(this, _DOMTokenList_instances, "m", _DOMTokenList_getTokenList).call(this).values();
  }
  /**
   * Get ClassName.
   *
   * @param index Index.
   * */
  item(index) {
    index = typeof index === "number" ? index : 0;
    return index >= 0 && this[index] ? this[index] : null;
  }
  /**
   * Replace Token.
   *
   * @param token Token.
   * @param newToken NewToken.
   */
  replace(token, newToken) {
    const list2 = __classPrivateFieldGet$I(this, _DOMTokenList_instances, "m", _DOMTokenList_getTokenList).call(this);
    const index = list2.indexOf(token);
    if (index === -1) {
      return false;
    }
    list2[index] = newToken;
    __classPrivateFieldGet$I(this, _DOMTokenList_ownerElement, "f").setAttribute(__classPrivateFieldGet$I(this, _DOMTokenList_attributeName, "f"), list2.join(" "));
    return true;
  }
  /**
   * Supports.
   *
   * @param _token Token.
   */
  supports(_token) {
    return false;
  }
  /**
   * Returns an iterator, allowing you to go through all values of the key/value pairs contained in this object.
   */
  values() {
    return __classPrivateFieldGet$I(this, _DOMTokenList_instances, "m", _DOMTokenList_getTokenList).call(this).values();
  }
  /**
   * Returns an iterator, allowing you to go through all key/value pairs contained in this object.
   */
  entries() {
    return __classPrivateFieldGet$I(this, _DOMTokenList_instances, "m", _DOMTokenList_getTokenList).call(this).entries();
  }
  /**
   * Executes a provided callback function once for each DOMTokenList element.
   *
   * @param callback
   * @param thisArg
   */
  forEach(callback, thisArg) {
    return __classPrivateFieldGet$I(this, _DOMTokenList_instances, "m", _DOMTokenList_getTokenList).call(this).forEach(callback, thisArg);
  }
  /**
   * Returns an iterator, allowing you to go through all keys of the key/value pairs contained in this object.
   *
   */
  keys() {
    return __classPrivateFieldGet$I(this, _DOMTokenList_instances, "m", _DOMTokenList_getTokenList).call(this).keys();
  }
  /**
   * Adds tokens.
   *
   * @param tokens Tokens.
   */
  add(...tokens2) {
    const list2 = __classPrivateFieldGet$I(this, _DOMTokenList_instances, "m", _DOMTokenList_getTokenList).call(this);
    for (const token of tokens2) {
      const index = list2.indexOf(token);
      if (index === -1) {
        list2.push(token);
      } else {
        list2[index] = token;
      }
    }
    __classPrivateFieldGet$I(this, _DOMTokenList_ownerElement, "f").setAttribute(__classPrivateFieldGet$I(this, _DOMTokenList_attributeName, "f"), list2.join(" "));
  }
  /**
   * Removes tokens.
   *
   * @param tokens Tokens.
   */
  remove(...tokens2) {
    const list2 = __classPrivateFieldGet$I(this, _DOMTokenList_instances, "m", _DOMTokenList_getTokenList).call(this);
    for (const token of tokens2) {
      const index = list2.indexOf(token);
      if (index !== -1) {
        list2.splice(index, 1);
      }
    }
    __classPrivateFieldGet$I(this, _DOMTokenList_ownerElement, "f").setAttribute(__classPrivateFieldGet$I(this, _DOMTokenList_attributeName, "f"), list2.join(" "));
  }
  /**
   * Check if the list contains a class.
   *
   * @param className Class name.
   * @returns TRUE if it contains.
   */
  contains(className) {
    const list2 = __classPrivateFieldGet$I(this, _DOMTokenList_instances, "m", _DOMTokenList_getTokenList).call(this);
    return list2.includes(className);
  }
  /**
   * Toggle a class name.
   *
   * @param token A string representing the class name you want to toggle.
   * @param [force] If included, turns the toggle into a one way-only operation. If set to `false`, then class name will only be removed, but not added. If set to `true`, then class name will only be added, but not removed.
   * @returns A boolean value, `true` or `false`, indicating whether class name is in the list after the call or not.
   */
  toggle(token, force) {
    let shouldAdd;
    if (force !== void 0) {
      shouldAdd = force;
    } else {
      shouldAdd = !this.contains(token);
    }
    if (shouldAdd) {
      this.add(token);
      return true;
    }
    this.remove(token);
    return false;
  }
  /**
   * Updates indices.
   */
  [updateIndices]() {
    const list2 = __classPrivateFieldGet$I(this, _DOMTokenList_instances, "m", _DOMTokenList_getTokenList).call(this);
    for (let i = list2.length - 1, max2 = this.length; i < max2; i++) {
      delete this[i];
    }
    for (let i = 0, max2 = list2.length; i < max2; i++) {
      this[i] = list2[i];
    }
    __classPrivateFieldSet$F(this, _DOMTokenList_length, list2.length, "f");
  }
  /**
   * Returns DOMTokenList value.
   */
  toString() {
    return this.value || "";
  }
}
_DOMTokenList_getTokenList = function _DOMTokenList_getTokenList2() {
  const attr = __classPrivateFieldGet$I(this, _DOMTokenList_ownerElement, "f").getAttribute(__classPrivateFieldGet$I(this, _DOMTokenList_attributeName, "f"));
  if (!attr) {
    return [];
  }
  const list2 = [];
  for (const item2 of attr.trim().split(ATTRIBUTE_SPLIT_REGEXP)) {
    if (!list2.includes(item2)) {
      list2.push(item2);
    }
  }
  return list2;
};
var SelectorCombinatorEnum;
(function(SelectorCombinatorEnum2) {
  SelectorCombinatorEnum2["descendant"] = "descendant";
  SelectorCombinatorEnum2["child"] = "child";
  SelectorCombinatorEnum2["adjacentSibling"] = "adjacentSibling";
})(SelectorCombinatorEnum || (SelectorCombinatorEnum = {}));
const SelectorCombinatorEnum$1 = SelectorCombinatorEnum;
class SelectorItem {
  /**
   * Constructor.
   *
   * @param [options] Options.
   * @param [options.combinator] Combinator.
   * @param [options.tagName] Tag name.
   * @param [options.id] ID.
   * @param [options.classNames] Class names.
   * @param [options.attributes] Attributes.
   * @param [options.pseudos] Pseudos.
   * @param [options.isPseudoElement] Is pseudo element.
   * @param [options.ignoreErrors] Ignore errors.
   */
  constructor(options2) {
    this.tagName = (options2 == null ? void 0 : options2.tagName) || null;
    this.id = (options2 == null ? void 0 : options2.id) || null;
    this.classNames = (options2 == null ? void 0 : options2.classNames) || null;
    this.attributes = (options2 == null ? void 0 : options2.attributes) || null;
    this.pseudos = (options2 == null ? void 0 : options2.pseudos) || null;
    this.isPseudoElement = (options2 == null ? void 0 : options2.isPseudoElement) || false;
    this.combinator = (options2 == null ? void 0 : options2.combinator) || SelectorCombinatorEnum$1.descendant;
    this.ignoreErrors = (options2 == null ? void 0 : options2.ignoreErrors) || false;
  }
  /**
   * Matches a selector against an element.
   *
   * @param element HTML element.
   * @returns Result.
   */
  match(element) {
    let priorityWeight = 0;
    if (this.isPseudoElement) {
      return null;
    }
    if (this.tagName) {
      if (this.tagName !== "*" && this.tagName !== element[tagName].toUpperCase()) {
        return null;
      }
      priorityWeight += 1;
    }
    if (this.id) {
      if (this.id !== element.id) {
        return null;
      }
      priorityWeight += 100;
    }
    if (this.classNames) {
      const result = this.matchClass(element);
      if (!result) {
        return null;
      }
      priorityWeight += result.priorityWeight;
    }
    if (this.attributes) {
      const result = this.matchAttributes(element);
      if (!result) {
        return null;
      }
      priorityWeight += result.priorityWeight;
    }
    if (this.pseudos) {
      const result = this.matchPseudo(element);
      if (!result) {
        return null;
      }
      priorityWeight += result.priorityWeight;
    }
    return { priorityWeight };
  }
  /**
   * Matches a pseudo selector.
   *
   * @param element Element.
   * @returns Result.
   */
  matchPseudo(element) {
    const parent = element[parentNode];
    const parentChildren = element[parentNode] ? element[parentNode][children] : [];
    if (!this.pseudos) {
      return { priorityWeight: 0 };
    }
    let priorityWeight = 0;
    for (const pseudo of this.pseudos) {
      switch (pseudo.name) {
        case "not":
        case "nth-child":
        case "nth-of-type":
        case "nth-last-child":
        case "nth-last-of-type":
        case "is":
        case "where":
          if (!pseudo.arguments) {
            if (this.ignoreErrors) {
              return null;
            }
            throw new DOMException(`Failed to execute 'matches' on '${element.constructor.name}': '${this.getSelectorString()}' is not a valid selector.`);
          }
          break;
      }
      if (!parent) {
        switch (pseudo.name) {
          case "first-child":
          case "last-child":
          case "only-child":
          case "first-of-type":
          case "last-of-type":
          case "only-of-type":
          case "nth-child":
          case "nth-of-type":
          case "nth-last-child":
          case "nth-last-of-type":
            return null;
        }
      }
      const selectorMatch = this.matchPseudoItem(element, parentChildren, pseudo);
      if (!selectorMatch) {
        return null;
      }
      priorityWeight += selectorMatch.priorityWeight;
    }
    return { priorityWeight };
  }
  /**
   * Matches a pseudo selector.
   *
   * @param element Element.
   * @param parentChildren Parent children.
   * @param pseudo Pseudo.
   */
  matchPseudoItem(element, parentChildren, pseudo) {
    switch (pseudo.name) {
      case "first-child":
        return parentChildren[0] === element ? { priorityWeight: 10 } : null;
      case "last-child":
        return parentChildren.length && parentChildren[parentChildren.length - 1] === element ? { priorityWeight: 10 } : null;
      case "only-child":
        return parentChildren.length === 1 && parentChildren[0] === element ? { priorityWeight: 10 } : null;
      case "first-of-type":
        for (const child of parentChildren) {
          if (child[tagName] === element[tagName]) {
            return child === element ? { priorityWeight: 10 } : null;
          }
        }
        return null;
      case "last-of-type":
        for (let i = parentChildren.length - 1; i >= 0; i--) {
          const child = parentChildren[i];
          if (child[tagName] === element[tagName]) {
            return child === element ? { priorityWeight: 10 } : null;
          }
        }
        return null;
      case "only-of-type":
        let isFound = false;
        for (const child of parentChildren) {
          if (child[tagName] === element[tagName]) {
            if (isFound || child !== element) {
              return null;
            }
            isFound = true;
          }
        }
        return isFound ? { priorityWeight: 10 } : null;
      case "checked":
        return element[tagName] === "INPUT" && element.checked ? { priorityWeight: 10 } : null;
      case "empty":
        return !element[children].length ? { priorityWeight: 10 } : null;
      case "root":
        return element[tagName] === "HTML" ? { priorityWeight: 10 } : null;
      case "not":
        return !pseudo.selectorItems[0].match(element) ? { priorityWeight: 10 } : null;
      case "nth-child":
        const nthChildIndex = pseudo.selectorItems[0] ? parentChildren.filter((child) => pseudo.selectorItems[0].match(child)).indexOf(element) : parentChildren.indexOf(element);
        return nthChildIndex !== -1 && pseudo.nthFunction(nthChildIndex + 1) ? { priorityWeight: 10 } : null;
      case "nth-of-type":
        if (!element[parentNode]) {
          return null;
        }
        const nthOfTypeIndex = parentChildren.filter((child) => child[tagName] === element[tagName]).indexOf(element);
        return nthOfTypeIndex !== -1 && pseudo.nthFunction(nthOfTypeIndex + 1) ? { priorityWeight: 10 } : null;
      case "nth-last-child":
        const nthLastChildIndex = pseudo.selectorItems[0] ? parentChildren.filter((child) => pseudo.selectorItems[0].match(child)).reverse().indexOf(element) : parentChildren.reverse().indexOf(element);
        return nthLastChildIndex !== -1 && pseudo.nthFunction(nthLastChildIndex + 1) ? { priorityWeight: 10 } : null;
      case "nth-last-of-type":
        const nthLastOfTypeIndex = parentChildren.filter((child) => child[tagName] === element[tagName]).reverse().indexOf(element);
        return nthLastOfTypeIndex !== -1 && pseudo.nthFunction(nthLastOfTypeIndex + 1) ? { priorityWeight: 10 } : null;
      case "target":
        const hash2 = element[ownerDocument].location.hash;
        if (!hash2) {
          return null;
        }
        return element.isConnected && element.id === hash2.slice(1) ? { priorityWeight: 10 } : null;
      case "is":
        let priorityWeight = 0;
        for (const selectorItem of pseudo.selectorItems) {
          const match2 = selectorItem.match(element);
          if (match2) {
            priorityWeight = match2.priorityWeight;
          }
        }
        return priorityWeight ? { priorityWeight } : null;
      case "where":
        for (const selectorItem of pseudo.selectorItems) {
          if (selectorItem.match(element)) {
            return { priorityWeight: 0 };
          }
        }
        return null;
      default:
        return null;
    }
  }
  /**
   * Matches attribute.
   *
   * @param element Element.
   * @returns Result.
   */
  matchAttributes(element) {
    if (!this.attributes) {
      return null;
    }
    let priorityWeight = 0;
    for (const attribute of this.attributes) {
      const elementAttribute = element[attributes].getNamedItem(attribute.name);
      if (!elementAttribute) {
        return null;
      }
      priorityWeight += 10;
      if (attribute.value !== null && (elementAttribute[value] === null || attribute.regExp && !attribute.regExp.test(elementAttribute[value]) || !attribute.regExp && attribute.value !== elementAttribute[value])) {
        return null;
      }
    }
    return { priorityWeight };
  }
  /**
   * Matches class.
   *
   * @param element Element.
   * @returns Result.
   */
  matchClass(element) {
    if (!this.classNames) {
      return null;
    }
    const classList2 = element.className.split(" ");
    let priorityWeight = 0;
    for (const className of this.classNames) {
      if (!classList2.includes(className)) {
        return null;
      }
      priorityWeight += 10;
    }
    return { priorityWeight };
  }
  /**
   * Returns the selector string.
   *
   * @returns Selector string.
   */
  getSelectorString() {
    return `${this.tagName ? this.tagName.toLowerCase() : ""}${this.id ? `#${this.id}` : ""}${this.classNames ? `.${this.classNames.join(".")}` : ""}${this.attributes ? this.attributes.map((attribute) => `[${attribute.name}${attribute.value ? `${attribute.operator || ""}="${attribute.value}"` : ""}]`).join("") : ""}${this.pseudos ? this.pseudos.map((pseudo) => `:${pseudo.name}${pseudo.arguments ? `(${pseudo.arguments})` : ""}`).join("") : ""}`;
  }
}
const SELECTOR_REGEXP = /(\*)|([a-zA-Z0-9-]+)|#((?:[a-zA-Z0-9-_]|\\.)+)|\.((?:[a-zA-Z0-9-_]|\\.)+)|\[([a-zA-Z0-9-_]+)\]|\[([a-zA-Z0-9-_]+) *([~|^$*]{0,1}) *= *["']{1}([^"']*)["']{1} *(s|i){0,1}\]|\[([a-zA-Z0-9-_]+) *([~|^$*]{0,1}) *= *([^\]]*)\]|:([a-zA-Z-]+) *\(([^)]+\)?)\)|:([a-zA-Z-]+)|::([a-zA-Z-]+)|([ ,+>]*)/g;
const ESCAPED_CHARACTER_REGEXP = /\\/g;
const NTH_FUNCTION = {
  odd: (n2) => (n2 + 1) % 2 === 0,
  even: (n2) => (n2 + 1) % 2 !== 0,
  alwaysFalse: () => false
};
const SPACE_REGEXP = / /g;
const SIMPLE_SELECTOR_REGEXP = /(^[a-zA-Z0-9-]+$)|(^\.[a-zA-Z0-9-_.]+$)|(^#[a-zA-Z0-9-_]+$)/;
class SelectorParser {
  /**
   * Parses a selector string and returns an instance of SelectorItem.
   *
   * @param selector Selector.
   * @param [options] Options.
   * @param [options.ignoreErrors] Ignores errors.
   * @returns Selector item.
   */
  static getSelectorItem(selector, options2) {
    return this.getSelectorGroups(selector, options2)[0][0];
  }
  /**
   * Parses a selector string and returns groups with SelectorItem instances.
   *
   * @param selector Selector.
   * @param [options] Options.
   * @param [options.ignoreErrors] Ignores errors.
   * @returns Selector groups.
   */
  static getSelectorGroups(selector, options2) {
    const ignoreErrors = options2 == null ? void 0 : options2.ignoreErrors;
    if (selector === "*") {
      return [[new SelectorItem({ tagName: "*", ignoreErrors })]];
    }
    const simpleMatch = selector.match(SIMPLE_SELECTOR_REGEXP);
    if (simpleMatch) {
      if (simpleMatch[1]) {
        return [[new SelectorItem({ tagName: selector.toUpperCase(), ignoreErrors })]];
      } else if (simpleMatch[2]) {
        return [
          [new SelectorItem({ classNames: selector.replace(".", "").split("."), ignoreErrors })]
        ];
      } else if (simpleMatch[3]) {
        return [[new SelectorItem({ id: selector.replace("#", ""), ignoreErrors })]];
      }
    }
    const regexp = new RegExp(SELECTOR_REGEXP);
    let currentSelectorItem = new SelectorItem({
      combinator: SelectorCombinatorEnum$1.descendant,
      ignoreErrors
    });
    let currentGroup = [currentSelectorItem];
    const groups = [currentGroup];
    let isValid = false;
    let match2;
    while (match2 = regexp.exec(selector)) {
      if (match2[0]) {
        isValid = true;
        if (match2[1]) {
          currentSelectorItem.tagName = "*";
        } else if (match2[2]) {
          currentSelectorItem.tagName = match2[2].toUpperCase();
        } else if (match2[3]) {
          currentSelectorItem.id = match2[3].replace(ESCAPED_CHARACTER_REGEXP, "");
        } else if (match2[4]) {
          currentSelectorItem.classNames = currentSelectorItem.classNames || [];
          currentSelectorItem.classNames.push(match2[4].replace(ESCAPED_CHARACTER_REGEXP, ""));
        } else if (match2[5]) {
          currentSelectorItem.attributes = currentSelectorItem.attributes || [];
          currentSelectorItem.attributes.push({
            name: match2[5].toLowerCase(),
            operator: null,
            value: null,
            modifier: null,
            regExp: null
          });
        } else if (match2[6] && match2[8] !== void 0) {
          currentSelectorItem.attributes = currentSelectorItem.attributes || [];
          currentSelectorItem.attributes.push({
            name: match2[6].toLowerCase(),
            operator: match2[7] || null,
            value: match2[8].replace(ESCAPED_CHARACTER_REGEXP, ""),
            modifier: match2[9] || null,
            regExp: this.getAttributeRegExp({
              operator: match2[7],
              value: match2[8],
              modifier: match2[9]
            })
          });
        } else if (match2[10] && match2[12] !== void 0) {
          currentSelectorItem.attributes = currentSelectorItem.attributes || [];
          currentSelectorItem.attributes.push({
            name: match2[10].toLowerCase(),
            operator: match2[11] || null,
            value: match2[12].replace(ESCAPED_CHARACTER_REGEXP, ""),
            modifier: null,
            regExp: this.getAttributeRegExp({ operator: match2[11], value: match2[12] })
          });
        } else if (match2[13] && match2[14]) {
          currentSelectorItem.pseudos = currentSelectorItem.pseudos || [];
          currentSelectorItem.pseudos.push(this.getPseudo(match2[13], match2[14], options2));
        } else if (match2[15]) {
          currentSelectorItem.pseudos = currentSelectorItem.pseudos || [];
          currentSelectorItem.pseudos.push(this.getPseudo(match2[15], null, options2));
        } else if (match2[16]) {
          currentSelectorItem.isPseudoElement = true;
        } else if (match2[17]) {
          switch (match2[17].trim()) {
            case ",":
              currentSelectorItem = new SelectorItem({
                combinator: SelectorCombinatorEnum$1.descendant,
                ignoreErrors
              });
              currentGroup = [currentSelectorItem];
              groups.push(currentGroup);
              break;
            case ">":
              currentSelectorItem = new SelectorItem({
                combinator: SelectorCombinatorEnum$1.child,
                ignoreErrors
              });
              currentGroup.push(currentSelectorItem);
              break;
            case "+":
              currentSelectorItem = new SelectorItem({
                combinator: SelectorCombinatorEnum$1.adjacentSibling,
                ignoreErrors
              });
              currentGroup.push(currentSelectorItem);
              break;
            case "":
              currentSelectorItem = new SelectorItem({
                combinator: SelectorCombinatorEnum$1.descendant,
                ignoreErrors
              });
              currentGroup.push(currentSelectorItem);
              break;
          }
        }
      } else {
        break;
      }
    }
    if (!isValid) {
      if (options2 == null ? void 0 : options2.ignoreErrors) {
        return [];
      }
      throw new DOMException(`Invalid selector: "${selector}"`);
    }
    return groups;
  }
  /**
   * Returns attribute RegExp.
   *
   * @param attribute Attribute.
   * @param attribute.value Attribute value.
   * @param attribute.operator Attribute operator.
   * @param attribute.modifier Attribute modifier.
   * @returns Attribute RegExp.
   */
  static getAttributeRegExp(attribute) {
    const modifier = attribute.modifier === "i" ? "i" : "";
    if (!attribute.operator || !attribute.value) {
      return null;
    }
    switch (attribute.operator) {
      case "~":
        return new RegExp(`[- ]${attribute.value}|${attribute.value}[- ]|^${attribute.value}$`, modifier);
      case "|":
        return new RegExp(`^${attribute.value}[- ]|^${attribute.value}$`, modifier);
      case "^":
        return new RegExp(`^${attribute.value}`, modifier);
      case "$":
        return new RegExp(`${attribute.value}$`, modifier);
      case "*":
        return new RegExp(`${attribute.value}`, modifier);
      default:
        return null;
    }
  }
  /**
   * Returns pseudo.
   *
   * @param name Pseudo name.
   * @param args Pseudo arguments.
   * @param [options] Options.
   * @param [options.ignoreErrors] Ignores errors.
   * @returns Pseudo.
   */
  static getPseudo(name2, args, options2) {
    const lowerName = name2.toLowerCase();
    if (!args) {
      return { name: lowerName, arguments: null, selectorItems: null, nthFunction: null };
    }
    switch (lowerName) {
      case "nth-last-child":
      case "nth-child":
        const nthOfIndex = args.indexOf(" of ");
        const nthFunction = nthOfIndex !== -1 ? args.substring(0, nthOfIndex) : args;
        const selectorItem = nthOfIndex !== -1 ? this.getSelectorItem(args.substring(nthOfIndex + 4).trim(), options2) : null;
        return {
          name: lowerName,
          arguments: args,
          selectorItems: [selectorItem],
          nthFunction: this.getPseudoNthFunction(nthFunction)
        };
      case "nth-of-type":
      case "nth-last-of-type":
        return {
          name: lowerName,
          arguments: args,
          selectorItems: null,
          nthFunction: this.getPseudoNthFunction(args)
        };
      case "not":
        return {
          name: lowerName,
          arguments: args,
          selectorItems: [this.getSelectorItem(args, options2)],
          nthFunction: null
        };
      case "is":
      case "where":
        const selectorGroups = this.getSelectorGroups(args, options2);
        const selectorItems = [];
        for (const group of selectorGroups) {
          selectorItems.push(group[0]);
        }
        return {
          name: lowerName,
          arguments: args,
          selectorItems,
          nthFunction: null
        };
      default:
        return { name: lowerName, arguments: args, selectorItems: null, nthFunction: null };
    }
  }
  /**
   * Returns pseudo nth function.
   *
   * Based on:
   * https://github.com/dperini/nwsapi/blob/master/src/nwsapi.js
   *
   * @param args Pseudo arguments.
   * @returns Pseudo nth function.
   */
  static getPseudoNthFunction(args) {
    if (args === "odd") {
      return NTH_FUNCTION.odd;
    } else if (args === "even") {
      return NTH_FUNCTION.even;
    }
    const parts = args.replace(SPACE_REGEXP, "").split("n");
    let partA = parseInt(parts[0], 10) || 0;
    if (parts[0] == "-") {
      partA = -1;
    }
    if (parts.length === 1) {
      return (n2) => n2 == partA;
    }
    let partB = parseInt(parts[1], 10) || 0;
    if (parts[0] == "+") {
      partB = 1;
    }
    if (partA >= 1 || partA <= -1) {
      if (partA >= 1) {
        if (Math.abs(partA) === 1) {
          return (n2) => n2 > partB - 1;
        }
        return (n2) => n2 > partB - 1 && (n2 + -1 * partB) % partA === 0;
      }
      if (Math.abs(partA) === 1) {
        return (n2) => n2 < partB + 1;
      }
      return (n2) => n2 < partB + 1 && (n2 + -1 * partB) % partA === 0;
    }
    if (parts[0]) {
      return (n2) => n2 === partB;
    }
    return (n2) => n2 > partB - 1;
  }
}
const INVALID_SELECTOR_REGEXP = /^[.#\[]?\d|[.#]$/;
class QuerySelector {
  /**
   * Finds elements based on a query selector.
   *
   * @param node Node to search in.
   * @param selector Selector.
   * @returns HTML elements.
   */
  static querySelectorAll(node2, selector) {
    if (selector === "") {
      throw new Error(`Failed to execute 'querySelectorAll' on '${node2.constructor.name}': The provided selector is empty.`);
    }
    if (selector === null || selector === void 0) {
      return new NodeList();
    }
    if (INVALID_SELECTOR_REGEXP.test(selector)) {
      throw new Error(`Failed to execute 'querySelectorAll' on '${node2.constructor.name}': '${selector}' is not a valid selector.`);
    }
    const groups = SelectorParser.getSelectorGroups(selector);
    let matches = [];
    for (const items of groups) {
      matches = matches.concat(node2[nodeType] === NodeTypeEnum$1.elementNode ? this.findAll(node2, [node2], items) : this.findAll(null, node2[children], items));
    }
    const nodeList = new NodeList();
    const matchesMap = {};
    for (let i = 0, max2 = matches.length; i < max2; i++) {
      matchesMap[matches[i].documentPosition] = matches[i].element;
    }
    const keys = Object.keys(matchesMap).sort();
    for (let i = 0, max2 = keys.length; i < max2; i++) {
      nodeList.push(matchesMap[keys[i]]);
    }
    return nodeList;
  }
  /**
   * Finds an element based on a query selector.
   *
   * @param node Node to search in.
   * @param selector Selector.
   * @returns HTML element.
   */
  static querySelector(node2, selector) {
    if (selector === "") {
      throw new Error(`Failed to execute 'querySelector' on '${node2.constructor.name}': The provided selector is empty.`);
    }
    if (selector === null || selector === void 0) {
      return null;
    }
    if (INVALID_SELECTOR_REGEXP.test(selector)) {
      throw new Error(`Failed to execute 'querySelector' on '${node2.constructor.name}': '${selector}' is not a valid selector.`);
    }
    for (const items of SelectorParser.getSelectorGroups(selector)) {
      const match2 = node2[nodeType] === NodeTypeEnum$1.elementNode ? this.findFirst(node2, [node2], items) : this.findFirst(null, node2[children], items);
      if (match2) {
        return match2;
      }
    }
    return null;
  }
  /**
   * Checks if an element matches a selector and returns priority weight.
   *
   * @param element Element to match.
   * @param selector Selector to match with.
   * @param [options] Options.
   * @param [options.ignoreErrors] Ignores errors.
   * @returns Result.
   */
  static matches(element, selector, options2) {
    if (!selector) {
      return null;
    }
    if (selector === "*") {
      return {
        priorityWeight: 1
      };
    }
    const ignoreErrors = options2 == null ? void 0 : options2.ignoreErrors;
    if (INVALID_SELECTOR_REGEXP.test(selector)) {
      if (ignoreErrors) {
        return null;
      }
      throw new Error(`Failed to execute 'matches' on '${element.constructor.name}': '${selector}' is not a valid selector.`);
    }
    for (const items of SelectorParser.getSelectorGroups(selector, options2)) {
      const result = this.matchSelector(element, element, items.reverse(), 0);
      if (result) {
        return result;
      }
    }
    return null;
  }
  /**
   * Checks if a node matches a selector.
   *
   * @param targetElement Target element.
   * @param currentElement Current element.
   * @param selectorItems Selector items.
   * @param [priorityWeight] Priority weight.
   * @returns Result.
   */
  static matchSelector(targetElement, currentElement, selectorItems, priorityWeight = 0) {
    const selectorItem = selectorItems[0];
    const result = selectorItem.match(currentElement);
    if (result) {
      if (selectorItems.length === 1) {
        return {
          priorityWeight: priorityWeight + result.priorityWeight
        };
      }
      switch (selectorItem.combinator) {
        case SelectorCombinatorEnum$1.adjacentSibling:
          if (currentElement.previousElementSibling) {
            const match2 = this.matchSelector(targetElement, currentElement.previousElementSibling, selectorItems.slice(1), priorityWeight + result.priorityWeight);
            if (match2) {
              return match2;
            }
          }
          break;
        case SelectorCombinatorEnum$1.child:
        case SelectorCombinatorEnum$1.descendant:
          if (currentElement.parentElement) {
            const match2 = this.matchSelector(targetElement, currentElement.parentElement, selectorItems.slice(1), priorityWeight + result.priorityWeight);
            if (match2) {
              return match2;
            }
          }
          break;
      }
    }
    if (selectorItem.combinator === SelectorCombinatorEnum$1.descendant && targetElement !== currentElement && currentElement.parentElement) {
      return this.matchSelector(targetElement, currentElement.parentElement, selectorItems, priorityWeight);
    }
    return null;
  }
  /**
   * Finds elements based on a query selector for a part of a list of selectors separated with comma.
   *
   * @param rootElement Root element.
   * @param children Child elements.
   * @param selectorItems Selector items.
   * @param [documentPosition] Document position of the element.
   * @returns Document position and element map.
   */
  static findAll(rootElement, children$1, selectorItems, documentPosition) {
    const selectorItem = selectorItems[0];
    const nextSelectorItem = selectorItems[1];
    let matched = [];
    for (let i = 0, max2 = children$1.length; i < max2; i++) {
      const child = children$1[i];
      const position = (documentPosition ? documentPosition + ">" : "") + String.fromCharCode(i);
      if (selectorItem.match(child)) {
        if (!nextSelectorItem) {
          if (rootElement !== child) {
            matched.push({
              documentPosition: position,
              element: child
            });
          }
        } else {
          switch (nextSelectorItem.combinator) {
            case SelectorCombinatorEnum$1.adjacentSibling:
              if (child.nextElementSibling) {
                matched = matched.concat(this.findAll(rootElement, [child.nextElementSibling], selectorItems.slice(1), position));
              }
              break;
            case SelectorCombinatorEnum$1.descendant:
            case SelectorCombinatorEnum$1.child:
              matched = matched.concat(this.findAll(rootElement, child[children], selectorItems.slice(1), position));
              break;
          }
        }
      }
      if (selectorItem.combinator === SelectorCombinatorEnum$1.descendant && child[children].length) {
        matched = matched.concat(this.findAll(rootElement, child[children], selectorItems, position));
      }
    }
    return matched;
  }
  /**
   * Finds an element based on a query selector for a part of a list of selectors separated with comma.
   *
   * @param rootElement Root element.
   * @param children Child elements.
   * @param selectorItems Selector items.
   * @returns HTML element.
   */
  static findFirst(rootElement, children$1, selectorItems) {
    const selectorItem = selectorItems[0];
    const nextSelectorItem = selectorItems[1];
    for (const child of children$1) {
      if (selectorItem.match(child)) {
        if (!nextSelectorItem) {
          if (rootElement !== child) {
            return child;
          }
        } else {
          switch (nextSelectorItem.combinator) {
            case SelectorCombinatorEnum$1.adjacentSibling:
              if (child.nextElementSibling) {
                const match3 = this.findFirst(rootElement, [child.nextElementSibling], selectorItems.slice(1));
                if (match3) {
                  return match3;
                }
              }
              break;
            case SelectorCombinatorEnum$1.descendant:
            case SelectorCombinatorEnum$1.child:
              const match2 = this.findFirst(rootElement, child[children], selectorItems.slice(1));
              if (match2) {
                return match2;
              }
              break;
          }
        }
      }
      if (selectorItem.combinator === SelectorCombinatorEnum$1.descendant && child[children].length) {
        const match2 = this.findFirst(rootElement, child[children], selectorItems);
        if (match2) {
          return match2;
        }
      }
    }
    return null;
  }
}
var HTMLElementConfigContentModelEnum;
(function(HTMLElementConfigContentModelEnum2) {
  HTMLElementConfigContentModelEnum2["rawText"] = "rawText";
  HTMLElementConfigContentModelEnum2["noSelfDescendants"] = "noSelfDescendants";
  HTMLElementConfigContentModelEnum2["noFirstLevelSelfDescendants"] = "noFirstLevelSelfDescendants";
  HTMLElementConfigContentModelEnum2["noDescendants"] = "noDescendants";
  HTMLElementConfigContentModelEnum2["anyDescendants"] = "anyDescendants";
})(HTMLElementConfigContentModelEnum || (HTMLElementConfigContentModelEnum = {}));
const HTMLElementConfigContentModelEnum$1 = HTMLElementConfigContentModelEnum;
const HTMLElementConfig = {
  a: {
    className: "HTMLAnchorElement",
    localName: "a",
    tagName: "A",
    contentModel: HTMLElementConfigContentModelEnum$1.noSelfDescendants
  },
  abbr: {
    className: "HTMLElement",
    localName: "abbr",
    tagName: "ABBR",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  address: {
    className: "HTMLElement",
    localName: "address",
    tagName: "ADDRESS",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  area: {
    className: "HTMLElement",
    localName: "area",
    tagName: "AREA",
    contentModel: HTMLElementConfigContentModelEnum$1.noDescendants
  },
  article: {
    className: "HTMLElement",
    localName: "article",
    tagName: "ARTICLE",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  aside: {
    className: "HTMLElement",
    localName: "aside",
    tagName: "ASIDE",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  audio: {
    className: "HTMLAudioElement",
    localName: "audio",
    tagName: "AUDIO",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  b: {
    className: "HTMLElement",
    localName: "b",
    tagName: "B",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  base: {
    className: "HTMLBaseElement",
    localName: "base",
    tagName: "BASE",
    contentModel: HTMLElementConfigContentModelEnum$1.noDescendants
  },
  bdi: {
    className: "HTMLElement",
    localName: "bdi",
    tagName: "BDI",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  bdo: {
    className: "HTMLElement",
    localName: "bdo",
    tagName: "BDO",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  blockquaote: {
    className: "HTMLElement",
    localName: "blockquaote",
    tagName: "BLOCKQUAOTE",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  body: {
    className: "HTMLElement",
    localName: "body",
    tagName: "BODY",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  template: {
    className: "HTMLTemplateElement",
    localName: "template",
    tagName: "TEMPLATE",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  form: {
    className: "HTMLFormElement",
    localName: "form",
    tagName: "FORM",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  input: {
    className: "HTMLInputElement",
    localName: "input",
    tagName: "INPUT",
    contentModel: HTMLElementConfigContentModelEnum$1.noDescendants
  },
  textarea: {
    className: "HTMLTextAreaElement",
    localName: "textarea",
    tagName: "TEXTAREA",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  script: {
    className: "HTMLScriptElement",
    localName: "script",
    tagName: "SCRIPT",
    contentModel: HTMLElementConfigContentModelEnum$1.rawText
  },
  img: {
    className: "HTMLImageElement",
    localName: "img",
    tagName: "IMG",
    contentModel: HTMLElementConfigContentModelEnum$1.noDescendants
  },
  link: {
    className: "HTMLLinkElement",
    localName: "link",
    tagName: "LINK",
    contentModel: HTMLElementConfigContentModelEnum$1.noDescendants
  },
  style: {
    className: "HTMLStyleElement",
    localName: "style",
    tagName: "STYLE",
    contentModel: HTMLElementConfigContentModelEnum$1.rawText
  },
  label: {
    className: "HTMLLabelElement",
    localName: "label",
    tagName: "LABEL",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  slot: {
    className: "HTMLSlotElement",
    localName: "slot",
    tagName: "SLOT",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  meta: {
    className: "HTMLMetaElement",
    localName: "meta",
    tagName: "META",
    contentModel: HTMLElementConfigContentModelEnum$1.noDescendants
  },
  blockquote: {
    className: "HTMLElement",
    localName: "blockquote",
    tagName: "BLOCKQUOTE",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  br: {
    className: "HTMLElement",
    localName: "br",
    tagName: "BR",
    contentModel: HTMLElementConfigContentModelEnum$1.noDescendants
  },
  button: {
    className: "HTMLButtonElement",
    localName: "button",
    tagName: "BUTTON",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  canvas: {
    className: "HTMLElement",
    localName: "canvas",
    tagName: "CANVAS",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  caption: {
    className: "HTMLElement",
    localName: "caption",
    tagName: "CAPTION",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  cite: {
    className: "HTMLElement",
    localName: "cite",
    tagName: "CITE",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  code: {
    className: "HTMLElement",
    localName: "code",
    tagName: "CODE",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  col: {
    className: "HTMLElement",
    localName: "col",
    tagName: "COL",
    contentModel: HTMLElementConfigContentModelEnum$1.noDescendants
  },
  colgroup: {
    className: "HTMLElement",
    localName: "colgroup",
    tagName: "COLGROUP",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  data: {
    className: "HTMLElement",
    localName: "data",
    tagName: "DATA",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  datalist: {
    className: "HTMLElement",
    localName: "datalist",
    tagName: "DATALIST",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  dd: {
    className: "HTMLElement",
    localName: "dd",
    tagName: "DD",
    contentModel: HTMLElementConfigContentModelEnum$1.noFirstLevelSelfDescendants
  },
  del: {
    className: "HTMLElement",
    localName: "del",
    tagName: "DEL",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  details: {
    className: "HTMLElement",
    localName: "details",
    tagName: "DETAILS",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  dfn: {
    className: "HTMLElement",
    localName: "dfn",
    tagName: "DFN",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  dialog: {
    className: "HTMLDialogElement",
    localName: "dialog",
    tagName: "DIALOG",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  div: {
    className: "HTMLElement",
    localName: "div",
    tagName: "DIV",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  dl: {
    className: "HTMLElement",
    localName: "dl",
    tagName: "DL",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  dt: {
    className: "HTMLElement",
    localName: "dt",
    tagName: "DT",
    contentModel: HTMLElementConfigContentModelEnum$1.noFirstLevelSelfDescendants
  },
  em: {
    className: "HTMLElement",
    localName: "em",
    tagName: "EM",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  embed: {
    className: "HTMLElement",
    localName: "embed",
    tagName: "EMBED",
    contentModel: HTMLElementConfigContentModelEnum$1.noDescendants
  },
  fieldset: {
    className: "HTMLElement",
    localName: "fieldset",
    tagName: "FIELDSET",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  figcaption: {
    className: "HTMLElement",
    localName: "figcaption",
    tagName: "FIGCAPTION",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  figure: {
    className: "HTMLElement",
    localName: "figure",
    tagName: "FIGURE",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  footer: {
    className: "HTMLElement",
    localName: "footer",
    tagName: "FOOTER",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  h1: {
    className: "HTMLElement",
    localName: "h1",
    tagName: "H1",
    contentModel: HTMLElementConfigContentModelEnum$1.noFirstLevelSelfDescendants
  },
  h2: {
    className: "HTMLElement",
    localName: "h2",
    tagName: "H2",
    contentModel: HTMLElementConfigContentModelEnum$1.noFirstLevelSelfDescendants
  },
  h3: {
    className: "HTMLElement",
    localName: "h3",
    tagName: "H3",
    contentModel: HTMLElementConfigContentModelEnum$1.noFirstLevelSelfDescendants
  },
  h4: {
    className: "HTMLElement",
    localName: "h4",
    tagName: "H4",
    contentModel: HTMLElementConfigContentModelEnum$1.noFirstLevelSelfDescendants
  },
  h5: {
    className: "HTMLElement",
    localName: "h5",
    tagName: "H5",
    contentModel: HTMLElementConfigContentModelEnum$1.noFirstLevelSelfDescendants
  },
  h6: {
    className: "HTMLElement",
    localName: "h6",
    tagName: "H6",
    contentModel: HTMLElementConfigContentModelEnum$1.noFirstLevelSelfDescendants
  },
  head: {
    className: "HTMLElement",
    localName: "head",
    tagName: "HEAD",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  header: {
    className: "HTMLElement",
    localName: "header",
    tagName: "HEADER",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  hgroup: {
    className: "HTMLElement",
    localName: "hgroup",
    tagName: "HGROUP",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  hr: {
    className: "HTMLElement",
    localName: "hr",
    tagName: "HR",
    contentModel: HTMLElementConfigContentModelEnum$1.noDescendants
  },
  html: {
    className: "HTMLElement",
    localName: "html",
    tagName: "HTML",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  i: {
    className: "HTMLElement",
    localName: "i",
    tagName: "I",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  iframe: {
    className: "HTMLIFrameElement",
    localName: "iframe",
    tagName: "IFRAME",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  ins: {
    className: "HTMLElement",
    localName: "ins",
    tagName: "INS",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  kbd: {
    className: "HTMLElement",
    localName: "kbd",
    tagName: "KBD",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  legend: {
    className: "HTMLElement",
    localName: "legend",
    tagName: "LEGEND",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  li: {
    className: "HTMLElement",
    localName: "li",
    tagName: "LI",
    contentModel: HTMLElementConfigContentModelEnum$1.noFirstLevelSelfDescendants
  },
  main: {
    className: "HTMLElement",
    localName: "main",
    tagName: "MAIN",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  map: {
    className: "HTMLElement",
    localName: "map",
    tagName: "MAP",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  mark: {
    className: "HTMLElement",
    localName: "mark",
    tagName: "MARK",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  math: {
    className: "HTMLElement",
    localName: "math",
    tagName: "MATH",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  menu: {
    className: "HTMLElement",
    localName: "menu",
    tagName: "MENU",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  menuitem: {
    className: "HTMLElement",
    localName: "menuitem",
    tagName: "MENUITEM",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  meter: {
    className: "HTMLElement",
    localName: "meter",
    tagName: "METER",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  nav: {
    className: "HTMLElement",
    localName: "nav",
    tagName: "NAV",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  noscript: {
    className: "HTMLElement",
    localName: "noscript",
    tagName: "NOSCRIPT",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  object: {
    className: "HTMLElement",
    localName: "object",
    tagName: "OBJECT",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  ol: {
    className: "HTMLElement",
    localName: "ol",
    tagName: "OL",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  optgroup: {
    className: "HTMLOptGroupElement",
    localName: "optgroup",
    tagName: "OPTGROUP",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  option: {
    className: "HTMLOptionElement",
    localName: "option",
    tagName: "OPTION",
    contentModel: HTMLElementConfigContentModelEnum$1.noFirstLevelSelfDescendants
  },
  output: {
    className: "HTMLElement",
    localName: "output",
    tagName: "OUTPUT",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  p: {
    className: "HTMLElement",
    localName: "p",
    tagName: "P",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  param: {
    className: "HTMLElement",
    localName: "param",
    tagName: "PARAM",
    contentModel: HTMLElementConfigContentModelEnum$1.noDescendants
  },
  picture: {
    className: "HTMLElement",
    localName: "picture",
    tagName: "PICTURE",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  pre: {
    className: "HTMLElement",
    localName: "pre",
    tagName: "PRE",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  progress: {
    className: "HTMLElement",
    localName: "progress",
    tagName: "PROGRESS",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  q: {
    className: "HTMLElement",
    localName: "q",
    tagName: "Q",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  rb: {
    className: "HTMLElement",
    localName: "rb",
    tagName: "RB",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  rp: {
    className: "HTMLElement",
    localName: "rp",
    tagName: "RP",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  rt: {
    className: "HTMLElement",
    localName: "rt",
    tagName: "RT",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  rtc: {
    className: "HTMLElement",
    localName: "rtc",
    tagName: "RTC",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  ruby: {
    className: "HTMLElement",
    localName: "ruby",
    tagName: "RUBY",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  s: {
    className: "HTMLElement",
    localName: "s",
    tagName: "S",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  samp: {
    className: "HTMLElement",
    localName: "samp",
    tagName: "SAMP",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  section: {
    className: "HTMLElement",
    localName: "section",
    tagName: "SECTION",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  select: {
    className: "HTMLSelectElement",
    localName: "select",
    tagName: "SELECT",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  small: {
    className: "HTMLElement",
    localName: "small",
    tagName: "SMALL",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  source: {
    className: "HTMLElement",
    localName: "source",
    tagName: "SOURCE",
    contentModel: HTMLElementConfigContentModelEnum$1.noDescendants
  },
  span: {
    className: "HTMLElement",
    localName: "span",
    tagName: "SPAN",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  strong: {
    className: "HTMLElement",
    localName: "strong",
    tagName: "STRONG",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  sub: {
    className: "HTMLElement",
    localName: "sub",
    tagName: "SUB",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  summary: {
    className: "HTMLElement",
    localName: "summary",
    tagName: "SUMMARY",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  sup: {
    className: "HTMLElement",
    localName: "sup",
    tagName: "SUP",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  table: {
    className: "HTMLElement",
    localName: "table",
    tagName: "TABLE",
    contentModel: HTMLElementConfigContentModelEnum$1.noFirstLevelSelfDescendants
  },
  tbody: {
    className: "HTMLElement",
    localName: "tbody",
    tagName: "TBODY",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  td: {
    className: "HTMLElement",
    localName: "td",
    tagName: "TD",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  tfoot: {
    className: "HTMLElement",
    localName: "tfoot",
    tagName: "TFOOT",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  th: {
    className: "HTMLElement",
    localName: "th",
    tagName: "TH",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  thead: {
    className: "HTMLElement",
    localName: "thead",
    tagName: "THEAD",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  time: {
    className: "HTMLTimeElement",
    localName: "time",
    tagName: "TIME",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  title: {
    className: "HTMLElement",
    localName: "title",
    tagName: "TITLE",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  tr: {
    className: "HTMLElement",
    localName: "tr",
    tagName: "TR",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  track: {
    className: "HTMLElement",
    localName: "track",
    tagName: "TRACK",
    contentModel: HTMLElementConfigContentModelEnum$1.noDescendants
  },
  u: {
    className: "HTMLElement",
    localName: "u",
    tagName: "U",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  ul: {
    className: "HTMLElement",
    localName: "ul",
    tagName: "UL",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  var: {
    className: "HTMLElement",
    localName: "var",
    tagName: "VAR",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  video: {
    className: "HTMLVideoElement",
    localName: "video",
    tagName: "VIDEO",
    contentModel: HTMLElementConfigContentModelEnum$1.anyDescendants
  },
  wbr: {
    className: "HTMLElement",
    localName: "wbr",
    tagName: "WBR",
    contentModel: HTMLElementConfigContentModelEnum$1.noDescendants
  }
};
const htmlDecodeTree = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map((c) => c.charCodeAt(0))
);
const xmlDecodeTree = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map((c) => c.charCodeAt(0))
);
var _a$D;
const decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
const fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a$D = String.fromCodePoint) !== null && _a$D !== void 0 ? _a$D : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
}
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
  CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
  CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
const TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code2) {
  return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
}
function isHexadecimalCharacter(code2) {
  return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code2) {
  return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber(code2);
}
function isEntityInAttributeInvalidEnd(code2) {
  return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric(code2);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
class EntityDecoder {
  constructor(decodeTree, emitCodePoint, errors2) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors2;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset2) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset2) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset2 + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset2);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset2);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset2);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset2);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset2);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset2) {
    if (offset2 >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset2) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset2 + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset2);
  }
  addToNumericResult(str, start2, end2, base2) {
    if (start2 !== end2) {
      const digitCount = end2 - start2;
      this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start2, digitCount), base2);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset2) {
    const startIdx = offset2;
    while (offset2 < str.length) {
      const char = str.charCodeAt(offset2);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset2 += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset2, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset2, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset2) {
    const startIdx = offset2;
    while (offset2 < str.length) {
      const char = str.charCodeAt(offset2);
      if (isNumber(char)) {
        offset2 += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset2, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset2, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a2;
    if (this.consumed <= expectedLength) {
      (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset2) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset2 < str.length; offset2++, this.excess++) {
      const char = str.charCodeAt(offset2);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a2;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a2;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
}
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset2 = 0;
    while ((offset2 = str.indexOf("&", offset2)) >= 0) {
      ret += str.slice(lastIndex, offset2);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        // Skip the "&"
        offset2 + 1
      );
      if (len < 0) {
        lastIndex = offset2 + decoder.end();
        break;
      }
      lastIndex = offset2 + len;
      offset2 = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value2 = char - jumpOffset;
    return value2 < 0 || value2 >= branchCount ? -1 : decodeTree[nodeIdx + value2] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
const htmlDecoder = getDecoder(htmlDecodeTree);
getDecoder(xmlDecodeTree);
function decodeHTML(str, mode2 = DecodingMode.Legacy) {
  return htmlDecoder(str, mode2);
}
function decodeHTMLAttribute(str) {
  return htmlDecoder(str, DecodingMode.Attribute);
}
function getEscaper(regex, map2) {
  return function escape(data2) {
    let match2;
    let lastIdx = 0;
    let result = "";
    while (match2 = regex.exec(data2)) {
      if (lastIdx !== match2.index) {
        result += data2.substring(lastIdx, match2.index);
      }
      result += map2.get(match2[0].charCodeAt(0));
      lastIdx = match2.index + 1;
    }
    return result + data2.substring(lastIdx);
  };
}
const escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));
const MARKUP_REGEXP = /<([a-zA-Z0-9-]+)|<\/([a-zA-Z0-9-]+)\s*>|<!--([^-]+)-->|<!--([^>]+)>|<!([^>]*)>|<\?([^>]+)>|(\/>)|(>)/gm;
const ATTRIBUTE_REGEXP = /\s*([a-zA-Z0-9-_:.$@?]+) *= *([a-zA-Z0-9-_:.$@?{}/]+)|\s*([a-zA-Z0-9-_:.$@?]+) *= *"([^"]*)("{0,1})|\s*([a-zA-Z0-9-_:.$@?]+) *= *'([^']*)('{0,1})|\s*([a-zA-Z0-9-_:.$@?]+)/gm;
var MarkupReadStateEnum;
(function(MarkupReadStateEnum2) {
  MarkupReadStateEnum2["startOrEndTag"] = "startOrEndTag";
  MarkupReadStateEnum2["insideStartTag"] = "insideStartTag";
  MarkupReadStateEnum2["plainTextContent"] = "plainTextContent";
})(MarkupReadStateEnum || (MarkupReadStateEnum = {}));
const DOCUMENT_TYPE_ATTRIBUTE_REGEXP = /"([^"]+)"/gm;
class XMLParser {
  /**
   * Parses XML/HTML and returns a root element.
   *
   * @param document Document.
   * @param xml XML/HTML string.
   * @param [options] Options.
   * @param [options.rootNode] Node to append elements to. Otherwise a new DocumentFragment is created.
   * @param [options.evaluateScripts = false] Set to "true" to enable script execution.
   * @returns Root node.
   */
  static parse(document2, xml, options2) {
    var _a2;
    const root = options2 && options2.rootNode ? options2.rootNode : document2.createDocumentFragment();
    const stack = [root];
    const stackTagNames = [];
    const markupRegexp = new RegExp(MARKUP_REGEXP, "gm");
    const { evaluateScripts = false } = options2 || {};
    let currentNode = root;
    let match2;
    let readState = MarkupReadStateEnum.startOrEndTag;
    let startTagIndex = 0;
    let lastIndex = 0;
    if (xml !== null && xml !== void 0) {
      xml = String(xml);
      while (match2 = markupRegexp.exec(xml)) {
        switch (readState) {
          case MarkupReadStateEnum.startOrEndTag:
            if (match2.index !== lastIndex && (match2[1] || match2[2] || match2[3] || match2[4] || match2[5] !== void 0 || match2[6])) {
              currentNode.appendChild(document2.createTextNode(decodeHTML(xml.substring(lastIndex, match2.index))));
            }
            if (match2[1]) {
              const tagName$13 = match2[1].toUpperCase();
              const localName2 = tagName$13 === "SVG" ? "svg" : match2[1];
              const config = HTMLElementConfig[localName2];
              if ((config == null ? void 0 : config.contentModel) === HTMLElementConfigContentModelEnum$1.noFirstLevelSelfDescendants && stackTagNames[stackTagNames.length - 1] === tagName$13) {
                stack.pop();
                stackTagNames.pop();
                currentNode = stack[stack.length - 1] || root;
              } else if ((config == null ? void 0 : config.contentModel) === HTMLElementConfigContentModelEnum$1.noSelfDescendants && stackTagNames.includes(tagName$13)) {
                while (currentNode !== root) {
                  if (currentNode[tagName].toUpperCase() === tagName$13) {
                    stack.pop();
                    stackTagNames.pop();
                    currentNode = stack[stack.length - 1] || root;
                    break;
                  }
                  stack.pop();
                  stackTagNames.pop();
                  currentNode = stack[stack.length - 1] || root;
                }
              }
              const namespaceURI$1 = tagName$13 === "SVG" ? NamespaceURI.svg : currentNode[namespaceURI] || NamespaceURI.html;
              const newElement = document2.createElementNS(namespaceURI$1, localName2);
              currentNode.appendChild(newElement);
              currentNode = newElement;
              stack.push(currentNode);
              stackTagNames.push(tagName$13);
              readState = MarkupReadStateEnum.insideStartTag;
              startTagIndex = markupRegexp.lastIndex;
            } else if (match2[2]) {
              if (match2[2].toUpperCase() === ((_a2 = currentNode[tagName]) == null ? void 0 : _a2.toUpperCase())) {
                stack.pop();
                stackTagNames.pop();
                currentNode = stack[stack.length - 1] || root;
              }
            } else if (match2[3] || match2[4] || match2[6] && currentNode[namespaceURI] === NamespaceURI.html) {
              let comment2;
              if (match2[3]) {
                comment2 = match2[3];
              } else if (match2[4]) {
                comment2 = match2[4].endsWith("--") ? match2[4].slice(0, -2) : match2[4];
              } else {
                comment2 = "?" + match2[6];
              }
              currentNode.appendChild(document2.createComment(decodeHTML(comment2)));
            } else if (match2[5] !== void 0) {
              const exclamationComment = decodeHTML(match2[5]);
              currentNode.appendChild(this.getDocumentTypeNode(document2, exclamationComment) || document2.createComment(exclamationComment));
            } else if (match2[6]) ;
            else {
              currentNode.appendChild(document2.createTextNode(decodeHTML(xml.substring(lastIndex, markupRegexp.lastIndex))));
            }
            break;
          case MarkupReadStateEnum.insideStartTag:
            if (match2[7] || match2[8]) {
              const attributeString = xml.substring(startTagIndex, match2.index);
              let hasAttributeStringEnded = true;
              if (!!attributeString) {
                const attributeRegexp = new RegExp(ATTRIBUTE_REGEXP, "gm");
                let attributeMatch;
                while (attributeMatch = attributeRegexp.exec(attributeString)) {
                  if (attributeMatch[1] && attributeMatch[2] || attributeMatch[3] && attributeMatch[5] === '"' || attributeMatch[6] && attributeMatch[8] === "'" || attributeMatch[9]) {
                    const name2 = attributeMatch[1] || attributeMatch[3] || attributeMatch[6] || attributeMatch[9] || "";
                    const rawValue = attributeMatch[2] || attributeMatch[4] || attributeMatch[7] || "";
                    const value2 = rawValue ? decodeHTMLAttribute(rawValue) : "";
                    const namespaceURI$1 = currentNode[namespaceURI] === NamespaceURI.svg && name2 === "xmlns" ? NamespaceURI.xmlns : null;
                    currentNode.setAttributeNS(namespaceURI$1, name2, value2);
                    startTagIndex += attributeMatch[0].length;
                  } else if (!attributeMatch[1] && (attributeMatch[3] && !attributeMatch[5] || attributeMatch[6] && !attributeMatch[8])) {
                    hasAttributeStringEnded = false;
                    break;
                  }
                }
              }
              if (hasAttributeStringEnded) {
                const config = HTMLElementConfig[currentNode[localName]];
                if ((config == null ? void 0 : config.contentModel) === HTMLElementConfigContentModelEnum$1.noDescendants || // SVG tag is self closing (<svg/>).
                match2[7] && currentNode[namespaceURI] === NamespaceURI.svg) {
                  stack.pop();
                  stackTagNames.pop();
                  currentNode = stack[stack.length - 1] || root;
                  readState = MarkupReadStateEnum.startOrEndTag;
                } else {
                  readState = (config == null ? void 0 : config.contentModel) === HTMLElementConfigContentModelEnum$1.rawText ? MarkupReadStateEnum.plainTextContent : MarkupReadStateEnum.startOrEndTag;
                }
                startTagIndex = markupRegexp.lastIndex;
              }
            }
            break;
          case MarkupReadStateEnum.plainTextContent:
            const tagName$12 = currentNode[tagName];
            if (tagName$12 && match2[2] && match2[2].toUpperCase() === tagName$12) {
              if (tagName$12 === "SCRIPT") {
                currentNode[evaluateScript] = evaluateScripts;
              } else if (tagName$12 === "LINK") {
                currentNode[evaluateCSS] = evaluateScripts;
              }
              currentNode.appendChild(document2.createTextNode(decodeHTML(xml.substring(startTagIndex, match2.index))));
              stack.pop();
              stackTagNames.pop();
              currentNode = stack[stack.length - 1] || root;
              readState = MarkupReadStateEnum.startOrEndTag;
            }
            break;
        }
        lastIndex = markupRegexp.lastIndex;
      }
      if (lastIndex !== xml.length) {
        currentNode.appendChild(document2.createTextNode(decodeHTML(xml.substring(lastIndex))));
      }
    }
    return root;
  }
  /**
   * Returns document type node.
   *
   * @param document Document.
   * @param value Value.
   * @returns Document type node.
   */
  static getDocumentTypeNode(document2, value2) {
    if (!value2.toUpperCase().startsWith("DOCTYPE")) {
      return null;
    }
    const docTypeSplit = value2.split(" ");
    if (docTypeSplit.length <= 1) {
      return null;
    }
    const docTypeString = docTypeSplit.slice(1).join(" ");
    const attributes2 = [];
    const attributeRegExp = new RegExp(DOCUMENT_TYPE_ATTRIBUTE_REGEXP, "gm");
    const isPublic = docTypeString.toUpperCase().includes("PUBLIC");
    let attributeMatch;
    while (attributeMatch = attributeRegExp.exec(docTypeString)) {
      attributes2.push(attributeMatch[1]);
    }
    const publicId2 = isPublic ? attributes2[0] || "" : "";
    const systemId2 = isPublic ? attributes2[1] || "" : attributes2[0] || "";
    return document2.implementation.createDocumentType(docTypeSplit[1].toLowerCase(), publicId2, systemId2);
  }
}
class XMLSerializer {
  /**
   * Constructor.
   *
   * @param [options] Options.
   * @param [options.includeShadowRoots] Include shadow roots.
   * @param [options.escapeEntities] Escape text.
   */
  constructor(options2) {
    this.options = {
      includeShadowRoots: false,
      escapeEntities: true
    };
    if (options2) {
      if (options2.includeShadowRoots !== void 0) {
        this.options.includeShadowRoots = options2.includeShadowRoots;
      }
      if (options2.escapeEntities !== void 0) {
        this.options.escapeEntities = options2.escapeEntities;
      }
    }
  }
  /**
   * Renders an element as HTML.
   *
   * @param root Root element.
   * @returns Result.
   */
  serializeToString(root) {
    switch (root[nodeType]) {
      case NodeTypeEnum$1.elementNode:
        const element = root;
        const localName$1 = element[localName];
        const config = HTMLElementConfig[element[localName]];
        if ((config == null ? void 0 : config.contentModel) === HTMLElementConfigContentModelEnum$1.noDescendants) {
          return `<${localName$1}${this.getAttributes(element)}>`;
        }
        const childNodes$1 = localName$1 === "template" ? root.content[childNodes] : root[childNodes];
        let innerHTML = "";
        for (const node2 of childNodes$1) {
          innerHTML += this.serializeToString(node2);
        }
        if (this.options.includeShadowRoots && element.shadowRoot) {
          innerHTML += `<template shadowrootmode="${element.shadowRoot[mode]}">`;
          for (const node2 of element.shadowRoot[childNodes]) {
            innerHTML += this.serializeToString(node2);
          }
          innerHTML += "</template>";
        }
        return `<${localName$1}${this.getAttributes(element)}>${innerHTML}</${localName$1}>`;
      case Node2.DOCUMENT_FRAGMENT_NODE:
      case Node2.DOCUMENT_NODE:
        let html = "";
        for (const node2 of root[childNodes]) {
          html += this.serializeToString(node2);
        }
        return html;
      case NodeTypeEnum$1.commentNode:
        return `<!--${root.textContent}-->`;
      case NodeTypeEnum$1.processingInstructionNode:
        return `<!--?${root.target} ${root.textContent}?-->`;
      case NodeTypeEnum$1.textNode:
        return this.options.escapeEntities ? escapeText(root.textContent) : root.textContent;
      case NodeTypeEnum$1.documentTypeNode:
        const doctype = root;
        const identifier = doctype.publicId ? " PUBLIC" : doctype.systemId ? " SYSTEM" : "";
        const publicId2 = doctype.publicId ? ` "${doctype.publicId}"` : "";
        const systemId2 = doctype.systemId ? ` "${doctype.systemId}"` : "";
        return `<!DOCTYPE ${doctype.name}${identifier}${publicId2}${systemId2}>`;
    }
    return "";
  }
  /**
   * Returns attributes as a string.
   *
   * @param element Element.
   * @returns Attributes.
   */
  getAttributes(element) {
    let attributeString = "";
    if (!element[attributes].getNamedItem("is") && element[isValue]) {
      attributeString += ' is="' + element[isValue] + '"';
    }
    for (let i = 0, max2 = element[attributes].length; i < max2; i++) {
      const attribute = element[attributes][i];
      if (attribute[value] !== null) {
        const escapedValue = this.options.escapeEntities ? escapeText(attribute[value]) : attribute[value];
        attributeString += " " + attribute[name] + '="' + escapedValue + '"';
      }
    }
    return attributeString;
  }
}
class ChildNodeUtility {
  /**
   * Removes the node from its parent.
   *
   * @param childNode Child node.
   */
  static remove(childNode) {
    if (childNode[parentNode]) {
      childNode[parentNode].removeChild(childNode);
    }
  }
  /**
   * The Node.replaceWith() method replaces this Node in the children list of its parent with a set of Node or DOMString objects.
   *
   * @param childNode Child node.
   * @param nodes List of Node or DOMString.
   */
  static replaceWith(childNode, ...nodes) {
    const parent = childNode[parentNode];
    if (!parent) {
      throw new DOMException("This element has no parent node.");
    }
    for (const node2 of nodes) {
      if (typeof node2 === "string") {
        const newChildNodes = XMLParser.parse(childNode[ownerDocument], node2)[childNodes].slice();
        for (const newChildNode of newChildNodes) {
          parent.insertBefore(newChildNode, childNode);
        }
      } else {
        parent.insertBefore(node2, childNode);
      }
    }
    parent.removeChild(childNode);
  }
  /**
   * Inserts a set of Node or DOMString objects in the children list of this ChildNode's parent, just before this ChildNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param childNode Child node.
   * @param nodes List of Node or DOMString.
   */
  static before(childNode, ...nodes) {
    const parent = childNode[parentNode];
    if (!parent) {
      return;
    }
    for (const node2 of nodes) {
      if (typeof node2 === "string") {
        const newChildNodes = XMLParser.parse(childNode[ownerDocument], node2)[childNodes].slice();
        for (const newChildNode of newChildNodes) {
          parent.insertBefore(newChildNode, childNode);
        }
      } else {
        parent.insertBefore(node2, childNode);
      }
    }
  }
  /**
   * Inserts a set of Node or DOMString objects in the children list of this ChildNode's parent, just after this ChildNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param childNode Child node.
   * @param nodes List of Node or DOMString.
   */
  static after(childNode, ...nodes) {
    const parent = childNode[parentNode];
    if (!parent) {
      return;
    }
    const nextSibling = childNode.nextSibling;
    for (const node2 of nodes) {
      if (typeof node2 === "string") {
        const newChildNodes = XMLParser.parse(childNode[ownerDocument], node2)[childNodes].slice();
        for (const newChildNode of newChildNodes) {
          if (!nextSibling) {
            parent.appendChild(newChildNode);
          } else {
            parent.insertBefore(newChildNode, nextSibling);
          }
        }
      } else if (!nextSibling) {
        parent.appendChild(node2);
      } else {
        parent.insertBefore(node2, nextSibling);
      }
    }
  }
}
var _a$C;
class HTMLCollection extends Array {
  constructor() {
    super(...arguments);
    this[_a$C] = {};
  }
  /**
   * Returns item by index.
   *
   * @param index Index.
   */
  item(index) {
    return index >= 0 && this[index] ? this[index] : null;
  }
  /**
   * Returns named item.
   *
   * @param name Name.
   * @returns Node.
   */
  namedItem(name2) {
    return this[namedItems][name2] && this[namedItems][name2].length ? this[namedItems][name2][0] : null;
  }
  /**
   * Appends named item.
   *
   * @param node Node.
   * @param name Name.
   */
  [(_a$C = namedItems, appendNamedItem)](node2, name2) {
    if (name2) {
      this[namedItems][name2] = this[namedItems][name2] || [];
      if (!this[namedItems][name2].includes(node2)) {
        this[namedItems][name2].push(node2);
      }
      if (!this.hasOwnProperty(name2) && this[isValidPropertyName](name2)) {
        this[name2] = this[namedItems][name2][0];
      }
    }
  }
  /**
   * Appends named item.
   *
   * @param node Node.
   * @param name Name.
   */
  [removeNamedItem](node2, name2) {
    if (name2 && this[namedItems][name2]) {
      const index = this[namedItems][name2].indexOf(node2);
      if (index > -1) {
        this[namedItems][name2].splice(index, 1);
        if (this[namedItems][name2].length === 0) {
          delete this[namedItems][name2];
          if (this.hasOwnProperty(name2) && this[isValidPropertyName](name2)) {
            delete this[name2];
          }
        } else if (this[isValidPropertyName](name2)) {
          this[name2] = this[namedItems][name2][0];
        }
      }
    }
  }
  /**
   * Returns "true" if the property name is valid.
   *
   * @param name Name.
   * @returns True if the property name is valid.
   */
  [isValidPropertyName](name2) {
    return !!name2 && !this.constructor.prototype.hasOwnProperty(name2) && !Array.prototype.hasOwnProperty(name2) && (isNaN(Number(name2)) || name2.includes("."));
  }
}
class ParentNodeUtility {
  /**
   * Inserts a set of Node objects or DOMString objects after the last child of the ParentNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param parentNode Parent node.
   * @param nodes List of Node or DOMString.
   */
  static append(parentNode2, ...nodes) {
    for (const node2 of nodes) {
      if (typeof node2 === "string") {
        XMLParser.parse(parentNode2[ownerDocument], node2, {
          rootNode: parentNode2
        });
      } else {
        parentNode2.appendChild(node2);
      }
    }
  }
  /**
   * Inserts a set of Node objects or DOMString objects before the first child of the ParentNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param parentNode Parent node.
   * @param nodes List of Node or DOMString.
   */
  static prepend(parentNode2, ...nodes) {
    const firstChild = parentNode2.firstChild;
    for (const node2 of nodes) {
      if (typeof node2 === "string") {
        const newChildNodes = XMLParser.parse(parentNode2[ownerDocument], node2)[childNodes].slice();
        for (const newChildNode of newChildNodes) {
          parentNode2.insertBefore(newChildNode, firstChild);
        }
      } else {
        parentNode2.insertBefore(node2, firstChild);
      }
    }
  }
  /**
   * Replaces the existing children of a ParentNode with a specified new set of children.
   *
   * @param parentNode Parent node.
   * @param nodes List of Node or DOMString.
   */
  static replaceChildren(parentNode2, ...nodes) {
    for (const node2 of parentNode2[childNodes].slice()) {
      parentNode2.removeChild(node2);
    }
    this.append(parentNode2, ...nodes);
  }
  /**
   * Returns an elements by class name.
   *
   * @param parentNode Parent node.
   * @param className Tag name.
   * @returns Matching element.
   */
  static getElementsByClassName(parentNode2, className) {
    let matches = new HTMLCollection();
    for (const child of parentNode2[children]) {
      if (child.className.split(" ").includes(className)) {
        matches.push(child);
      }
      matches = matches.concat(this.getElementsByClassName(child, className));
    }
    return matches;
  }
  /**
   * Returns an elements by tag name.
   *
   * @param parentNode Parent node.
   * @param tagName Tag name.
   * @returns Matching element.
   */
  static getElementsByTagName(parentNode2, tagName$12) {
    const upperTagName = tagName$12.toUpperCase();
    const includeAll = tagName$12 === "*";
    let matches = new HTMLCollection();
    for (const child of parentNode2[children]) {
      if (includeAll || child[tagName].toUpperCase() === upperTagName) {
        matches.push(child);
      }
      matches = matches.concat(this.getElementsByTagName(child, tagName$12));
    }
    return matches;
  }
  /**
   * Returns an elements by tag name and namespace.
   *
   * @param parentNode Parent node.
   * @param namespaceURI Namespace URI.
   * @param tagName Tag name.
   * @returns Matching element.
   */
  static getElementsByTagNameNS(parentNode2, namespaceURI$1, tagName$12) {
    const formattedTagName = namespaceURI$1 === NamespaceURI.html ? tagName$12.toUpperCase() : tagName$12;
    const includeAll = tagName$12 === "*";
    let matches = new HTMLCollection();
    for (const child of parentNode2[children]) {
      if ((includeAll || child[tagName] === formattedTagName) && child[namespaceURI] === namespaceURI$1) {
        matches.push(child);
      }
      matches = matches.concat(this.getElementsByTagNameNS(child, namespaceURI$1, tagName$12));
    }
    return matches;
  }
  /**
   * Returns the first element matching a tag name.
   * This is not part of the browser standard and is only used internally in the document.
   *
   * @param parentNode Parent node.
   * @param tagName Tag name.
   * @returns Matching element.
   */
  static getElementByTagName(parentNode2, tagName$12) {
    const upperTagName = tagName$12.toUpperCase();
    for (const child of parentNode2[children]) {
      if (child[tagName] === upperTagName) {
        return child;
      }
      const match2 = this.getElementByTagName(child, tagName$12);
      if (match2) {
        return match2;
      }
    }
    return null;
  }
  /**
   * Returns an element by ID.
   *
   * @param parentNode Parent node.
   * @param id ID.
   * @returns Matching element.
   */
  static getElementById(parentNode2, id) {
    id = String(id);
    for (const child of parentNode2[children]) {
      if (child.id === id) {
        return child;
      }
      const match2 = this.getElementById(child, id);
      if (match2) {
        return match2;
      }
    }
    return null;
  }
}
class NonDocumentChildNodeUtility {
  /**
   * Previous element sibling.
   *
   * @param childNode Child node.
   * @returns Element.
   */
  static previousElementSibling(childNode) {
    let sibling = childNode.previousSibling;
    while (sibling && sibling[nodeType] !== NodeTypeEnum$1.elementNode) {
      sibling = sibling.previousSibling;
    }
    return sibling;
  }
  /**
   * Next element sibling.
   *
   * @param childNode Child node.
   * @returns Element.
   */
  static nextElementSibling(childNode) {
    let sibling = childNode.nextSibling;
    while (sibling && sibling[nodeType] !== NodeTypeEnum$1.elementNode) {
      sibling = sibling.nextSibling;
    }
    return sibling;
  }
}
class DOMRectList extends Array {
  /**
   * Returns item by index.
   *
   * @param index Index.
   */
  item(index) {
    return this[index] ?? null;
  }
}
const NAMED_ITEM_ATTRIBUTES = ["id", "name"];
class ElementUtility {
  /**
   * Handles appending a child element to the "children" property.
   *
   * @param ancestorNode Ancestor node.
   * @param node Node to append.
   * @param [options] Options.
   * @param [options.disableAncestorValidation] Disables validation for checking if the node is an ancestor of the ancestorNode.
   * @returns Appended node.
   */
  static appendChild(ancestorNode, node2, options2) {
    if (node2[nodeType] === NodeTypeEnum$1.elementNode && node2 !== ancestorNode) {
      if (!(options2 == null ? void 0 : options2.disableAncestorValidation) && NodeUtility.isInclusiveAncestor(node2, ancestorNode)) {
        throw new DOMException("Failed to execute 'appendChild' on 'Node': The new node is a parent of the node to insert to.", DOMExceptionNameEnum$1.domException);
      }
      if (node2[parentNode]) {
        const parentNodeChildren = node2[parentNode][children];
        if (parentNodeChildren) {
          const index = parentNodeChildren.indexOf(node2);
          if (index !== -1) {
            for (const attributeName of NAMED_ITEM_ATTRIBUTES) {
              const attribute = node2[attributes].getNamedItem(attributeName);
              if (attribute) {
                parentNodeChildren[removeNamedItem](node2, attribute[value]);
              }
            }
            parentNodeChildren.splice(index, 1);
          }
        }
      }
      const ancestorNodeChildren = ancestorNode[children];
      for (const attributeName of NAMED_ITEM_ATTRIBUTES) {
        const attribute = node2[attributes].getNamedItem(attributeName);
        if (attribute) {
          ancestorNodeChildren[appendNamedItem](node2, attribute[value]);
        }
      }
      ancestorNodeChildren.push(node2);
      NodeUtility.appendChild(ancestorNode, node2, { disableAncestorValidation: true });
    } else {
      NodeUtility.appendChild(ancestorNode, node2, options2);
    }
    return node2;
  }
  /**
   * Handles removing a child element from the "children" property.
   *
   * @param ancestorNode Ancestor node.
   * @param node Node.
   * @returns Removed node.
   */
  static removeChild(ancestorNode, node2) {
    if (node2[nodeType] === NodeTypeEnum$1.elementNode) {
      const ancestorNodeChildren = ancestorNode[children];
      const index = ancestorNodeChildren.indexOf(node2);
      if (index !== -1) {
        for (const attributeName of NAMED_ITEM_ATTRIBUTES) {
          const attribute = node2[attributes].getNamedItem(attributeName);
          if (attribute) {
            ancestorNodeChildren[removeNamedItem](node2, attribute[value]);
          }
        }
        ancestorNodeChildren.splice(index, 1);
      }
    }
    NodeUtility.removeChild(ancestorNode, node2);
    return node2;
  }
  /**
   *
   * Handles inserting a child element to the "children" property.
   *
   * @param ancestorNode Ancestor node.
   * @param newNode Node to insert.
   * @param referenceNode Node to insert before.
   * @param [options] Options.
   * @param [options.disableAncestorValidation] Disables validation for checking if the node is an ancestor of the ancestorNode.
   * @returns Inserted node.
   */
  static insertBefore(ancestorNode, newNode, referenceNode, options2) {
    if (newNode === referenceNode) {
      return newNode;
    }
    if (newNode[nodeType] === NodeTypeEnum$1.elementNode && referenceNode) {
      if (!(options2 == null ? void 0 : options2.disableAncestorValidation) && NodeUtility.isInclusiveAncestor(newNode, ancestorNode)) {
        throw new DOMException("Failed to execute 'insertBefore' on 'Node': The new node is a parent of the node to insert to.", DOMExceptionNameEnum$1.domException);
      }
      if (newNode[parentNode]) {
        const parentNodeChildren = newNode[parentNode][children];
        if (parentNodeChildren) {
          const index = parentNodeChildren.indexOf(newNode);
          if (index !== -1) {
            for (const attributeName of NAMED_ITEM_ATTRIBUTES) {
              const attribute = newNode[attributes].getNamedItem(attributeName);
              if (attribute) {
                parentNodeChildren[removeNamedItem](newNode, attribute[value]);
              }
            }
            parentNodeChildren.splice(index, 1);
          }
        }
        const parentChildNodes = ancestorNode[childNodes];
        if (parentChildNodes) {
          const index = parentChildNodes.indexOf(newNode);
          if (index !== -1) {
            parentChildNodes.splice(index, 1);
          }
        }
      }
      const ancestorNodeChildren = ancestorNode[children];
      if (referenceNode[nodeType] === NodeTypeEnum$1.elementNode) {
        const index = ancestorNodeChildren.indexOf(referenceNode);
        if (index !== -1) {
          ancestorNodeChildren.splice(index, 0, newNode);
        }
      } else {
        ancestorNodeChildren.length = 0;
        for (const node2 of ancestorNode[childNodes]) {
          if (node2 === referenceNode) {
            ancestorNodeChildren.push(newNode);
          }
          if (node2[nodeType] === NodeTypeEnum$1.elementNode) {
            ancestorNodeChildren.push(node2);
          }
        }
      }
      for (const attributeName of NAMED_ITEM_ATTRIBUTES) {
        const attribute = newNode[attributes].getNamedItem(attributeName);
        if (attribute) {
          ancestorNodeChildren[appendNamedItem](newNode, attribute[value]);
        }
      }
      NodeUtility.insertBefore(ancestorNode, newNode, referenceNode, {
        disableAncestorValidation: true
      });
    } else {
      NodeUtility.insertBefore(ancestorNode, newNode, referenceNode, options2);
    }
    return newNode;
  }
}
var _a$B;
class NamedNodeMap {
  constructor() {
    this.length = 0;
    this[_a$B] = {};
  }
  /**
   * Returns string.
   *
   * @returns string.
   */
  get [(_a$B = namedItems, Symbol.toStringTag)]() {
    return "NamedNodeMap";
  }
  /**
   * Iterator.
   *
   * @returns Iterator.
   */
  *[Symbol.iterator]() {
    for (let i = 0, max2 = this.length; i < max2; i++) {
      yield this[i];
    }
  }
  /**
   * Returns item by index.
   *
   * @param index Index.
   */
  item(index) {
    return index >= 0 && this[index] ? this[index] : null;
  }
  /**
   * Returns named item.
   *
   * @param name Name.
   * @returns Item.
   */
  getNamedItem(name2) {
    return this[namedItems][name2] || null;
  }
  /**
   * Returns item by name and namespace.
   *
   * @param namespace Namespace.
   * @param localName Local name of the attribute.
   * @returns Item.
   */
  getNamedItemNS(namespace, localName2) {
    const attribute = this.getNamedItem(localName2);
    if (attribute && attribute[namespaceURI] === namespace && attribute.localName === localName2) {
      return attribute;
    }
    for (let i = 0, max2 = this.length; i < max2; i++) {
      if (this[i][namespaceURI] === namespace && this[i].localName === localName2) {
        return this[i];
      }
    }
    return null;
  }
  /**
   * Sets named item.
   *
   * @param item Item.
   * @returns Replaced item.
   */
  setNamedItem(item2) {
    return this[setNamedItemWithoutConsequences](item2);
  }
  /**
   * Adds a new namespaced item.
   *
   * @alias setNamedItem()
   * @param item Item.
   * @returns Replaced item.
   */
  setNamedItemNS(item2) {
    return this.setNamedItem(item2);
  }
  /**
   * Removes an item.
   *
   * @throws DOMException
   * @param name Name of item.
   * @returns Removed item.
   */
  removeNamedItem(name2) {
    const item2 = this[removeNamedItem](name2);
    if (!item2) {
      throw new DOMException(`Failed to execute 'removeNamedItem' on 'NamedNodeMap': No item with name '${name2}' was found.`, DOMExceptionNameEnum$1.notFoundError);
    }
    return item2;
  }
  /**
   * Removes a namespaced item.
   *
   * @param namespace Namespace.
   * @param localName Local name of the item.
   * @returns Removed item.
   */
  removeNamedItemNS(namespace, localName2) {
    const attribute = this.getNamedItemNS(namespace, localName2);
    if (attribute) {
      return this.removeNamedItem(attribute[name]);
    }
    return null;
  }
  /**
   * Sets named item without calling listeners for certain attributes.
   *
   * @param item Item.
   * @returns Replaced item.
   */
  [setNamedItemWithoutConsequences](item2) {
    if (item2[name]) {
      const replacedItem = this[namedItems][item2[name]] || null;
      this[namedItems][item2[name]] = item2;
      if (replacedItem) {
        this[removeNamedItemIndex](replacedItem);
      }
      this[this.length] = item2;
      this.length++;
      if (this[isValidPropertyName](item2[name])) {
        this[item2[name]] = item2;
      }
      return replacedItem;
    }
    return null;
  }
  /**
   * Removes an item without throwing if it doesn't exist.
   *
   * @param name Name of item.
   * @returns Removed item, or null if it didn't exist.
   */
  [removeNamedItem](name2) {
    return this[removeNamedItemWithoutConsequences](name2);
  }
  /**
   * Removes an item without calling listeners for certain attributes.
   *
   * @param name Name of item.
   * @returns Removed item, or null if it didn't exist.
   */
  [removeNamedItemWithoutConsequences](name2) {
    const removedItem = this[namedItems][name2] || null;
    if (!removedItem) {
      return null;
    }
    this[removeNamedItemIndex](removedItem);
    if (this[name2] === removedItem) {
      delete this[name2];
    }
    delete this[namedItems][name2];
    return removedItem;
  }
  /**
   * Removes an item from index.
   *
   * @param item Item.
   */
  [removeNamedItemIndex](item2) {
    for (let i = 0; i < this.length; i++) {
      if (this[i] === item2) {
        for (let b = i; b < this.length; b++) {
          if (b < this.length - 1) {
            this[b] = this[b + 1];
          } else {
            delete this[b];
          }
        }
        this.length--;
        break;
      }
    }
  }
  /**
   * Returns "true" if the property name is valid.
   *
   * @param name Name.
   * @returns True if the property name is valid.
   */
  [isValidPropertyName](name2) {
    return !!name2 && !this.constructor.prototype.hasOwnProperty(name2) && (isNaN(Number(name2)) || name2.includes("."));
  }
}
class ElementNamedNodeMap extends NamedNodeMap {
  /**
   * Constructor.
   *
   * @param ownerElement Owner element.
   */
  constructor(ownerElement$1) {
    super();
    this[ownerElement] = ownerElement$1;
  }
  /**
   * @override
   */
  getNamedItem(name2) {
    return this[namedItems][this[getAttributeName](name2)] || null;
  }
  /**
   * @override
   */
  getNamedItemNS(namespace, localName2) {
    return super.getNamedItemNS(namespace, this[getAttributeName](localName2));
  }
  /**
   * @override
   */
  setNamedItem(item2) {
    var _a2;
    if (!item2[name]) {
      return null;
    }
    item2[name] = this[getAttributeName](item2[name]);
    item2[ownerElement] = this[ownerElement];
    const replacedItem = super.setNamedItem(item2);
    const oldValue = replacedItem ? replacedItem[value] : null;
    if (this[ownerElement][isConnected]) {
      this[ownerElement].ownerDocument[cacheID]++;
    }
    if (item2[name] === "class" && this[ownerElement][classList]) {
      this[ownerElement][classList][updateIndices]();
    }
    if (item2[name] === "id" || item2[name] === "name") {
      if (this[ownerElement][parentNode] && this[ownerElement][parentNode][children] && item2[value] !== oldValue) {
        if (oldValue) {
          this[ownerElement][parentNode][children][removeNamedItem](this[ownerElement], oldValue);
        }
        if (item2[value]) {
          this[ownerElement][parentNode][children][appendNamedItem](this[ownerElement], item2[value]);
        }
      }
    }
    if (this[ownerElement].attributeChangedCallback && this[ownerElement].constructor[observedAttributes] && this[ownerElement].constructor[observedAttributes].includes(item2[name])) {
      this[ownerElement].attributeChangedCallback(item2[name], oldValue, item2[value]);
    }
    if (this[ownerElement][observers].length > 0) {
      for (const observer of this[ownerElement][observers]) {
        if (((_a2 = observer.options) == null ? void 0 : _a2.attributes) && (!observer.options.attributeFilter || observer.options.attributeFilter.includes(item2[name]))) {
          observer.report(new MutationRecord({
            target: this[ownerElement],
            type: MutationTypeEnum$1.attributes,
            attributeName: item2[name],
            oldValue: observer.options.attributeOldValue ? oldValue : null
          }));
        }
      }
    }
    return replacedItem || null;
  }
  /**
   * @override
   */
  [removeNamedItem](name$1) {
    var _a2;
    const removedItem = super[removeNamedItem](this[getAttributeName](name$1));
    if (!removedItem) {
      return null;
    }
    if (this[ownerElement][isConnected]) {
      this[ownerElement].ownerDocument[cacheID]++;
    }
    if (removedItem[name] === "class" && this[ownerElement][classList]) {
      this[ownerElement][classList][updateIndices]();
    }
    if (removedItem[name] === "id" || removedItem[name] === "name") {
      if (this[ownerElement][parentNode] && this[ownerElement][parentNode][children] && removedItem[value]) {
        this[ownerElement][parentNode][children][removeNamedItem](this[ownerElement], removedItem[value]);
      }
    }
    if (this[ownerElement].attributeChangedCallback && this[ownerElement].constructor[observedAttributes] && this[ownerElement].constructor[observedAttributes].includes(removedItem[name])) {
      this[ownerElement].attributeChangedCallback(removedItem[name], removedItem[value], null);
    }
    if (this[ownerElement][observers].length > 0) {
      for (const observer of this[ownerElement][observers]) {
        if (((_a2 = observer.options) == null ? void 0 : _a2.attributes) && (!observer.options.attributeFilter || observer.options.attributeFilter.includes(removedItem[name]))) {
          observer.report(new MutationRecord({
            target: this[ownerElement],
            type: MutationTypeEnum$1.attributes,
            attributeName: removedItem[name],
            oldValue: observer.options.attributeOldValue ? removedItem[value] : null
          }));
        }
      }
    }
    return removedItem;
  }
  /**
   * @override
   */
  removeNamedItemNS(namespace, localName2) {
    return super.removeNamedItemNS(namespace, this[getAttributeName](localName2));
  }
  /**
   * Returns attribute name.
   *
   * @param name Name.
   * @returns Attribute name based on namespace.
   */
  [getAttributeName](name2) {
    if (this[ownerElement][namespaceURI] === NamespaceURI.svg) {
      return name2;
    }
    return name2.toLowerCase();
  }
}
var _a$A, _b$l, _c$h, _d$b, _e$a, _f$8, _g$5, _h$4, _j$4, _k$3, _l$3, _m$3, _o$3, _p$2, _q$2, _r$1, _s$1, _t$1;
let Element$1 = class Element2 extends Node2 {
  constructor() {
    super(...arguments);
    this.oncancel = null;
    this.onerror = null;
    this.onscroll = null;
    this.onselect = null;
    this.onwheel = null;
    this.oncopy = null;
    this.oncut = null;
    this.onpaste = null;
    this.oncompositionend = null;
    this.oncompositionstart = null;
    this.oncompositionupdate = null;
    this.onblur = null;
    this.onfocus = null;
    this.onfocusin = null;
    this.onfocusout = null;
    this.onfullscreenchange = null;
    this.onfullscreenerror = null;
    this.onkeydown = null;
    this.onkeyup = null;
    this.onauxclick = null;
    this.onclick = null;
    this.oncontextmenu = null;
    this.ondblclick = null;
    this.onmousedown = null;
    this.onmouseenter = null;
    this.onmouseleave = null;
    this.onmousemove = null;
    this.onmouseout = null;
    this.onmouseover = null;
    this.onmouseup = null;
    this.ontouchcancel = null;
    this.ontouchend = null;
    this.ontouchmove = null;
    this.ontouchstart = null;
    this[_d$b] = new HTMLCollection();
    this[_e$a] = null;
    this[_f$8] = null;
    this[_g$5] = null;
    this[_h$4] = NodeTypeEnum$1.elementNode;
    this[_j$4] = this.constructor[tagName] || null;
    this[_k$3] = this.constructor[localName] || null;
    this[_l$3] = null;
    this[_m$3] = null;
    this[_o$3] = 0;
    this[_p$2] = 0;
    this[_q$2] = 0;
    this[_r$1] = 0;
    this[_s$1] = new ElementNamedNodeMap(this);
    this[_t$1] = this.constructor[namespaceURI] || null;
  }
  /**
   * Returns tag name.
   *
   * @returns Tag name.
   */
  get tagName() {
    return this[tagName];
  }
  /**
   * Returns prefix.
   *
   * @returns Prefix.
   */
  get prefix() {
    return this[prefix];
  }
  /**
   * Returns shadow root.
   *
   * @returns Shadow root.
   */
  get shadowRoot() {
    const shadowRoot$1 = this[shadowRoot];
    return shadowRoot$1 && shadowRoot$1[mode] === "open" ? shadowRoot$1 : null;
  }
  /**
   * Returns scroll height.
   *
   * @returns Scroll height.
   */
  get scrollHeight() {
    return this[scrollHeight];
  }
  /**
   * Returns scroll width.
   *
   * @returns Scroll width.
   */
  get scrollWidth() {
    return this[scrollWidth];
  }
  /**
   * Returns scroll top.
   *
   * @returns Scroll top.
   */
  get scrollTop() {
    return this[scrollTop];
  }
  /**
   * Sets scroll top.
   *
   * @param value Scroll top.
   */
  set scrollTop(value2) {
    this[scrollTop] = value2;
  }
  /**
   * Returns scroll left.
   *
   * @returns Scroll left.
   */
  get scrollLeft() {
    return this[scrollLeft];
  }
  /**
   * Sets scroll left.
   *
   * @param value Scroll left.
   */
  set scrollLeft(value2) {
    this[scrollLeft] = value2;
  }
  /**
   * Returns attributes.
   *
   * @returns Attributes.
   */
  get attributes() {
    return this[attributes];
  }
  /**
   * Returns namespace URI.
   *
   * @returns Namespace URI.
   */
  get namespaceURI() {
    return this[namespaceURI];
  }
  /**
   * Returns element children.
   */
  get children() {
    return this[children];
  }
  /**
   * Returns class list.
   *
   * @returns Class list.
   */
  get classList() {
    if (!this[classList]) {
      this[classList] = new DOMTokenList(this, "class");
    }
    return this[classList];
  }
  /**
   * Returns ID.
   *
   * @returns ID.
   */
  get id() {
    return this.getAttribute("id") || "";
  }
  /**
   * Sets ID.
   *
   * @param id ID.
   */
  set id(id) {
    this.setAttribute("id", id);
  }
  /**
   * Returns class name.
   *
   * @returns Class name.
   */
  get className() {
    return this.getAttribute("class") || "";
  }
  /**
   * Sets class name.
   *
   * @param className Class name.
   */
  set className(className) {
    this.setAttribute("class", className);
  }
  /**
   * Node name.
   *
   * @returns Node name.
   */
  get nodeName() {
    return this[tagName];
  }
  /**
   * Local name.
   *
   * @returns Local name.
   */
  get localName() {
    return this[localName];
  }
  /**
   * Returns role.
   *
   * @returns Role.
   */
  get role() {
    return this.getAttribute("role") || "";
  }
  /**
   * Sets role.
   *
   * @param role Role.
   */
  set role(role) {
    this.setAttribute("role", role);
  }
  /**
   * Previous element sibling.
   *
   * @returns Element.
   */
  get previousElementSibling() {
    return NonDocumentChildNodeUtility.previousElementSibling(this);
  }
  /**
   * Next element sibling.
   *
   * @returns Element.
   */
  get nextElementSibling() {
    return NonDocumentChildNodeUtility.nextElementSibling(this);
  }
  /**
   * Get text value of children.
   *
   * @returns Text content.
   */
  get textContent() {
    let result = "";
    for (const childNode of this[childNodes]) {
      if (childNode[nodeType] === NodeTypeEnum$1.elementNode || childNode[nodeType] === NodeTypeEnum$1.textNode) {
        result += childNode.textContent;
      }
    }
    return result;
  }
  /**
   * Sets text content.
   *
   * @param textContent Text content.
   */
  set textContent(textContent) {
    for (const child of this[childNodes].slice()) {
      this.removeChild(child);
    }
    if (textContent) {
      this.appendChild(this[ownerDocument].createTextNode(textContent));
    }
  }
  /**
   * Returns inner HTML.
   *
   * @returns HTML.
   */
  get innerHTML() {
    return this.getInnerHTML();
  }
  /**
   * Sets inner HTML.
   *
   * @param html HTML.
   */
  set innerHTML(html) {
    for (const child of this[childNodes].slice()) {
      this.removeChild(child);
    }
    XMLParser.parse(this[ownerDocument], html, { rootNode: this });
  }
  /**
   * Returns outer HTML.
   *
   * @returns HTML.
   */
  get outerHTML() {
    return new XMLSerializer({ escapeEntities: false }).serializeToString(this);
  }
  /**
   * Returns outer HTML.
   *
   * @param html HTML.
   */
  set outerHTML(html) {
    this.replaceWith(html);
  }
  /**
   * First element child.
   *
   * @returns Element.
   */
  get firstElementChild() {
    return this[children][0] ?? null;
  }
  /**
   * Last element child.
   *
   * @returns Element.
   */
  get lastElementChild() {
    return this[children][this[children].length - 1] ?? null;
  }
  /**
   * Last element child.
   *
   * @returns Element.
   */
  get childElementCount() {
    return this[children].length;
  }
  /**
   * Returns slot.
   *
   * @returns Slot.
   */
  get slot() {
    return this.getAttributeNS(null, "slot") || "";
  }
  /**
   * Returns slot.
   *
   * @param slot Slot.
   */
  set slot(title) {
    this.setAttribute("slot", title);
  }
  /**
   * Returns inner HTML and optionally the content of shadow roots.
   *
   * This is a feature implemented in Chromium, but not supported by Mozilla yet.
   *
   * @see https://web.dev/declarative-shadow-dom/
   * @see https://chromestatus.com/feature/5191745052606464
   * @param [options] Options.
   * @param [options.includeShadowRoots] Set to "true" to include shadow roots.
   * @returns HTML.
   */
  getInnerHTML(options2) {
    const xmlSerializer = new XMLSerializer({
      includeShadowRoots: options2 && options2.includeShadowRoots,
      escapeEntities: false
    });
    let xml = "";
    for (const node2 of this[childNodes]) {
      xml += xmlSerializer.serializeToString(node2);
    }
    return xml;
  }
  /**
   * @override
   */
  [(_a$A = tagName, _b$l = localName, _c$h = namespaceURI, _d$b = children, _e$a = classList, _f$8 = isValue, _g$5 = computedStyle, _h$4 = nodeType, _j$4 = tagName, _k$3 = localName, _l$3 = prefix, _m$3 = shadowRoot, _o$3 = scrollHeight, _p$2 = scrollWidth, _q$2 = scrollTop, _r$1 = scrollLeft, _s$1 = attributes, _t$1 = namespaceURI, cloneNode)](deep = false) {
    const clone2 = super[cloneNode](deep);
    clone2[tagName] = this[tagName];
    clone2[localName] = this[localName];
    clone2[namespaceURI] = this[namespaceURI];
    for (let i = 0, max2 = this[attributes].length; i < max2; i++) {
      const attribute = this[attributes][i];
      clone2[attributes].setNamedItem(Object.assign(this[ownerDocument].createAttributeNS(attribute[namespaceURI], attribute[name]), attribute));
    }
    if (deep) {
      for (const node2 of clone2[childNodes]) {
        if (node2[nodeType] === NodeTypeEnum$1.elementNode) {
          clone2[children].push(node2);
        }
      }
    }
    return clone2;
  }
  /**
   * @override
   */
  [appendChild](node2) {
    return ElementUtility.appendChild(this, node2);
  }
  /**
   * @override
   */
  [removeChild](node2) {
    return ElementUtility.removeChild(this, node2);
  }
  /**
   * @override
   */
  [insertBefore](newNode, referenceNode) {
    return ElementUtility.insertBefore(this, newNode, referenceNode);
  }
  /**
   * Removes the node from its parent.
   */
  remove() {
    ChildNodeUtility.remove(this);
  }
  /**
   * The Node.replaceWith() method replaces this Node in the children list of its parent with a set of Node or DOMString objects.
   *
   * @param nodes List of Node or DOMString.
   */
  replaceWith(...nodes) {
    ChildNodeUtility.replaceWith(this, ...nodes);
  }
  /**
   * Inserts a set of Node or DOMString objects in the children list of this ChildNode's parent, just before this ChildNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param nodes List of Node or DOMString.
   */
  before(...nodes) {
    ChildNodeUtility.before(this, ...nodes);
  }
  /**
   * Inserts a set of Node or DOMString objects in the children list of this ChildNode's parent, just after this ChildNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param nodes List of Node or DOMString.
   */
  after(...nodes) {
    ChildNodeUtility.after(this, ...nodes);
  }
  /**
   * Inserts a set of Node objects or DOMString objects after the last child of the ParentNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param nodes List of Node or DOMString.
   */
  append(...nodes) {
    ParentNodeUtility.append(this, ...nodes);
  }
  /**
   * Inserts a set of Node objects or DOMString objects before the first child of the ParentNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param nodes List of Node or DOMString.
   */
  prepend(...nodes) {
    ParentNodeUtility.prepend(this, ...nodes);
  }
  /**
   * Replaces the existing children of a node with a specified new set of children.
   *
   * @param nodes List of Node or DOMString.
   */
  replaceChildren(...nodes) {
    ParentNodeUtility.replaceChildren(this, ...nodes);
  }
  /**
   * Inserts a node to the given position.
   *
   * @param position Position to insert element.
   * @param element Node to insert.
   * @returns Inserted node or null if couldn't insert.
   */
  insertAdjacentElement(position, element) {
    if (position === "beforebegin") {
      if (!this.parentElement) {
        return null;
      }
      this.parentElement.insertBefore(element, this);
    } else if (position === "afterbegin") {
      this.insertBefore(element, this.firstChild);
    } else if (position === "beforeend") {
      this.appendChild(element);
    } else if (position === "afterend") {
      if (!this.parentElement) {
        return null;
      }
      this.parentElement.insertBefore(element, this.nextSibling);
    }
    return element;
  }
  /**
   * Inserts an HTML string to the given position.
   *
   * @param position Position to insert text.
   * @param text HTML string to insert.
   */
  insertAdjacentHTML(position, text2) {
    for (const node2 of XMLParser.parse(this[ownerDocument], text2)[childNodes].slice()) {
      this.insertAdjacentElement(position, node2);
    }
  }
  /**
   * Inserts text to the given position.
   *
   * @param position Position to insert text.
   * @param text String to insert.
   */
  insertAdjacentText(position, text2) {
    if (!text2) {
      return;
    }
    const textNode = this[ownerDocument].createTextNode(text2);
    this.insertAdjacentElement(position, textNode);
  }
  /**
   * Sets an attribute.
   *
   * @param name Name.
   * @param value Value.
   */
  setAttribute(name2, value$1) {
    const attribute = this[ownerDocument].createAttributeNS(null, name2);
    attribute[value] = String(value$1);
    this.setAttributeNode(attribute);
  }
  /**
   * Sets a namespace attribute.
   *
   * @param namespaceURI Namespace URI.
   * @param name Name.
   * @param value Value.
   */
  setAttributeNS(namespaceURI2, name2, value$1) {
    const attribute = this[ownerDocument].createAttributeNS(namespaceURI2, name2);
    attribute[value] = String(value$1);
    this.setAttributeNode(attribute);
  }
  /**
   * Returns attribute names.
   *
   * @returns Attribute names.
   */
  getAttributeNames() {
    const attributeNames = [];
    for (let i = 0, max2 = this[attributes].length; i < max2; i++) {
      attributeNames.push(this[attributes][i][name]);
    }
    return attributeNames;
  }
  /**
   * Returns attribute value.
   *
   * @param name Name.
   */
  getAttribute(name2) {
    const attribute = this.getAttributeNode(name2);
    if (attribute) {
      return attribute[value];
    }
    return null;
  }
  /**
   * Toggle an attribute.
   * Returns `true` if attribute name is eventually present, and `false` otherwise.
   *
   * @param name A DOMString specifying the name of the attribute to be toggled.
   * @param force A boolean value to determine whether the attribute should be added or removed, no matter whether the attribute is present or not at the moment.
   */
  toggleAttribute(name2, force) {
    name2 = name2.toLowerCase();
    const attribute = this.getAttributeNode(name2);
    if (attribute) {
      if (force === true) {
        return true;
      }
      this.removeAttributeNode(attribute);
      return false;
    }
    if (force === false) {
      return false;
    }
    this.setAttribute(name2, "");
    return true;
  }
  /**
   * Returns namespace attribute value.
   *
   * @param namespace Namespace URI.
   * @param localName Local name.
   */
  getAttributeNS(namespace, localName2) {
    const attribute = this.getAttributeNodeNS(namespace, localName2);
    if (attribute) {
      return attribute[value];
    }
    return null;
  }
  /**
   * Returns a boolean value indicating whether the specified element has the attribute or not.
   *
   * @param name Attribute name.
   * @returns True if attribute exists, false otherwise.
   */
  hasAttribute(name2) {
    return !!this.getAttributeNode(name2);
  }
  /**
   * Returns a boolean value indicating whether the specified element has the namespace attribute or not.
   *
   * @param namespace Namespace URI.
   * @param localName Local name.
   * @returns True if attribute exists, false otherwise.
   */
  hasAttributeNS(namespace, localName2) {
    return this[attributes].getNamedItemNS(namespace, localName2) !== null;
  }
  /**
   * Returns "true" if the element has attributes.
   *
   * @returns "true" if the element has attributes.
   */
  hasAttributes() {
    return this[attributes].length > 0;
  }
  /**
   * Removes an attribute.
   *
   * @param name Name.
   */
  removeAttribute(name2) {
    try {
      this[attributes].removeNamedItem(name2);
    } catch (error2) {
    }
  }
  /**
   * Removes a namespace attribute.
   *
   * @param namespace Namespace URI.
   * @param localName Local name.
   */
  removeAttributeNS(namespace, localName2) {
    this[attributes].removeNamedItemNS(namespace, localName2);
  }
  /**
   * Attaches a shadow root.
   *
   * @param init Shadow root init.
   * @param init.mode Shadow root mode.
   * @returns Shadow root.
   */
  attachShadow(init) {
    if (this[shadowRoot]) {
      throw new DOMException("Shadow root has already been attached.");
    }
    const shadowRoot$1 = NodeFactory.createNode(this[ownerDocument], this[ownerDocument][ownerWindow].ShadowRoot);
    this[shadowRoot] = shadowRoot$1;
    shadowRoot$1[host] = this;
    shadowRoot$1[mode] = init.mode;
    shadowRoot$1[connectToNode](this);
    return this[shadowRoot];
  }
  /**
   * Converts to string.
   *
   * @returns String.
   */
  toString() {
    return this.outerHTML;
  }
  /**
   * Returns the size of an element and its position relative to the viewport.
   *
   * @returns DOM rect.
   */
  getBoundingClientRect() {
    return new DOMRect();
  }
  /**
   * Returns a collection of DOMRect objects that indicate the bounding rectangles for each CSS border box in a client.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getClientRects
   * @returns DOM rect list.
   */
  getClientRects() {
    const domRectList = new DOMRectList();
    domRectList.push(this.getBoundingClientRect());
    return domRectList;
  }
  /**
   * The matches() method checks to see if the Element would be selected by the provided selectorString.
   *
   * @param selector Selector.
   * @returns "true" if matching.
   */
  matches(selector) {
    return !!QuerySelector.matches(this, selector);
  }
  /**
   * Traverses the Element and its parents (heading toward the document root) until it finds a node that matches the provided selector string.
   *
   * @param selector Selector.
   * @returns Closest matching element.
   */
  closest(selector) {
    let parent = this;
    while (parent) {
      if (QuerySelector.matches(parent, selector)) {
        return parent;
      }
      parent = parent.parentElement;
    }
    return null;
  }
  /**
   * Query CSS selector to find matching elments.
   *
   * @param selector CSS selector.
   * @returns Matching elements.
   */
  querySelectorAll(selector) {
    return QuerySelector.querySelectorAll(this, selector);
  }
  /**
   * Query CSS Selector to find matching node.
   *
   * @param selector CSS selector.
   * @returns Matching element.
   */
  querySelector(selector) {
    return QuerySelector.querySelector(this, selector);
  }
  /**
   * Returns an elements by class name.
   *
   * @param className Tag name.
   * @returns Matching element.
   */
  getElementsByClassName(className) {
    return ParentNodeUtility.getElementsByClassName(this, className);
  }
  /**
   * Returns an elements by tag name.
   *
   * @param tagName Tag name.
   * @returns Matching element.
   */
  getElementsByTagName(tagName3) {
    return ParentNodeUtility.getElementsByTagName(this, tagName3);
  }
  /**
   * Returns an elements by tag name and namespace.
   *
   * @param namespaceURI Namespace URI.
   * @param tagName Tag name.
   * @returns Matching element.
   */
  getElementsByTagNameNS(namespaceURI2, tagName3) {
    return ParentNodeUtility.getElementsByTagNameNS(this, namespaceURI2, tagName3);
  }
  /**
   * The setAttributeNode() method adds a new Attr node to the specified element.
   *
   * @param attribute Attribute.
   * @returns Replaced attribute.
   */
  setAttributeNode(attribute) {
    return this[attributes].setNamedItem(attribute);
  }
  /**
   * The setAttributeNodeNS() method adds a new Attr node to the specified element.
   *
   * @param attribute Attribute.
   * @returns Replaced attribute.
   */
  setAttributeNodeNS(attribute) {
    return this[attributes].setNamedItemNS(attribute);
  }
  /**
   * Returns an Attr node.
   *
   * @param name Name.
   * @returns Replaced attribute.
   */
  getAttributeNode(name2) {
    return this[attributes].getNamedItem(name2);
  }
  /**
   * Returns a namespaced Attr node.
   *
   * @param namespace Namespace.
   * @param localName Name.
   * @returns Replaced attribute.
   */
  getAttributeNodeNS(namespace, localName2) {
    return this[attributes].getNamedItemNS(namespace, localName2);
  }
  /**
   * Removes an Attr node.
   *
   * @param attribute Attribute.
   * @returns Removed attribute.
   */
  removeAttributeNode(attribute) {
    return this[attributes].removeNamedItem(attribute[name]);
  }
  /**
   * Removes an Attr node.
   *
   * @param attribute Attribute.
   * @returns Removed attribute.
   */
  removeAttributeNodeNS(attribute) {
    return this[attributes].removeNamedItemNS(attribute[namespaceURI], attribute.localName);
  }
  /**
   * Scrolls to a particular set of coordinates.
   *
   * @param x X position or options object.
   * @param y Y position.
   */
  scroll(x2, y2) {
    if (typeof x2 === "object") {
      if (x2.behavior === "smooth") {
        this[ownerDocument][ownerWindow].setTimeout(() => {
          if (x2.top !== void 0) {
            this.scrollTop = x2.top;
          }
          if (x2.left !== void 0) {
            this.scrollLeft = x2.left;
          }
        });
      } else {
        if (x2.top !== void 0) {
          this.scrollTop = x2.top;
        }
        if (x2.left !== void 0) {
          this.scrollLeft = x2.left;
        }
      }
    } else if (x2 !== void 0 && y2 !== void 0) {
      this.scrollLeft = x2;
      this.scrollTop = y2;
    }
  }
  /**
   * Scrolls to a particular set of coordinates.
   *
   * @param x X position or options object.
   * @param y Y position.
   */
  scrollTo(x2, y2) {
    this.scroll(x2, y2);
  }
  /**
   * Scrolls the element's ancestor containers such that the element on which scrollIntoView() is called is visible to the user.
   *
   * @param [_options] Options.
   */
  scrollIntoView(_options) {
  }
  /**
   * @override
   */
  dispatchEvent(event) {
    const returnValue2 = super.dispatchEvent(event);
    const browserSettings = WindowBrowserSettingsReader.getSettings(this[ownerDocument][ownerWindow]);
    if (browserSettings && !browserSettings.disableJavaScriptEvaluation && (event.eventPhase === EventPhaseEnum$1.atTarget || event.eventPhase === EventPhaseEnum$1.bubbling) && !event[immediatePropagationStopped]) {
      const attribute = this.getAttribute("on" + event.type);
      if (attribute && !event[immediatePropagationStopped]) {
        const code2 = `//# sourceURL=${this[ownerDocument][ownerWindow].location.href}
${attribute}`;
        if (browserSettings.disableErrorCapturing || browserSettings.errorCapture !== BrowserErrorCaptureEnum$1.tryAndCatch) {
          this[ownerDocument][ownerWindow].eval(code2);
        } else {
          WindowErrorUtility.captureError(this[ownerDocument][ownerWindow], () => this[ownerDocument][ownerWindow].eval(code2));
        }
      }
    }
    return returnValue2;
  }
};
Element$1[_a$A] = null;
Element$1[_b$l] = null;
Element$1[_c$h] = null;
const NodeFilter = {
  FILTER_ACCEPT: 1,
  FILTER_REJECT: 2,
  FILTER_SKIP: 3,
  SHOW_ALL: -1,
  SHOW_ELEMENT: 1,
  SHOW_ATTRIBUTE: 2,
  SHOW_TEXT: 4,
  SHOW_CDATA_SECTION: 8,
  SHOW_ENTITY_REFERENCE: 16,
  SHOW_ENTITY: 32,
  SHOW_PROCESSING_INSTRUCTION: 64,
  SHOW_COMMENT: 128,
  SHOW_DOCUMENT: 256,
  SHOW_DOCUMENT_TYPE: 512,
  SHOW_DOCUMENT_FRAGMENT: 1024,
  SHOW_NOTATION: 2048
};
const NodeFilterMask = {
  /* ELEMENT_NODE */
  1: NodeFilter.SHOW_ELEMENT,
  /* ATTRIBUTE_NODE */
  2: NodeFilter.SHOW_ATTRIBUTE,
  /* TEXT_NODE */
  3: NodeFilter.SHOW_TEXT,
  /* CDATA_SECTION_NODE */
  4: NodeFilter.SHOW_CDATA_SECTION,
  /* ENTITY_REFERENCE_NODE */
  5: NodeFilter.SHOW_ENTITY_REFERENCE,
  /* ENTITY_NODE */
  6: NodeFilter.SHOW_PROCESSING_INSTRUCTION,
  /* PROCESSING_INSTRUCTION_NODE */
  7: NodeFilter.SHOW_PROCESSING_INSTRUCTION,
  /* COMMENT_NODE */
  8: NodeFilter.SHOW_COMMENT,
  /* DOCUMENT_NODE */
  9: NodeFilter.SHOW_DOCUMENT,
  /* DOCUMENT_TYPE_NODE */
  10: NodeFilter.SHOW_DOCUMENT_TYPE,
  /* DOCUMENT_FRAGMENT_NODE */
  11: NodeFilter.SHOW_DOCUMENT_FRAGMENT,
  /* NOTATION_NODE */
  12: NodeFilter.SHOW_NOTATION
};
class TreeWalker {
  /**
   * Constructor.
   *
   * @param root Root.
   * @param [whatToShow] What to show.
   * @param [filter] Filter.
   */
  constructor(root, whatToShow = -1, filter = null) {
    this.root = null;
    this.whatToShow = -1;
    this.filter = null;
    this.currentNode = null;
    if (!(root instanceof Node2)) {
      throw new DOMException("Parameter 1 was not of type Node.");
    }
    this.root = root;
    this.whatToShow = whatToShow;
    this.filter = filter;
    this.currentNode = root;
  }
  /**
   * Moves the current Node to the next visible node in the document order.
   *
   * @returns Current node.
   */
  nextNode() {
    if (!this.firstChild()) {
      while (!this.nextSibling() && this.parentNode()) {
      }
      this.currentNode = this.currentNode === this.root ? null : this.currentNode || null;
    }
    return this.currentNode;
  }
  /**
   * Moves the current Node to the previous visible node in the document order, and returns the found node. It also moves the current node to this one. If no such node exists, or if it is before that the root node defined at the object construction, returns null and the current node is not changed.
   *
   * @returns Current node.
   */
  previousNode() {
    while (!this.previousSibling() && this.parentNode()) {
    }
    this.currentNode = this.currentNode === this.root ? null : this.currentNode || null;
    return this.currentNode;
  }
  /**
   * Moves the current Node to the first visible ancestor node in the document order, and returns the found node. It also moves the current node to this one. If no such node exists, or if it is before that the root node defined at the object construction, returns null and the current node is not changed.
   *
   * @returns Current node.
   */
  parentNode() {
    if (this.currentNode !== this.root && this.currentNode && this.currentNode[parentNode]) {
      this.currentNode = this.currentNode[parentNode];
      if (this.filterNode(this.currentNode) === NodeFilter.FILTER_ACCEPT) {
        return this.currentNode;
      }
      this.parentNode();
    }
    this.currentNode = null;
    return null;
  }
  /**
   * Moves the current Node to the first visible child of the current node, and returns the found child. It also moves the current node to this child. If no such child exists, returns null and the current node is not changed.
   *
   * @returns Current node.
   */
  firstChild() {
    const childNodes$1 = this.currentNode ? this.currentNode[childNodes] : [];
    if (childNodes$1.length > 0) {
      this.currentNode = childNodes$1[0];
      if (this.filterNode(this.currentNode) === NodeFilter.FILTER_ACCEPT) {
        return this.currentNode;
      }
      return this.nextSibling();
    }
    return null;
  }
  /**
   * Moves the current Node to the last visible child of the current node, and returns the found child. It also moves the current node to this child. If no such child exists, null is returned and the current node is not changed.
   *
   * @returns Current node.
   */
  lastChild() {
    const childNodes$1 = this.currentNode ? this.currentNode[childNodes] : [];
    if (childNodes$1.length > 0) {
      this.currentNode = childNodes$1[childNodes$1.length - 1];
      if (this.filterNode(this.currentNode) === NodeFilter.FILTER_ACCEPT) {
        return this.currentNode;
      }
      return this.previousSibling();
    }
    return null;
  }
  /**
   * Moves the current Node to its previous sibling, if any, and returns the found sibling. If there is no such node, return null and the current node is not changed.
   *
   * @returns Current node.
   */
  previousSibling() {
    if (this.currentNode !== this.root && this.currentNode && this.currentNode[parentNode]) {
      const siblings = this.currentNode[parentNode][childNodes];
      const index = siblings.indexOf(this.currentNode);
      if (index > 0) {
        this.currentNode = siblings[index - 1];
        if (this.filterNode(this.currentNode) === NodeFilter.FILTER_ACCEPT) {
          return this.currentNode;
        }
        return this.previousSibling();
      }
    }
    return null;
  }
  /**
   * Moves the current Node to its next sibling, if any, and returns the found sibling. If there is no such node, null is returned and the current node is not changed.
   *
   * @returns Current node.
   */
  nextSibling() {
    if (this.currentNode !== this.root && this.currentNode && this.currentNode[parentNode]) {
      const siblings = this.currentNode[parentNode][childNodes];
      const index = siblings.indexOf(this.currentNode);
      if (index + 1 < siblings.length) {
        this.currentNode = siblings[index + 1];
        if (this.filterNode(this.currentNode) === NodeFilter.FILTER_ACCEPT) {
          return this.currentNode;
        }
        return this.nextSibling();
      }
    }
    return null;
  }
  /**
   * Filters a node.
   *
   * Based on solution:
   * https://gist.github.com/shawndumas/1132009.
   *
   * @param node Node.
   * @returns Child nodes.
   */
  filterNode(node2) {
    const mask = NodeFilterMask[node2.nodeType];
    if (mask && (this.whatToShow & mask) == 0) {
      return NodeFilter.FILTER_SKIP;
    }
    if (typeof this.filter === "function") {
      return this.filter(node2);
    }
    if (this.filter) {
      return this.filter.acceptNode(node2);
    }
    return NodeFilter.FILTER_ACCEPT;
  }
}
var __classPrivateFieldSet$E = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$H = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _NodeIterator_walker;
class NodeIterator {
  /**
   * Constructor.
   *
   * @param root Root.
   * @param [whatToShow] What to show.
   * @param [filter] Filter.
   */
  constructor(root, whatToShow = -1, filter = null) {
    this.root = null;
    this.whatToShow = -1;
    this.filter = null;
    _NodeIterator_walker.set(this, void 0);
    this.root = root;
    this.whatToShow = whatToShow;
    this.filter = filter;
    __classPrivateFieldSet$E(this, _NodeIterator_walker, new TreeWalker(root, whatToShow, filter), "f");
  }
  /**
   * Moves the current Node to the next visible node in the document order.
   *
   * @returns Current node.
   */
  nextNode() {
    return __classPrivateFieldGet$H(this, _NodeIterator_walker, "f").nextNode();
  }
  /**
   * Moves the current Node to the previous visible node in the document order, and returns the found node. It also moves the current node to this one. If no such node exists, or if it is before that the root node defined at the object construction, returns null and the current node is not changed.
   *
   * @returns Current node.
   */
  previousNode() {
    return __classPrivateFieldGet$H(this, _NodeIterator_walker, "f").previousNode();
  }
}
_NodeIterator_walker = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet$D = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$G = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DOMImplementation_document;
class DOMImplementation {
  /**
   * Constructor.
   *
   * @param window Window.
   */
  constructor(window2) {
    _DOMImplementation_document.set(this, void 0);
    __classPrivateFieldSet$D(this, _DOMImplementation_document, window2, "f");
  }
  /**
   * Creates and returns an XML Document.
   *
   * TODO: Not fully implemented.
   */
  createDocument() {
    return new (__classPrivateFieldGet$G(this, _DOMImplementation_document, "f"))[ownerWindow].HTMLDocument();
  }
  /**
   * Creates and returns an HTML Document.
   */
  createHTMLDocument() {
    return new (__classPrivateFieldGet$G(this, _DOMImplementation_document, "f"))[ownerWindow].HTMLDocument();
  }
  /**
   * Creates and returns an HTML Document.
   *
   * @param qualifiedName Qualified name.
   * @param publicId Public ID.
   * @param systemId System ID.
   */
  createDocumentType(qualifiedName, publicId$1, systemId$1) {
    const documentType = NodeFactory.createNode(__classPrivateFieldGet$G(this, _DOMImplementation_document, "f"), __classPrivateFieldGet$G(this, _DOMImplementation_document, "f")[ownerWindow].DocumentType);
    documentType[name] = qualifiedName;
    documentType[publicId] = publicId$1;
    documentType[systemId] = systemId$1;
    return documentType;
  }
}
_DOMImplementation_document = /* @__PURE__ */ new WeakMap();
var _a$z, _b$k, _c$g, _d$a;
class DocumentType extends Node2 {
  constructor() {
    super(...arguments);
    this[_a$z] = NodeTypeEnum$1.documentTypeNode;
    this[_b$k] = "";
    this[_c$g] = "";
    this[_d$a] = "";
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this[name];
  }
  /**
   * Returns public ID.
   *
   * @returns Public ID.
   */
  get publicId() {
    return this[publicId];
  }
  /**
   * Returns system ID.
   *
   * @returns System ID.
   */
  get systemId() {
    return this[systemId];
  }
  /**
   * Node name.
   *
   * @returns Node name.
   */
  get nodeName() {
    return this.name;
  }
  /**
   * Converts to string.
   *
   * @returns String.
   */
  toString() {
    return "[object DocumentType]";
  }
  /**
   * @override
   */
  [(_a$z = nodeType, _b$k = name, _c$g = publicId, _d$a = systemId, cloneNode)](deep = false) {
    const clone2 = super[cloneNode](deep);
    clone2[name] = this[name];
    clone2[publicId] = this[publicId];
    clone2[systemId] = this[systemId];
    return clone2;
  }
}
var DocumentReadyStateEnum;
(function(DocumentReadyStateEnum2) {
  DocumentReadyStateEnum2["loading"] = "loading";
  DocumentReadyStateEnum2["interactive"] = "interactive";
  DocumentReadyStateEnum2["complete"] = "complete";
})(DocumentReadyStateEnum || (DocumentReadyStateEnum = {}));
const DocumentReadyStateEnum$1 = DocumentReadyStateEnum;
class RangeUtility {
  /**
   * Compares boundary points.
   *
   * Based on logic from:
   * https://github.com/jsdom/jsdom/blob/master/lib/jsdom/living/range/boundary-point.js
   *
   * @see https://dom.spec.whatwg.org/#concept-range-bp-after
   * @param pointA Point A.
   * @param pointB Point B.
   * @returns A number, -1, 0, or 1, indicating whether the corresponding boundary-point of the Range is respectively before, equal to, or after the corresponding boundary-point of sourceRange.
   */
  static compareBoundaryPointsPosition(pointA, pointB) {
    if (pointA.node === pointB.node) {
      if (pointA.offset === pointB.offset) {
        return 0;
      } else if (pointA.offset < pointB.offset) {
        return -1;
      }
      return 1;
    }
    if (NodeUtility.isFollowing(pointA.node, pointB.node)) {
      return this.compareBoundaryPointsPosition(pointB, pointA) === -1 ? 1 : -1;
    }
    if (NodeUtility.isInclusiveAncestor(pointA.node, pointB.node)) {
      let child = pointB.node;
      while (child[parentNode] !== pointA.node) {
        child = child[parentNode];
      }
      if (child[parentNode][childNodes].indexOf(child) < pointA.offset) {
        return 1;
      }
    }
    return -1;
  }
  /**
   * Validates a boundary point.
   *
   * @throws DOMException
   * @param point Boundary point.
   */
  static validateBoundaryPoint(point) {
    if (point.node[nodeType] === NodeTypeEnum$1.documentTypeNode) {
      throw new DOMException(`DocumentType Node can't be used as boundary point.`, DOMExceptionNameEnum$1.invalidNodeTypeError);
    }
    if (point.offset > NodeUtility.getNodeLength(point.node)) {
      throw new DOMException(`Offset out of bound.`, DOMExceptionNameEnum$1.indexSizeError);
    }
  }
  /**
   * Returns "true" if contained.
   *
   * @param node Node.
   * @param range Range.
   * @returns "true" if contained.
   */
  static isContained(node2, range) {
    return this.compareBoundaryPointsPosition({ node: node2, offset: 0 }, { node: range.startContainer, offset: range.startOffset }) === 1 && this.compareBoundaryPointsPosition({ node: node2, offset: NodeUtility.getNodeLength(node2) }, { node: range.endContainer, offset: range.endOffset }) === -1;
  }
  /**
   * Returns "true" if partially contained.
   *
   * @param node Node.
   * @param range Range.
   * @returns "true" if partially contained.
   */
  static isPartiallyContained(node2, range) {
    return NodeUtility.isInclusiveAncestor(node2, range.startContainer) && !NodeUtility.isInclusiveAncestor(node2, range.endContainer) || !NodeUtility.isInclusiveAncestor(node2, range.startContainer) && NodeUtility.isInclusiveAncestor(node2, range.endContainer);
  }
}
var SelectionDirectionEnum;
(function(SelectionDirectionEnum2) {
  SelectionDirectionEnum2[SelectionDirectionEnum2["forwards"] = 1] = "forwards";
  SelectionDirectionEnum2[SelectionDirectionEnum2["backwards"] = -1] = "backwards";
  SelectionDirectionEnum2[SelectionDirectionEnum2["directionless"] = 0] = "directionless";
})(SelectionDirectionEnum || (SelectionDirectionEnum = {}));
const SelectionDirectionEnum$1 = SelectionDirectionEnum;
var __classPrivateFieldSet$C = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$F = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Selection_instances, _Selection_ownerDocument, _Selection_range, _Selection_direction, _Selection_associateRange;
class Selection {
  /**
   * Constructor.
   *
   * @param ownerDocument Owner document.
   */
  constructor(ownerDocument2) {
    _Selection_instances.add(this);
    _Selection_ownerDocument.set(this, null);
    _Selection_range.set(this, null);
    _Selection_direction.set(this, SelectionDirectionEnum$1.directionless);
    __classPrivateFieldSet$C(this, _Selection_ownerDocument, ownerDocument2, "f");
  }
  /**
   * Returns range count.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-rangecount
   * @returns Range count.
   */
  get rangeCount() {
    return __classPrivateFieldGet$F(this, _Selection_range, "f") ? 1 : 0;
  }
  /**
   * Returns collapsed state.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-iscollapsed
   * @returns "true" if collapsed.
   */
  get isCollapsed() {
    return __classPrivateFieldGet$F(this, _Selection_range, "f") === null || __classPrivateFieldGet$F(this, _Selection_range, "f").collapsed;
  }
  /**
   * Returns type.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-type
   * @returns Type.
   */
  get type() {
    if (!__classPrivateFieldGet$F(this, _Selection_range, "f")) {
      return "None";
    } else if (__classPrivateFieldGet$F(this, _Selection_range, "f").collapsed) {
      return "Caret";
    }
    return "Range";
  }
  /**
   * Returns anchor node.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-anchornode
   * @returns Node.
   */
  get anchorNode() {
    if (!__classPrivateFieldGet$F(this, _Selection_range, "f")) {
      return null;
    }
    return __classPrivateFieldGet$F(this, _Selection_direction, "f") === SelectionDirectionEnum$1.forwards ? __classPrivateFieldGet$F(this, _Selection_range, "f").startContainer : __classPrivateFieldGet$F(this, _Selection_range, "f").endContainer;
  }
  /**
   * Returns anchor offset.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-anchoroffset
   * @returns Node.
   */
  get anchorOffset() {
    if (!__classPrivateFieldGet$F(this, _Selection_range, "f")) {
      return 0;
    }
    return __classPrivateFieldGet$F(this, _Selection_direction, "f") === SelectionDirectionEnum$1.forwards ? __classPrivateFieldGet$F(this, _Selection_range, "f").startOffset : __classPrivateFieldGet$F(this, _Selection_range, "f").endOffset;
  }
  /**
   * Returns anchor node.
   *
   * @deprecated
   * @alias anchorNode
   * @returns Node.
   */
  get baseNode() {
    return this.anchorNode;
  }
  /**
   * Returns anchor offset.
   *
   * @deprecated
   * @alias anchorOffset
   * @returns Node.
   */
  get baseOffset() {
    return this.anchorOffset;
  }
  /**
   * Returns focus node.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-focusnode
   * @returns Node.
   */
  get focusNode() {
    return this.anchorNode;
  }
  /**
   * Returns focus offset.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-focusoffset
   * @returns Node.
   */
  get focusOffset() {
    return this.anchorOffset;
  }
  /**
   * Returns focus node.
   *
   * @deprecated
   * @alias focusNode
   * @returns Node.
   */
  get extentNode() {
    return this.focusNode;
  }
  /**
   * Returns focus offset.
   *
   * @deprecated
   * @alias focusOffset
   * @returns Node.
   */
  get extentOffset() {
    return this.focusOffset;
  }
  /**
   * Adds a range.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-addrange
   * @param newRange Range.
   */
  addRange(newRange) {
    if (!newRange) {
      throw new Error("Failed to execute addRange on Selection. Parameter 1 is not of type Range.");
    }
    if (!__classPrivateFieldGet$F(this, _Selection_range, "f") && newRange[ownerDocument] === __classPrivateFieldGet$F(this, _Selection_ownerDocument, "f")) {
      __classPrivateFieldGet$F(this, _Selection_instances, "m", _Selection_associateRange).call(this, newRange);
    }
  }
  /**
   * Returns Range.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-getrangeat
   * @param index Index.
   * @returns Range.
   */
  getRangeAt(index) {
    if (!__classPrivateFieldGet$F(this, _Selection_range, "f") || index !== 0) {
      throw new DOMException("Invalid range index.", DOMExceptionNameEnum$1.indexSizeError);
    }
    return __classPrivateFieldGet$F(this, _Selection_range, "f");
  }
  /**
   * Removes a range from a selection.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-removerange
   * @param range Range.
   */
  removeRange(range) {
    if (__classPrivateFieldGet$F(this, _Selection_range, "f") !== range) {
      throw new DOMException("Invalid range.", DOMExceptionNameEnum$1.notFoundError);
    }
    __classPrivateFieldGet$F(this, _Selection_instances, "m", _Selection_associateRange).call(this, null);
  }
  /**
   * Removes all ranges.
   */
  removeAllRanges() {
    __classPrivateFieldGet$F(this, _Selection_instances, "m", _Selection_associateRange).call(this, null);
  }
  /**
   * Removes all ranges.
   *
   * @alias removeAllRanges()
   */
  empty() {
    this.removeAllRanges();
  }
  /**
   * Collapses the current selection to a single point.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-collapse
   * @param node Node.
   * @param offset Offset.
   */
  collapse(node2, offset2) {
    if (node2 === null) {
      this.removeAllRanges();
      return;
    }
    if (node2[nodeType] === NodeTypeEnum$1.documentTypeNode) {
      throw new DOMException("DocumentType Node can't be used as boundary point.", DOMExceptionNameEnum$1.invalidNodeTypeError);
    }
    if (offset2 > NodeUtility.getNodeLength(node2)) {
      throw new DOMException("Invalid range index.", DOMExceptionNameEnum$1.indexSizeError);
    }
    if (node2[ownerDocument] !== __classPrivateFieldGet$F(this, _Selection_ownerDocument, "f")) {
      return;
    }
    const newRange = new (__classPrivateFieldGet$F(this, _Selection_ownerDocument, "f"))[ownerWindow].Range();
    newRange[start].node = node2;
    newRange[start].offset = offset2;
    newRange[end].node = node2;
    newRange[end].offset = offset2;
    __classPrivateFieldGet$F(this, _Selection_instances, "m", _Selection_associateRange).call(this, newRange);
  }
  /**
   * Collapses the current selection to a single point.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-setposition
   * @alias collapse()
   * @param node Node.
   * @param offset Offset.
   */
  setPosition(node2, offset2) {
    this.collapse(node2, offset2);
  }
  /**
   * Collapses the selection to the end.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-collapsetoend
   */
  collapseToEnd() {
    if (__classPrivateFieldGet$F(this, _Selection_range, "f") === null) {
      throw new DOMException("There is no selection to collapse.", DOMExceptionNameEnum$1.invalidStateError);
    }
    const { node: node2, offset: offset2 } = __classPrivateFieldGet$F(this, _Selection_range, "f")[end];
    const newRange = new (__classPrivateFieldGet$F(this, _Selection_ownerDocument, "f"))[ownerWindow].Range();
    newRange[start].node = node2;
    newRange[start].offset = offset2;
    newRange[end].node = node2;
    newRange[end].offset = offset2;
    __classPrivateFieldGet$F(this, _Selection_instances, "m", _Selection_associateRange).call(this, newRange);
  }
  /**
   * Collapses the selection to the start.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-collapsetostart
   */
  collapseToStart() {
    if (!__classPrivateFieldGet$F(this, _Selection_range, "f")) {
      throw new DOMException("There is no selection to collapse.", DOMExceptionNameEnum$1.invalidStateError);
    }
    const { node: node2, offset: offset2 } = __classPrivateFieldGet$F(this, _Selection_range, "f")[start];
    const newRange = new (__classPrivateFieldGet$F(this, _Selection_ownerDocument, "f"))[ownerWindow].Range();
    newRange[start].node = node2;
    newRange[start].offset = offset2;
    newRange[end].node = node2;
    newRange[end].offset = offset2;
    __classPrivateFieldGet$F(this, _Selection_instances, "m", _Selection_associateRange).call(this, newRange);
  }
  /**
   * Indicates whether a specified node is part of the selection.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-containsnode
   * @param node Node.
   * @param [allowPartialContainment] Set to "true" to allow partial containment.
   * @returns Always returns "true" for now.
   */
  containsNode(node2, allowPartialContainment = false) {
    if (!__classPrivateFieldGet$F(this, _Selection_range, "f") || node2[ownerDocument] !== __classPrivateFieldGet$F(this, _Selection_ownerDocument, "f")) {
      return false;
    }
    const startIsBeforeNode = RangeUtility.compareBoundaryPointsPosition(__classPrivateFieldGet$F(this, _Selection_range, "f")[start], {
      node: node2,
      offset: 0
    }) === -1;
    const endIsAfterNode = RangeUtility.compareBoundaryPointsPosition(__classPrivateFieldGet$F(this, _Selection_range, "f")[end], {
      node: node2,
      offset: NodeUtility.getNodeLength(node2)
    }) === 1;
    return allowPartialContainment ? startIsBeforeNode || endIsAfterNode : startIsBeforeNode && endIsAfterNode;
  }
  /**
   * Deletes the selected text from the document's DOM.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-deletefromdocument
   */
  deleteFromDocument() {
    if (__classPrivateFieldGet$F(this, _Selection_range, "f")) {
      __classPrivateFieldGet$F(this, _Selection_range, "f").deleteContents();
    }
  }
  /**
   * Moves the focus of the selection to a specified point.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-extend
   * @param node Node.
   * @param offset Offset.
   */
  extend(node2, offset2) {
    if (node2[ownerDocument] !== __classPrivateFieldGet$F(this, _Selection_ownerDocument, "f")) {
      return;
    }
    if (!__classPrivateFieldGet$F(this, _Selection_range, "f")) {
      throw new DOMException("There is no selection to extend.", DOMExceptionNameEnum$1.invalidStateError);
    }
    const anchorNode = this.anchorNode;
    const anchorOffset = this.anchorOffset;
    const newRange = new (__classPrivateFieldGet$F(this, _Selection_ownerDocument, "f"))[ownerWindow].Range();
    newRange[start].node = node2;
    newRange[start].offset = 0;
    newRange[end].node = node2;
    newRange[end].offset = 0;
    if (node2[ownerDocument] !== __classPrivateFieldGet$F(this, _Selection_range, "f")[ownerDocument]) {
      newRange[start].offset = offset2;
      newRange[end].offset = offset2;
    } else if (RangeUtility.compareBoundaryPointsPosition({ node: anchorNode, offset: anchorOffset }, { node: node2, offset: offset2 }) <= 0) {
      newRange[start].node = anchorNode;
      newRange[start].offset = anchorOffset;
      newRange[end].node = node2;
      newRange[end].offset = offset2;
    } else {
      newRange[start].node = node2;
      newRange[start].offset = offset2;
      newRange[end].node = anchorNode;
      newRange[end].offset = anchorOffset;
    }
    __classPrivateFieldGet$F(this, _Selection_instances, "m", _Selection_associateRange).call(this, newRange);
    __classPrivateFieldSet$C(this, _Selection_direction, RangeUtility.compareBoundaryPointsPosition({ node: node2, offset: offset2 }, { node: anchorNode, offset: anchorOffset }) === -1 ? SelectionDirectionEnum$1.backwards : SelectionDirectionEnum$1.forwards, "f");
  }
  /**
   * Selects all children.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-selectallchildren
   * @param node Node.
   */
  selectAllChildren(node2) {
    if (node2[nodeType] === NodeTypeEnum$1.documentTypeNode) {
      throw new DOMException("DocumentType Node can't be used as boundary point.", DOMExceptionNameEnum$1.invalidNodeTypeError);
    }
    if (node2[ownerDocument] !== __classPrivateFieldGet$F(this, _Selection_ownerDocument, "f")) {
      return;
    }
    const length2 = node2.childNodes.length;
    const newRange = new (__classPrivateFieldGet$F(this, _Selection_ownerDocument, "f"))[ownerWindow].Range();
    newRange[start].node = node2;
    newRange[start].offset = 0;
    newRange[end].node = node2;
    newRange[end].offset = length2;
    __classPrivateFieldGet$F(this, _Selection_instances, "m", _Selection_associateRange).call(this, newRange);
  }
  /**
   * Sets the selection to be a range including all or parts of two specified DOM nodes, and any content located between them.
   *
   * @see https://w3c.github.io/selection-api/#dom-selection-setbaseandextent
   * @param anchorNode Anchor node.
   * @param anchorOffset Anchor offset.
   * @param focusNode Focus node.
   * @param focusOffset Focus offset.
   */
  setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset) {
    if (anchorOffset > NodeUtility.getNodeLength(anchorNode) || focusOffset > NodeUtility.getNodeLength(focusNode)) {
      throw new DOMException("Invalid anchor or focus offset.", DOMExceptionNameEnum$1.indexSizeError);
    }
    if (anchorNode[ownerDocument] !== __classPrivateFieldGet$F(this, _Selection_ownerDocument, "f") || focusNode[ownerDocument] !== __classPrivateFieldGet$F(this, _Selection_ownerDocument, "f")) {
      return;
    }
    const anchor = { node: anchorNode, offset: anchorOffset };
    const focus = { node: focusNode, offset: focusOffset };
    const newRange = new (__classPrivateFieldGet$F(this, _Selection_ownerDocument, "f"))[ownerWindow].Range();
    if (RangeUtility.compareBoundaryPointsPosition(anchor, focus) === -1) {
      newRange[start] = anchor;
      newRange[end] = focus;
    } else {
      newRange[start] = focus;
      newRange[end] = anchor;
    }
    __classPrivateFieldGet$F(this, _Selection_instances, "m", _Selection_associateRange).call(this, newRange);
    __classPrivateFieldSet$C(this, _Selection_direction, RangeUtility.compareBoundaryPointsPosition(focus, anchor) === -1 ? SelectionDirectionEnum$1.backwards : SelectionDirectionEnum$1.forwards, "f");
  }
  /**
   * Returns string currently being represented by the selection object.
   *
   * @returns Selection as string.
   */
  toString() {
    return __classPrivateFieldGet$F(this, _Selection_range, "f") ? __classPrivateFieldGet$F(this, _Selection_range, "f").toString() : "";
  }
}
_Selection_ownerDocument = /* @__PURE__ */ new WeakMap(), _Selection_range = /* @__PURE__ */ new WeakMap(), _Selection_direction = /* @__PURE__ */ new WeakMap(), _Selection_instances = /* @__PURE__ */ new WeakSet(), _Selection_associateRange = function _Selection_associateRange2(range) {
  const oldRange = __classPrivateFieldGet$F(this, _Selection_range, "f");
  __classPrivateFieldSet$C(this, _Selection_range, range, "f");
  __classPrivateFieldSet$C(this, _Selection_direction, range === null ? SelectionDirectionEnum$1.directionless : SelectionDirectionEnum$1.forwards, "f");
  if (oldRange !== __classPrivateFieldGet$F(this, _Selection_range, "f")) {
    __classPrivateFieldGet$F(this, _Selection_ownerDocument, "f").dispatchEvent(new Event("selectionchange"));
  }
};
var VisibilityStateEnum;
(function(VisibilityStateEnum2) {
  VisibilityStateEnum2["hidden"] = "hidden";
  VisibilityStateEnum2["visible"] = "visible";
  VisibilityStateEnum2["prerender"] = "prerender";
})(VisibilityStateEnum || (VisibilityStateEnum = {}));
const VisibilityStateEnum$1 = VisibilityStateEnum;
class CookieStringUtility {
  /**
   * Returns cookie.
   *
   * @param originURL Origin URL.
   * @param cookieString Cookie string.
   * @returns Cookie.
   */
  static stringToCookie(originURL, cookieString) {
    const parts = cookieString.split(";");
    const [key, value2] = parts.shift().split("=");
    const cookie = {
      // Required
      key: key.trim(),
      value: value2 ?? null,
      originURL,
      // Optional
      domain: "",
      path: "",
      expires: null,
      httpOnly: false,
      secure: false,
      sameSite: CookieSameSiteEnum$1.lax
    };
    if (!cookie.key) {
      return null;
    }
    for (const part of parts) {
      const keyAndValue = part.split("=");
      const key2 = keyAndValue[0].trim().toLowerCase();
      const value3 = keyAndValue[1];
      switch (key2) {
        case "expires":
          cookie.expires = new Date(value3);
          break;
        case "max-age":
          cookie.expires = new Date(parseInt(value3, 10) * 1e3 + Date.now());
          break;
        case "domain":
          cookie.domain = value3;
          break;
        case "path":
          cookie.path = value3.startsWith("/") ? value3 : `/${value3}`;
          break;
        case "httponly":
          cookie.httpOnly = true;
          break;
        case "secure":
          cookie.secure = true;
          break;
        case "samesite":
          switch (value3.toLowerCase()) {
            case "strict":
              cookie.sameSite = CookieSameSiteEnum$1.strict;
              break;
            case "lax":
              cookie.sameSite = CookieSameSiteEnum$1.lax;
              break;
            case "none":
              cookie.sameSite = CookieSameSiteEnum$1.none;
          }
          break;
      }
    }
    const lowerKey = cookie.key.toLowerCase();
    if (lowerKey.startsWith("__secure-") && !cookie.secure) {
      return null;
    }
    if (lowerKey.startsWith("__host-") && (!cookie.secure || cookie.path !== "/" || cookie.domain)) {
      return null;
    }
    return cookie;
  }
  /**
   * Returns cookie string with key and value.
   *
   * @param cookies Cookies.
   * @returns Cookie string.
   */
  static cookiesToString(cookies) {
    const cookieString = [];
    for (const cookie of cookies) {
      if (cookie.value !== null) {
        cookieString.push(`${cookie.key}=${cookie.value}`);
      } else {
        cookieString.push(cookie.key);
      }
    }
    return cookieString.join("; ");
  }
}
var __classPrivateFieldSet$B = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$E = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Document_instances, _Document_selection, _Document_browserFrame, _Document_importNode, _a$y, _b$j, _c$f, _d$9, _e$9, _f$7, _g$4, _h$3, _j$3, _k$2, _l$2, _m$2, _o$2, _p$1, _q$1;
const PROCESSING_INSTRUCTION_TARGET_REGEXP = /^[a-z][a-z0-9-]+$/;
let Document$1 = class Document extends Node2 {
  /**
   * Constructor.
   *
   * @param injected Injected properties.
   * @param injected.browserFrame Browser frame.
   * @param injected.window Window.
   */
  constructor(injected) {
    super();
    _Document_instances.add(this);
    this[_a$y] = new HTMLCollection();
    this[_b$j] = null;
    this[_c$f] = null;
    this[_d$9] = null;
    this[_e$9] = this;
    this[_f$7] = 0;
    this[_g$4] = true;
    this[_h$3] = false;
    this[_j$3] = NodeTypeEnum$1.documentNode;
    this[_k$2] = true;
    this[_l$2] = [];
    this[_m$2] = new DOMImplementation(this);
    this[_o$2] = DocumentReadyStateEnum$1.interactive;
    this[_p$1] = "";
    this[_q$1] = null;
    _Document_selection.set(this, null);
    _Document_browserFrame.set(this, void 0);
    this.onreadystatechange = null;
    this.onpointerlockchange = null;
    this.onpointerlockerror = null;
    this.onbeforecopy = null;
    this.onbeforecut = null;
    this.onbeforepaste = null;
    this.onfreeze = null;
    this.onresume = null;
    this.onsearch = null;
    this.onvisibilitychange = null;
    this.onfullscreenchange = null;
    this.onfullscreenerror = null;
    this.onwebkitfullscreenchange = null;
    this.onwebkitfullscreenerror = null;
    this.onbeforexrselect = null;
    this.onabort = null;
    this.onbeforeinput = null;
    this.onblur = null;
    this.oncancel = null;
    this.oncanplay = null;
    this.oncanplaythrough = null;
    this.onchange = null;
    this.onclick = null;
    this.onclose = null;
    this.oncontextlost = null;
    this.oncontextmenu = null;
    this.oncontextrestored = null;
    this.oncuechange = null;
    this.ondblclick = null;
    this.ondrag = null;
    this.ondragend = null;
    this.ondragenter = null;
    this.ondragleave = null;
    this.ondragover = null;
    this.ondragstart = null;
    this.ondrop = null;
    this.ondurationchange = null;
    this.onemptied = null;
    this.onended = null;
    this.onerror = null;
    this.onfocus = null;
    this.onformdata = null;
    this.oninput = null;
    this.oninvalid = null;
    this.onkeydown = null;
    this.onkeypress = null;
    this.onkeyup = null;
    this.onload = null;
    this.onloadeddata = null;
    this.onloadedmetadata = null;
    this.onloadstart = null;
    this.onmousedown = null;
    this.onmouseenter = null;
    this.onmouseleave = null;
    this.onmousemove = null;
    this.onmouseout = null;
    this.onmouseover = null;
    this.onmouseup = null;
    this.onmousewheel = null;
    this.onpause = null;
    this.onplay = null;
    this.onplaying = null;
    this.onprogress = null;
    this.onratechange = null;
    this.onreset = null;
    this.onresize = null;
    this.onscroll = null;
    this.onsecuritypolicyviolation = null;
    this.onseeked = null;
    this.onseeking = null;
    this.onselect = null;
    this.onslotchange = null;
    this.onstalled = null;
    this.onsubmit = null;
    this.onsuspend = null;
    this.ontimeupdate = null;
    this.ontoggle = null;
    this.onvolumechange = null;
    this.onwaiting = null;
    this.onwebkitanimationend = null;
    this.onwebkitanimationiteration = null;
    this.onwebkitanimationstart = null;
    this.onwebkittransitionend = null;
    this.onwheel = null;
    this.onauxclick = null;
    this.ongotpointercapture = null;
    this.onlostpointercapture = null;
    this.onpointerdown = null;
    this.onpointermove = null;
    this.onpointerrawupdate = null;
    this.onpointerup = null;
    this.onpointercancel = null;
    this.onpointerover = null;
    this.onpointerout = null;
    this.onpointerenter = null;
    this.onpointerleave = null;
    this.onselectstart = null;
    this.onselectionchange = null;
    this.onanimationend = null;
    this.onanimationiteration = null;
    this.onanimationstart = null;
    this.ontransitionrun = null;
    this.ontransitionstart = null;
    this.ontransitionend = null;
    this.ontransitioncancel = null;
    this.oncopy = null;
    this.oncut = null;
    this.onpaste = null;
    this.onbeforematch = null;
    __classPrivateFieldSet$B(this, _Document_browserFrame, injected.browserFrame, "f");
    this[ownerWindow] = injected.window;
  }
  /**
   * Returns adopted style sheets.
   *
   * @returns Adopted style sheets.
   */
  get adoptedStyleSheets() {
    return this[adoptedStyleSheets];
  }
  /**
   * Sets adopted style sheets.
   *
   * @param value Adopted style sheets.
   */
  set adoptedStyleSheets(value2) {
    this[adoptedStyleSheets] = value2;
  }
  /**
   * Returns DOM implementation.
   *
   * @returns DOM implementation.
   */
  get implementation() {
    return this[implementation];
  }
  /**
   * Returns document ready state.
   *
   * @returns Document ready state.
   */
  get readyState() {
    return this[readyState];
  }
  /**
   * Returns referrer.
   *
   * @returns Referrer.
   */
  get referrer() {
    return this[referrer];
  }
  /**
   * Returns default view.
   *
   * @returns Default view.
   */
  get defaultView() {
    return this[defaultView];
  }
  /**
   * Returns document children.
   */
  get children() {
    return this[children];
  }
  /**
   * Returns character set.
   *
   * @deprecated
   * @returns Character set.
   */
  get charset() {
    return this.characterSet;
  }
  /**
   * Returns character set.
   *
   * @returns Character set.
   */
  get characterSet() {
    var _a2;
    const charset = (_a2 = this.querySelector("meta[charset]")) == null ? void 0 : _a2.getAttributeNS(null, "charset");
    return charset ? charset : "UTF-8";
  }
  /**
   * Returns title.
   *
   * @returns Title.
   */
  get title() {
    const element = ParentNodeUtility.getElementByTagName(this, "title");
    if (element) {
      return element.textContent;
    }
    return "";
  }
  /**
   * Returns set title.
   *
   */
  set title(title) {
    const element = ParentNodeUtility.getElementByTagName(this, "title");
    if (element) {
      element.textContent = title;
    } else {
      const newElement = this.createElement("title");
      newElement.textContent = title;
      this.head.appendChild(newElement);
    }
  }
  /**
   * Returns a collection of all area elements and a elements in a document with a value for the href attribute.
   */
  get links() {
    return this.querySelectorAll("a[href],area[href]");
  }
  /**
   * Returns a collection of all form elements in a document.
   */
  get forms() {
    return this.getElementsByTagName("form");
  }
  /**
   * Last element child.
   *
   * @returns Element.
   */
  get childElementCount() {
    return this[children].length;
  }
  /**
   * First element child.
   *
   * @returns Element.
   */
  get firstElementChild() {
    return this[children][0] ?? null;
  }
  /**
   * Last element child.
   *
   * @returns Element.
   */
  get lastElementChild() {
    return this[children][this[children].length - 1] ?? null;
  }
  /**
   * Returns cookie string.
   *
   * @returns Cookie.
   */
  get cookie() {
    return CookieStringUtility.cookiesToString(__classPrivateFieldGet$E(this, _Document_browserFrame, "f").page.context.cookieContainer.getCookies(new URL_1(this[ownerWindow].location.href), true));
  }
  /**
   * Sets a cookie string.
   *
   * @param cookie Cookie string.
   */
  set cookie(cookie) {
    __classPrivateFieldGet$E(this, _Document_browserFrame, "f").page.context.cookieContainer.addCookies([
      CookieStringUtility.stringToCookie(new URL_1(this[ownerWindow].location.href), cookie)
    ]);
  }
  /**
   * Node name.
   *
   * @returns Node name.
   */
  get nodeName() {
    return "#document";
  }
  /**
   * Returns <html> element.
   *
   * @returns Element.
   */
  get documentElement() {
    return ParentNodeUtility.getElementByTagName(this, "html");
  }
  /**
   * Returns document type element.
   *
   * @returns Document type.
   */
  get doctype() {
    for (const node2 of this[childNodes]) {
      if (node2 instanceof DocumentType) {
        return node2;
      }
    }
    return null;
  }
  /**
   * Returns <body> element.
   *
   * @returns Element.
   */
  get body() {
    return ParentNodeUtility.getElementByTagName(this, "body");
  }
  /**
   * Returns <head> element.
   *
   * @returns Element.
   */
  get head() {
    return ParentNodeUtility.getElementByTagName(this, "head");
  }
  /**
   * Returns CSS style sheets.
   *
   * @returns CSS style sheets.
   */
  get styleSheets() {
    const styles = this.querySelectorAll('link[rel="stylesheet"][href],style');
    const styleSheets = [];
    for (const style2 of styles) {
      const sheet2 = style2.sheet;
      if (sheet2) {
        styleSheets.push(sheet2);
      }
    }
    return styleSheets;
  }
  /**
   * Returns active element.
   *
   * @returns Active element.
   */
  get activeElement() {
    if (this[activeElement] && !this[activeElement][isConnected]) {
      this[activeElement] = null;
    }
    if (this[activeElement] && this[activeElement] instanceof Element$1) {
      let rootNode2 = this[activeElement].getRootNode();
      let activeElement$1 = this[activeElement];
      while (rootNode2 !== this) {
        activeElement$1 = rootNode2.host;
        rootNode2 = activeElement$1 ? activeElement$1.getRootNode() : this;
      }
      return activeElement$1;
    }
    return this[activeElement] || this.body || this.documentElement || null;
  }
  /**
   * Returns scrolling element.
   *
   * @returns Scrolling element.
   */
  get scrollingElement() {
    return this.documentElement;
  }
  /**
   * Returns location.
   *
   * @returns Location.
   */
  get location() {
    return this[ownerWindow].location;
  }
  /**
   * Returns scripts.
   *
   * @returns Scripts.
   */
  get scripts() {
    return this.getElementsByTagName("script");
  }
  /**
   * Returns base URI.
   *
   * @override
   * @returns Base URI.
   */
  get baseURI() {
    const element = ParentNodeUtility.getElementByTagName(this, "base");
    if (element) {
      return element.href;
    }
    return this[ownerWindow].location.href;
  }
  /**
   * Returns URL.
   *
   * @returns the URL of the current document.
   * */
  get URL() {
    return this[ownerWindow].location.href;
  }
  /**
   * Returns document URI.
   *
   * @returns the URL of the current document.
   * */
  get documentURI() {
    return this.URL;
  }
  /**
   * Returns document visibility state.
   *
   * @returns the visibility state of the current document.
   * */
  get visibilityState() {
    if (this.defaultView) {
      return VisibilityStateEnum$1.visible;
    }
    return VisibilityStateEnum$1.hidden;
  }
  /**
   * Returns document hidden state.
   *
   * @returns the hidden state of the current document.
   * */
  get hidden() {
    if (this.defaultView) {
      return false;
    }
    return true;
  }
  /**
   * Gets the currently executing script element.
   *
   * @returns the currently executing script element.
   */
  get currentScript() {
    return this[currentScript];
  }
  /**
   * Inserts a set of Node objects or DOMString objects after the last child of the ParentNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param nodes List of Node or DOMString.
   */
  append(...nodes) {
    ParentNodeUtility.append(this, ...nodes);
  }
  /**
   * Inserts a set of Node objects or DOMString objects before the first child of the ParentNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param nodes List of Node or DOMString.
   */
  prepend(...nodes) {
    ParentNodeUtility.prepend(this, ...nodes);
  }
  /**
   * Replaces the existing children of a node with a specified new set of children.
   *
   * @param nodes List of Node or DOMString.
   */
  replaceChildren(...nodes) {
    ParentNodeUtility.replaceChildren(this, ...nodes);
  }
  /**
   * Query CSS selector to find matching elments.
   *
   * @param selector CSS selector.
   * @returns Matching elements.
   */
  querySelectorAll(selector) {
    return QuerySelector.querySelectorAll(this, selector);
  }
  /**
   * Query CSS Selector to find matching node.
   *
   * @param selector CSS selector.
   * @returns Matching element.
   */
  querySelector(selector) {
    return QuerySelector.querySelector(this, selector);
  }
  /**
   * Returns true if the command is supported.
   * @deprecated
   * @param _ Command.
   * @returns True if the command is supported, false otherwise.
   */
  queryCommandSupported(_) {
    if (!arguments.length) {
      throw new TypeError("Failed to execute 'queryCommandSupported' on 'Document': 1 argument required, but only 0 present.");
    }
    return true;
  }
  /**
   * Returns an elements by class name.
   *
   * @param className Tag name.
   * @returns Matching element.
   */
  getElementsByClassName(className) {
    return ParentNodeUtility.getElementsByClassName(this, className);
  }
  /**
   * Returns an elements by tag name.
   *
   * @param tagName Tag name.
   * @returns Matching element.
   */
  getElementsByTagName(tagName3) {
    return ParentNodeUtility.getElementsByTagName(this, tagName3);
  }
  /**
   * Returns an elements by tag name and namespace.
   *
   * @param namespaceURI Namespace URI.
   * @param tagName Tag name.
   * @returns Matching element.
   */
  getElementsByTagNameNS(namespaceURI2, tagName3) {
    return ParentNodeUtility.getElementsByTagNameNS(this, namespaceURI2, tagName3);
  }
  /**
   * Returns an element by ID.
   *
   * @param id ID.
   * @returns Matching element.
   */
  getElementById(id) {
    return ParentNodeUtility.getElementById(this, id);
  }
  /**
   * Returns an element by Name.
   *
   * @returns Matching element.
   * @param name
   */
  getElementsByName(name2) {
    const getElementsByName = (parentNode2, name3) => {
      const matches = new NodeList();
      for (const child of parentNode2[children]) {
        if (child.getAttributeNS(null, "name") === name3) {
          matches.push(child);
        }
        for (const match2 of getElementsByName(child, name3)) {
          matches.push(match2);
        }
      }
      return matches;
    };
    return getElementsByName(this, name2);
  }
  /**
   * @override
   */
  [(_Document_selection = /* @__PURE__ */ new WeakMap(), _Document_browserFrame = /* @__PURE__ */ new WeakMap(), _Document_instances = /* @__PURE__ */ new WeakSet(), _a$y = children, _b$j = activeElement, _c$f = nextActiveElement, _d$9 = currentScript, _e$9 = rootNode, _f$7 = cacheID, _g$4 = isFirstWrite, _h$3 = isFirstWriteAfterOpen, _j$3 = nodeType, _k$2 = isConnected, _l$2 = adoptedStyleSheets, _m$2 = implementation, _o$2 = readyState, _p$1 = referrer, _q$1 = defaultView, cloneNode)](deep = false) {
    const clone2 = super[cloneNode](deep);
    if (deep) {
      for (const node2 of clone2[childNodes]) {
        if (node2[nodeType] === NodeTypeEnum$1.elementNode) {
          clone2[children].push(node2);
        }
      }
    }
    return clone2;
  }
  /**
   * @override
   */
  [appendChild](node2) {
    return ElementUtility.appendChild(this, node2);
  }
  /**
   * @override
   */
  [removeChild](node2) {
    return ElementUtility.removeChild(this, node2);
  }
  /**
   * @override
   */
  [insertBefore](newNode, referenceNode) {
    return ElementUtility.insertBefore(this, newNode, referenceNode);
  }
  /**
   * Replaces the document HTML with new HTML.
   *
   * @param html HTML.
   */
  write(html) {
    const root = XMLParser.parse(this, html, { evaluateScripts: true });
    if (this[isFirstWrite] || this[isFirstWriteAfterOpen]) {
      if (this[isFirstWrite]) {
        if (!this[isFirstWriteAfterOpen]) {
          this.open();
        }
        this[isFirstWrite] = false;
      }
      this[isFirstWriteAfterOpen] = false;
      let documentElement = null;
      let documentTypeNode = null;
      for (const node2 of root[childNodes]) {
        if (node2["tagName"] === "HTML") {
          documentElement = node2;
        } else if (node2[nodeType] === NodeTypeEnum$1.documentTypeNode) {
          documentTypeNode = node2;
        }
        if (documentElement && documentTypeNode) {
          break;
        }
      }
      if (documentElement) {
        if (!this.documentElement) {
          if (documentTypeNode) {
            this.appendChild(documentTypeNode);
          }
          this.appendChild(documentElement);
          const head = ParentNodeUtility.getElementByTagName(this, "head");
          let body2 = ParentNodeUtility.getElementByTagName(this, "body");
          if (!body2) {
            body2 = this.createElement("body");
            documentElement.appendChild(this.createElement("body"));
          }
          if (!head) {
            documentElement.insertBefore(this.createElement("head"), body2);
          }
        } else {
          const rootBody = ParentNodeUtility.getElementByTagName(root, "body");
          const body2 = ParentNodeUtility.getElementByTagName(this, "body");
          if (rootBody && body2) {
            for (const child of rootBody[childNodes].slice()) {
              body2.appendChild(child);
            }
          }
        }
        const body = ParentNodeUtility.getElementByTagName(this, "body");
        if (body) {
          for (const child of root[childNodes].slice()) {
            if (child["tagName"] !== "HTML" && child[nodeType] !== NodeTypeEnum$1.documentTypeNode) {
              body.appendChild(child);
            }
          }
        }
      } else {
        const documentElement2 = this.createElement("html");
        const bodyElement = this.createElement("body");
        const headElement = this.createElement("head");
        for (const child of root[childNodes].slice()) {
          bodyElement.appendChild(child);
        }
        documentElement2.appendChild(headElement);
        documentElement2.appendChild(bodyElement);
        this.appendChild(documentElement2);
      }
    } else {
      const bodyNode = ParentNodeUtility.getElementByTagName(root, "body");
      const body = ParentNodeUtility.getElementByTagName(this, "body");
      for (const child of (bodyNode || root)[childNodes].slice()) {
        body.appendChild(child);
      }
    }
  }
  /**
   * Opens the document.
   *
   * @returns Document.
   */
  open() {
    this[isFirstWriteAfterOpen] = true;
    for (const eventType of Object.keys(this[listeners])) {
      const listeners$1 = this[listeners][eventType];
      if (listeners$1) {
        for (const listener of listeners$1) {
          this.removeEventListener(eventType, listener);
        }
      }
    }
    for (const child of this[childNodes].slice()) {
      this.removeChild(child);
    }
    return this;
  }
  /**
   * Closes the document.
   */
  close() {
  }
  /**
   * Creates an element.
   *
   * @param qualifiedName Tag name.
   * @param [options] Options.
   * @param [options.is] Tag name of a custom element previously defined via customElements.define().
   * @returns Element.
   */
  createElement(qualifiedName, options2) {
    return this.createElementNS(NamespaceURI.html, qualifiedName, options2);
  }
  /**
   * Creates an element with the specified namespace URI and qualified name.
   *
   * @param namespaceURI Namespace URI.
   * @param qualifiedName Tag name.
   * @param [options] Options.
   * @param [options.is] Tag name of a custom element previously defined via customElements.define().
   * @returns Element.
   */
  createElementNS(namespaceURI$1, qualifiedName, options2) {
    var _a2;
    qualifiedName = String(qualifiedName);
    if (!qualifiedName) {
      throw new DOMException("Failed to execute 'createElementNS' on 'Document': The qualified name provided is empty.");
    }
    if (namespaceURI$1 === NamespaceURI.svg) {
      const element2 = NodeFactory.createNode(this, qualifiedName === "svg" ? this[ownerWindow].SVGSVGElement : this[ownerWindow].SVGElement);
      element2[tagName] = qualifiedName;
      element2[localName] = qualifiedName;
      element2[namespaceURI] = namespaceURI$1;
      element2[isValue] = options2 && options2.is ? String(options2.is) : null;
      return element2;
    }
    const customElement = (_a2 = this[ownerWindow].customElements[registry]) == null ? void 0 : _a2[options2 && options2.is ? String(options2.is) : qualifiedName];
    if (customElement) {
      const element2 = new customElement.elementClass();
      element2[tagName] = qualifiedName.toUpperCase();
      element2[localName] = qualifiedName;
      element2[namespaceURI] = namespaceURI$1;
      element2[isValue] = options2 && options2.is ? String(options2.is) : null;
      return element2;
    }
    const localName$1 = qualifiedName.toLowerCase();
    const elementClass = HTMLElementConfig[localName$1] ? this[ownerWindow][HTMLElementConfig[localName$1].className] : null;
    if (elementClass) {
      const element2 = NodeFactory.createNode(this, elementClass);
      element2[tagName] = qualifiedName.toUpperCase();
      element2[localName] = localName$1;
      element2[namespaceURI] = namespaceURI$1;
      element2[isValue] = options2 && options2.is ? String(options2.is) : null;
      return element2;
    }
    const element = NodeFactory.createNode(
      this,
      // If the tag name contains a hyphen, it is an unknown custom element and we should use HTMLElement.
      localName$1.includes("-") ? this[ownerWindow].HTMLElement : this[ownerWindow].HTMLUnknownElement
    );
    element[tagName] = qualifiedName.toUpperCase();
    element[localName] = localName$1;
    element[namespaceURI] = namespaceURI$1;
    element[isValue] = options2 && options2.is ? String(options2.is) : null;
    return element;
  }
  /* eslint-enable jsdoc/valid-types */
  /**
   * Creates a text node.
   *
   * @param [data] Text data.
   * @returns Text node.
   */
  createTextNode(data2) {
    if (arguments.length < 1) {
      throw new TypeError(`Failed to execute 'createTextNode' on 'Document': 1 argument required, but only ${arguments.length} present.`);
    }
    return NodeFactory.createNode(this, this[ownerWindow].Text, String(data2));
  }
  /**
   * Creates a comment node.
   *
   * @param [data] Text data.
   * @returns Text node.
   */
  createComment(data2) {
    return NodeFactory.createNode(this, this[ownerWindow].Comment, data2);
  }
  /**
   * Creates a document fragment.
   *
   * @returns Document fragment.
   */
  createDocumentFragment() {
    return new this[ownerWindow].DocumentFragment();
  }
  /**
   * Creates a node iterator.
   *
   * @param root Root.
   * @param [whatToShow] What to show.
   * @param [filter] Filter.
   */
  createNodeIterator(root, whatToShow = -1, filter = null) {
    return new NodeIterator(root, whatToShow, filter);
  }
  /**
   * Creates a Tree Walker.
   *
   * @param root Root.
   * @param [whatToShow] What to show.
   * @param [filter] Filter.
   */
  createTreeWalker(root, whatToShow = -1, filter = null) {
    return new TreeWalker(root, whatToShow, filter);
  }
  /**
   * Creates an event.
   *
   * @deprecated
   * @param type Type.
   * @returns Event.
   */
  createEvent(type) {
    if (typeof this[ownerWindow][type] === "function") {
      return new this[ownerWindow][type]("init");
    }
    return new Event("init");
  }
  /**
   * Creates an Attr node.
   *
   * @param qualifiedName Name.
   * @returns Attribute.
   */
  createAttribute(qualifiedName) {
    return this.createAttributeNS(null, qualifiedName.toLowerCase());
  }
  /**
   * Creates a namespaced Attr node.
   *
   * @param namespaceURI Namespace URI.
   * @param qualifiedName Qualified name.
   * @returns Element.
   */
  createAttributeNS(namespaceURI$1, qualifiedName) {
    const attribute = NodeFactory.createNode(this, this[ownerWindow].Attr);
    attribute[namespaceURI] = namespaceURI$1;
    attribute[name] = qualifiedName;
    return attribute;
  }
  /**
   * Imports a node.
   *
   * @param node Node to import.
   * @param [deep=false] Set to "true" if the clone should be deep.
   */
  importNode(node2, deep = false) {
    if (!(node2 instanceof Node2)) {
      throw new DOMException("Parameter 1 was not of type Node.");
    }
    const clone2 = node2.cloneNode(deep);
    __classPrivateFieldGet$E(this, _Document_instances, "m", _Document_importNode).call(this, clone2);
    return clone2;
  }
  /**
   * Creates a range.
   *
   * @returns Range.
   */
  createRange() {
    return new this[ownerWindow].Range();
  }
  /**
   * Adopts a node.
   *
   * @param node Node to adopt.
   * @returns Adopted node.
   */
  adoptNode(node2) {
    if (!(node2 instanceof Node2)) {
      throw new DOMException("Parameter 1 was not of type Node.");
    }
    const adopted = node2[parentNode] ? node2[parentNode].removeChild(node2) : node2;
    const document2 = this;
    Object.defineProperty(adopted, "ownerDocument", { value: document2 });
    return adopted;
  }
  /**
   * Returns selection.
   *
   * @returns Selection.
   */
  getSelection() {
    if (!__classPrivateFieldGet$E(this, _Document_selection, "f")) {
      __classPrivateFieldSet$B(this, _Document_selection, new Selection(this), "f");
    }
    return __classPrivateFieldGet$E(this, _Document_selection, "f");
  }
  /**
   * Returns a boolean value indicating whether the document or any element inside the document has focus.
   *
   * @returns "true" if the document has focus.
   */
  hasFocus() {
    return !!this.activeElement;
  }
  /**
   * Creates a Processing Instruction node.
   *
   * @param target Target.
   * @param data Data.
   * @returns ProcessingInstruction.
   */
  createProcessingInstruction(target$1, data2) {
    if (!target$1 || !PROCESSING_INSTRUCTION_TARGET_REGEXP.test(target$1)) {
      throw new DOMException(`Failed to execute 'createProcessingInstruction' on 'Document': The target provided ('${target$1}') is not a valid name.`);
    }
    if (data2.includes("?>")) {
      throw new DOMException(`Failed to execute 'createProcessingInstruction' on 'Document': The data provided ('?>') contains '?>'`);
    }
    const processingInstruction = NodeFactory.createNode(this, this[ownerWindow].ProcessingInstruction, data2);
    processingInstruction[target] = target$1;
    return processingInstruction;
  }
  /**
   * Get element at a given point.
   *
   * @param _x horizontal coordinate
   * @param _y vertical coordinate
   * @returns Always returns null since Happy DOM does not render elements.
   */
  elementFromPoint(_x, _y) {
    return null;
  }
};
_Document_importNode = function _Document_importNode2(node2) {
  node2[ownerDocument] = this;
  for (const child of node2[childNodes]) {
    __classPrivateFieldGet$E(this, _Document_instances, "m", _Document_importNode2).call(this, child);
  }
};
let HTMLDocument$1 = class HTMLDocument extends Document$1 {
  /**
   * Constructor.
   *
   * @param injected Injected properties.
   * @param injected.browserFrame Browser frame.
   * @param injected.window Window.
   */
  constructor(injected) {
    super(injected);
    const doctype = this[implementation].createDocumentType("html", "", "");
    const documentElement = this.createElement("html");
    const bodyElement = this.createElement("body");
    const headElement = this.createElement("head");
    this.appendChild(doctype);
    this.appendChild(documentElement);
    documentElement.appendChild(headElement);
    documentElement.appendChild(bodyElement);
  }
};
let XMLDocument$1 = class XMLDocument extends Document$1 {
};
let SVGDocument$1 = class SVGDocument extends Document$1 {
};
var _a$x, _b$i, _c$e;
let DocumentFragment$1 = class DocumentFragment extends Node2 {
  constructor() {
    super(...arguments);
    this[_a$x] = new HTMLCollection();
    this[_b$i] = this;
    this[_c$e] = NodeTypeEnum$1.documentFragmentNode;
  }
  /**
   * Returns the document fragment children.
   */
  get children() {
    return this[children];
  }
  /**
   * Last element child.
   *
   * @returns Element.
   */
  get childElementCount() {
    return this[children].length;
  }
  /**
   * First element child.
   *
   * @returns Element.
   */
  get firstElementChild() {
    return this[children][0] ?? null;
  }
  /**
   * Last element child.
   *
   * @returns Element.
   */
  get lastElementChild() {
    return this[children][this[children].length - 1] ?? null;
  }
  /**
   * Get text value of children.
   *
   * @returns Text content.
   */
  get textContent() {
    let result = "";
    for (const childNode of this[childNodes]) {
      if (childNode[nodeType] === NodeTypeEnum$1.elementNode || childNode[nodeType] === NodeTypeEnum$1.textNode) {
        result += childNode.textContent;
      }
    }
    return result;
  }
  /**
   * Sets text content.
   *
   * @param textContent Text content.
   */
  set textContent(textContent) {
    for (const child of this[childNodes].slice()) {
      this.removeChild(child);
    }
    if (textContent) {
      this.appendChild(this[ownerDocument].createTextNode(textContent));
    }
  }
  /**
   * Inserts a set of Node objects or DOMString objects after the last child of the ParentNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param nodes List of Node or DOMString.
   */
  append(...nodes) {
    ParentNodeUtility.append(this, ...nodes);
  }
  /**
   * Inserts a set of Node objects or DOMString objects before the first child of the ParentNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param nodes List of Node or DOMString.
   */
  prepend(...nodes) {
    ParentNodeUtility.prepend(this, ...nodes);
  }
  /**
   * Replaces the existing children of a node with a specified new set of children.
   *
   * @param nodes List of Node or DOMString.
   */
  replaceChildren(...nodes) {
    ParentNodeUtility.replaceChildren(this, ...nodes);
  }
  /**
   * Query CSS selector to find matching elments.
   *
   * @param selector CSS selector.
   * @returns Matching elements.
   */
  querySelectorAll(selector) {
    return QuerySelector.querySelectorAll(this, selector);
  }
  /**
   * Query CSS Selector to find a matching element.
   *
   * @param selector CSS selector.
   * @returns Matching element.
   */
  querySelector(selector) {
    return QuerySelector.querySelector(this, selector);
  }
  /**
   * Returns an element by ID.
   *
   * @param id ID.
   * @returns Matching element.
   */
  getElementById(id) {
    return ParentNodeUtility.getElementById(this, id);
  }
  /**
   * @override
   */
  [(_a$x = children, _b$i = rootNode, _c$e = nodeType, cloneNode)](deep = false) {
    const clone2 = super[cloneNode](deep);
    if (deep) {
      for (const node2 of clone2[childNodes]) {
        if (node2[nodeType] === NodeTypeEnum$1.elementNode) {
          clone2[children].push(node2);
        }
      }
    }
    return clone2;
  }
  /**
   * @override
   */
  [appendChild](node2) {
    return ElementUtility.appendChild(this, node2);
  }
  /**
   * @override
   */
  [removeChild](node2) {
    return ElementUtility.removeChild(this, node2);
  }
  /**
   * @override
   */
  [insertBefore](newNode, referenceNode) {
    return ElementUtility.insertBefore(this, newNode, referenceNode);
  }
};
var _a$w, _b$h, _c$d;
let ShadowRoot$1 = class ShadowRoot2 extends DocumentFragment$1 {
  constructor() {
    super(...arguments);
    this.onslotchange = null;
    this[_a$w] = [];
    this[_b$h] = "open";
    this[_c$d] = null;
  }
  /**
   * Returns mode.
   *
   * @returns Mode.
   */
  get mode() {
    return this[mode];
  }
  /**
   * Returns host.
   *
   * @returns Host.
   */
  get host() {
    return this[host];
  }
  /**
   * Returns inner HTML.
   *
   * @returns HTML.
   */
  get innerHTML() {
    const xmlSerializer = new XMLSerializer({
      escapeEntities: false
    });
    let xml = "";
    for (const node2 of this[childNodes]) {
      xml += xmlSerializer.serializeToString(node2);
    }
    return xml;
  }
  /**
   * Sets inner HTML.
   *
   * @param html HTML.
   */
  set innerHTML(html) {
    for (const child of this[childNodes].slice()) {
      this.removeChild(child);
    }
    XMLParser.parse(this[ownerDocument], html, { rootNode: this });
  }
  /**
   * Returns adopted style sheets.
   *
   * @returns Adopted style sheets.
   */
  get adoptedStyleSheets() {
    return this[adoptedStyleSheets];
  }
  /**
   * Sets adopted style sheets.
   *
   * @param value Adopted style sheets.
   */
  set adoptedStyleSheets(value2) {
    this[adoptedStyleSheets] = value2;
  }
  /**
   * Returns active element.
   *
   * @returns Active element.
   */
  get activeElement() {
    const activeElement$1 = this[ownerDocument][activeElement];
    if (activeElement$1 && activeElement$1[isConnected] && activeElement$1.getRootNode() === this) {
      return activeElement$1;
    }
    return null;
  }
  /**
   * Converts to string.
   *
   * @returns String.
   */
  toString() {
    return this.innerHTML;
  }
  /**
   * @override
   */
  [(_a$w = adoptedStyleSheets, _b$h = mode, _c$d = host, cloneNode)](deep = false) {
    const clone2 = super[cloneNode](deep);
    clone2[mode] = this.mode;
    return clone2;
  }
};
const COLOR_REGEXP = /^#([0-9a-fA-F]{3,4}){1,2}$|^rgb\(([^)]*)\)$|^rgba\(([^)]*)\)$|^hsla?\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*(,\s*(-?\d+|-?\d*.\d+)\s*)?\)/;
const LENGTH_REGEXP = /^(0|[-+]?[0-9]*\.?[0-9]+(in|cm|em|mm|pt|pc|px|ex|rem|vh|vw|ch|vw|vh|vmin|vmax|Q))$/;
const PERCENTAGE_REGEXP = /^[-+]?[0-9]*\.?[0-9]+%$/;
const DEGREE_REGEXP = /^[0-9]+deg$/;
const URL_REGEXP$1 = /^url\(\s*([^)]*)\s*\)$/;
const INTEGER_REGEXP = /^[0-9]+$/;
const FLOAT_REGEXP = /^[0-9.]+$/;
const CALC_REGEXP = /^calc\([^^)]+\)$/;
const CSS_VARIABLE_REGEXP$1 = /^var\( *(--[^) ]+)\)$/;
const FIT_CONTENT_REGEXP = /^fit-content\([^^)]+\)$/;
const GRADIENT_REGEXP = /^(repeating-linear|linear|radial|repeating-radial|conic|repeating-conic)-gradient\([^)]+\)$/;
const GLOBALS = ["inherit", "initial", "unset", "revert"];
const COLORS = [
  "none",
  "currentcolor",
  "transparent",
  "silver",
  "gray",
  "white",
  "maroon",
  "red",
  "purple",
  "fuchsia",
  "green",
  "lime",
  "olive",
  "yellow",
  "navy",
  "blue",
  "teal",
  "aliceblue",
  "aqua",
  "antiquewhite",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkgrey",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkslategrey",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dimgrey",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "greenyellow",
  "grey",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightgrey",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightslategrey",
  "lightsteelblue",
  "lightyellow",
  "limegreen",
  "linen",
  "magenta",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "oldlace",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "rebeccapurple",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "skyblue",
  "slateblue",
  "slategray",
  "slategrey",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "whitesmoke",
  "yellowgreen"
];
class CSSStyleDeclarationValueParser {
  /**
   * Returns length.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getLength(value2) {
    if (value2 === "0") {
      return "0px";
    }
    if (LENGTH_REGEXP.test(value2)) {
      return value2;
    }
    return null;
  }
  /**
   * Returns percentance.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getPercentage(value2) {
    if (value2 === "0") {
      return "0%";
    }
    if (PERCENTAGE_REGEXP.test(value2)) {
      return value2;
    }
    return null;
  }
  /**
   * Returns degree.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getDegree(value2) {
    if (value2 === "0") {
      return "0deg";
    }
    if (DEGREE_REGEXP.test(value2)) {
      return value2;
    }
    return null;
  }
  /**
   * Returns calc.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getCalc(value2) {
    if (CALC_REGEXP.test(value2)) {
      return value2;
    }
    return null;
  }
  /**
   * Returns fit content.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getFitContent(value2) {
    const lowerValue = value2.toLowerCase();
    if (lowerValue === "auto" || lowerValue === "max-content" || lowerValue === "min-content" || lowerValue === "fit-content") {
      return lowerValue;
    }
    if (FIT_CONTENT_REGEXP.test(lowerValue)) {
      return lowerValue;
    }
    return null;
  }
  /**
   * Returns measurement.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getMeasurement(value2) {
    return this.getLength(value2) || this.getPercentage(value2) || this.getCalc(value2);
  }
  /**
   * Returns measurement or auto, min-content, max-content or fit-content.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getContentMeasurement(value2) {
    return this.getFitContent(value2) || this.getMeasurement(value2);
  }
  /**
   * Returns measurement or auto, min-content, max-content or fit-content.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getAutoMeasurement(value2) {
    if (value2.toLocaleLowerCase() === "auto") {
      return "auto";
    }
    return this.getMeasurement(value2);
  }
  /**
   * Returns integer.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getInteger(value2) {
    if (INTEGER_REGEXP.test(value2)) {
      return value2;
    }
    return null;
  }
  /**
   * Returns float.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getFloat(value2) {
    if (FLOAT_REGEXP.test(value2)) {
      return value2;
    }
    return null;
  }
  /**
   * Returns gradient.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getGradient(value2) {
    if (GRADIENT_REGEXP.test(value2)) {
      return value2;
    }
    return null;
  }
  /**
   * Returns color.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getColor(value2) {
    const lowerValue = value2.toLowerCase();
    if (COLORS.includes(lowerValue)) {
      return lowerValue;
    }
    if (COLOR_REGEXP.test(value2)) {
      return value2.replace(/,([^ ])/g, ", $1");
    }
    return null;
  }
  /**
   * Returns URL.
   *
   * Based on:
   * https://github.com/jsdom/cssstyle/blob/master/lib/parsers.js#L222
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getURL(value2) {
    if (!value2) {
      return null;
    }
    if (value2.toLowerCase() === "none") {
      return "none";
    }
    const result = URL_REGEXP$1.exec(value2);
    if (!result) {
      return null;
    }
    let url = result[1];
    if ((url[0] === '"' || url[0] === "'") && url[0] !== url[url.length - 1]) {
      return null;
    }
    if (url[0] === '"' || url[0] === "'") {
      url = url.substring(1, url.length - 1);
    }
    for (let i = 0; i < url.length; i++) {
      switch (url[i]) {
        case "(":
        case ")":
        case " ":
        case "	":
        case "\n":
        case "'":
        case '"':
          return null;
        case "\\":
          i++;
          break;
      }
    }
    return `url("${url}")`;
  }
  /**
   * Returns global initial value.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getInitial(value2) {
    return value2.toLowerCase() === "initial" ? "initial" : null;
  }
  /**
   * Returns CSS variable.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getVariable(value2) {
    const cssVariableMatch = value2.match(CSS_VARIABLE_REGEXP$1);
    if (cssVariableMatch) {
      return `var(${cssVariableMatch[1]})`;
    }
    return null;
  }
  /**
   * Returns global.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getGlobal(value2) {
    const lowerValue = value2.toLowerCase();
    return GLOBALS.includes(lowerValue) ? lowerValue : null;
  }
  /**
   * Returns global, unless it is not set to 'initial' as it is sometimes treated different.
   *
   * @param value Value.
   * @returns Parsed value.
   */
  static getGlobalExceptInitial(value2) {
    const lowerValue = value2.toLowerCase();
    return lowerValue !== "initial" && GLOBALS.includes(lowerValue) ? lowerValue : null;
  }
}
const RECT_REGEXP = /^rect\((.*)\)$/i;
const SPLIT_PARTS_REGEXP = /,(?=(?:(?:(?!\))[\s\S])*\()|[^\(\)]*$)/;
const BORDER_STYLE = [
  "none",
  "hidden",
  "dotted",
  "dashed",
  "solid",
  "double",
  "groove",
  "ridge",
  "inset",
  "outset"
];
const BORDER_WIDTH = ["thin", "medium", "thick"];
const BORDER_COLLAPSE = ["separate", "collapse"];
const BACKGROUND_REPEAT = ["repeat", "repeat-x", "repeat-y", "no-repeat"];
const BACKGROUND_ORIGIN = ["border-box", "padding-box", "content-box"];
const BACKGROUND_CLIP = ["border-box", "padding-box", "content-box"];
const BACKGROUND_ATTACHMENT = ["scroll", "fixed"];
const FLEX_BASIS = ["auto", "fill", "content"];
const CLEAR = ["none", "left", "right", "both"];
const FLOAT = ["none", "left", "right", "inline-start", "inline-end"];
const SYSTEM_FONT = ["caption", "icon", "menu", "message-box", "small-caption", "status-bar"];
const FONT_WEIGHT = ["normal", "bold", "bolder", "lighter"];
const FONT_STYLE = ["normal", "italic", "oblique"];
const FONT_SIZE = [
  "xx-small",
  "x-small",
  "small",
  "medium",
  "large",
  "x-large",
  "xx-large",
  "xxx-large",
  "smaller",
  "larger"
];
const FONT_STRETCH = [
  "ultra-condensed",
  "extra-condensed",
  "condensed",
  "semi-condensed",
  "normal",
  "semi-expanded",
  "expanded",
  "extra-expanded",
  "ultra-expanded"
];
const DISPLAY = [
  /* Legacy values */
  "block",
  "inline",
  "inline-block",
  "flex",
  "inline-flex",
  "grid",
  "inline-grid",
  "flow-root",
  /* Box generation */
  "none",
  "contents",
  /* Two-value syntax */
  "block flow",
  "inline flow",
  "inline flow-root",
  "block flex",
  "inline flex",
  "block grid",
  "inline grid",
  "block flow-root",
  /* Other values */
  "table",
  "table-row",
  "list-item"
];
const BORDER_IMAGE_REPEAT = ["stretch", "repeat", "round", "space"];
const TEXT_TRANSFORM = [
  "capitalize",
  "uppercase",
  "lowercase",
  "none",
  "full-width",
  "full-size-kana"
];
const VISIBILITY = ["visible", "hidden", "collapse"];
class CSSStyleDeclarationPropertySetParser {
  /**
   * Returns border collapse.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderCollapse(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-collapse": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || BORDER_COLLAPSE.includes(lowerValue)) {
      return { "border-collapse": { value: lowerValue, important } };
    }
    return null;
  }
  /**
   * Returns display.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getDisplay(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { display: { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || DISPLAY.includes(lowerValue)) {
      return { display: { value: lowerValue, important } };
    }
    return null;
  }
  /**
   * Returns direction.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getDirection(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { direction: { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || lowerValue === "ltr" || lowerValue === "rtl") {
      return { direction: { value: lowerValue, important } };
    }
    return null;
  }
  /**
   * Returns letter spacing.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getLetterSpacing(value2, important) {
    const parsedValue = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getContentMeasurement(value2);
    return parsedValue ? { "letter-spacing": { value: parsedValue, important } } : null;
  }
  /**
   * Returns word spacing.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getWordSpacing(value2, important) {
    const parsedValue = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getContentMeasurement(value2);
    return parsedValue ? { "word-spacing": { value: parsedValue, important } } : null;
  }
  /**
   * Returns text indent.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getTextIndent(value2, important) {
    const parsedValue = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getContentMeasurement(value2);
    return parsedValue ? { "text-indent": { value: parsedValue, important } } : null;
  }
  /**
   * Returns width.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getWidth(value2, important) {
    const parsedValue = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getContentMeasurement(value2);
    return parsedValue ? { width: { value: parsedValue, important } } : null;
  }
  /**
   * Returns height.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getHeight(value2, important) {
    const parsedValue = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getContentMeasurement(value2);
    return parsedValue ? { height: { value: parsedValue, important } } : null;
  }
  /**
   * Returns top.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getTop(value2, important) {
    const parsedValue = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getContentMeasurement(value2);
    return parsedValue ? { top: { value: parsedValue, important } } : null;
  }
  /**
   * Returns top.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getRight(value2, important) {
    const parsedValue = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getContentMeasurement(value2);
    return parsedValue ? { right: { value: parsedValue, important } } : null;
  }
  /**
   * Returns top.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBottom(value2, important) {
    const parsedValue = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getContentMeasurement(value2);
    return parsedValue ? { bottom: { value: parsedValue, important } } : null;
  }
  /**
   * Returns top.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getLeft(value2, important) {
    const parsedValue = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getContentMeasurement(value2);
    return parsedValue ? { left: { value: parsedValue, important } } : null;
  }
  /**
   * Returns clear.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getClear(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { clear: { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || CLEAR.includes(lowerValue)) {
      return { clear: { value: lowerValue, important } };
    }
    return null;
  }
  /**
   * Returns clip
   *
   * Based on:
   * https://github.com/jsdom/cssstyle/blob/master/lib/properties/clip.js
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getClip(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { clip: { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || lowerValue === "auto") {
      return { clip: { value: lowerValue, important } };
    }
    const matches = lowerValue.match(RECT_REGEXP);
    if (!matches) {
      return null;
    }
    const parts = matches[1].split(/\s*,\s*/);
    if (parts.length !== 4) {
      return null;
    }
    for (const part of parts) {
      if (!CSSStyleDeclarationValueParser.getMeasurement(part)) {
        return null;
      }
    }
    return { clip: { value: value2, important } };
  }
  /**
   * Returns float.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFloat(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { float: { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || FLOAT.includes(lowerValue)) {
      return { float: { value: lowerValue, important } };
    }
    return null;
  }
  /**
   * Returns float.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getCSSFloat(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "css-float": { value: variable, important } };
    }
    const float = this.getFloat(value2, important);
    return float ? { "css-float": float["float"] } : null;
  }
  /**
   * Returns outline.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getOutline(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { outline: { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getOutlineColor(globalValue, important),
        ...this.getOutlineStyle(globalValue, important),
        ...this.getOutlineWidth(globalValue, important)
      };
    }
    const properties = {
      ...this.getOutlineColor("initial", important),
      ...this.getOutlineStyle("initial", important),
      ...this.getOutlineWidth("initial", important)
    };
    const parts = value2.split(/ +/);
    for (const part of parts) {
      const width2 = this.getOutlineWidth(part, important);
      const style2 = this.getOutlineStyle(part, important);
      const color = this.getOutlineColor(part, important);
      if (width2 === null && style2 === null && color === null) {
        return null;
      }
      Object.assign(properties, width2, style2, color);
    }
    return properties;
  }
  /**
   * Returns outline color.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getOutlineColor(value2, important) {
    const color = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getColor(value2);
    return color ? {
      "outline-color": { value: color, important }
    } : null;
  }
  /**
   * Returns outline offset.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getOutlineOffset(value2, important) {
    const parsedValue = CSSStyleDeclarationValueParser.getVariable(value2) || CSSStyleDeclarationValueParser.getLength(value2);
    return parsedValue ? { "outline-offset": { value: parsedValue, important } } : null;
  }
  /**
   * Returns outline style.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getOutlineStyle(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "outline-style": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || BORDER_STYLE.includes(lowerValue)) {
      return {
        "outline-style": { value: lowerValue, important }
      };
    }
    return null;
  }
  /**
   * Returns outline width.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getOutlineWidth(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "outline-width": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    const parsedValue = BORDER_WIDTH.includes(lowerValue) || CSSStyleDeclarationValueParser.getGlobal(lowerValue) ? lowerValue : CSSStyleDeclarationValueParser.getLength(value2);
    if (parsedValue) {
      return {
        "outline-width": { value: parsedValue, important }
      };
    }
    return null;
  }
  /**
   * Returns border.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBorder(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { border: { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBorderWidth(globalValue, important),
        ...this.getBorderStyle(globalValue, important),
        ...this.getBorderColor(globalValue, important),
        ...this.getBorderImage(globalValue, important)
      };
    }
    const properties = {
      ...this.getBorderWidth("initial", important),
      ...this.getBorderStyle("initial", important),
      ...this.getBorderColor("initial", important),
      ...this.getBorderImage("initial", important)
    };
    const parts = value2.replace(/ *, */g, ",").split(/ +/);
    for (const part of parts) {
      const width2 = this.getBorderWidth(part, important);
      const style2 = this.getBorderStyle(part, important);
      const color = this.getBorderColor(part, important);
      if (width2 === null && style2 === null && color === null) {
        return null;
      }
      Object.assign(properties, width2, style2, color);
    }
    return properties;
  }
  /**
   * Returns border width.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderWidth(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-width": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBorderTopWidth(globalValue, important),
        ...this.getBorderRightWidth(globalValue, important),
        ...this.getBorderBottomWidth(globalValue, important),
        ...this.getBorderLeftWidth(globalValue, important)
      };
    }
    const parts = value2.split(/ +/);
    const top2 = this.getBorderTopWidth(parts[0], important);
    const right2 = this.getBorderRightWidth(parts[1] || parts[0], important);
    const bottom2 = this.getBorderBottomWidth(parts[2] || parts[0], important);
    const left2 = this.getBorderLeftWidth(parts[3] || parts[1] || parts[0], important);
    if (!top2 || !right2 || !bottom2 || !left2) {
      return null;
    }
    return {
      ...top2,
      ...right2,
      ...bottom2,
      ...left2
    };
  }
  /**
   * Returns border style.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderStyle(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-style": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBorderTopStyle(globalValue, important),
        ...this.getBorderRightStyle(globalValue, important),
        ...this.getBorderBottomStyle(globalValue, important),
        ...this.getBorderLeftStyle(globalValue, important)
      };
    }
    const parts = value2.split(/ +/);
    const top2 = this.getBorderTopStyle(parts[0], important);
    const right2 = this.getBorderRightStyle(parts[1] || parts[0], important);
    const bottom2 = this.getBorderBottomStyle(parts[2] || parts[0], important);
    const left2 = this.getBorderLeftStyle(parts[3] || parts[1] || parts[0], important);
    if (!top2 || !right2 || !bottom2 || !left2) {
      return null;
    }
    return {
      ...top2,
      ...right2,
      ...bottom2,
      ...left2
    };
  }
  /**
   * Returns border color.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderColor(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-color": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBorderTopColor(globalValue, important),
        ...this.getBorderRightColor(globalValue, important),
        ...this.getBorderBottomColor(globalValue, important),
        ...this.getBorderLeftColor(globalValue, important)
      };
    }
    const parts = value2.split(/ +/);
    const top2 = this.getBorderTopColor(parts[0], important);
    const right2 = this.getBorderRightColor(parts[1] || parts[0], important);
    const bottom2 = this.getBorderBottomColor(parts[2] || parts[0], important);
    const left2 = this.getBorderLeftColor(parts[3] || parts[1] || parts[0], important);
    if (!top2 || !right2 || !bottom2 || !left2) {
      return null;
    }
    return {
      ...top2,
      ...right2,
      ...bottom2,
      ...left2
    };
  }
  /**
   * Returns border image.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderImage(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-image": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBorderImageSource(globalValue, important),
        ...this.getBorderImageSlice(globalValue, important),
        ...this.getBorderImageWidth(globalValue, important),
        ...this.getBorderImageOutset(globalValue, important),
        ...this.getBorderImageRepeat(globalValue, important)
      };
    }
    let parsedValue = value2.replace(/[ ]*\/[ ]*/g, "/");
    const sourceMatch = parsedValue.match(/ *([a-zA-Z-]+\([^)]*\)) */);
    if (sourceMatch) {
      parsedValue = parsedValue.replace(sourceMatch[0], "");
    }
    const parts = parsedValue.split(/ +/);
    if (sourceMatch) {
      parts.push(sourceMatch[1]);
    }
    const properties = {
      ...this.getBorderImageSource("none", important),
      ...this.getBorderImageSlice("100%", important),
      ...this.getBorderImageWidth("1", important),
      ...this.getBorderImageOutset("0", important),
      ...this.getBorderImageRepeat("stretch", important)
    };
    for (let i = 0, max2 = parts.length; i < max2; i++) {
      const part = parts[i];
      const previousPart = i > 0 ? parts[i - 1] : "";
      if (!part.startsWith("url") && part.includes("/")) {
        const [slice, width2, outset] = part.split("/");
        const borderImageSlice = this.getBorderImageSlice(`${previousPart} ${slice}`, important) || this.getBorderImageSlice(slice, important);
        const borderImageWidth = this.getBorderImageWidth(width2, important);
        const borderImageOutset = outset && this.getBorderImageOutset(outset, important);
        if (!borderImageSlice || !borderImageWidth || borderImageOutset === null) {
          return null;
        }
        Object.assign(properties, borderImageSlice, borderImageWidth, borderImageOutset);
      } else {
        const slice = this.getBorderImageSlice(`${previousPart} ${part}`, important) || this.getBorderImageSlice(part, important);
        const source = this.getBorderImageSource(part, important);
        const repeat = this.getBorderImageRepeat(part, important);
        if (!slice && !source && !repeat) {
          return null;
        }
        Object.assign(properties, slice, source, repeat);
      }
    }
    return properties;
  }
  /**
   * Returns border source.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderImageSource(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-image-source": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || lowerValue === "none") {
      return {
        "border-image-source": {
          important,
          value: lowerValue
        }
      };
    }
    const parsedValue = CSSStyleDeclarationValueParser.getURL(value2) || CSSStyleDeclarationValueParser.getGradient(value2);
    if (!parsedValue) {
      return null;
    }
    return {
      "border-image-source": {
        important,
        value: parsedValue
      }
    };
  }
  /**
   * Returns border slice.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderImageSlice(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-image-slice": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue)) {
      return {
        "border-image-slice": {
          important,
          value: lowerValue
        }
      };
    }
    if (lowerValue !== lowerValue.trim()) {
      return null;
    }
    const regexp = /(fill)|(calc\([^^)]+\))|([0-9]+%)|([0-9]+)/g;
    const values = [];
    let match2;
    while (match2 = regexp.exec(lowerValue)) {
      const previousCharacter = lowerValue[match2.index - 1];
      const nextCharacter = lowerValue[match2.index + match2[0].length];
      if (previousCharacter && previousCharacter !== " " || nextCharacter && nextCharacter !== " ") {
        return null;
      }
      const fill = match2[1] && "fill";
      const calc = match2[2] && CSSStyleDeclarationValueParser.getCalc(match2[2]);
      const percentage = match2[3] && CSSStyleDeclarationValueParser.getPercentage(match2[3]);
      const integer = match2[4] && CSSStyleDeclarationValueParser.getInteger(match2[4]);
      if (!fill && !calc && !percentage && !integer) {
        return null;
      }
      values.push(fill || calc || percentage || integer);
    }
    if (!values.length || values.length > 4) {
      return null;
    }
    return {
      "border-image-slice": {
        important,
        value: values.join(" ")
      }
    };
  }
  /**
   * Returns border width.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderImageWidth(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-image-width": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue)) {
      return {
        "border-image-width": {
          important,
          value: lowerValue
        }
      };
    }
    const parts = lowerValue.split(/ +/);
    if (parts.length > 4) {
      return null;
    }
    for (const part of parts) {
      if (!CSSStyleDeclarationValueParser.getInteger(part) && !CSSStyleDeclarationValueParser.getAutoMeasurement(part)) {
        return null;
      }
    }
    return {
      "border-image-width": {
        important,
        value: value2
      }
    };
  }
  /**
   * Returns border outset.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderImageOutset(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-image-outset": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue)) {
      return {
        "border-image-outset": {
          important,
          value: lowerValue
        }
      };
    }
    const parts = value2.split(/ +/);
    if (parts.length > 4) {
      return null;
    }
    for (const part of parts) {
      if (!CSSStyleDeclarationValueParser.getLength(part) && !CSSStyleDeclarationValueParser.getFloat(part)) {
        return null;
      }
    }
    return {
      "border-image-outset": {
        important,
        value: value2
      }
    };
  }
  /**
   * Returns border repeat.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderImageRepeat(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-image-repeat": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue)) {
      return {
        "border-image-repeat": {
          important,
          value: lowerValue
        }
      };
    }
    const parts = lowerValue.split(/ +/);
    if (parts.length > 2) {
      return null;
    }
    for (const part of parts) {
      if (!BORDER_IMAGE_REPEAT.includes(part)) {
        return null;
      }
    }
    return {
      "border-image-repeat": {
        important,
        value: value2
      }
    };
  }
  /**
   * Returns border width.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderTopWidth(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-top-width": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    const parsedValue = BORDER_WIDTH.includes(lowerValue) || CSSStyleDeclarationValueParser.getGlobal(lowerValue) ? lowerValue : CSSStyleDeclarationValueParser.getLength(value2);
    if (parsedValue) {
      return {
        "border-top-width": { value: parsedValue, important }
      };
    }
    return null;
  }
  /**
   * Returns border width.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderRightWidth(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-right-width": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    const parsedValue = BORDER_WIDTH.includes(lowerValue) || CSSStyleDeclarationValueParser.getGlobal(lowerValue) ? lowerValue : CSSStyleDeclarationValueParser.getLength(value2);
    if (parsedValue) {
      return {
        "border-right-width": { value: parsedValue, important }
      };
    }
    return null;
  }
  /**
   * Returns border width.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderBottomWidth(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-bottom-width": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    const parsedValue = BORDER_WIDTH.includes(lowerValue) || CSSStyleDeclarationValueParser.getGlobal(lowerValue) ? lowerValue : CSSStyleDeclarationValueParser.getLength(value2);
    if (parsedValue) {
      return {
        "border-bottom-width": { value: parsedValue, important }
      };
    }
    return null;
  }
  /**
   * Returns border width.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderLeftWidth(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-left-width": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    const parsedValue = BORDER_WIDTH.includes(lowerValue) || CSSStyleDeclarationValueParser.getGlobal(lowerValue) ? lowerValue : CSSStyleDeclarationValueParser.getLength(value2);
    if (parsedValue) {
      return {
        "border-left-width": { value: parsedValue, important }
      };
    }
    return null;
  }
  /**
   * Returns border style.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderTopStyle(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-top-style": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || BORDER_STYLE.includes(lowerValue)) {
      return {
        "border-top-style": { value: lowerValue, important }
      };
    }
    return null;
  }
  /**
   * Returns border style.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderRightStyle(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-right-style": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || BORDER_STYLE.includes(lowerValue)) {
      return {
        "border-right-style": { value: lowerValue, important }
      };
    }
    return null;
  }
  /**
   * Returns border style.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderBottomStyle(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-bottom-style": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || BORDER_STYLE.includes(lowerValue)) {
      return {
        "border-bottom-style": { value: lowerValue, important }
      };
    }
    return null;
  }
  /**
   * Returns border style.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderLeftStyle(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-left-style": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || BORDER_STYLE.includes(lowerValue)) {
      return {
        "border-left-style": { value: lowerValue, important }
      };
    }
    return null;
  }
  /**
   * Returns border color.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderTopColor(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-top-color": { value: variable, important } };
    }
    const color = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getColor(value2);
    return color ? {
      "border-top-color": { value: color, important }
    } : null;
  }
  /**
   * Returns border color.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderRightColor(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-right-color": { value: variable, important } };
    }
    const color = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getColor(value2);
    return color ? {
      "border-right-color": { value: color, important }
    } : null;
  }
  /**
   * Returns border color.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderBottomColor(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-bottom-color": { value: variable, important } };
    }
    const color = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getColor(value2);
    return color ? {
      "border-bottom-color": { value: color, important }
    } : null;
  }
  /**
   * Returns border color.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBorderLeftColor(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-left-color": { value: variable, important } };
    }
    const color = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getColor(value2);
    return color ? {
      "border-left-color": { value: color, important }
    } : null;
  }
  /**
   * Returns border radius.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBorderRadius(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-radius": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBorderTopLeftRadius(globalValue, important),
        ...this.getBorderTopRightRadius(globalValue, important),
        ...this.getBorderBottomRightRadius(globalValue, important),
        ...this.getBorderBottomLeftRadius(globalValue, important)
      };
    }
    const parts = value2.split(/ +/);
    const topLeft = this.getBorderTopLeftRadius(parts[0], important);
    const topRight = this.getBorderTopRightRadius(parts[1] || parts[0], important);
    const bottomRight = this.getBorderBottomRightRadius(parts[2] || parts[0], important);
    const bottomLeft = this.getBorderBottomLeftRadius(parts[3] || parts[1] || parts[0], important);
    if (!topLeft || !topRight || !bottomRight || !bottomLeft) {
      return null;
    }
    return {
      ...topLeft,
      ...topRight,
      ...bottomRight,
      ...bottomLeft
    };
  }
  /**
   * Returns border radius.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBorderTopLeftRadius(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-top-left-radius": { value: variable, important } };
    }
    const radius = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getMeasurement(value2);
    return radius ? { "border-top-left-radius": { important, value: radius } } : null;
  }
  /**
   * Returns border radius.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBorderTopRightRadius(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-top-right-radius": { value: variable, important } };
    }
    const radius = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getMeasurement(value2);
    return radius ? { "border-top-right-radius": { important, value: radius } } : null;
  }
  /**
   * Returns border radius.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBorderBottomRightRadius(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-bottom-right-radius": { value: variable, important } };
    }
    const radius = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getMeasurement(value2);
    return radius ? { "border-bottom-right-radius": { important, value: radius } } : null;
  }
  /**
   * Returns border radius.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBorderBottomLeftRadius(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-bottom-left-radius": { value: variable, important } };
    }
    const radius = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getMeasurement(value2);
    return radius ? { "border-bottom-left-radius": { important, value: radius } } : null;
  }
  /**
   * Returns border top, right, bottom or left.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBorderTop(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-top": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBorderTopWidth(globalValue, important),
        ...this.getBorderTopStyle(globalValue, important),
        ...this.getBorderTopColor(globalValue, important)
      };
    }
    const properties = {
      ...this.getBorderTopWidth("initial", important),
      ...this.getBorderTopStyle("initial", important),
      ...this.getBorderTopColor("initial", important)
    };
    const parts = value2.split(/ +/);
    for (const part of parts) {
      const width2 = this.getBorderTopWidth(part, important);
      const style2 = this.getBorderTopStyle(part, important);
      const color = this.getBorderTopColor(part, important);
      if (width2 === null && style2 === null && color === null) {
        return null;
      }
      Object.assign(properties, width2, style2, color);
    }
    return properties;
  }
  /**
   * Returns border top, right, bottom or left.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBorderRight(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-right": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBorderRightWidth(globalValue, important),
        ...this.getBorderRightStyle(globalValue, important),
        ...this.getBorderRightColor(globalValue, important)
      };
    }
    const properties = {
      ...this.getBorderRightWidth("initial", important),
      ...this.getBorderRightStyle("initial", important),
      ...this.getBorderRightColor("initial", important)
    };
    const parts = value2.split(/ +/);
    for (const part of parts) {
      const width2 = this.getBorderRightWidth(part, important);
      const style2 = this.getBorderRightStyle(part, important);
      const color = this.getBorderRightColor(part, important);
      if (width2 === null && style2 === null && color === null) {
        return null;
      }
      Object.assign(properties, width2, style2, color);
    }
    return properties;
  }
  /**
   * Returns border top, right, bottom or left.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBorderBottom(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-bottom": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBorderBottomWidth(globalValue, important),
        ...this.getBorderBottomStyle(globalValue, important),
        ...this.getBorderBottomColor(globalValue, important)
      };
    }
    const properties = {
      ...this.getBorderBottomWidth("initial", important),
      ...this.getBorderBottomStyle("initial", important),
      ...this.getBorderBottomColor("initial", important)
    };
    const parts = value2.split(/ +/);
    for (const part of parts) {
      const width2 = this.getBorderBottomWidth(part, important);
      const style2 = this.getBorderBottomStyle(part, important);
      const color = this.getBorderBottomColor(part, important);
      if (width2 === null && style2 === null && color === null) {
        return null;
      }
      Object.assign(properties, width2, style2, color);
    }
    return properties;
  }
  /**
   * Returns border top, right, bottom or left.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBorderLeft(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "border-left": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBorderLeftWidth(globalValue, important),
        ...this.getBorderLeftStyle(globalValue, important),
        ...this.getBorderLeftColor(globalValue, important)
      };
    }
    const properties = {
      ...this.getBorderLeftWidth("initial", important),
      ...this.getBorderLeftStyle("initial", important),
      ...this.getBorderLeftColor("initial", important)
    };
    const parts = value2.split(/ +/);
    for (const part of parts) {
      const width2 = this.getBorderLeftWidth(part, important);
      const style2 = this.getBorderLeftStyle(part, important);
      const color = this.getBorderLeftColor(part, important);
      if (width2 === null && style2 === null && color === null) {
        return null;
      }
      Object.assign(properties, width2, style2, color);
    }
    return properties;
  }
  /**
   * Returns padding.
   *
   * @param value Value.
   * @param important Important.
   */
  static getPadding(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { padding: { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getPaddingTop(globalValue, important),
        ...this.getPaddingRight(globalValue, important),
        ...this.getPaddingBottom(globalValue, important),
        ...this.getPaddingLeft(globalValue, important)
      };
    }
    const parts = value2.split(/ +/);
    const top2 = this.getPaddingTop(parts[0], important);
    const right2 = this.getPaddingRight(parts[1] || parts[0], important);
    const bottom2 = this.getPaddingBottom(parts[2] || parts[0], important);
    const left2 = this.getPaddingLeft(parts[3] || parts[1] || parts[0], important);
    if (!top2 || !right2 || !bottom2 || !left2) {
      return null;
    }
    return {
      ...top2,
      ...right2,
      ...bottom2,
      ...left2
    };
  }
  /**
   * Returns padding top.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getPaddingTop(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "padding-top": { value: variable, important } };
    }
    const padding = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getMeasurement(value2);
    return padding ? { "padding-top": { value: padding, important } } : null;
  }
  /**
   * Returns padding right.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getPaddingRight(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "padding-right": { value: variable, important } };
    }
    const padding = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getMeasurement(value2);
    return padding ? { "padding-right": { value: padding, important } } : null;
  }
  /**
   * Returns padding bottom.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getPaddingBottom(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "padding-bottom": { value: variable, important } };
    }
    const padding = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getMeasurement(value2);
    return padding ? { "padding-bottom": { value: padding, important } } : null;
  }
  /**
   * Returns padding left.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getPaddingLeft(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "padding-left": { value: variable, important } };
    }
    const padding = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getMeasurement(value2);
    return padding ? { "padding-left": { value: padding, important } } : null;
  }
  /**
   * Returns margin.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getMargin(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { margin: { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getMarginTop(globalValue, important),
        ...this.getMarginRight(globalValue, important),
        ...this.getMarginBottom(globalValue, important),
        ...this.getMarginLeft(globalValue, important)
      };
    }
    const parts = value2.split(/ +/);
    const top2 = this.getMarginTop(parts[0], important);
    const right2 = this.getMarginRight(parts[1] || parts[0], important);
    const bottom2 = this.getMarginBottom(parts[2] || parts[0], important);
    const left2 = this.getMarginLeft(parts[3] || parts[1] || parts[0], important);
    if (!top2 || !right2 || !bottom2 || !left2) {
      return null;
    }
    return {
      ...top2,
      ...right2,
      ...bottom2,
      ...left2
    };
  }
  /**
   * Returns margin top.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getMarginTop(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "margin-top": { value: variable, important } };
    }
    const margin = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getAutoMeasurement(value2);
    return margin ? { "margin-top": { value: margin, important } } : null;
  }
  /**
   * Returns margin right.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getMarginRight(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "margin-right": { value: variable, important } };
    }
    const margin = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getAutoMeasurement(value2);
    return margin ? { "margin-right": { value: margin, important } } : null;
  }
  /**
   * Returns margin right.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getMarginBottom(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "margin-bottom": { value: variable, important } };
    }
    const margin = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getAutoMeasurement(value2);
    return margin ? { "margin-bottom": { value: margin, important } } : null;
  }
  /**
   * Returns margin left.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getMarginLeft(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "margin-left": { value: variable, important } };
    }
    const margin = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getAutoMeasurement(value2);
    return margin ? { "margin-left": { value: margin, important } } : null;
  }
  /**
   * Returns flex.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getFlex(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { flex: { value: variable, important } };
    }
    const lowerValue = value2.trim().toLowerCase();
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getFlexGrow(globalValue, important),
        ...this.getFlexShrink(globalValue, important),
        ...this.getFlexBasis(globalValue, important)
      };
    }
    switch (lowerValue) {
      case "none":
        return {
          ...this.getFlexGrow("0", important),
          ...this.getFlexShrink("0", important),
          ...this.getFlexBasis("auto", important)
        };
      case "auto":
        return {
          ...this.getFlexGrow("1", important),
          ...this.getFlexShrink("1", important),
          ...this.getFlexBasis("auto", important)
        };
    }
    const measurement = CSSStyleDeclarationValueParser.getContentMeasurement(lowerValue);
    if (measurement) {
      return {
        ...this.getFlexGrow("1", important),
        ...this.getFlexShrink("1", important),
        ...this.getFlexBasis(measurement, important)
      };
    }
    const parts = value2.split(/ +/);
    const flexGrow = this.getFlexGrow(parts[0], important);
    const flexShrink = this.getFlexShrink(parts[1] || "1", important);
    const flexBasis = this.getFlexBasis(parts[2] || "0%", important);
    if (!flexGrow || !flexShrink || !flexBasis) {
      return null;
    }
    return {
      ...flexGrow,
      ...flexShrink,
      ...flexBasis
    };
  }
  /**
   * Returns flex basis.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFlexBasis(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "flex-basis": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || FLEX_BASIS.includes(lowerValue)) {
      return { "flex-basis": { value: lowerValue, important } };
    }
    const measurement = CSSStyleDeclarationValueParser.getContentMeasurement(lowerValue);
    return measurement ? { "flex-basis": { value: measurement, important } } : null;
  }
  /**
   * Returns flex shrink.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFlexShrink(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "flex-shrink": { value: variable, important } };
    }
    const parsedValue = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getFloat(value2);
    return parsedValue ? { "flex-shrink": { value: parsedValue, important } } : null;
  }
  /**
   * Returns flex grow.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFlexGrow(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "flex-grow": { value: variable, important } };
    }
    const parsedValue = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getFloat(value2);
    return parsedValue ? { "flex-grow": { value: parsedValue, important } } : null;
  }
  /**
   * Returns background.
   *
   * @param name Name.
   * @param value Value.
   * @param important Important.
   * @returns Property values.
   */
  static getBackground(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { background: { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBackgroundImage(globalValue, important),
        ...this.getBackgroundPosition(globalValue, important),
        ...this.getBackgroundSize(globalValue, important),
        ...this.getBackgroundRepeat(globalValue, important),
        ...this.getBackgroundAttachment(globalValue, important),
        ...this.getBackgroundOrigin(globalValue, important),
        ...this.getBackgroundClip(globalValue, important),
        ...this.getBackgroundColor(globalValue, important)
      };
    }
    const properties = {
      ...this.getBackgroundImage("initial", important),
      ...this.getBackgroundPosition("initial", important),
      ...this.getBackgroundSize("initial", important),
      ...this.getBackgroundRepeat("initial", important),
      ...this.getBackgroundAttachment("initial", important),
      ...this.getBackgroundOrigin("initial", important),
      ...this.getBackgroundClip("initial", important),
      ...this.getBackgroundColor("initial", important)
    };
    const parts = value2.replace(/[ ]*,[ ]*/g, ",").replace(/[ ]*\/[ ]*/g, "/").split(/ +/);
    const backgroundPositions = [];
    for (const part of parts) {
      if (!part.startsWith("url") && part.includes("/")) {
        const [position, size] = part.split("/");
        const backgroundPositionX = this.getBackgroundPositionX(position, important);
        const backgroundPositionY = this.getBackgroundPositionY(position, important);
        const backgroundSize = this.getBackgroundSize(size, important);
        if (!backgroundPositionX && !backgroundPositionY || !backgroundSize) {
          return null;
        }
        if (backgroundPositionY) {
          backgroundPositions.push(backgroundPositionY["background-position-y"].value);
        } else if (backgroundPositionX) {
          backgroundPositions.push(backgroundPositionX["background-position-x"].value);
        }
        Object.assign(properties, backgroundSize);
      } else {
        const backgroundImage = this.getBackgroundImage(part, important);
        const backgroundRepeat = this.getBackgroundRepeat(part, important);
        const backgroundAttachment = this.getBackgroundAttachment(part, important);
        const backgroundPositionX = this.getBackgroundPositionX(part, important);
        const backgroundPositionY = this.getBackgroundPositionY(part, important);
        const backgroundColor = this.getBackgroundColor(part, important);
        const backgroundOrigin = this.getBackgroundOrigin(part, important);
        const backgroundClip = this.getBackgroundClip(part, important);
        if (!backgroundImage && !backgroundRepeat && !backgroundAttachment && !backgroundPositionX && !backgroundPositionY && !backgroundColor && !backgroundOrigin && !backgroundClip) {
          return null;
        }
        if (backgroundPositionX) {
          backgroundPositions.push(backgroundPositionX["background-position-x"].value);
        } else if (backgroundPositionY) {
          backgroundPositions.push(backgroundPositionY["background-position-y"].value);
        }
        Object.assign(properties, backgroundImage, backgroundRepeat, backgroundAttachment, backgroundColor, backgroundOrigin, backgroundClip);
      }
    }
    if (backgroundPositions.length) {
      Object.assign(properties, this.getBackgroundPosition(backgroundPositions.join(" "), important));
    }
    return properties;
  }
  /**
   * Returns background size.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBackgroundSize(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "background-size": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue)) {
      return { "background-size": { value: lowerValue, important } };
    }
    const imageParts = lowerValue.split(SPLIT_PARTS_REGEXP);
    const parsed = [];
    for (const imagePart of imageParts) {
      const parts = imagePart.trim().split(" ");
      if (parts.length !== 1 && parts.length !== 2) {
        return null;
      }
      if (parts.length === 1) {
        if (parts[0] !== "cover" && parts[0] !== "contain" && !CSSStyleDeclarationValueParser.getAutoMeasurement(parts[0])) {
          return null;
        }
        parsed.push(parts[0]);
      } else {
        if (!CSSStyleDeclarationValueParser.getAutoMeasurement(parts[0]) || !CSSStyleDeclarationValueParser.getAutoMeasurement(parts[1])) {
          return null;
        }
        parsed.push(`${parts[0]} ${parts[1]}`);
      }
    }
    if (parsed.length === 1) {
      return { "background-size": { value: parsed.join(", "), important } };
    }
    return null;
  }
  /**
   * Returns background origin.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBackgroundOrigin(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "background-origin": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || BACKGROUND_ORIGIN.includes(lowerValue)) {
      return { "background-origin": { value: lowerValue, important } };
    }
    return null;
  }
  /**
   * Returns background clip.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBackgroundClip(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "background-clip": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || BACKGROUND_CLIP.includes(lowerValue)) {
      return { "background-clip": { value: lowerValue, important } };
    }
    return null;
  }
  /**
   * Returns background repeat.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBackgroundRepeat(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "background-repeat": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || BACKGROUND_REPEAT.includes(lowerValue)) {
      return { "background-repeat": { value: lowerValue, important } };
    }
    return null;
  }
  /**
   * Returns background attachment.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBackgroundAttachment(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "background-attachment": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || BACKGROUND_ATTACHMENT.includes(lowerValue)) {
      return { "background-attachment": { value: lowerValue, important } };
    }
    return null;
  }
  /**
   * Returns background position.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBackgroundPosition(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "background-position": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return {
        ...this.getBackgroundPositionX(globalValue, important),
        ...this.getBackgroundPositionY(globalValue, important)
      };
    }
    const imageParts = value2.split(SPLIT_PARTS_REGEXP);
    let x2 = "";
    let y2 = "";
    for (const imagePart of imageParts) {
      const parts = imagePart.trim().split(/ +/);
      if (x2) {
        x2 += ",";
        y2 += ",";
      }
      switch (parts.length) {
        case 1:
          if (parts[0] === "top" || parts[0] === "bottom") {
            x2 += "center";
            y2 += parts[0];
          } else if (parts[0] === "left" || parts[0] === "right") {
            x2 += parts[0];
            y2 += "center";
          } else if (parts[0] === "center") {
            x2 += "center";
            y2 += "center";
          }
          break;
        case 2:
          x2 += parts[0] === "top" || parts[0] === "bottom" ? parts[1] : parts[0];
          y2 += parts[0] === "top" || parts[0] === "bottom" ? parts[0] : parts[1];
          break;
        case 3:
          if (parts[0] === "top" || parts[0] === "bottom" || parts[1] === "left" || parts[1] === "right" || parts[2] === "left" || parts[2] === "right") {
            if (CSSStyleDeclarationValueParser.getMeasurement(parts[1])) {
              x2 += parts[2];
              y2 += `${parts[0]} ${parts[1]}`;
            } else {
              x2 += `${parts[1]} ${parts[2]}`;
              y2 += parts[0];
            }
          } else {
            if (CSSStyleDeclarationValueParser.getMeasurement(parts[1])) {
              x2 += `${parts[0]} ${parts[1]}`;
              y2 += parts[2];
            } else {
              x2 += parts[0];
              y2 += `${parts[1]} ${parts[2]}`;
            }
          }
          break;
        case 4:
          x2 += parts[0] === "top" || parts[0] === "bottom" || parts[1] === "top" || parts[1] === "bottom" ? `${parts[2]} ${parts[3]}` : `${parts[0]} ${parts[1]}`;
          y2 += parts[0] === "top" || parts[0] === "bottom" || parts[1] === "top" || parts[1] === "bottom" ? `${parts[0]} ${parts[1]}` : `${parts[2]} ${parts[3]}`;
          break;
        default:
          return null;
      }
    }
    const xValue = this.getBackgroundPositionX(x2, important);
    const yValue = this.getBackgroundPositionY(y2, important);
    if (xValue && yValue) {
      return {
        ...xValue,
        ...yValue
      };
    }
    return null;
  }
  /**
   * Returns background position.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBackgroundPositionX(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "background-position-x": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue)) {
      return { "background-position-x": { value: lowerValue, important } };
    }
    const imageParts = lowerValue.split(SPLIT_PARTS_REGEXP);
    let parsedValue = "";
    for (const imagePart of imageParts) {
      const parts = imagePart.trim().split(/ +/);
      if (parsedValue) {
        parsedValue += ",";
      }
      for (const part of parts) {
        const measurement = CSSStyleDeclarationValueParser.getMeasurement(part);
        if (!measurement && part !== "left" && part !== "right" && part !== "center") {
          return null;
        }
        if (parsedValue) {
          parsedValue += " ";
        }
        parsedValue += measurement || part;
      }
    }
    return { "background-position-x": { value: parsedValue, important } };
  }
  /**
   * Returns background position.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getBackgroundPositionY(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "background-position-y": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue)) {
      return { "background-position-y": { value: lowerValue, important } };
    }
    const imageParts = lowerValue.split(SPLIT_PARTS_REGEXP);
    let parsedValue = "";
    for (const imagePart of imageParts) {
      const parts = imagePart.trim().split(/ +/);
      if (parsedValue) {
        parsedValue += ",";
      }
      for (const part of parts) {
        const measurement = CSSStyleDeclarationValueParser.getMeasurement(part);
        if (!measurement && part !== "top" && part !== "bottom" && part !== "center") {
          return null;
        }
        if (parsedValue) {
          parsedValue += " ";
        }
        parsedValue += measurement || part;
      }
    }
    return { "background-position-y": { value: parsedValue, important } };
  }
  /**
   * Returns background color.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property value.
   */
  static getBackgroundColor(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "background-color": { value: variable, important } };
    }
    const color = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getColor(value2);
    return color ? {
      ["background-color"]: { important, value: color }
    } : null;
  }
  /**
   * Returns background image.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property value.
   */
  static getBackgroundImage(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "background-image": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || lowerValue === "none") {
      return { "background-image": { value: lowerValue, important } };
    }
    const parts = value2.split(SPLIT_PARTS_REGEXP);
    const parsed = [];
    for (const part of parts) {
      const url = CSSStyleDeclarationValueParser.getURL(part.trim());
      if (!url) {
        return null;
      }
      parsed.push(url);
    }
    if (parsed.length) {
      return { "background-image": { value: parsed.join(", "), important } };
    }
    return null;
  }
  /**
   * Returns color.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property value.
   */
  static getColor(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { color: { value: variable, important } };
    }
    const color = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getColor(value2);
    return color ? { color: { important, value: color } } : null;
  }
  /**
   * Returns color.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property value.
   */
  static getFloodColor(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "flood-color": { value: variable, important } };
    }
    const color = CSSStyleDeclarationValueParser.getGlobal(value2) || CSSStyleDeclarationValueParser.getColor(value2);
    return color ? { "flood-color": { important, value: color } } : null;
  }
  /**
   * Returns font.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFont(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { font: { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue)) {
      return {
        ...this.getFontStyle(lowerValue, important),
        ...this.getFontVariant(lowerValue, important),
        ...this.getFontWeight(lowerValue, important),
        ...this.getFontStretch(lowerValue, important),
        ...this.getFontSize(lowerValue, important),
        ...this.getLineHeight(lowerValue, important),
        ...this.getFontFamily(lowerValue, important)
      };
    }
    if (SYSTEM_FONT.includes(lowerValue)) {
      return { font: { value: lowerValue, important } };
    }
    const properties = {
      ...this.getFontStyle("normal", important),
      ...this.getFontVariant("normal", important),
      ...this.getFontWeight("normal", important),
      ...this.getFontStretch("normal", important),
      ...this.getLineHeight("normal", important)
    };
    const parts = value2.replace(/ *\/ */g, "/").split(/ +/);
    for (let i = 0, max2 = parts.length; i < max2; i++) {
      const part = parts[i];
      if (part.includes("/")) {
        const [size, height2] = part.split("/");
        const fontSize = this.getFontSize(size, important);
        const lineHeight = this.getLineHeight(height2, important);
        if (!fontSize || !lineHeight) {
          return null;
        }
        Object.assign(properties, fontSize, lineHeight);
      } else {
        const fontStyle = this.getFontStyle(part, important);
        const fontVariant = this.getFontVariant(part, important);
        const fontWeight = this.getFontWeight(part, important);
        const fontSize = this.getFontSize(part, important);
        const fontStretch = this.getFontStretch(part, important);
        if (fontStyle) {
          Object.assign(properties, fontStyle);
        } else if (fontVariant) {
          Object.assign(properties, fontVariant);
        } else if (fontWeight) {
          Object.assign(properties, fontWeight);
        } else if (fontSize) {
          Object.assign(properties, fontSize);
        } else if (fontStretch) {
          Object.assign(properties, fontStretch);
        } else {
          const fontFamilyValue = parts.slice(i).join(" ");
          const fontFamily = this.getFontFamily(fontFamilyValue, important);
          if (!fontFamily) {
            return null;
          }
          Object.assign(properties, fontFamily);
          break;
        }
      }
    }
    return properties;
  }
  /**
   * Returns font style.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFontStyle(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "font-style": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || FONT_STYLE.includes(lowerValue)) {
      return { "font-style": { value: lowerValue, important } };
    }
    const parts = value2.split(/ +/);
    if (parts.length === 2 && parts[0] === "oblique") {
      const degree = CSSStyleDeclarationValueParser.getDegree(parts[1]);
      return degree ? { "font-style": { value: lowerValue, important } } : null;
    }
    return null;
  }
  /**
   * Returns font variant.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFontVariant(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "font-variant": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    return CSSStyleDeclarationValueParser.getGlobal(lowerValue) || lowerValue === "normal" || lowerValue === "small-caps" ? { "font-variant": { value: lowerValue, important } } : null;
  }
  /**
   * Returns font strech.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFontStretch(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "font-stretch": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || FONT_STRETCH.includes(lowerValue)) {
      return { "font-stretch": { value: lowerValue, important } };
    }
    const percentage = CSSStyleDeclarationValueParser.getPercentage(value2);
    return percentage ? { "font-stretch": { value: percentage, important } } : null;
  }
  /**
   * Returns font weight.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFontWeight(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "font-weight": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || FONT_WEIGHT.includes(lowerValue)) {
      return { "font-weight": { value: lowerValue, important } };
    }
    const integer = CSSStyleDeclarationValueParser.getInteger(value2);
    return integer ? { "font-weight": { value: integer, important } } : null;
  }
  /**
   * Returns font size.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFontSize(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "font-size": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || FONT_SIZE.includes(lowerValue)) {
      return { "font-size": { value: lowerValue, important } };
    }
    const measurement = CSSStyleDeclarationValueParser.getMeasurement(value2);
    return measurement ? { "font-size": { value: measurement, important } } : null;
  }
  /**
   * Returns line height.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getLineHeight(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "line-height": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    if (CSSStyleDeclarationValueParser.getGlobal(lowerValue) || lowerValue === "normal") {
      return { "line-height": { value: lowerValue, important } };
    }
    const lineHeight = CSSStyleDeclarationValueParser.getFloat(value2) || CSSStyleDeclarationValueParser.getMeasurement(value2);
    return lineHeight ? { "line-height": { value: lineHeight, important } } : null;
  }
  /**
   * Returns font family.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getFontFamily(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "font-family": { value: variable, important } };
    }
    const globalValue = CSSStyleDeclarationValueParser.getGlobal(value2);
    if (globalValue) {
      return { "font-family": { value: globalValue, important } };
    }
    const parts = value2.split(",");
    let parsedValue = "";
    let endWithApostroph = false;
    for (let i = 0, max2 = parts.length; i < max2; i++) {
      let trimmedPart = parts[i].trim().replace(/'/g, '"');
      if (!trimmedPart) {
        return null;
      }
      if (trimmedPart.includes(" ")) {
        const apostrophCount = (trimmedPart.match(/"/g) || []).length;
        if ((trimmedPart[0] !== '"' || i !== 0) && apostrophCount !== 2 && apostrophCount !== 0) {
          return null;
        }
        if (trimmedPart[0] === '"' && trimmedPart[trimmedPart.length - 1] !== '"') {
          endWithApostroph = true;
        } else if (trimmedPart[0] !== '"' && trimmedPart[trimmedPart.length - 1] !== '"') {
          trimmedPart = `"${trimmedPart}"`;
        }
      }
      if (i > 0) {
        parsedValue += ", ";
      }
      parsedValue += trimmedPart;
    }
    if (endWithApostroph) {
      parsedValue += '"';
    }
    if (!parsedValue) {
      return null;
    }
    return {
      "font-family": {
        important,
        value: parsedValue
      }
    };
  }
  /**
   * Returns font family.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property values
   */
  static getTextTransform(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { "text-transform": { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    const parsedValue = CSSStyleDeclarationValueParser.getGlobal(lowerValue) || TEXT_TRANSFORM.includes(lowerValue) && lowerValue;
    if (parsedValue) {
      return {
        "text-transform": { value: parsedValue, important }
      };
    }
    return null;
  }
  /**
   * Returns visibility.
   *
   * @param value Value.
   * @param important Important.
   * @returns Property
   */
  static getVisibility(value2, important) {
    const variable = CSSStyleDeclarationValueParser.getVariable(value2);
    if (variable) {
      return { visibility: { value: variable, important } };
    }
    const lowerValue = value2.toLowerCase();
    const parsedValue = CSSStyleDeclarationValueParser.getGlobal(lowerValue) || VISIBILITY.includes(lowerValue) && lowerValue;
    if (parsedValue) {
      return {
        visibility: { value: parsedValue, important }
      };
    }
    return null;
  }
}
class CSSStyleDeclarationPropertyGetParser {
  /**
   * Returns margin.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getMargin(properties) {
    return this.getPaddingLikeProperty(["margin-top", "margin-right", "margin-bottom", "margin-left"], properties);
  }
  /**
   * Returns padding.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getPadding(properties) {
    return this.getPaddingLikeProperty(["padding-top", "padding-right", "padding-bottom", "padding-left"], properties);
  }
  /**
   * Returns outline.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getOutline(properties) {
    var _a2, _b2, _c2, _d2, _e2;
    if (!((_a2 = properties["outline-color"]) == null ? void 0 : _a2.value) || !((_b2 = properties["outline-style"]) == null ? void 0 : _b2.value) || !((_c2 = properties["outline-width"]) == null ? void 0 : _c2.value)) {
      return null;
    }
    const important = properties["outline-color"].important && properties["outline-style"].important && properties["outline-width"].important;
    if (CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["outline-width"].value) && properties["outline-width"].value === properties["outline-style"].value && properties["outline-width"].value === properties["outline-color"].value) {
      return {
        important,
        value: properties["outline-width"].value
      };
    }
    const values = [];
    if (!CSSStyleDeclarationValueParser.getInitial((_d2 = properties["outline-color"]) == null ? void 0 : _d2.value)) {
      values.push(properties["outline-color"].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial((_e2 = properties["outline-style"]) == null ? void 0 : _e2.value)) {
      values.push(properties["outline-style"].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties["outline-width"].value)) {
      values.push(properties["outline-width"].value);
    }
    return {
      important,
      value: values.join(" ")
    };
  }
  /**
   * Returns border.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBorder(properties) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i, _j2, _k2, _l2, _m2, _n, _o2, _p2, _q2, _r2, _s2, _t2, _u2, _v, _w, _x, _y, _z;
    if (!((_a2 = properties["border-top-width"]) == null ? void 0 : _a2.value) || ((_b2 = properties["border-top-width"]) == null ? void 0 : _b2.value) !== ((_c2 = properties["border-right-width"]) == null ? void 0 : _c2.value) || ((_d2 = properties["border-top-width"]) == null ? void 0 : _d2.value) !== ((_e2 = properties["border-bottom-width"]) == null ? void 0 : _e2.value) || ((_f2 = properties["border-top-width"]) == null ? void 0 : _f2.value) !== ((_g2 = properties["border-left-width"]) == null ? void 0 : _g2.value) || !((_h2 = properties["border-top-style"]) == null ? void 0 : _h2.value) || ((_i = properties["border-top-style"]) == null ? void 0 : _i.value) !== ((_j2 = properties["border-right-style"]) == null ? void 0 : _j2.value) || ((_k2 = properties["border-top-style"]) == null ? void 0 : _k2.value) !== ((_l2 = properties["border-bottom-style"]) == null ? void 0 : _l2.value) || ((_m2 = properties["border-top-style"]) == null ? void 0 : _m2.value) !== ((_n = properties["border-left-style"]) == null ? void 0 : _n.value) || !((_o2 = properties["border-top-color"]) == null ? void 0 : _o2.value) || ((_p2 = properties["border-top-color"]) == null ? void 0 : _p2.value) !== ((_q2 = properties["border-right-color"]) == null ? void 0 : _q2.value) || ((_r2 = properties["border-top-color"]) == null ? void 0 : _r2.value) !== ((_s2 = properties["border-bottom-color"]) == null ? void 0 : _s2.value) || ((_t2 = properties["border-top-color"]) == null ? void 0 : _t2.value) !== ((_u2 = properties["border-left-color"]) == null ? void 0 : _u2.value) || !((_v = properties["border-image-source"]) == null ? void 0 : _v.value) || !((_w = properties["border-image-slice"]) == null ? void 0 : _w.value) || !((_x = properties["border-image-width"]) == null ? void 0 : _x.value) || !((_y = properties["border-image-outset"]) == null ? void 0 : _y.value) || !((_z = properties["border-image-repeat"]) == null ? void 0 : _z.value)) {
      return null;
    }
    const important = properties["border-top-width"].important && properties["border-right-width"].important && properties["border-bottom-width"].important && properties["border-left-width"].important && properties["border-top-style"].important && properties["border-right-style"].important && properties["border-bottom-style"].important && properties["border-left-style"].important && properties["border-top-color"].important && properties["border-right-color"].important && properties["border-bottom-color"].important && properties["border-left-color"].important && properties["border-image-source"].important && properties["border-image-slice"].important && properties["border-image-width"].important && properties["border-image-outset"].important && properties["border-image-repeat"].important;
    if (CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["border-top-width"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["border-top-style"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["border-top-color"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["border-image-source"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["border-image-slice"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["border-image-width"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["border-image-outset"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["border-image-repeat"].value)) {
      if (properties["border-top-width"].value !== properties["border-top-style"].value || properties["border-top-width"].value !== properties["border-top-color"].value || properties["border-top-width"].value !== properties["border-image-source"].value || properties["border-top-width"].value !== properties["border-image-slice"].value || properties["border-top-width"].value !== properties["border-image-width"].value || properties["border-top-width"].value !== properties["border-image-outset"].value || properties["border-top-width"].value !== properties["border-image-repeat"].value) {
        return null;
      }
      return {
        important,
        value: properties["border-top-width"].value
      };
    }
    const values = [];
    if (!CSSStyleDeclarationValueParser.getInitial(properties["border-top-width"].value)) {
      values.push(properties["border-top-width"].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties["border-top-style"].value)) {
      values.push(properties["border-top-style"].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties["border-top-color"].value)) {
      values.push(properties["border-top-color"].value);
    }
    return {
      important,
      value: values.join(" ")
    };
  }
  /**
   * Returns border.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBorderTop(properties) {
    return this.getBorderTopRightBottomLeft("top", properties);
  }
  /**
   * Returns border.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBorderRight(properties) {
    return this.getBorderTopRightBottomLeft("right", properties);
  }
  /**
   * Returns border.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBorderBottom(properties) {
    return this.getBorderTopRightBottomLeft("bottom", properties);
  }
  /**
   * Returns border.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBorderLeft(properties) {
    return this.getBorderTopRightBottomLeft("left", properties);
  }
  /**
   * Returns border.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBorderColor(properties) {
    return this.getPaddingLikeProperty(["border-top-color", "border-right-color", "border-bottom-color", "border-left-color"], properties);
  }
  /**
   * Returns border.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBorderWidth(properties) {
    return this.getPaddingLikeProperty(["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"], properties);
  }
  /**
   * Returns border.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBorderStyle(properties) {
    return this.getPaddingLikeProperty(["border-top-style", "border-right-style", "border-bottom-style", "border-left-style"], properties);
  }
  /**
   * Returns border radius.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBorderRadius(properties) {
    return this.getPaddingLikeProperty([
      "border-top-left-radius",
      "border-top-right-radius",
      "border-bottom-right-radius",
      "border-bottom-left-radius"
    ], properties);
  }
  /**
   * Returns border image.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBorderImage(properties) {
    var _a2, _b2, _c2, _d2, _e2;
    if (!((_a2 = properties["border-image-source"]) == null ? void 0 : _a2.value) || !((_b2 = properties["border-image-slice"]) == null ? void 0 : _b2.value) || !((_c2 = properties["border-image-width"]) == null ? void 0 : _c2.value) || !((_d2 = properties["border-image-outset"]) == null ? void 0 : _d2.value) || !((_e2 = properties["border-image-repeat"]) == null ? void 0 : _e2.value)) {
      return null;
    }
    const important = properties["border-image-source"].important && properties["border-image-slice"].important && properties["border-image-width"].important && properties["border-image-outset"].important && properties["border-image-repeat"].important;
    if (CSSStyleDeclarationValueParser.getGlobal(properties["border-image-source"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["border-image-slice"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["border-image-width"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["border-image-outset"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["border-image-repeat"].value)) {
      if (properties["border-image-source"].value !== properties["border-image-slice"].value || properties["border-image-source"].value !== properties["border-image-width"].value || properties["border-image-source"].value !== properties["border-image-outset"].value || properties["border-image-source"].value !== properties["border-image-repeat"].value) {
        return null;
      }
      return {
        important,
        value: properties["border-image-source"].value
      };
    }
    return {
      important,
      value: `${properties["border-image-source"].value} ${properties["border-image-slice"].value} / ${properties["border-image-width"].value} / ${properties["border-image-outset"].value} ${properties["border-image-repeat"].value}`
    };
  }
  /**
   * Returns background.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBackground(properties) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i;
    if (!((_a2 = properties["background-image"]) == null ? void 0 : _a2.value) || !((_b2 = properties["background-repeat"]) == null ? void 0 : _b2.value) || !((_c2 = properties["background-attachment"]) == null ? void 0 : _c2.value) || !((_d2 = properties["background-position-x"]) == null ? void 0 : _d2.value) || !((_e2 = properties["background-position-y"]) == null ? void 0 : _e2.value) || !((_f2 = properties["background-color"]) == null ? void 0 : _f2.value) || !((_g2 = properties["background-size"]) == null ? void 0 : _g2.value) || !((_h2 = properties["background-origin"]) == null ? void 0 : _h2.value) || !((_i = properties["background-clip"]) == null ? void 0 : _i.value)) {
      return null;
    }
    const important = properties["background-image"].important && properties["background-repeat"].important && properties["background-attachment"].important && properties["background-position-x"].important && properties["background-position-y"].important && properties["background-color"].important && properties["background-size"].important && properties["background-origin"].important && properties["background-clip"].important;
    if (CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["background-image"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["background-repeat"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["background-attachment"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["background-position-x"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["background-position-y"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["background-color"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["background-size"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["background-origin"].value) || CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties["background-clip"].value)) {
      if (properties["background-image"].value !== properties["background-repeat"].value || properties["background-image"].value !== properties["background-attachment"].value || properties["background-image"].value !== properties["background-position-x"].value || properties["background-image"].value !== properties["background-position-y"].value || properties["background-image"].value !== properties["background-color"].value || properties["background-image"].value !== properties["background-size"].value || properties["background-image"].value !== properties["background-origin"].value || properties["background-image"].value !== properties["background-clip"].value) {
        return null;
      }
      return {
        important,
        value: properties["background-image"].value
      };
    }
    const values = [];
    if (!CSSStyleDeclarationValueParser.getInitial(properties["background-image"].value)) {
      values.push(properties["background-image"].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties["background-position-x"].value) && !CSSStyleDeclarationValueParser.getInitial(properties["background-position-y"].value) && !CSSStyleDeclarationValueParser.getInitial(properties["background-size"].value)) {
      values.push(`${properties["background-position-x"].value} ${properties["background-position-y"].value} / ${properties["background-size"].value}`);
    } else if (!CSSStyleDeclarationValueParser.getInitial(properties["background-position-x"].value) && !CSSStyleDeclarationValueParser.getInitial(properties["background-position-y"].value)) {
      values.push(`${properties["background-position-x"].value} ${properties["background-position-y"].value}`);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties["background-repeat"].value)) {
      values.push(properties["background-repeat"].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties["background-attachment"].value)) {
      values.push(properties["background-attachment"].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties["background-origin"].value)) {
      values.push(properties["background-origin"].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties["background-clip"].value)) {
      values.push(properties["background-clip"].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial(properties["background-color"].value)) {
      values.push(properties["background-color"].value);
    }
    return {
      important,
      value: values.join(" ")
    };
  }
  /**
   * Returns background position.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getBackgroundPosition(properties) {
    var _a2, _b2;
    if (!((_a2 = properties["background-position-x"]) == null ? void 0 : _a2.value) || !((_b2 = properties["background-position-y"]) == null ? void 0 : _b2.value)) {
      return null;
    }
    const important = properties["background-position-x"].important && properties["background-position-y"].important;
    if (CSSStyleDeclarationValueParser.getGlobal(properties["background-position-x"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["background-position-y"].value)) {
      if (properties["background-position-x"].value !== properties["background-position-y"].value) {
        return null;
      }
      return {
        important,
        value: properties["background-position-x"].value
      };
    }
    const positionX = properties["background-position-x"].value.replace(/ *, */g, ",").split(",");
    const positionY = properties["background-position-y"].value.replace(/ *, */g, ",").split(",");
    const parts = [];
    for (let i = 0; i < positionX.length; i++) {
      parts.push(`${positionX[i]} ${positionY[i]}`);
    }
    return {
      important,
      value: parts.join(", ")
    };
  }
  /**
   * Returns flex.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getFlex(properties) {
    var _a2, _b2, _c2;
    if (!((_a2 = properties["flex-grow"]) == null ? void 0 : _a2.value) || !((_b2 = properties["flex-shrink"]) == null ? void 0 : _b2.value) || !((_c2 = properties["flex-basis"]) == null ? void 0 : _c2.value)) {
      return null;
    }
    const important = properties["flex-grow"].important && properties["flex-shrink"].important && properties["flex-basis"].important;
    if (CSSStyleDeclarationValueParser.getGlobal(properties["flex-grow"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["flex-shrink"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["flex-basis"].value)) {
      if (properties["flex-grow"].value !== properties["flex-shrink"].value || properties["flex-grow"].value !== properties["flex-basis"].value) {
        return null;
      }
      return {
        important,
        value: properties["flex-grow"].value
      };
    }
    return {
      important,
      value: `${properties["flex-grow"].value} ${properties["flex-shrink"].value} ${properties["flex-basis"].value}`
    };
  }
  /**
   * Returns flex.
   *
   * @param properties Properties.
   * @returns Property value
   */
  static getFont(properties) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
    if (!((_a2 = properties["font-size"]) == null ? void 0 : _a2.value) || !((_b2 = properties["font-family"]) == null ? void 0 : _b2.value) || !((_c2 = properties["font-weight"]) == null ? void 0 : _c2.value) || !((_d2 = properties["font-style"]) == null ? void 0 : _d2.value) || !((_e2 = properties["font-variant"]) == null ? void 0 : _e2.value) || !((_f2 = properties["font-stretch"]) == null ? void 0 : _f2.value) || !((_g2 = properties["line-height"]) == null ? void 0 : _g2.value)) {
      return null;
    }
    const important = properties["font-size"].important && properties["font-family"].important && properties["font-weight"].important && properties["font-style"].important && properties["font-variant"].important && properties["font-stretch"].important && properties["line-height"].important;
    if (CSSStyleDeclarationValueParser.getGlobal(properties["font-size"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["font-family"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["font-weight"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["font-style"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["font-variant"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["font-stretch"].value) || CSSStyleDeclarationValueParser.getGlobal(properties["line-height"].value)) {
      if (properties["font-size"].value !== properties["font-family"].value || properties["font-size"].value !== properties["font-weight"].value || properties["font-size"].value !== properties["font-style"].value || properties["font-size"].value !== properties["font-variant"].value || properties["font-size"].value !== properties["font-stretch"].value || properties["font-size"].value !== properties["line-height"].value) {
        return null;
      }
      return {
        important,
        value: properties["font-size"].value
      };
    }
    const values = [];
    if (properties["font-style"].value !== "normal") {
      values.push(properties["font-style"].value);
    }
    if (properties["font-variant"].value !== "normal") {
      values.push(properties["font-variant"].value);
    }
    if (properties["font-weight"].value !== "normal") {
      values.push(properties["font-weight"].value);
    }
    if (properties["font-stretch"].value !== "normal") {
      values.push(properties["font-stretch"].value);
    }
    if (properties["line-height"].value !== "normal") {
      values.push(`${properties["font-size"].value} / ${properties["line-height"].value}`);
    } else {
      values.push(properties["font-size"].value);
    }
    values.push(properties["font-family"].value);
    return {
      important,
      value: values.join(" ")
    };
  }
  /**
   * Returns border.
   *
   * @param properties Properties.
   * @param position
   * @returns Property value
   */
  static getBorderTopRightBottomLeft(position, properties) {
    var _a2, _b2, _c2, _d2, _e2;
    if (!((_a2 = properties[`border-${position}-width`]) == null ? void 0 : _a2.value) || !((_b2 = properties[`border-${position}-style`]) == null ? void 0 : _b2.value) || !((_c2 = properties[`border-${position}-color`]) == null ? void 0 : _c2.value)) {
      return null;
    }
    const important = properties[`border-${position}-width`].important && properties[`border-${position}-style`].important && properties[`border-${position}-color`].important;
    if (CSSStyleDeclarationValueParser.getGlobalExceptInitial(properties[`border-${position}-width`].value) && properties[`border-${position}-width`].value === properties[`border-${position}-style`].value && properties[`border-${position}-width`].value === properties[`border-${position}-color`].value) {
      return {
        important,
        value: properties[`border-${position}-width`].value
      };
    }
    const values = [];
    if (!CSSStyleDeclarationValueParser.getInitial(properties[`border-${position}-width`].value)) {
      values.push(properties[`border-${position}-width`].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial((_d2 = properties[`border-${position}-style`]) == null ? void 0 : _d2.value)) {
      values.push(properties[`border-${position}-style`].value);
    }
    if (!CSSStyleDeclarationValueParser.getInitial((_e2 = properties[`border-${position}-color`]) == null ? void 0 : _e2.value)) {
      values.push(properties[`border-${position}-color`].value);
    }
    return {
      important,
      value: values.join(" ")
    };
  }
  /**
   * Returns a padding like property.
   *
   * @param properties Properties.
   * @param position
   * @param propertyNames
   * @returns Property value
   */
  static getPaddingLikeProperty(propertyNames, properties) {
    var _a2, _b2, _c2, _d2;
    if (!((_a2 = properties[propertyNames[0]]) == null ? void 0 : _a2.value) || !((_b2 = properties[propertyNames[1]]) == null ? void 0 : _b2.value) || !((_c2 = properties[propertyNames[2]]) == null ? void 0 : _c2.value) || !((_d2 = properties[propertyNames[3]]) == null ? void 0 : _d2.value)) {
      return null;
    }
    const important = properties[propertyNames[0]].important && properties[propertyNames[1]].important && properties[propertyNames[2]].important && properties[propertyNames[3]].important;
    if (CSSStyleDeclarationValueParser.getGlobal(properties[propertyNames[0]].value) || CSSStyleDeclarationValueParser.getGlobal(properties[propertyNames[1]].value) || CSSStyleDeclarationValueParser.getGlobal(properties[propertyNames[2]].value) || CSSStyleDeclarationValueParser.getGlobal(properties[propertyNames[3]].value)) {
      if (properties[propertyNames[0]].value !== properties[propertyNames[1]].value || properties[propertyNames[0]].value !== properties[propertyNames[2]].value || properties[propertyNames[0]].value !== properties[propertyNames[3]].value) {
        return null;
      }
      return {
        important,
        value: properties[propertyNames[0]].value
      };
    }
    const values = [properties[propertyNames[0]].value];
    if (properties[propertyNames[1]].value !== properties[propertyNames[0]].value || properties[propertyNames[2]].value !== properties[propertyNames[0]].value || properties[propertyNames[3]].value !== properties[propertyNames[1]].value) {
      values.push(properties[propertyNames[1]].value);
    }
    if (properties[propertyNames[2]].value !== properties[propertyNames[0]].value || properties[propertyNames[3]].value !== properties[propertyNames[1]].value) {
      values.push(properties[propertyNames[2]].value);
    }
    if (properties[propertyNames[3]].value !== properties[propertyNames[1]].value) {
      values.push(properties[propertyNames[3]].value);
    }
    return {
      important,
      value: values.join(" ")
    };
  }
}
const SPLIT_RULES_REGEXP = /\s*([^:;]+?)\s*:\s*((?:[^(;]*?(?:\([^)]*\))?)*?)\s*(!important)?\s*(?:$|;)/g;
class CSSStyleDeclarationCSSParser {
  /**
   * Class construtor.
   *
   * @param cssText CSS string.
   * @param callback Callback.
   */
  static parse(cssText2) {
    const properties = {};
    const rules = [];
    const regexp = new RegExp(SPLIT_RULES_REGEXP);
    let match2;
    while (match2 = regexp.exec(cssText2)) {
      const name2 = (match2[1] ?? "").trim();
      const value2 = (match2[2] ?? "").trim();
      const important = match2[3] ? true : false;
      if (name2 && value2) {
        if (name2.startsWith("--")) {
          properties[name2] = value2;
        }
        rules.push({ name: name2, value: value2, important });
      }
    }
    return { rules, properties };
  }
}
const TO_STRING_SHORTHAND_PROPERTIES = [
  ["margin"],
  ["padding"],
  ["border", ["border-width", "border-style", "border-color", "border-image"]],
  ["border-radius"],
  ["background", "background-position"],
  ["font"]
];
class CSSStyleDeclarationPropertyManager {
  /**
   * Class construtor.
   *
   * @param [options] Options.
   * @param [options.cssText] CSS string.
   */
  constructor(options2) {
    var _a2;
    this.properties = {};
    this.definedPropertyNames = {};
    if (options2 == null ? void 0 : options2.cssText) {
      const { rules } = CSSStyleDeclarationCSSParser.parse(options2.cssText);
      for (const rule of rules) {
        if (rule.important || !((_a2 = this.get(rule.name)) == null ? void 0 : _a2.important)) {
          this.set(rule.name, rule.value, rule.important);
        }
      }
    }
  }
  /**
   * Returns property value.
   *
   * @param name Property name.
   * @returns Property value.
   */
  get(name2) {
    if (this.properties[name2]) {
      return this.properties[name2];
    }
    switch (name2) {
      case "margin":
        return CSSStyleDeclarationPropertyGetParser.getMargin(this.properties);
      case "padding":
        return CSSStyleDeclarationPropertyGetParser.getPadding(this.properties);
      case "border":
        return CSSStyleDeclarationPropertyGetParser.getBorder(this.properties);
      case "border-top":
        return CSSStyleDeclarationPropertyGetParser.getBorderTop(this.properties);
      case "border-right":
        return CSSStyleDeclarationPropertyGetParser.getBorderRight(this.properties);
      case "border-bottom":
        return CSSStyleDeclarationPropertyGetParser.getBorderBottom(this.properties);
      case "border-left":
        return CSSStyleDeclarationPropertyGetParser.getBorderLeft(this.properties);
      case "border-color":
        return CSSStyleDeclarationPropertyGetParser.getBorderColor(this.properties);
      case "border-style":
        return CSSStyleDeclarationPropertyGetParser.getBorderStyle(this.properties);
      case "border-width":
        return CSSStyleDeclarationPropertyGetParser.getBorderWidth(this.properties);
      case "border-radius":
        return CSSStyleDeclarationPropertyGetParser.getBorderRadius(this.properties);
      case "border-image":
        return CSSStyleDeclarationPropertyGetParser.getBorderImage(this.properties);
      case "outline":
        return CSSStyleDeclarationPropertyGetParser.getOutline(this.properties);
      case "background":
        return CSSStyleDeclarationPropertyGetParser.getBackground(this.properties);
      case "background-position":
        return CSSStyleDeclarationPropertyGetParser.getBackgroundPosition(this.properties);
      case "flex":
        return CSSStyleDeclarationPropertyGetParser.getFlex(this.properties);
      case "font":
        return CSSStyleDeclarationPropertyGetParser.getFont(this.properties);
    }
    return this.properties[name2] || null;
  }
  /**
   * Removes a property.
   *
   * @param name Property name.
   */
  remove(name2) {
    delete this.properties[name2];
    delete this.definedPropertyNames[name2];
    switch (name2) {
      case "border":
        delete this.properties["border-top-width"];
        delete this.properties["border-right-width"];
        delete this.properties["border-bottom-width"];
        delete this.properties["border-left-width"];
        delete this.properties["border-top-style"];
        delete this.properties["border-right-style"];
        delete this.properties["border-bottom-style"];
        delete this.properties["border-left-style"];
        delete this.properties["border-top-color"];
        delete this.properties["border-right-color"];
        delete this.properties["border-bottom-color"];
        delete this.properties["border-left-color"];
        delete this.properties["border-image-source"];
        delete this.properties["border-image-slice"];
        delete this.properties["border-image-width"];
        delete this.properties["border-image-outset"];
        delete this.properties["border-image-repeat"];
        break;
      case "border-top":
        delete this.properties["border-top-width"];
        delete this.properties["border-top-style"];
        delete this.properties["border-top-color"];
        delete this.properties["border-image-source"];
        delete this.properties["border-image-slice"];
        delete this.properties["border-image-width"];
        delete this.properties["border-image-outset"];
        delete this.properties["border-image-repeat"];
        break;
      case "border-right":
        delete this.properties["border-right-width"];
        delete this.properties["border-right-style"];
        delete this.properties["border-right-color"];
        delete this.properties["border-image-source"];
        delete this.properties["border-image-slice"];
        delete this.properties["border-image-width"];
        delete this.properties["border-image-outset"];
        delete this.properties["border-image-repeat"];
        break;
      case "border-bottom":
        delete this.properties["border-bottom-width"];
        delete this.properties["border-bottom-style"];
        delete this.properties["border-bottom-color"];
        delete this.properties["border-image-source"];
        delete this.properties["border-image-slice"];
        delete this.properties["border-image-width"];
        delete this.properties["border-image-outset"];
        delete this.properties["border-image-repeat"];
        break;
      case "border-left":
        delete this.properties["border-left-width"];
        delete this.properties["border-left-style"];
        delete this.properties["border-left-color"];
        delete this.properties["border-image-source"];
        delete this.properties["border-image-slice"];
        delete this.properties["border-image-width"];
        delete this.properties["border-image-outset"];
        delete this.properties["border-image-repeat"];
        break;
      case "border-width":
        delete this.properties["border-top-width"];
        delete this.properties["border-right-width"];
        delete this.properties["border-bottom-width"];
        delete this.properties["border-left-width"];
        break;
      case "border-style":
        delete this.properties["border-top-style"];
        delete this.properties["border-right-style"];
        delete this.properties["border-bottom-style"];
        delete this.properties["border-left-style"];
        break;
      case "border-color":
        delete this.properties["border-top-color"];
        delete this.properties["border-right-color"];
        delete this.properties["border-bottom-color"];
        delete this.properties["border-left-color"];
        break;
      case "border-image":
        delete this.properties["border-image-source"];
        delete this.properties["border-image-slice"];
        delete this.properties["border-image-width"];
        delete this.properties["border-image-outset"];
        delete this.properties["border-image-repeat"];
        break;
      case "border-radius":
        delete this.properties["border-top-left-radius"];
        delete this.properties["border-top-right-radius"];
        delete this.properties["border-bottom-right-radius"];
        delete this.properties["border-bottom-left-radius"];
        break;
      case "outline":
        delete this.properties["outline-color"];
        delete this.properties["outline-style"];
        delete this.properties["outline-width"];
        break;
      case "background":
        delete this.properties["background-color"];
        delete this.properties["background-image"];
        delete this.properties["background-repeat"];
        delete this.properties["background-attachment"];
        delete this.properties["background-position-x"];
        delete this.properties["background-position-y"];
        delete this.properties["background-size"];
        delete this.properties["background-origin"];
        delete this.properties["background-clip"];
        break;
      case "background-position":
        delete this.properties["background-position-x"];
        delete this.properties["background-position-y"];
        break;
      case "flex":
        delete this.properties["flex-grow"];
        delete this.properties["flex-shrink"];
        delete this.properties["flex-basis"];
        break;
      case "font":
        delete this.properties["font-style"];
        delete this.properties["font-variant"];
        delete this.properties["font-weight"];
        delete this.properties["font-stretch"];
        delete this.properties["font-size"];
        delete this.properties["line-height"];
        delete this.properties["font-family"];
        break;
      case "padding":
        delete this.properties["padding-top"];
        delete this.properties["padding-right"];
        delete this.properties["padding-bottom"];
        delete this.properties["padding-left"];
        break;
      case "margin":
        delete this.properties["margin-top"];
        delete this.properties["margin-right"];
        delete this.properties["margin-bottom"];
        delete this.properties["margin-left"];
        break;
    }
  }
  /**
   * Sets a property
   *
   * @param name Name.
   * @param value Value.
   * @param important Important.
   */
  set(name2, value2, important) {
    if (value2 === null) {
      this.remove(name2);
      return;
    }
    let properties = null;
    switch (name2) {
      case "border":
        properties = CSSStyleDeclarationPropertySetParser.getBorder(value2, important);
        break;
      case "border-top":
        properties = CSSStyleDeclarationPropertySetParser.getBorderTop(value2, important);
        break;
      case "border-right":
        properties = CSSStyleDeclarationPropertySetParser.getBorderRight(value2, important);
        break;
      case "border-bottom":
        properties = CSSStyleDeclarationPropertySetParser.getBorderBottom(value2, important);
        break;
      case "border-left":
        properties = CSSStyleDeclarationPropertySetParser.getBorderLeft(value2, important);
        break;
      case "border-width":
        properties = CSSStyleDeclarationPropertySetParser.getBorderWidth(value2, important);
        break;
      case "border-style":
        properties = CSSStyleDeclarationPropertySetParser.getBorderStyle(value2, important);
        break;
      case "border-color":
        properties = CSSStyleDeclarationPropertySetParser.getBorderColor(value2, important);
        break;
      case "border-image":
        properties = CSSStyleDeclarationPropertySetParser.getBorderImage(value2, important);
        break;
      case "border-image-source":
        properties = CSSStyleDeclarationPropertySetParser.getBorderImageSource(value2, important);
        break;
      case "border-image-slice":
        properties = CSSStyleDeclarationPropertySetParser.getBorderImageSlice(value2, important);
        break;
      case "border-image-width":
        properties = CSSStyleDeclarationPropertySetParser.getBorderImageWidth(value2, important);
        break;
      case "border-image-outset":
        properties = CSSStyleDeclarationPropertySetParser.getBorderImageOutset(value2, important);
        break;
      case "border-image-repeat":
        properties = CSSStyleDeclarationPropertySetParser.getBorderImageRepeat(value2, important);
        break;
      case "border-top-width":
        properties = CSSStyleDeclarationPropertySetParser.getBorderTopWidth(value2, important);
        break;
      case "border-right-width":
        properties = CSSStyleDeclarationPropertySetParser.getBorderRightWidth(value2, important);
        break;
      case "border-bottom-width":
        properties = CSSStyleDeclarationPropertySetParser.getBorderBottomWidth(value2, important);
        break;
      case "border-left-width":
        properties = CSSStyleDeclarationPropertySetParser.getBorderLeftWidth(value2, important);
        break;
      case "border-top-color":
        properties = CSSStyleDeclarationPropertySetParser.getBorderTopColor(value2, important);
        break;
      case "border-right-color":
        properties = CSSStyleDeclarationPropertySetParser.getBorderRightColor(value2, important);
        break;
      case "border-bottom-color":
        properties = CSSStyleDeclarationPropertySetParser.getBorderBottomColor(value2, important);
        break;
      case "border-left-color":
        properties = CSSStyleDeclarationPropertySetParser.getBorderLeftColor(value2, important);
        break;
      case "border-top-style":
        properties = CSSStyleDeclarationPropertySetParser.getBorderTopStyle(value2, important);
        break;
      case "border-right-style":
        properties = CSSStyleDeclarationPropertySetParser.getBorderRightStyle(value2, important);
        break;
      case "border-bottom-style":
        properties = CSSStyleDeclarationPropertySetParser.getBorderBottomStyle(value2, important);
        break;
      case "border-left-style":
        properties = CSSStyleDeclarationPropertySetParser.getBorderLeftStyle(value2, important);
        break;
      case "border-radius":
        properties = CSSStyleDeclarationPropertySetParser.getBorderRadius(value2, important);
        break;
      case "border-top-left-radius":
        properties = CSSStyleDeclarationPropertySetParser.getBorderTopLeftRadius(value2, important);
        break;
      case "border-top-right-radius":
        properties = CSSStyleDeclarationPropertySetParser.getBorderTopRightRadius(value2, important);
        break;
      case "border-bottom-right-radius":
        properties = CSSStyleDeclarationPropertySetParser.getBorderBottomRightRadius(value2, important);
        break;
      case "border-bottom-left-radius":
        properties = CSSStyleDeclarationPropertySetParser.getBorderBottomLeftRadius(value2, important);
        break;
      case "border-collapse":
        properties = CSSStyleDeclarationPropertySetParser.getBorderCollapse(value2, important);
        break;
      case "outline":
        properties = CSSStyleDeclarationPropertySetParser.getOutline(value2, important);
        break;
      case "outline-width":
        properties = CSSStyleDeclarationPropertySetParser.getOutlineWidth(value2, important);
        break;
      case "outline-style":
        properties = CSSStyleDeclarationPropertySetParser.getOutlineStyle(value2, important);
        break;
      case "outline-color":
        properties = CSSStyleDeclarationPropertySetParser.getOutlineColor(value2, important);
        break;
      case "letter-spacing":
        properties = CSSStyleDeclarationPropertySetParser.getLetterSpacing(value2, important);
        break;
      case "word-spacing":
        properties = CSSStyleDeclarationPropertySetParser.getWordSpacing(value2, important);
        break;
      case "clear":
        properties = CSSStyleDeclarationPropertySetParser.getClear(value2, important);
        break;
      case "clip":
        properties = CSSStyleDeclarationPropertySetParser.getClip(value2, important);
        break;
      case "css-float":
        properties = CSSStyleDeclarationPropertySetParser.getCSSFloat(value2, important);
        break;
      case "float":
        properties = CSSStyleDeclarationPropertySetParser.getFloat(value2, important);
        break;
      case "display":
        properties = CSSStyleDeclarationPropertySetParser.getDisplay(value2, important);
        break;
      case "direction":
        properties = CSSStyleDeclarationPropertySetParser.getDirection(value2, important);
        break;
      case "flex":
        properties = CSSStyleDeclarationPropertySetParser.getFlex(value2, important);
        break;
      case "flex-shrink":
        properties = CSSStyleDeclarationPropertySetParser.getFlexShrink(value2, important);
        break;
      case "flex-grow":
        properties = CSSStyleDeclarationPropertySetParser.getFlexGrow(value2, important);
        break;
      case "flex-basis":
        properties = CSSStyleDeclarationPropertySetParser.getFlexBasis(value2, important);
        break;
      case "padding":
        properties = CSSStyleDeclarationPropertySetParser.getPadding(value2, important);
        break;
      case "padding-top":
        properties = CSSStyleDeclarationPropertySetParser.getPaddingTop(value2, important);
        break;
      case "padding-right":
        properties = CSSStyleDeclarationPropertySetParser.getPaddingRight(value2, important);
        break;
      case "padding-bottom":
        properties = CSSStyleDeclarationPropertySetParser.getPaddingBottom(value2, important);
        break;
      case "padding-left":
        properties = CSSStyleDeclarationPropertySetParser.getPaddingLeft(value2, important);
        break;
      case "margin":
        properties = CSSStyleDeclarationPropertySetParser.getMargin(value2, important);
        break;
      case "margin-top":
        properties = CSSStyleDeclarationPropertySetParser.getMarginTop(value2, important);
        break;
      case "margin-right":
        properties = CSSStyleDeclarationPropertySetParser.getMarginRight(value2, important);
        break;
      case "margin-bottom":
        properties = CSSStyleDeclarationPropertySetParser.getMarginBottom(value2, important);
        break;
      case "margin-left":
        properties = CSSStyleDeclarationPropertySetParser.getMarginLeft(value2, important);
        break;
      case "background":
        properties = CSSStyleDeclarationPropertySetParser.getBackground(value2, important);
        break;
      case "background-image":
        properties = CSSStyleDeclarationPropertySetParser.getBackgroundImage(value2, important);
        break;
      case "background-color":
        properties = CSSStyleDeclarationPropertySetParser.getBackgroundColor(value2, important);
        break;
      case "background-repeat":
        properties = CSSStyleDeclarationPropertySetParser.getBackgroundRepeat(value2, important);
        break;
      case "background-attachment":
        properties = CSSStyleDeclarationPropertySetParser.getBackgroundAttachment(value2, important);
        break;
      case "background-position":
        properties = CSSStyleDeclarationPropertySetParser.getBackgroundPosition(value2, important);
        break;
      case "width":
        properties = CSSStyleDeclarationPropertySetParser.getWidth(value2, important);
        break;
      case "height":
        properties = CSSStyleDeclarationPropertySetParser.getHeight(value2, important);
        break;
      case "top":
        properties = CSSStyleDeclarationPropertySetParser.getTop(value2, important);
        break;
      case "right":
        properties = CSSStyleDeclarationPropertySetParser.getRight(value2, important);
        break;
      case "bottom":
        properties = CSSStyleDeclarationPropertySetParser.getBottom(value2, important);
        break;
      case "left":
        properties = CSSStyleDeclarationPropertySetParser.getLeft(value2, important);
        break;
      case "font":
        properties = CSSStyleDeclarationPropertySetParser.getFont(value2, important);
        break;
      case "font-style":
        properties = CSSStyleDeclarationPropertySetParser.getFontStyle(value2, important);
        break;
      case "font-variant":
        properties = CSSStyleDeclarationPropertySetParser.getFontVariant(value2, important);
        break;
      case "font-weight":
        properties = CSSStyleDeclarationPropertySetParser.getFontWeight(value2, important);
        break;
      case "font-stretch":
        properties = CSSStyleDeclarationPropertySetParser.getFontStretch(value2, important);
        break;
      case "font-size":
        properties = CSSStyleDeclarationPropertySetParser.getFontSize(value2, important);
        break;
      case "line-height":
        properties = CSSStyleDeclarationPropertySetParser.getLineHeight(value2, important);
        break;
      case "text-indent":
        properties = CSSStyleDeclarationPropertySetParser.getTextIndent(value2, important);
        break;
      case "font-family":
        properties = CSSStyleDeclarationPropertySetParser.getFontFamily(value2, important);
        break;
      case "color":
        properties = CSSStyleDeclarationPropertySetParser.getColor(value2, important);
        break;
      case "flood-color":
        properties = CSSStyleDeclarationPropertySetParser.getFloodColor(value2, important);
        break;
      case "text-transform":
        properties = CSSStyleDeclarationPropertySetParser.getTextTransform(value2, important);
        break;
      case "visibility":
        properties = CSSStyleDeclarationPropertySetParser.getVisibility(value2, important);
        break;
      default:
        const trimmedValue = value2.trim();
        if (trimmedValue) {
          const globalValue = CSSStyleDeclarationValueParser.getGlobal(trimmedValue);
          properties = {
            [name2]: { value: globalValue || trimmedValue, important }
          };
        }
        break;
    }
    if (properties !== null && Object.keys(properties).length > 0) {
      this.definedPropertyNames[name2] = true;
      Object.assign(this.properties, properties);
    }
  }
  /**
   * Returns a clone.
   *
   * @returns Clone.
   */
  clone() {
    const _class = this.constructor;
    const clone2 = new _class();
    clone2.properties = JSON.parse(JSON.stringify(this.properties));
    clone2.definedPropertyNames = Object.assign({}, this.definedPropertyNames);
    return clone2;
  }
  /**
   * Returns size.
   *
   * @returns Size.
   */
  size() {
    return Object.keys(this.properties).length;
  }
  /**
   * Returns property name.
   *
   * @param index Index.
   * @returns Property name.
   */
  item(index) {
    return Object.keys(this.properties)[index] || "";
  }
  /**
   * Converts properties to string.
   *
   * @returns String.
   */
  toString() {
    const result = [];
    const clone2 = this.clone();
    const properties = {};
    for (const shorthandPropertyGroup of TO_STRING_SHORTHAND_PROPERTIES) {
      for (const shorthandProperty of shorthandPropertyGroup) {
        if (Array.isArray(shorthandProperty)) {
          let isMatch = false;
          for (const childShorthandProperty of shorthandProperty) {
            const property = clone2.get(childShorthandProperty);
            if (property) {
              properties[childShorthandProperty] = property;
              clone2.remove(childShorthandProperty);
              isMatch = true;
            }
          }
          if (isMatch) {
            break;
          }
        } else {
          const property = clone2.get(shorthandProperty);
          if (property) {
            properties[shorthandProperty] = property;
            clone2.remove(shorthandProperty);
            break;
          }
        }
      }
    }
    for (const name2 of Object.keys(clone2.properties)) {
      properties[name2] = clone2.get(name2);
    }
    for (const definedPropertyName of Object.keys(this.definedPropertyNames)) {
      const property = properties[definedPropertyName];
      if (property) {
        result.push(`${definedPropertyName}: ${property.value}${property.important ? " !important" : ""};`);
        delete properties[definedPropertyName];
      }
    }
    for (const propertyName of Object.keys(properties)) {
      const property = properties[propertyName];
      if (property) {
        result.push(`${propertyName}: ${property.value}${property.important ? " !important" : ""};`);
      }
    }
    return result.join(" ");
  }
}
var CSSRuleTypeEnum;
(function(CSSRuleTypeEnum2) {
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["containerRule"] = 0] = "containerRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["styleRule"] = 1] = "styleRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["importRule"] = 3] = "importRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["mediaRule"] = 4] = "mediaRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["fontFaceRule"] = 5] = "fontFaceRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["pageRule"] = 6] = "pageRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["keyframesRule"] = 7] = "keyframesRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["keyframeRule"] = 8] = "keyframeRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["namespaceRule"] = 10] = "namespaceRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["counterStyleRule"] = 11] = "counterStyleRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["supportsRule"] = 12] = "supportsRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["documentRule"] = 13] = "documentRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["fontFeatureValuesRule"] = 14] = "fontFeatureValuesRule";
  CSSRuleTypeEnum2[CSSRuleTypeEnum2["regionStyleRule"] = 16] = "regionStyleRule";
})(CSSRuleTypeEnum || (CSSRuleTypeEnum = {}));
const CSSRuleTypeEnum$1 = CSSRuleTypeEnum;
const CSSStyleDeclarationElementDefaultCSS = {
  default: "display: inline;",
  A: "",
  ABBR: "",
  ADDRESS: "display: block;",
  AREA: "",
  ARTICLE: "display: block;",
  ASIDE: "display: block;",
  AUDIO: "display: none;",
  B: "",
  BASE: "display: none;",
  BDI: "",
  BDO: "",
  BLOCKQUAOTE: "",
  BODY: "display: block;",
  TEMPLATE: "display: none;",
  FORM: "display: block;",
  INPUT: "display: inline-block;",
  TEXTAREA: "display: inline-block;",
  SCRIPT: "display: none;",
  IMG: "",
  LINK: "display: none;",
  STYLE: "display: none;",
  LABEL: "",
  SLOT: "display: contents;",
  SVG: "",
  CIRCLE: "",
  ELLIPSE: "",
  LINE: "",
  PATH: "",
  POLYGON: "",
  POLYLINE: "",
  RECT: "",
  STOP: "",
  USE: "",
  META: "display: none;",
  BLOCKQUOTE: "display: block;",
  BR: "",
  BUTTON: "display: inline-block;",
  CANVAS: "",
  CAPTION: "display: table-caption;",
  CITE: "",
  CODE: "",
  COL: "display: table-column;",
  COLGROUP: "display: table-column-group;",
  DATA: "",
  DATALIST: "display: none;",
  DD: "display: block;",
  DEL: "",
  DETAILS: "display: block;",
  DFN: "",
  DIALOG: {
    default: "display: none;",
    open: "display: block;"
  },
  DIV: "display: block;",
  DL: "display: block;",
  DT: "display: block;",
  EM: "",
  EMBED: "",
  FIELDSET: "display: block;",
  FIGCAPTION: "display: block;",
  FIGURE: "display: block;",
  FOOTER: "display: block;",
  H1: "display: block;",
  H2: "display: block;",
  H3: "display: block;",
  H4: "display: block;",
  H5: "display: block;",
  H6: "display: block;",
  HEAD: "display: none;",
  HEADER: "display: block;",
  HGROUP: "display: block;",
  HR: "display: block;",
  HTML: 'display: block;direction: ltr;font: 16px "Times New Roman";',
  I: "",
  IFRAME: "",
  INS: "",
  KBD: "",
  LEGEND: "display: block;",
  LI: "display: list-item;",
  MAIN: "display: block;",
  MAP: "",
  MARK: "",
  MATH: "",
  MENU: "display: block;",
  MENUITEM: "",
  METER: "display: inline-block;",
  NAV: "display: block;",
  NOSCRIPT: "",
  OBJECT: "",
  OL: "display: block;",
  OPTGROUP: "display: block;",
  OPTION: "display: block;",
  OUTPUT: "unicode-bidi: isolate;",
  P: "display: block;",
  PARAM: "display: none;",
  PICTURE: "",
  PRE: "display: block;",
  PROGRESS: "display: inline-block;",
  Q: "",
  RB: "",
  RP: "display: none;",
  RT: "",
  RTC: "",
  RUBY: "",
  S: "",
  SAMP: "",
  SECTION: "display: block;",
  SELECT: "display: inline-block;",
  SMALL: "",
  SOURCE: "",
  SPAN: "",
  STRONG: "",
  SUB: "",
  SUMMARY: "display: block;",
  SUP: "",
  TABLE: "display: table;",
  TBODY: "display: table-row-group;",
  TD: "display: table-cell;",
  TFOOT: "display: table-footer-group;",
  TH: "display: table-cell;",
  THEAD: "display: table-header-group;",
  TIME: "",
  TITLE: "display: none;",
  TR: "display: table-row;",
  TRACK: "",
  U: "",
  UL: "display: block;",
  VAR: "",
  VIDEO: "",
  WBR: ""
};
const CSSStyleDeclarationElementInheritedProperties = {
  "border-collapse": true,
  "border-spacing": true,
  "caption-side": true,
  color: true,
  cursor: true,
  direction: true,
  "empty-cells": true,
  "font-family": true,
  "font-size": true,
  "font-style": true,
  "font-variant": true,
  "font-weight": true,
  "font-size-adjust": true,
  "font-stretch": true,
  font: true,
  "letter-spacing": true,
  "line-height": true,
  "list-style-image": true,
  "list-style-position": true,
  "list-style-type": true,
  "list-style": true,
  orphans: true,
  quotes: true,
  "tab-size": true,
  "text-align": true,
  "text-align-last": true,
  "text-decoration-color": true,
  "text-indent": true,
  "text-justify": true,
  "text-shadow": true,
  "text-transform": true,
  visibility: true,
  "white-space": true,
  widows: true,
  "word-break": true,
  "word-spacing": true,
  "word-wrap": true
};
const CSSStyleDeclarationElementMeasurementProperties = [
  "background-position-x",
  "background-position-y",
  "background-size",
  "border-image-outset",
  "border-top-width",
  "border-right-width",
  "border-bottom-width",
  "border-left-width",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-bottom-right-radius",
  "border-bottom-left-radius",
  "border-image-width",
  "clip",
  "font-size",
  "padding-top",
  "padding-right",
  "padding-bottom",
  "padding-left",
  "margin-top",
  "margin-right",
  "margin-bottom",
  "margin-left",
  "width",
  "height",
  "min-width",
  "min-height",
  "max-width",
  "max-height",
  "top",
  "right",
  "bottom",
  "left",
  "outline-width",
  "outline-offset",
  "letter-spacing",
  "word-spacing",
  "text-indent",
  "line-height"
];
class CSSMeasurementConverter {
  /**
   * Returns measurement in pixels.
   *
   * @param options Options.
   * @param options.ownerWindow Owner window.
   * @param options.value Measurement (e.g. "10px", "10rem" or "10em").
   * @param options.rootFontSize Root font size in pixels.
   * @param options.parentFontSize Parent font size in pixels.
   * @param [options.parentSize] Parent size in pixels.
   * @returns Measurement in pixels.
   */
  static toPixels(options2) {
    const value2 = parseFloat(options2.value);
    const unit = options2.value.replace(value2.toString(), "");
    if (isNaN(value2)) {
      return null;
    }
    switch (unit) {
      case "px":
        return value2;
      case "rem":
        return this.round(value2 * parseFloat(options2.rootFontSize));
      case "em":
        return this.round(value2 * parseFloat(options2.parentFontSize));
      case "vw":
        return this.round(value2 * options2.ownerWindow.innerWidth / 100);
      case "vh":
        return this.round(value2 * options2.ownerWindow.innerHeight / 100);
      case "%":
        return options2.parentSize !== void 0 && options2.parentSize !== null ? this.round(value2 * parseFloat(options2.parentSize) / 100) : null;
      case "vmin":
        return this.round(value2 * Math.min(options2.ownerWindow.innerWidth, options2.ownerWindow.innerHeight) / 100);
      case "vmax":
        return value2 * Math.max(options2.ownerWindow.innerWidth, options2.ownerWindow.innerHeight) / 100;
      case "cm":
        return this.round(value2 * 37.7812);
      case "mm":
        return this.round(value2 * 3.7781);
      case "in":
        return this.round(value2 * 96);
      case "pt":
        return this.round(value2 * 1.3281);
      case "pc":
        return this.round(value2 * 16);
      case "Q":
        return this.round(value2 * 0.945);
      default:
        return null;
    }
  }
  /**
   * Rounds the number with 4 decimals.
   *
   * @param value Value.
   * @returns Rounded value.
   */
  static round(value2) {
    return Math.round(value2 * 1e4) / 1e4;
  }
}
class MediaQueryListEvent extends Event {
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type, eventInit = null) {
    super(type, eventInit);
    this.matches = (eventInit == null ? void 0 : eventInit.matches) ?? false;
    this.media = (eventInit == null ? void 0 : eventInit.media) ?? "";
  }
}
var MediaQueryTypeEnum;
(function(MediaQueryTypeEnum2) {
  MediaQueryTypeEnum2["all"] = "all";
  MediaQueryTypeEnum2["print"] = "print";
  MediaQueryTypeEnum2["screen"] = "screen";
})(MediaQueryTypeEnum || (MediaQueryTypeEnum = {}));
const MediaQueryTypeEnum$1 = MediaQueryTypeEnum;
class MediaQueryItem {
  /**
   * Constructor.
   *
   * @param options Options.
   * @param options.ownerWindow Owner window.
   * @param [options.rootFontSize] Root font size.
   * @param [options.mediaTypes] Media types.
   * @param [options.not] Not.
   * @param [options.rules] Rules.
   * @param [options.ranges] Ranges.
   */
  constructor(options2) {
    this.rootFontSize = null;
    this.ownerWindow = options2.ownerWindow;
    this.rootFontSize = options2.rootFontSize || null;
    this.mediaTypes = options2.mediaTypes || [];
    this.not = options2.not || false;
    this.rules = options2.rules || [];
    this.ranges = options2.ranges || [];
  }
  /**
   * Returns media string.
   */
  toString() {
    return `${this.not ? "not " : ""}${this.mediaTypes.join(", ")}${(this.not || this.mediaTypes.length > 0) && !!this.ranges.length ? " and " : ""}${this.ranges.map((range) => `(${range.before ? `${range.before.value} ${range.before.operator} ` : ""}${range.type}${range.after ? ` ${range.after.operator} ${range.after.value}` : ""})`).join(" and ")}${(this.not || this.mediaTypes.length > 0) && !!this.rules.length ? " and " : ""}${this.rules.map((rule) => rule.value ? `(${rule.name}: ${rule.value})` : `(${rule.name})`).join(" and ")}`;
  }
  /**
   * Returns "true" if the item matches.
   */
  matches() {
    return this.not ? !this.matchesAll() : this.matchesAll();
  }
  /**
   * Returns "true" if all matches.
   *
   * @returns "true" if all matches.
   */
  matchesAll() {
    if (!!this.mediaTypes.length) {
      let isMediaTypeMatch = false;
      for (const mediaType of this.mediaTypes) {
        if (this.matchesMediaType(mediaType)) {
          isMediaTypeMatch = true;
          break;
        }
      }
      if (!isMediaTypeMatch) {
        return false;
      }
    }
    for (const rule of this.rules) {
      if (!this.matchesRule(rule)) {
        return false;
      }
    }
    for (const range of this.ranges) {
      if (!this.matchesRange(range)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns "true" if the mediaType matches.
   *
   * @param mediaType Media type.
   * @returns "true" if the mediaType matches.
   */
  matchesMediaType(mediaType) {
    if (mediaType === MediaQueryTypeEnum$1.all) {
      return true;
    }
    return mediaType === WindowBrowserSettingsReader.getSettings(this.ownerWindow).device.mediaType;
  }
  /**
   * Returns "true" if the range matches.
   *
   * @param range Range.
   * @returns "true" if the range matches.
   */
  matchesRange(range) {
    const windowSize = range.type === "width" ? this.ownerWindow.innerWidth : this.ownerWindow.innerHeight;
    if (range.before) {
      const beforeValue = this.toPixels(range.before.value);
      if (beforeValue === null) {
        return false;
      }
      switch (range.before.operator) {
        case "<":
          if (beforeValue >= windowSize) {
            return false;
          }
          break;
        case "<=":
          if (beforeValue > windowSize) {
            return false;
          }
          break;
        case ">":
          if (beforeValue <= windowSize) {
            return false;
          }
          break;
        case ">=":
          if (beforeValue < windowSize) {
            return false;
          }
          break;
      }
    }
    if (range.after) {
      const afterValue = this.toPixels(range.after.value);
      if (afterValue === null) {
        return false;
      }
      switch (range.after.operator) {
        case "<":
          if (windowSize >= afterValue) {
            return false;
          }
          break;
        case "<=":
          if (windowSize > afterValue) {
            return false;
          }
          break;
        case ">":
          if (windowSize <= afterValue) {
            return false;
          }
          break;
        case ">=":
          if (windowSize < afterValue) {
            return false;
          }
          break;
      }
    }
    return true;
  }
  /**
   * Returns "true" if the rule matches.
   *
   * @param rule Rule.
   * @returns "true" if the rule matches.
   */
  matchesRule(rule) {
    if (!rule.value) {
      switch (rule.name) {
        case "min-width":
        case "max-width":
        case "min-height":
        case "max-height":
        case "width":
        case "height":
        case "orientation":
        case "prefers-color-scheme":
        case "hover":
        case "any-hover":
        case "any-pointer":
        case "pointer":
        case "display-mode":
        case "min-aspect-ratio":
        case "max-aspect-ratio":
        case "aspect-ratio":
          return true;
      }
      return false;
    }
    switch (rule.name) {
      case "min-width":
        const minWidth = this.toPixels(rule.value);
        return minWidth !== null && this.ownerWindow.innerWidth >= minWidth;
      case "max-width":
        const maxWidth = this.toPixels(rule.value);
        return maxWidth !== null && this.ownerWindow.innerWidth <= maxWidth;
      case "min-height":
        const minHeight = this.toPixels(rule.value);
        return minHeight !== null && this.ownerWindow.innerHeight >= minHeight;
      case "max-height":
        const maxHeight = this.toPixels(rule.value);
        return maxHeight !== null && this.ownerWindow.innerHeight <= maxHeight;
      case "width":
        const width2 = this.toPixels(rule.value);
        return width2 !== null && this.ownerWindow.innerWidth === width2;
      case "height":
        const height2 = this.toPixels(rule.value);
        return height2 !== null && this.ownerWindow.innerHeight === height2;
      case "orientation":
        return rule.value === "landscape" ? this.ownerWindow.innerWidth > this.ownerWindow.innerHeight : this.ownerWindow.innerWidth < this.ownerWindow.innerHeight;
      case "prefers-color-scheme":
        return rule.value === WindowBrowserSettingsReader.getSettings(this.ownerWindow).device.prefersColorScheme;
      case "any-hover":
      case "hover":
        if (rule.value === "none") {
          return this.ownerWindow.navigator.maxTouchPoints > 0;
        }
        if (rule.value === "hover") {
          return this.ownerWindow.navigator.maxTouchPoints === 0;
        }
        return false;
      case "any-pointer":
      case "pointer":
        if (rule.value === "none") {
          return false;
        }
        if (rule.value === "coarse") {
          return this.ownerWindow.navigator.maxTouchPoints > 0;
        }
        if (rule.value === "fine") {
          return this.ownerWindow.navigator.maxTouchPoints === 0;
        }
        return false;
      case "display-mode":
        return rule.value === "browser";
      case "min-aspect-ratio":
      case "max-aspect-ratio":
      case "aspect-ratio":
        const aspectRatio = rule.value.split("/");
        const aspectRatioWidth = parseInt(aspectRatio[0], 10);
        const aspectRatioHeight = parseInt(aspectRatio[1], 10);
        if (isNaN(aspectRatioWidth) || isNaN(aspectRatioHeight)) {
          return false;
        }
        switch (rule.name) {
          case "min-aspect-ratio":
            return aspectRatioWidth / aspectRatioHeight <= this.ownerWindow.innerWidth / this.ownerWindow.innerHeight;
          case "max-aspect-ratio":
            return aspectRatioWidth / aspectRatioHeight >= this.ownerWindow.innerWidth / this.ownerWindow.innerHeight;
          case "aspect-ratio":
            return aspectRatioWidth / aspectRatioHeight === this.ownerWindow.innerWidth / this.ownerWindow.innerHeight;
        }
    }
    return false;
  }
  /**
   * Convert to pixels.
   *
   * @param value Value.
   * @returns Value in pixels.
   */
  toPixels(value2) {
    if (!WindowBrowserSettingsReader.getSettings(this.ownerWindow).disableComputedStyleRendering && value2.endsWith("em")) {
      this.rootFontSize = this.rootFontSize || parseFloat(this.ownerWindow.getComputedStyle(this.ownerWindow.document.documentElement).fontSize);
      return CSSMeasurementConverter.toPixels({
        ownerWindow: this.ownerWindow,
        value: value2,
        rootFontSize: this.rootFontSize,
        parentFontSize: this.rootFontSize
      });
    }
    return CSSMeasurementConverter.toPixels({
      ownerWindow: this.ownerWindow,
      value: value2,
      rootFontSize: 16,
      parentFontSize: 16
    });
  }
}
const MEDIA_QUERY_REGEXP = /(not|only|all|screen|print)|\(([^\)]+)(\)){0,1}|(,)| +(or|and) +/g;
const IS_RESOLUTION_REGEXP = /[<>]/;
const RESOLUTION_REGEXP = /(?:([0-9]+[a-z]+) *(<|<=|>|=>)){0,1} *(width|height) *(?:(<|<=|>|=>) *([0-9]+[a-z]+)){0,1}/;
class MediaQueryParser {
  /**
   * Parses a media query string.
   *
   * @param options Options.
   * @param options.ownerWindow Owner window.
   * @param options.mediaQuery Media query string.
   * @param [options.rootFontSize] Root font size.
   * @returns Media query items.
   */
  static parse(options2) {
    let currentMediaQueryItem = new MediaQueryItem({
      ownerWindow: options2.ownerWindow,
      rootFontSize: options2.rootFontSize
    });
    const mediaQueryItems = [currentMediaQueryItem];
    const regexp = new RegExp(MEDIA_QUERY_REGEXP);
    let match2 = null;
    while (match2 = regexp.exec(options2.mediaQuery.toLowerCase())) {
      if (match2[4] === "," || match2[5] === "or") {
        currentMediaQueryItem = new MediaQueryItem({
          ownerWindow: options2.ownerWindow,
          rootFontSize: options2.rootFontSize
        });
        mediaQueryItems.push(currentMediaQueryItem);
      } else if (match2[1] === "all" || match2[1] === "screen" || match2[1] === "print") {
        currentMediaQueryItem.mediaTypes.push(match2[1]);
      } else if (match2[1] === "not") {
        currentMediaQueryItem.not = true;
      } else if (match2[2]) {
        const resolutionMatch = IS_RESOLUTION_REGEXP.test(match2[2]) ? match2[2].match(RESOLUTION_REGEXP) : null;
        if (resolutionMatch && (resolutionMatch[1] || resolutionMatch[5])) {
          currentMediaQueryItem.ranges.push({
            before: resolutionMatch[1] ? {
              value: resolutionMatch[1],
              operator: resolutionMatch[2]
            } : null,
            type: resolutionMatch[3],
            after: resolutionMatch[5] ? {
              value: resolutionMatch[5],
              operator: resolutionMatch[4]
            } : null
          });
        } else {
          const [name2, value2] = match2[2].split(":");
          const trimmedValue = value2 ? value2.trim() : null;
          if (!trimmedValue && !match2[3]) {
            return [
              new MediaQueryItem({
                ownerWindow: options2.ownerWindow,
                rootFontSize: options2.rootFontSize,
                not: true,
                mediaTypes: [MediaQueryTypeEnum$1.all]
              })
            ];
          }
          currentMediaQueryItem.rules.push({
            name: name2.trim(),
            value: trimmedValue
          });
        }
      }
    }
    return mediaQueryItems;
  }
}
var __classPrivateFieldSet$A = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$D = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MediaQueryList_ownerWindow, _MediaQueryList_items, _MediaQueryList_media, _MediaQueryList_rootFontSize;
class MediaQueryList extends EventTarget {
  /**
   * Constructor.
   *
   * @param options Options.
   * @param options.ownerWindow Owner window.
   * @param options.media Media.
   * @param [options.rootFontSize] Root font size.
   */
  constructor(options2) {
    super();
    this.onchange = null;
    _MediaQueryList_ownerWindow.set(this, void 0);
    _MediaQueryList_items.set(this, null);
    _MediaQueryList_media.set(this, void 0);
    _MediaQueryList_rootFontSize.set(this, null);
    __classPrivateFieldSet$A(this, _MediaQueryList_ownerWindow, options2.ownerWindow, "f");
    __classPrivateFieldSet$A(this, _MediaQueryList_media, options2.media, "f");
    __classPrivateFieldSet$A(this, _MediaQueryList_rootFontSize, options2.rootFontSize || null, "f");
  }
  /**
   * Returns media.
   *
   * @returns Media.
   */
  get media() {
    __classPrivateFieldSet$A(this, _MediaQueryList_items, __classPrivateFieldGet$D(this, _MediaQueryList_items, "f") || MediaQueryParser.parse({
      ownerWindow: __classPrivateFieldGet$D(this, _MediaQueryList_ownerWindow, "f"),
      mediaQuery: __classPrivateFieldGet$D(this, _MediaQueryList_media, "f"),
      rootFontSize: __classPrivateFieldGet$D(this, _MediaQueryList_rootFontSize, "f")
    }), "f");
    return __classPrivateFieldGet$D(this, _MediaQueryList_items, "f").map((item2) => item2.toString()).join(", ");
  }
  /**
   * Returns "true" if the document matches.
   *
   * @returns Matches.
   */
  get matches() {
    __classPrivateFieldSet$A(this, _MediaQueryList_items, __classPrivateFieldGet$D(this, _MediaQueryList_items, "f") || MediaQueryParser.parse({
      ownerWindow: __classPrivateFieldGet$D(this, _MediaQueryList_ownerWindow, "f"),
      mediaQuery: __classPrivateFieldGet$D(this, _MediaQueryList_media, "f"),
      rootFontSize: __classPrivateFieldGet$D(this, _MediaQueryList_rootFontSize, "f")
    }), "f");
    for (const item2 of __classPrivateFieldGet$D(this, _MediaQueryList_items, "f")) {
      if (!item2.matches()) {
        return false;
      }
    }
    return true;
  }
  /**
   * Adds a listener.
   *
   * @deprecated
   * @param callback Callback.
   */
  addListener(callback) {
    this.addEventListener("change", callback);
  }
  /**
   * Removes listener.
   *
   * @deprecated
   * @param callback Callback.
   */
  removeListener(callback) {
    this.removeEventListener("change", callback);
  }
  /**
   * @override
   */
  addEventListener(type, listener) {
    super.addEventListener(type, listener);
    if (type === "change") {
      let matchesState = false;
      const resizeListener = () => {
        const matches = this.matches;
        if (matches !== matchesState) {
          matchesState = matches;
          this.dispatchEvent(new MediaQueryListEvent("change", { matches, media: this.media }));
        }
      };
      listener[windowResizeListener] = resizeListener;
      __classPrivateFieldGet$D(this, _MediaQueryList_ownerWindow, "f").addEventListener("resize", resizeListener);
    }
  }
  /**
   * @override
   */
  removeEventListener(type, listener) {
    super.removeEventListener(type, listener);
    if (type === "change" && listener[windowResizeListener]) {
      __classPrivateFieldGet$D(this, _MediaQueryList_ownerWindow, "f").removeEventListener("resize", listener[windowResizeListener]);
    }
  }
}
_MediaQueryList_ownerWindow = /* @__PURE__ */ new WeakMap(), _MediaQueryList_items = /* @__PURE__ */ new WeakMap(), _MediaQueryList_media = /* @__PURE__ */ new WeakMap(), _MediaQueryList_rootFontSize = /* @__PURE__ */ new WeakMap();
const CSS_MEASUREMENT_REGEXP = /[0-9.]+(px|rem|em|vw|vh|%|vmin|vmax|cm|mm|in|pt|pc|Q)/g;
const CSS_VARIABLE_REGEXP = /var\( *(--[^), ]+)\)|var\( *(--[^), ]+), *(.+)\)/;
class CSSStyleDeclarationElementStyle {
  /**
   * Constructor.
   *
   * @param element Element.
   * @param [computed] Computed.
   */
  constructor(element, computed = false) {
    this.cache = {
      propertyManager: null,
      cssText: null,
      documentCacheID: null
    };
    this.element = element;
    this.computed = computed;
  }
  /**
   * Returns element style properties.
   *
   * @returns Element style properties.
   */
  getElementStyle() {
    var _a2;
    if (this.computed) {
      return this.getComputedElementStyle();
    }
    const cssText2 = (_a2 = this.element[attributes]["style"]) == null ? void 0 : _a2[value];
    if (cssText2) {
      if (this.cache.propertyManager && this.cache.cssText === cssText2) {
        return this.cache.propertyManager;
      }
      this.cache.cssText = cssText2;
      this.cache.propertyManager = new CSSStyleDeclarationPropertyManager({ cssText: cssText2 });
      return this.cache.propertyManager;
    }
    return new CSSStyleDeclarationPropertyManager();
  }
  /**
   * Returns style sheets.
   *
   * @param element Element.
   * @returns Style sheets.
   */
  getComputedElementStyle() {
    var _a2;
    const documentElements = [];
    const parentElements = [];
    let styleAndElement = {
      element: this.element,
      cssTexts: []
    };
    let shadowRootElements = [];
    if (!this.element[isConnected]) {
      return new CSSStyleDeclarationPropertyManager();
    }
    if (this.cache.propertyManager && this.cache.documentCacheID === this.element[ownerDocument][cacheID]) {
      return this.cache.propertyManager;
    }
    this.cache.documentCacheID = this.element[ownerDocument][cacheID];
    while (styleAndElement.element) {
      if (styleAndElement.element[nodeType] === NodeTypeEnum$1.elementNode) {
        const rootNode2 = styleAndElement.element.getRootNode();
        if (rootNode2[nodeType] === NodeTypeEnum$1.documentNode) {
          documentElements.unshift(styleAndElement);
        } else {
          shadowRootElements.unshift(styleAndElement);
        }
        parentElements.unshift(styleAndElement);
      }
      if (styleAndElement.element === this.element[ownerDocument]) {
        const styleSheets = this.element[ownerDocument].querySelectorAll('style,link[rel="stylesheet"]');
        for (const styleSheet of styleSheets) {
          const sheet2 = styleSheet.sheet;
          if (sheet2) {
            this.parseCSSRules({
              elements: documentElements,
              rootElement: documentElements[0].element[tagName] === "HTML" ? documentElements[0] : null,
              cssRules: sheet2.cssRules
            });
          }
        }
        for (const sheet2 of this.element[ownerDocument].adoptedStyleSheets) {
          this.parseCSSRules({
            elements: documentElements,
            rootElement: documentElements[0].element[tagName] === "HTML" ? documentElements[0] : null,
            cssRules: sheet2.cssRules
          });
        }
        styleAndElement = { element: null, cssTexts: [] };
      } else if (styleAndElement.element[nodeType] === NodeTypeEnum$1.documentFragmentNode && styleAndElement.element.host) {
        const shadowRoot2 = styleAndElement.element;
        const styleSheets = shadowRoot2.querySelectorAll('style,link[rel="stylesheet"]');
        styleAndElement = {
          element: shadowRoot2.host,
          cssTexts: []
        };
        for (const styleSheet of styleSheets) {
          const sheet2 = styleSheet.sheet;
          if (sheet2) {
            this.parseCSSRules({
              elements: shadowRootElements,
              cssRules: sheet2.cssRules,
              hostElement: styleAndElement
            });
          }
        }
        for (const sheet2 of shadowRoot2.adoptedStyleSheets) {
          this.parseCSSRules({
            elements: shadowRootElements,
            cssRules: sheet2.cssRules,
            hostElement: styleAndElement
          });
        }
        shadowRootElements = [];
      } else {
        styleAndElement = {
          element: styleAndElement.element[parentNode],
          cssTexts: []
        };
      }
    }
    const targetElement = parentElements[parentElements.length - 1];
    const propertyManager = new CSSStyleDeclarationPropertyManager();
    const cssProperties = {};
    let rootFontSize = 16;
    let parentFontSize = 16;
    for (const parentElement of parentElements) {
      parentElement.cssTexts.sort((a, b) => a.priorityWeight - b.priorityWeight);
      let elementCSSText = "";
      if (CSSStyleDeclarationElementDefaultCSS[parentElement.element[tagName]]) {
        if (typeof CSSStyleDeclarationElementDefaultCSS[parentElement.element[tagName]] === "string") {
          elementCSSText += CSSStyleDeclarationElementDefaultCSS[parentElement.element[tagName]];
        } else {
          for (const key of Object.keys(CSSStyleDeclarationElementDefaultCSS[parentElement.element[tagName]])) {
            if (key === "default" || !!parentElement.element[key]) {
              elementCSSText += CSSStyleDeclarationElementDefaultCSS[parentElement.element[tagName]][key];
            }
          }
        }
        elementCSSText += CSSStyleDeclarationElementDefaultCSS[parentElement.element[tagName]];
      }
      for (const cssText2 of parentElement.cssTexts) {
        elementCSSText += cssText2.cssText;
      }
      const elementStyleAttribute = parentElement.element[attributes]["style"];
      if (elementStyleAttribute) {
        elementCSSText += elementStyleAttribute[value];
      }
      const rulesAndProperties = CSSStyleDeclarationCSSParser.parse(elementCSSText);
      const rules = rulesAndProperties.rules;
      Object.assign(cssProperties, rulesAndProperties.properties);
      for (const { name: name2, value: value2, important } of rules) {
        if (CSSStyleDeclarationElementInheritedProperties[name2] || parentElement === targetElement) {
          const parsedValue = this.parseCSSVariablesInValue(value2.trim(), cssProperties);
          if (parsedValue && (!((_a2 = propertyManager.get(name2)) == null ? void 0 : _a2.important) || important)) {
            propertyManager.set(name2, parsedValue, important);
            if (name2 === "font" || name2 === "font-size") {
              const fontSize = propertyManager.properties["font-size"];
              if (fontSize !== null) {
                const parsedValue2 = this.parseMeasurementsInValue({
                  value: fontSize.value,
                  rootFontSize,
                  parentFontSize,
                  parentSize: parentFontSize
                });
                if (parentElement.element[tagName] === "HTML") {
                  rootFontSize = parsedValue2;
                } else if (parentElement !== targetElement) {
                  parentFontSize = parsedValue2;
                }
              }
            }
          }
        }
      }
    }
    for (const name2 of CSSStyleDeclarationElementMeasurementProperties) {
      const property = propertyManager.properties[name2];
      if (property) {
        property.value = this.parseMeasurementsInValue({
          value: property.value,
          rootFontSize,
          parentFontSize,
          // TODO: Only "font-size" is supported when using percentage values. Add support for other properties.
          parentSize: name2 === "font-size" ? parentFontSize : null
        });
      }
    }
    this.cache.propertyManager = propertyManager;
    return propertyManager;
  }
  /**
   * Applies CSS text to elements.
   *
   * @param options Options.
   * @param options.elements Elements.
   * @param options.cssRules CSS rules.
   * @param options.rootElement Root element.
   * @param [options.hostElement] Host element.
   */
  parseCSSRules(options2) {
    if (!options2.elements.length) {
      return;
    }
    const ownerWindow$1 = this.element[ownerDocument][ownerWindow];
    for (const rule of options2.cssRules) {
      if (rule.type === CSSRuleTypeEnum$1.styleRule) {
        const selectorText = rule.selectorText;
        if (selectorText) {
          if (selectorText.startsWith(":host")) {
            if (options2.hostElement) {
              options2.hostElement.cssTexts.push({
                cssText: rule[cssText],
                priorityWeight: 0
              });
            }
          } else if (selectorText.startsWith(":root")) {
            if (options2.rootElement) {
              options2.rootElement.cssTexts.push({
                cssText: rule[cssText],
                priorityWeight: 0
              });
            }
          } else {
            for (const element of options2.elements) {
              const match2 = QuerySelector.matches(element.element, selectorText, {
                ignoreErrors: true
              });
              if (match2) {
                element.cssTexts.push({
                  cssText: rule[cssText],
                  priorityWeight: match2.priorityWeight
                });
              }
            }
          }
        }
      } else if (rule.type === CSSRuleTypeEnum$1.mediaRule && // TODO: We need to send in a predfined root font size as it will otherwise be calculated using Window.getComputedStyle(), which will cause a never ending loop. Is there another solution?
      new MediaQueryList({
        ownerWindow: ownerWindow$1,
        media: rule.conditionText,
        rootFontSize: this.element[tagName] === "HTML" ? 16 : null
      }).matches) {
        this.parseCSSRules({
          elements: options2.elements,
          cssRules: rule.cssRules,
          hostElement: options2.hostElement
        });
      }
    }
  }
  /**
   * Parses CSS variables in a value.
   *
   * @param value Value.
   * @param cssVariables CSS variables.
   * @returns CSS value.
   */
  parseCSSVariablesInValue(value2, cssVariables) {
    let newValue = value2;
    let match2;
    while ((match2 = newValue.match(CSS_VARIABLE_REGEXP)) !== null) {
      if (match2[2] !== void 0) {
        newValue = newValue.replace(match2[0], cssVariables[match2[2]] || match2[3]);
      } else {
        newValue = newValue.replace(match2[0], cssVariables[match2[1]] || "");
      }
    }
    return newValue;
  }
  /**
   * Parses measurements in a value.
   *
   * @param options Options.
   * @param options.value Value.
   * @param options.rootFontSize Root font size.
   * @param options.parentFontSize Parent font size.
   * @param [options.parentSize] Parent width.
   * @returns CSS value.
   */
  parseMeasurementsInValue(options2) {
    if (WindowBrowserSettingsReader.getSettings(this.element[ownerDocument][ownerWindow]).disableComputedStyleRendering) {
      return options2.value;
    }
    const regexp = new RegExp(CSS_MEASUREMENT_REGEXP);
    let newValue = options2.value;
    let match2;
    while ((match2 = regexp.exec(options2.value)) !== null) {
      if (match2[1] !== "px") {
        const valueInPixels = CSSMeasurementConverter.toPixels({
          ownerWindow: this.element[ownerDocument][ownerWindow],
          value: match2[0],
          rootFontSize: options2.rootFontSize,
          parentFontSize: options2.parentFontSize,
          parentSize: options2.parentSize
        });
        if (valueInPixels !== null) {
          newValue = newValue.replace(match2[0], valueInPixels + "px");
        }
      }
    }
    return newValue;
  }
}
var __classPrivateFieldSet$z = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$C = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractCSSStyleDeclaration_style, _AbstractCSSStyleDeclaration_ownerElement, _AbstractCSSStyleDeclaration_computed, _AbstractCSSStyleDeclaration_elementStyle;
class AbstractCSSStyleDeclaration {
  /**
   * Constructor.
   *
   * @param [ownerElement] Computed style element.
   * @param [computed] Computed.
   */
  constructor(ownerElement2 = null, computed = false) {
    this.parentRule = null;
    _AbstractCSSStyleDeclaration_style.set(this, null);
    _AbstractCSSStyleDeclaration_ownerElement.set(this, void 0);
    _AbstractCSSStyleDeclaration_computed.set(this, void 0);
    _AbstractCSSStyleDeclaration_elementStyle.set(this, null);
    __classPrivateFieldSet$z(this, _AbstractCSSStyleDeclaration_style, !ownerElement2 ? new CSSStyleDeclarationPropertyManager() : null, "f");
    __classPrivateFieldSet$z(this, _AbstractCSSStyleDeclaration_ownerElement, ownerElement2, "f");
    __classPrivateFieldSet$z(this, _AbstractCSSStyleDeclaration_computed, ownerElement2 ? computed : false, "f");
    __classPrivateFieldSet$z(this, _AbstractCSSStyleDeclaration_elementStyle, ownerElement2 ? new CSSStyleDeclarationElementStyle(ownerElement2, __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_computed, "f")) : null, "f");
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get length() {
    if (__classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")) {
      const style2 = __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_elementStyle, "f").getElementStyle();
      return style2.size();
    }
    return __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_style, "f").size();
  }
  /**
   * Returns the style decleration as a CSS text.
   *
   * @returns CSS text.
   */
  get cssText() {
    if (__classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")) {
      if (__classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_computed, "f")) {
        return "";
      }
      return __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_elementStyle, "f").getElementStyle().toString();
    }
    return __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_style, "f").toString();
  }
  /**
   * Sets CSS text.
   *
   * @param cssText CSS text.
   */
  set cssText(cssText2) {
    if (__classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_computed, "f")) {
      throw new DOMException(`Failed to execute 'cssText' on 'CSSStyleDeclaration': These styles are computed, and the properties are therefore read-only.`, DOMExceptionNameEnum$1.domException);
    }
    if (__classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")) {
      const style2 = new CSSStyleDeclarationPropertyManager({ cssText: cssText2 });
      let styleAttribute = __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")[attributes]["style"];
      if (!styleAttribute) {
        styleAttribute = __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")[ownerDocument].createAttribute("style");
        __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")[attributes][setNamedItemWithoutConsequences](styleAttribute);
      }
      if (__classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")[isConnected]) {
        __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")[ownerDocument][cacheID]++;
      }
      styleAttribute[value] = style2.toString();
    } else {
      __classPrivateFieldSet$z(this, _AbstractCSSStyleDeclaration_style, new CSSStyleDeclarationPropertyManager({ cssText: cssText2 }), "f");
    }
  }
  /**
   * Returns item.
   *
   * @param index Index.
   * @returns Item.
   */
  item(index) {
    if (__classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")) {
      return __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_elementStyle, "f").getElementStyle().item(index);
    }
    return __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_style, "f").item(index);
  }
  /**
   * Set a property.
   *
   * @param name Property name.
   * @param value Value. Must not contain "!important" as that should be set using the priority parameter.
   * @param [priority] Can be "important", or an empty string.
   */
  setProperty(name2, value$1, priority) {
    if (__classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_computed, "f")) {
      throw new DOMException(`Failed to execute 'setProperty' on 'CSSStyleDeclaration': These styles are computed, and therefore the '${name2}' property is read-only.`, DOMExceptionNameEnum$1.domException);
    }
    if (priority !== "" && priority !== void 0 && priority !== "important") {
      return;
    }
    const stringValue = String(value$1);
    if (!stringValue) {
      this.removeProperty(name2);
    } else if (__classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")) {
      let styleAttribute = __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")[attributes]["style"];
      if (!styleAttribute) {
        styleAttribute = __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")[ownerDocument].createAttribute("style");
        __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")[attributes][setNamedItemWithoutConsequences](styleAttribute);
      }
      if (__classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")[isConnected]) {
        __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")[ownerDocument][cacheID]++;
      }
      const style2 = __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_elementStyle, "f").getElementStyle();
      style2.set(name2, stringValue, !!priority);
      styleAttribute[value] = style2.toString();
    } else {
      __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_style, "f").set(name2, stringValue, !!priority);
    }
  }
  /**
   * Removes a property.
   *
   * @param name Property name in kebab case.
   * @param value Value. Must not contain "!important" as that should be set using the priority parameter.
   * @param [priority] Can be "important", or an empty string.
   */
  removeProperty(name2) {
    if (__classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_computed, "f")) {
      throw new DOMException(`Failed to execute 'removeProperty' on 'CSSStyleDeclaration': These styles are computed, and therefore the '${name2}' property is read-only.`, DOMExceptionNameEnum$1.domException);
    }
    if (__classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")) {
      const style2 = __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_elementStyle, "f").getElementStyle();
      style2.remove(name2);
      const newCSSText = style2.toString();
      if (__classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")[isConnected]) {
        __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")[ownerDocument][cacheID]++;
      }
      if (newCSSText) {
        __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")[attributes]["style"][value] = newCSSText;
      } else {
        __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")[attributes][removeNamedItemWithoutConsequences]("style");
      }
    } else {
      __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_style, "f").remove(name2);
    }
  }
  /**
   * Returns a property.
   *
   * @param name Property name in kebab case.
   * @returns Property value.
   */
  getPropertyValue(name2) {
    var _a2, _b2;
    if (__classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")) {
      const style2 = __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_elementStyle, "f").getElementStyle();
      return ((_a2 = style2.get(name2)) == null ? void 0 : _a2.value) || "";
    }
    return ((_b2 = __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_style, "f").get(name2)) == null ? void 0 : _b2.value) || "";
  }
  /**
   * Returns a property.
   *
   * @param name Property name in kebab case.
   * @returns "important" if set to be important.
   */
  getPropertyPriority(name2) {
    var _a2, _b2;
    if (__classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_ownerElement, "f")) {
      const style2 = __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_elementStyle, "f").getElementStyle();
      return ((_a2 = style2.get(name2)) == null ? void 0 : _a2.important) ? "important" : "";
    }
    return ((_b2 = __classPrivateFieldGet$C(this, _AbstractCSSStyleDeclaration_style, "f").get(name2)) == null ? void 0 : _b2.important) ? "important" : "";
  }
}
_AbstractCSSStyleDeclaration_style = /* @__PURE__ */ new WeakMap(), _AbstractCSSStyleDeclaration_ownerElement = /* @__PURE__ */ new WeakMap(), _AbstractCSSStyleDeclaration_computed = /* @__PURE__ */ new WeakMap(), _AbstractCSSStyleDeclaration_elementStyle = /* @__PURE__ */ new WeakMap();
class CSSStyleDeclaration extends AbstractCSSStyleDeclaration {
  /**
   * Index properties
   */
  get 0() {
    return this.item(0) || void 0;
  }
  get 1() {
    return this.item(1) || void 0;
  }
  get 2() {
    return this.item(2) || void 0;
  }
  get 3() {
    return this.item(3) || void 0;
  }
  get 4() {
    return this.item(4) || void 0;
  }
  get 5() {
    return this.item(5) || void 0;
  }
  get 6() {
    return this.item(6) || void 0;
  }
  get 7() {
    return this.item(7) || void 0;
  }
  get 8() {
    return this.item(8) || void 0;
  }
  get 9() {
    return this.item(9) || void 0;
  }
  get 10() {
    return this.item(10) || void 0;
  }
  get 11() {
    return this.item(11) || void 0;
  }
  get 12() {
    return this.item(12) || void 0;
  }
  get 13() {
    return this.item(13) || void 0;
  }
  get 14() {
    return this.item(14) || void 0;
  }
  get 15() {
    return this.item(15) || void 0;
  }
  get 16() {
    return this.item(16) || void 0;
  }
  get 17() {
    return this.item(17) || void 0;
  }
  get 18() {
    return this.item(18) || void 0;
  }
  get 19() {
    return this.item(19) || void 0;
  }
  get 20() {
    return this.item(20) || void 0;
  }
  get 21() {
    return this.item(21) || void 0;
  }
  get 22() {
    return this.item(22) || void 0;
  }
  get 23() {
    return this.item(23) || void 0;
  }
  get 24() {
    return this.item(24) || void 0;
  }
  get 25() {
    return this.item(25) || void 0;
  }
  get 26() {
    return this.item(26) || void 0;
  }
  get 27() {
    return this.item(27) || void 0;
  }
  get 28() {
    return this.item(28) || void 0;
  }
  get 29() {
    return this.item(29) || void 0;
  }
  get 30() {
    return this.item(30) || void 0;
  }
  get 31() {
    return this.item(31) || void 0;
  }
  get 32() {
    return this.item(32) || void 0;
  }
  get 33() {
    return this.item(33) || void 0;
  }
  get 34() {
    return this.item(34) || void 0;
  }
  get 35() {
    return this.item(35) || void 0;
  }
  get 36() {
    return this.item(36) || void 0;
  }
  get 37() {
    return this.item(37) || void 0;
  }
  get 38() {
    return this.item(38) || void 0;
  }
  get 39() {
    return this.item(39) || void 0;
  }
  get 40() {
    return this.item(40) || void 0;
  }
  get 41() {
    return this.item(41) || void 0;
  }
  get 42() {
    return this.item(42) || void 0;
  }
  get 43() {
    return this.item(43) || void 0;
  }
  get 44() {
    return this.item(44) || void 0;
  }
  get 45() {
    return this.item(45) || void 0;
  }
  get 46() {
    return this.item(46) || void 0;
  }
  get 47() {
    return this.item(47) || void 0;
  }
  get 48() {
    return this.item(48) || void 0;
  }
  get 49() {
    return this.item(49) || void 0;
  }
  get 50() {
    return this.item(50) || void 0;
  }
  get 51() {
    return this.item(51) || void 0;
  }
  get 52() {
    return this.item(52) || void 0;
  }
  get 53() {
    return this.item(53) || void 0;
  }
  get 54() {
    return this.item(54) || void 0;
  }
  get 55() {
    return this.item(55) || void 0;
  }
  get 56() {
    return this.item(56) || void 0;
  }
  get 57() {
    return this.item(57) || void 0;
  }
  get 58() {
    return this.item(58) || void 0;
  }
  get 59() {
    return this.item(59) || void 0;
  }
  get 60() {
    return this.item(60) || void 0;
  }
  get 61() {
    return this.item(61) || void 0;
  }
  get 62() {
    return this.item(62) || void 0;
  }
  get 63() {
    return this.item(63) || void 0;
  }
  get 64() {
    return this.item(64) || void 0;
  }
  get 65() {
    return this.item(65) || void 0;
  }
  get 66() {
    return this.item(66) || void 0;
  }
  get 67() {
    return this.item(67) || void 0;
  }
  get 68() {
    return this.item(68) || void 0;
  }
  get 69() {
    return this.item(69) || void 0;
  }
  get 70() {
    return this.item(70) || void 0;
  }
  get 71() {
    return this.item(71) || void 0;
  }
  get 72() {
    return this.item(72) || void 0;
  }
  get 73() {
    return this.item(73) || void 0;
  }
  get 74() {
    return this.item(74) || void 0;
  }
  get 75() {
    return this.item(75) || void 0;
  }
  get 76() {
    return this.item(76) || void 0;
  }
  get 77() {
    return this.item(77) || void 0;
  }
  get 78() {
    return this.item(78) || void 0;
  }
  get 79() {
    return this.item(79) || void 0;
  }
  get 80() {
    return this.item(80) || void 0;
  }
  get 81() {
    return this.item(81) || void 0;
  }
  get 82() {
    return this.item(82) || void 0;
  }
  get 83() {
    return this.item(83) || void 0;
  }
  get 84() {
    return this.item(84) || void 0;
  }
  get 85() {
    return this.item(85) || void 0;
  }
  get 86() {
    return this.item(86) || void 0;
  }
  get 87() {
    return this.item(87) || void 0;
  }
  get 88() {
    return this.item(88) || void 0;
  }
  get 89() {
    return this.item(89) || void 0;
  }
  get 90() {
    return this.item(90) || void 0;
  }
  get 91() {
    return this.item(91) || void 0;
  }
  get 92() {
    return this.item(92) || void 0;
  }
  get 93() {
    return this.item(93) || void 0;
  }
  get 94() {
    return this.item(94) || void 0;
  }
  get 95() {
    return this.item(95) || void 0;
  }
  get 96() {
    return this.item(96) || void 0;
  }
  get 97() {
    return this.item(97) || void 0;
  }
  get 98() {
    return this.item(98) || void 0;
  }
  get 99() {
    return this.item(99) || void 0;
  }
  get 100() {
    return this.item(100) || void 0;
  }
  get 101() {
    return this.item(101) || void 0;
  }
  get 102() {
    return this.item(102) || void 0;
  }
  get 103() {
    return this.item(103) || void 0;
  }
  get 104() {
    return this.item(104) || void 0;
  }
  get 105() {
    return this.item(105) || void 0;
  }
  get 106() {
    return this.item(106) || void 0;
  }
  get 107() {
    return this.item(107) || void 0;
  }
  get 108() {
    return this.item(108) || void 0;
  }
  get 109() {
    return this.item(109) || void 0;
  }
  get 110() {
    return this.item(110) || void 0;
  }
  get 111() {
    return this.item(111) || void 0;
  }
  get 112() {
    return this.item(112) || void 0;
  }
  get 113() {
    return this.item(113) || void 0;
  }
  get 114() {
    return this.item(114) || void 0;
  }
  get 115() {
    return this.item(115) || void 0;
  }
  get 116() {
    return this.item(116) || void 0;
  }
  get 117() {
    return this.item(117) || void 0;
  }
  get 118() {
    return this.item(118) || void 0;
  }
  get 119() {
    return this.item(119) || void 0;
  }
  get 120() {
    return this.item(120) || void 0;
  }
  get 121() {
    return this.item(121) || void 0;
  }
  get 122() {
    return this.item(122) || void 0;
  }
  get 123() {
    return this.item(123) || void 0;
  }
  get 124() {
    return this.item(124) || void 0;
  }
  get 125() {
    return this.item(125) || void 0;
  }
  get 126() {
    return this.item(126) || void 0;
  }
  get 127() {
    return this.item(127) || void 0;
  }
  get 128() {
    return this.item(128) || void 0;
  }
  get 129() {
    return this.item(129) || void 0;
  }
  get 130() {
    return this.item(130) || void 0;
  }
  get 131() {
    return this.item(131) || void 0;
  }
  get 132() {
    return this.item(132) || void 0;
  }
  get 133() {
    return this.item(133) || void 0;
  }
  get 134() {
    return this.item(134) || void 0;
  }
  get 135() {
    return this.item(135) || void 0;
  }
  get 136() {
    return this.item(136) || void 0;
  }
  get 137() {
    return this.item(137) || void 0;
  }
  get 138() {
    return this.item(138) || void 0;
  }
  get 139() {
    return this.item(139) || void 0;
  }
  get 140() {
    return this.item(140) || void 0;
  }
  get 141() {
    return this.item(141) || void 0;
  }
  get 142() {
    return this.item(142) || void 0;
  }
  get 143() {
    return this.item(143) || void 0;
  }
  get 144() {
    return this.item(144) || void 0;
  }
  get 145() {
    return this.item(145) || void 0;
  }
  get 146() {
    return this.item(146) || void 0;
  }
  get 147() {
    return this.item(147) || void 0;
  }
  get 148() {
    return this.item(148) || void 0;
  }
  get 149() {
    return this.item(149) || void 0;
  }
  get 150() {
    return this.item(150) || void 0;
  }
  get 151() {
    return this.item(151) || void 0;
  }
  get 152() {
    return this.item(152) || void 0;
  }
  get 153() {
    return this.item(153) || void 0;
  }
  get 154() {
    return this.item(154) || void 0;
  }
  get 155() {
    return this.item(155) || void 0;
  }
  get 156() {
    return this.item(156) || void 0;
  }
  get 157() {
    return this.item(157) || void 0;
  }
  get 158() {
    return this.item(158) || void 0;
  }
  get 159() {
    return this.item(159) || void 0;
  }
  get 160() {
    return this.item(160) || void 0;
  }
  get 161() {
    return this.item(161) || void 0;
  }
  get 162() {
    return this.item(162) || void 0;
  }
  get 163() {
    return this.item(163) || void 0;
  }
  get 164() {
    return this.item(164) || void 0;
  }
  get 165() {
    return this.item(165) || void 0;
  }
  get 166() {
    return this.item(166) || void 0;
  }
  get 167() {
    return this.item(167) || void 0;
  }
  get 168() {
    return this.item(168) || void 0;
  }
  get 169() {
    return this.item(169) || void 0;
  }
  get 170() {
    return this.item(170) || void 0;
  }
  get 171() {
    return this.item(171) || void 0;
  }
  get 172() {
    return this.item(172) || void 0;
  }
  get 173() {
    return this.item(173) || void 0;
  }
  get 174() {
    return this.item(174) || void 0;
  }
  get 175() {
    return this.item(175) || void 0;
  }
  get 176() {
    return this.item(176) || void 0;
  }
  get 177() {
    return this.item(177) || void 0;
  }
  get 178() {
    return this.item(178) || void 0;
  }
  get 179() {
    return this.item(179) || void 0;
  }
  get 180() {
    return this.item(180) || void 0;
  }
  get 181() {
    return this.item(181) || void 0;
  }
  get 182() {
    return this.item(182) || void 0;
  }
  get 183() {
    return this.item(183) || void 0;
  }
  get 184() {
    return this.item(184) || void 0;
  }
  get 185() {
    return this.item(185) || void 0;
  }
  get 186() {
    return this.item(186) || void 0;
  }
  get 187() {
    return this.item(187) || void 0;
  }
  get 188() {
    return this.item(188) || void 0;
  }
  get 189() {
    return this.item(189) || void 0;
  }
  get 190() {
    return this.item(190) || void 0;
  }
  get 191() {
    return this.item(191) || void 0;
  }
  get 192() {
    return this.item(192) || void 0;
  }
  get 193() {
    return this.item(193) || void 0;
  }
  get 194() {
    return this.item(194) || void 0;
  }
  get 195() {
    return this.item(195) || void 0;
  }
  get 196() {
    return this.item(196) || void 0;
  }
  get 197() {
    return this.item(197) || void 0;
  }
  get 198() {
    return this.item(198) || void 0;
  }
  get 199() {
    return this.item(199) || void 0;
  }
  get 200() {
    return this.item(200) || void 0;
  }
  get 201() {
    return this.item(201) || void 0;
  }
  get 202() {
    return this.item(202) || void 0;
  }
  get 203() {
    return this.item(203) || void 0;
  }
  get 204() {
    return this.item(204) || void 0;
  }
  get 205() {
    return this.item(205) || void 0;
  }
  get 206() {
    return this.item(206) || void 0;
  }
  get 207() {
    return this.item(207) || void 0;
  }
  get 208() {
    return this.item(208) || void 0;
  }
  get 209() {
    return this.item(209) || void 0;
  }
  get 210() {
    return this.item(210) || void 0;
  }
  get 211() {
    return this.item(211) || void 0;
  }
  get 212() {
    return this.item(212) || void 0;
  }
  get 213() {
    return this.item(213) || void 0;
  }
  get 214() {
    return this.item(214) || void 0;
  }
  get 215() {
    return this.item(215) || void 0;
  }
  get 216() {
    return this.item(216) || void 0;
  }
  get 217() {
    return this.item(217) || void 0;
  }
  get 218() {
    return this.item(218) || void 0;
  }
  get 219() {
    return this.item(219) || void 0;
  }
  get 220() {
    return this.item(220) || void 0;
  }
  get 221() {
    return this.item(221) || void 0;
  }
  get 222() {
    return this.item(222) || void 0;
  }
  get 223() {
    return this.item(223) || void 0;
  }
  get 224() {
    return this.item(224) || void 0;
  }
  get 225() {
    return this.item(225) || void 0;
  }
  get 226() {
    return this.item(226) || void 0;
  }
  get 227() {
    return this.item(227) || void 0;
  }
  get 228() {
    return this.item(228) || void 0;
  }
  get 229() {
    return this.item(229) || void 0;
  }
  get 230() {
    return this.item(230) || void 0;
  }
  get 231() {
    return this.item(231) || void 0;
  }
  get 232() {
    return this.item(232) || void 0;
  }
  get 233() {
    return this.item(233) || void 0;
  }
  get 234() {
    return this.item(234) || void 0;
  }
  get 235() {
    return this.item(235) || void 0;
  }
  get 236() {
    return this.item(236) || void 0;
  }
  get 237() {
    return this.item(237) || void 0;
  }
  get 238() {
    return this.item(238) || void 0;
  }
  get 239() {
    return this.item(239) || void 0;
  }
  get 240() {
    return this.item(240) || void 0;
  }
  get 241() {
    return this.item(241) || void 0;
  }
  get 242() {
    return this.item(242) || void 0;
  }
  get 243() {
    return this.item(243) || void 0;
  }
  get 244() {
    return this.item(244) || void 0;
  }
  get 245() {
    return this.item(245) || void 0;
  }
  get 246() {
    return this.item(246) || void 0;
  }
  get 247() {
    return this.item(247) || void 0;
  }
  get 248() {
    return this.item(248) || void 0;
  }
  get 249() {
    return this.item(249) || void 0;
  }
  get 250() {
    return this.item(250) || void 0;
  }
  get 251() {
    return this.item(251) || void 0;
  }
  get 252() {
    return this.item(252) || void 0;
  }
  get 253() {
    return this.item(253) || void 0;
  }
  get 254() {
    return this.item(254) || void 0;
  }
  get 255() {
    return this.item(255) || void 0;
  }
  get 256() {
    return this.item(256) || void 0;
  }
  get 257() {
    return this.item(257) || void 0;
  }
  get 258() {
    return this.item(258) || void 0;
  }
  get 259() {
    return this.item(259) || void 0;
  }
  get 260() {
    return this.item(260) || void 0;
  }
  get 261() {
    return this.item(261) || void 0;
  }
  get 262() {
    return this.item(262) || void 0;
  }
  get 263() {
    return this.item(263) || void 0;
  }
  get 264() {
    return this.item(264) || void 0;
  }
  get 265() {
    return this.item(265) || void 0;
  }
  get 266() {
    return this.item(266) || void 0;
  }
  get 267() {
    return this.item(267) || void 0;
  }
  get 268() {
    return this.item(268) || void 0;
  }
  get 269() {
    return this.item(269) || void 0;
  }
  get 270() {
    return this.item(270) || void 0;
  }
  get 271() {
    return this.item(271) || void 0;
  }
  get 272() {
    return this.item(272) || void 0;
  }
  get 273() {
    return this.item(273) || void 0;
  }
  get 274() {
    return this.item(274) || void 0;
  }
  get 275() {
    return this.item(275) || void 0;
  }
  get 276() {
    return this.item(276) || void 0;
  }
  get 277() {
    return this.item(277) || void 0;
  }
  get 278() {
    return this.item(278) || void 0;
  }
  get 279() {
    return this.item(279) || void 0;
  }
  get 280() {
    return this.item(280) || void 0;
  }
  get 281() {
    return this.item(281) || void 0;
  }
  get 282() {
    return this.item(282) || void 0;
  }
  get 283() {
    return this.item(283) || void 0;
  }
  get 284() {
    return this.item(284) || void 0;
  }
  get 285() {
    return this.item(285) || void 0;
  }
  get 286() {
    return this.item(286) || void 0;
  }
  get 287() {
    return this.item(287) || void 0;
  }
  get 288() {
    return this.item(288) || void 0;
  }
  get 289() {
    return this.item(289) || void 0;
  }
  get 290() {
    return this.item(290) || void 0;
  }
  get 291() {
    return this.item(291) || void 0;
  }
  get 292() {
    return this.item(292) || void 0;
  }
  get 293() {
    return this.item(293) || void 0;
  }
  get 294() {
    return this.item(294) || void 0;
  }
  get 295() {
    return this.item(295) || void 0;
  }
  get 296() {
    return this.item(296) || void 0;
  }
  get 297() {
    return this.item(297) || void 0;
  }
  get 298() {
    return this.item(298) || void 0;
  }
  get 299() {
    return this.item(299) || void 0;
  }
  get 300() {
    return this.item(300) || void 0;
  }
  get 301() {
    return this.item(301) || void 0;
  }
  get 302() {
    return this.item(302) || void 0;
  }
  get 303() {
    return this.item(303) || void 0;
  }
  get 304() {
    return this.item(304) || void 0;
  }
  get 305() {
    return this.item(305) || void 0;
  }
  get 306() {
    return this.item(306) || void 0;
  }
  get 307() {
    return this.item(307) || void 0;
  }
  get 308() {
    return this.item(308) || void 0;
  }
  get 309() {
    return this.item(309) || void 0;
  }
  get 310() {
    return this.item(310) || void 0;
  }
  get 311() {
    return this.item(311) || void 0;
  }
  get 312() {
    return this.item(312) || void 0;
  }
  get 313() {
    return this.item(313) || void 0;
  }
  get 314() {
    return this.item(314) || void 0;
  }
  get 315() {
    return this.item(315) || void 0;
  }
  get 316() {
    return this.item(316) || void 0;
  }
  get 317() {
    return this.item(317) || void 0;
  }
  get 318() {
    return this.item(318) || void 0;
  }
  get 319() {
    return this.item(319) || void 0;
  }
  get 320() {
    return this.item(320) || void 0;
  }
  get 321() {
    return this.item(321) || void 0;
  }
  get 322() {
    return this.item(322) || void 0;
  }
  get 323() {
    return this.item(323) || void 0;
  }
  get 324() {
    return this.item(324) || void 0;
  }
  get 325() {
    return this.item(325) || void 0;
  }
  get 326() {
    return this.item(326) || void 0;
  }
  get 327() {
    return this.item(327) || void 0;
  }
  get 328() {
    return this.item(328) || void 0;
  }
  get 329() {
    return this.item(329) || void 0;
  }
  get 330() {
    return this.item(330) || void 0;
  }
  get 331() {
    return this.item(331) || void 0;
  }
  get 332() {
    return this.item(332) || void 0;
  }
  get 333() {
    return this.item(333) || void 0;
  }
  get 334() {
    return this.item(334) || void 0;
  }
  get 335() {
    return this.item(335) || void 0;
  }
  get 336() {
    return this.item(336) || void 0;
  }
  get 337() {
    return this.item(337) || void 0;
  }
  get 338() {
    return this.item(338) || void 0;
  }
  get 339() {
    return this.item(339) || void 0;
  }
  get 340() {
    return this.item(340) || void 0;
  }
  get 341() {
    return this.item(341) || void 0;
  }
  get 342() {
    return this.item(342) || void 0;
  }
  get 343() {
    return this.item(343) || void 0;
  }
  get 344() {
    return this.item(344) || void 0;
  }
  get 345() {
    return this.item(345) || void 0;
  }
  get 346() {
    return this.item(346) || void 0;
  }
  get 347() {
    return this.item(347) || void 0;
  }
  get 348() {
    return this.item(348) || void 0;
  }
  get 349() {
    return this.item(349) || void 0;
  }
  get 350() {
    return this.item(350) || void 0;
  }
  get 351() {
    return this.item(351) || void 0;
  }
  get 352() {
    return this.item(352) || void 0;
  }
  get 353() {
    return this.item(353) || void 0;
  }
  get 354() {
    return this.item(354) || void 0;
  }
  get 355() {
    return this.item(355) || void 0;
  }
  get 356() {
    return this.item(356) || void 0;
  }
  get 357() {
    return this.item(357) || void 0;
  }
  get 358() {
    return this.item(358) || void 0;
  }
  get 359() {
    return this.item(359) || void 0;
  }
  get 360() {
    return this.item(360) || void 0;
  }
  get 361() {
    return this.item(361) || void 0;
  }
  get 362() {
    return this.item(362) || void 0;
  }
  get 363() {
    return this.item(363) || void 0;
  }
  get 364() {
    return this.item(364) || void 0;
  }
  get 365() {
    return this.item(365) || void 0;
  }
  get 366() {
    return this.item(366) || void 0;
  }
  get 367() {
    return this.item(367) || void 0;
  }
  get 368() {
    return this.item(368) || void 0;
  }
  get 369() {
    return this.item(369) || void 0;
  }
  get 370() {
    return this.item(370) || void 0;
  }
  get 371() {
    return this.item(371) || void 0;
  }
  get 372() {
    return this.item(372) || void 0;
  }
  get 373() {
    return this.item(373) || void 0;
  }
  get 374() {
    return this.item(374) || void 0;
  }
  get 375() {
    return this.item(375) || void 0;
  }
  get 376() {
    return this.item(376) || void 0;
  }
  get 377() {
    return this.item(377) || void 0;
  }
  get 378() {
    return this.item(378) || void 0;
  }
  get 379() {
    return this.item(379) || void 0;
  }
  get 380() {
    return this.item(380) || void 0;
  }
  get 381() {
    return this.item(381) || void 0;
  }
  get 382() {
    return this.item(382) || void 0;
  }
  get 383() {
    return this.item(383) || void 0;
  }
  get 384() {
    return this.item(384) || void 0;
  }
  get 385() {
    return this.item(385) || void 0;
  }
  get 386() {
    return this.item(386) || void 0;
  }
  get 387() {
    return this.item(387) || void 0;
  }
  get 388() {
    return this.item(388) || void 0;
  }
  get 389() {
    return this.item(389) || void 0;
  }
  get 390() {
    return this.item(390) || void 0;
  }
  get 391() {
    return this.item(391) || void 0;
  }
  get 392() {
    return this.item(392) || void 0;
  }
  get 393() {
    return this.item(393) || void 0;
  }
  /**
   * CSS properties
   */
  get accentColor() {
    return this.getPropertyValue("accent-color");
  }
  set accentColor(value2) {
    this.setProperty("accent-color", value2);
  }
  get appRegion() {
    return this.getPropertyValue("app-region");
  }
  set appRegion(value2) {
    this.setProperty("app-region", value2);
  }
  get alignContent() {
    return this.getPropertyValue("align-content");
  }
  set alignContent(value2) {
    this.setProperty("align-content", value2);
  }
  get alignItems() {
    return this.getPropertyValue("align-items");
  }
  set alignItems(value2) {
    this.setProperty("align-items", value2);
  }
  get alignSelf() {
    return this.getPropertyValue("align-self");
  }
  set alignSelf(value2) {
    this.setProperty("align-self", value2);
  }
  get alignmentBaseline() {
    return this.getPropertyValue("alignment-baseline");
  }
  set alignmentBaseline(value2) {
    this.setProperty("alignment-baseline", value2);
  }
  get all() {
    return this.getPropertyValue("all");
  }
  set all(value2) {
    this.setProperty("all", value2);
  }
  get animation() {
    return this.getPropertyValue("animation");
  }
  set animation(value2) {
    this.setProperty("animation", value2);
  }
  get animationDelay() {
    return this.getPropertyValue("animation-delay");
  }
  set animationDelay(value2) {
    this.setProperty("animation-delay", value2);
  }
  get animationDirection() {
    return this.getPropertyValue("animation-direction");
  }
  set animationDirection(value2) {
    this.setProperty("animation-direction", value2);
  }
  get animationDuration() {
    return this.getPropertyValue("animation-duration");
  }
  set animationDuration(value2) {
    this.setProperty("animation-duration", value2);
  }
  get animationFillMode() {
    return this.getPropertyValue("animation-fill-mode");
  }
  set animationFillMode(value2) {
    this.setProperty("animation-fill-mode", value2);
  }
  get animationIterationCount() {
    return this.getPropertyValue("animation-iteration-count");
  }
  set animationIterationCount(value2) {
    this.setProperty("animation-iteration-count", value2);
  }
  get animationName() {
    return this.getPropertyValue("animation-name");
  }
  set animationName(value2) {
    this.setProperty("animation-name", value2);
  }
  get animationPlayState() {
    return this.getPropertyValue("animation-play-state");
  }
  set animationPlayState(value2) {
    this.setProperty("animation-play-state", value2);
  }
  get animationTimingFunction() {
    return this.getPropertyValue("animation-timing-function");
  }
  set animationTimingFunction(value2) {
    this.setProperty("animation-timing-function", value2);
  }
  get appearance() {
    return this.getPropertyValue("appearance");
  }
  set appearance(value2) {
    this.setProperty("appearance", value2);
  }
  get backdropFilter() {
    return this.getPropertyValue("backdrop-filter");
  }
  set backdropFilter(value2) {
    this.setProperty("backdrop-filter", value2);
  }
  get backfaceVisibility() {
    return this.getPropertyValue("backface-visibility");
  }
  set backfaceVisibility(value2) {
    this.setProperty("backface-visibility", value2);
  }
  get background() {
    return this.getPropertyValue("background");
  }
  set background(value2) {
    this.setProperty("background", value2);
  }
  get backgroundAttachment() {
    return this.getPropertyValue("background-attachment");
  }
  set backgroundAttachment(value2) {
    this.setProperty("background-attachment", value2);
  }
  get backgroundBlendMode() {
    return this.getPropertyValue("background-blend-mode");
  }
  set backgroundBlendMode(value2) {
    this.setProperty("background-blend-mode", value2);
  }
  get backgroundClip() {
    return this.getPropertyValue("background-clip");
  }
  set backgroundClip(value2) {
    this.setProperty("background-clip", value2);
  }
  get backgroundColor() {
    return this.getPropertyValue("background-color");
  }
  set backgroundColor(value2) {
    this.setProperty("background-color", value2);
  }
  get backgroundImage() {
    return this.getPropertyValue("background-image");
  }
  set backgroundImage(value2) {
    this.setProperty("background-image", value2);
  }
  get backgroundOrigin() {
    return this.getPropertyValue("background-origin");
  }
  set backgroundOrigin(value2) {
    this.setProperty("background-origin", value2);
  }
  get backgroundPosition() {
    return this.getPropertyValue("background-position");
  }
  set backgroundPosition(value2) {
    this.setProperty("background-position", value2);
  }
  get backgroundPositionX() {
    return this.getPropertyValue("background-position-x");
  }
  set backgroundPositionX(value2) {
    this.setProperty("background-position-x", value2);
  }
  get backgroundPositionY() {
    return this.getPropertyValue("background-position-y");
  }
  set backgroundPositionY(value2) {
    this.setProperty("background-position-y", value2);
  }
  get backgroundRepeat() {
    return this.getPropertyValue("background-repeat");
  }
  set backgroundRepeat(value2) {
    this.setProperty("background-repeat", value2);
  }
  get backgroundRepeatX() {
    return this.getPropertyValue("background-repeat-x");
  }
  set backgroundRepeatX(value2) {
    this.setProperty("background-repeat-x", value2);
  }
  get backgroundRepeatY() {
    return this.getPropertyValue("background-repeat-y");
  }
  set backgroundRepeatY(value2) {
    this.setProperty("background-repeat-y", value2);
  }
  get backgroundSize() {
    return this.getPropertyValue("background-size");
  }
  set backgroundSize(value2) {
    this.setProperty("background-size", value2);
  }
  get baselineShift() {
    return this.getPropertyValue("baseline-shift");
  }
  set baselineShift(value2) {
    this.setProperty("baseline-shift", value2);
  }
  get blockSize() {
    return this.getPropertyValue("block-size");
  }
  set blockSize(value2) {
    this.setProperty("block-size", value2);
  }
  get border() {
    return this.getPropertyValue("border");
  }
  set border(value2) {
    this.setProperty("border", value2);
  }
  get borderBlockEnd() {
    return this.getPropertyValue("border-block-end");
  }
  set borderBlockEnd(value2) {
    this.setProperty("border-block-end", value2);
  }
  get borderBlockEndColor() {
    return this.getPropertyValue("border-block-end-color");
  }
  set borderBlockEndColor(value2) {
    this.setProperty("border-block-end-color", value2);
  }
  get borderBlockEndStyle() {
    return this.getPropertyValue("border-block-end-style");
  }
  set borderBlockEndStyle(value2) {
    this.setProperty("border-block-end-style", value2);
  }
  get borderBlockEndWidth() {
    return this.getPropertyValue("border-block-end-width");
  }
  set borderBlockEndWidth(value2) {
    this.setProperty("border-block-end-width", value2);
  }
  get borderBlockStart() {
    return this.getPropertyValue("border-block-start");
  }
  set borderBlockStart(value2) {
    this.setProperty("border-block-start", value2);
  }
  get borderBlockStartColor() {
    return this.getPropertyValue("border-block-start-color");
  }
  set borderBlockStartColor(value2) {
    this.setProperty("border-block-start-color", value2);
  }
  get borderBlockStartStyle() {
    return this.getPropertyValue("border-block-start-style");
  }
  set borderBlockStartStyle(value2) {
    this.setProperty("border-block-start-style", value2);
  }
  get borderBlockStartWidth() {
    return this.getPropertyValue("border-block-start-width");
  }
  set borderBlockStartWidth(value2) {
    this.setProperty("border-block-start-width", value2);
  }
  get borderBottom() {
    return this.getPropertyValue("border-bottom");
  }
  set borderBottom(value2) {
    this.setProperty("border-bottom", value2);
  }
  get borderBottomColor() {
    return this.getPropertyValue("border-bottom-color");
  }
  set borderBottomColor(value2) {
    this.setProperty("border-bottom-color", value2);
  }
  get borderBottomLeftRadius() {
    return this.getPropertyValue("border-bottom-left-radius");
  }
  set borderBottomLeftRadius(value2) {
    this.setProperty("border-bottom-left-radius", value2);
  }
  get borderBottomRightRadius() {
    return this.getPropertyValue("border-bottom-right-radius");
  }
  set borderBottomRightRadius(value2) {
    this.setProperty("border-bottom-right-radius", value2);
  }
  get borderBottomStyle() {
    return this.getPropertyValue("border-bottom-style");
  }
  set borderBottomStyle(value2) {
    this.setProperty("border-bottom-style", value2);
  }
  get borderBottomWidth() {
    return this.getPropertyValue("border-bottom-width");
  }
  set borderBottomWidth(value2) {
    this.setProperty("border-bottom-width", value2);
  }
  get borderCollapse() {
    return this.getPropertyValue("border-collapse");
  }
  set borderCollapse(value2) {
    this.setProperty("border-collapse", value2);
  }
  get borderColor() {
    return this.getPropertyValue("border-color");
  }
  set borderColor(value2) {
    this.setProperty("border-color", value2);
  }
  get borderImage() {
    return this.getPropertyValue("border-image");
  }
  set borderImage(value2) {
    this.setProperty("border-image", value2);
  }
  get borderImageOutset() {
    return this.getPropertyValue("border-image-outset");
  }
  set borderImageOutset(value2) {
    this.setProperty("border-image-outset", value2);
  }
  get borderImageRepeat() {
    return this.getPropertyValue("border-image-repeat");
  }
  set borderImageRepeat(value2) {
    this.setProperty("border-image-repeat", value2);
  }
  get borderImageSlice() {
    return this.getPropertyValue("border-image-slice");
  }
  set borderImageSlice(value2) {
    this.setProperty("border-image-slice", value2);
  }
  get borderImageSource() {
    return this.getPropertyValue("border-image-source");
  }
  set borderImageSource(value2) {
    this.setProperty("border-image-source", value2);
  }
  get borderImageWidth() {
    return this.getPropertyValue("border-image-width");
  }
  set borderImageWidth(value2) {
    this.setProperty("border-image-width", value2);
  }
  get borderInlineEnd() {
    return this.getPropertyValue("border-inline-end");
  }
  set borderInlineEnd(value2) {
    this.setProperty("border-inline-end", value2);
  }
  get borderInlineEndColor() {
    return this.getPropertyValue("border-inline-end-color");
  }
  set borderInlineEndColor(value2) {
    this.setProperty("border-inline-end-color", value2);
  }
  get borderInlineEndStyle() {
    return this.getPropertyValue("border-inline-end-style");
  }
  set borderInlineEndStyle(value2) {
    this.setProperty("border-inline-end-style", value2);
  }
  get borderInlineEndWidth() {
    return this.getPropertyValue("border-inline-end-width");
  }
  set borderInlineEndWidth(value2) {
    this.setProperty("border-inline-end-width", value2);
  }
  get borderInlineStart() {
    return this.getPropertyValue("border-inline-start");
  }
  set borderInlineStart(value2) {
    this.setProperty("border-inline-start", value2);
  }
  get borderInlineStartColor() {
    return this.getPropertyValue("border-inline-start-color");
  }
  set borderInlineStartColor(value2) {
    this.setProperty("border-inline-start-color", value2);
  }
  get borderInlineStartStyle() {
    return this.getPropertyValue("border-inline-start-style");
  }
  set borderInlineStartStyle(value2) {
    this.setProperty("border-inline-start-style", value2);
  }
  get borderInlineStartWidth() {
    return this.getPropertyValue("border-inline-start-width");
  }
  set borderInlineStartWidth(value2) {
    this.setProperty("border-inline-start-width", value2);
  }
  get borderLeft() {
    return this.getPropertyValue("border-left");
  }
  set borderLeft(value2) {
    this.setProperty("border-left", value2);
  }
  get borderLeftColor() {
    return this.getPropertyValue("border-left-color");
  }
  set borderLeftColor(value2) {
    this.setProperty("border-left-color", value2);
  }
  get borderLeftStyle() {
    return this.getPropertyValue("border-left-style");
  }
  set borderLeftStyle(value2) {
    this.setProperty("border-left-style", value2);
  }
  get borderLeftWidth() {
    return this.getPropertyValue("border-left-width");
  }
  set borderLeftWidth(value2) {
    this.setProperty("border-left-width", value2);
  }
  get borderRadius() {
    return this.getPropertyValue("border-radius");
  }
  set borderRadius(value2) {
    this.setProperty("border-radius", value2);
  }
  get borderRight() {
    return this.getPropertyValue("border-right");
  }
  set borderRight(value2) {
    this.setProperty("border-right", value2);
  }
  get borderRightColor() {
    return this.getPropertyValue("border-right-color");
  }
  set borderRightColor(value2) {
    this.setProperty("border-right-color", value2);
  }
  get borderRightStyle() {
    return this.getPropertyValue("border-right-style");
  }
  set borderRightStyle(value2) {
    this.setProperty("border-right-style", value2);
  }
  get borderRightWidth() {
    return this.getPropertyValue("border-right-width");
  }
  set borderRightWidth(value2) {
    this.setProperty("border-right-width", value2);
  }
  get borderSpacing() {
    return this.getPropertyValue("border-spacing");
  }
  set borderSpacing(value2) {
    this.setProperty("border-spacing", value2);
  }
  get borderStyle() {
    return this.getPropertyValue("border-style");
  }
  set borderStyle(value2) {
    this.setProperty("border-style", value2);
  }
  get borderTop() {
    return this.getPropertyValue("border-top");
  }
  set borderTop(value2) {
    this.setProperty("border-top", value2);
  }
  get borderTopColor() {
    return this.getPropertyValue("border-top-color");
  }
  set borderTopColor(value2) {
    this.setProperty("border-top-color", value2);
  }
  get borderTopLeftRadius() {
    return this.getPropertyValue("border-top-left-radius");
  }
  set borderTopLeftRadius(value2) {
    this.setProperty("border-top-left-radius", value2);
  }
  get borderTopRightRadius() {
    return this.getPropertyValue("border-top-right-radius");
  }
  set borderTopRightRadius(value2) {
    this.setProperty("border-top-right-radius", value2);
  }
  get borderTopStyle() {
    return this.getPropertyValue("border-top-style");
  }
  set borderTopStyle(value2) {
    this.setProperty("border-top-style", value2);
  }
  get borderTopWidth() {
    return this.getPropertyValue("border-top-width");
  }
  set borderTopWidth(value2) {
    this.setProperty("border-top-width", value2);
  }
  get borderWidth() {
    return this.getPropertyValue("border-width");
  }
  set borderWidth(value2) {
    this.setProperty("border-width", value2);
  }
  get borderEndEndRadius() {
    return this.getPropertyValue("border-end-end-radius");
  }
  set borderEndEndRadius(value2) {
    this.setProperty("border-end-end-radius", value2);
  }
  get borderEndStartRadius() {
    return this.getPropertyValue("border-end-start-radius");
  }
  set borderEndStartRadius(value2) {
    this.setProperty("border-end-start-radius", value2);
  }
  get borderStartEndRadius() {
    return this.getPropertyValue("border-start-end-radius");
  }
  set borderStartEndRadius(value2) {
    this.setProperty("border-start-end-radius", value2);
  }
  get borderStartStartRadius() {
    return this.getPropertyValue("border-start-start-radius");
  }
  set borderStartStartRadius(value2) {
    this.setProperty("border-start-start-radius", value2);
  }
  get bottom() {
    return this.getPropertyValue("bottom");
  }
  set bottom(value2) {
    this.setProperty("bottom", value2);
  }
  get boxShadow() {
    return this.getPropertyValue("box-shadow");
  }
  set boxShadow(value2) {
    this.setProperty("box-shadow", value2);
  }
  get boxSizing() {
    return this.getPropertyValue("box-sizing");
  }
  set boxSizing(value2) {
    this.setProperty("box-sizing", value2);
  }
  get breakAfter() {
    return this.getPropertyValue("break-after");
  }
  set breakAfter(value2) {
    this.setProperty("break-after", value2);
  }
  get breakBefore() {
    return this.getPropertyValue("break-before");
  }
  set breakBefore(value2) {
    this.setProperty("break-before", value2);
  }
  get breakInside() {
    return this.getPropertyValue("break-inside");
  }
  set breakInside(value2) {
    this.setProperty("break-inside", value2);
  }
  get bufferedRendering() {
    return this.getPropertyValue("buffered-rendering");
  }
  set bufferedRendering(value2) {
    this.setProperty("buffered-rendering", value2);
  }
  get captionSide() {
    return this.getPropertyValue("caption-side");
  }
  set captionSide(value2) {
    this.setProperty("caption-side", value2);
  }
  get caretColor() {
    return this.getPropertyValue("caret-color");
  }
  set caretColor(value2) {
    this.setProperty("caret-color", value2);
  }
  get clear() {
    return this.getPropertyValue("clear");
  }
  set clear(value2) {
    this.setProperty("clear", value2);
  }
  get clip() {
    return this.getPropertyValue("clip");
  }
  set clip(value2) {
    this.setProperty("clip", value2);
  }
  get clipPath() {
    return this.getPropertyValue("clip-path");
  }
  set clipPath(value2) {
    this.setProperty("clip-path", value2);
  }
  get clipRule() {
    return this.getPropertyValue("clip-rule");
  }
  set clipRule(value2) {
    this.setProperty("clip-rule", value2);
  }
  get color() {
    return this.getPropertyValue("color");
  }
  set color(value2) {
    this.setProperty("color", value2);
  }
  get colorInterpolation() {
    return this.getPropertyValue("color-interpolation");
  }
  set colorInterpolation(value2) {
    this.setProperty("color-interpolation", value2);
  }
  get colorInterpolationFilters() {
    return this.getPropertyValue("color-interpolation-filters");
  }
  set colorInterpolationFilters(value2) {
    this.setProperty("color-interpolation-filters", value2);
  }
  get colorRendering() {
    return this.getPropertyValue("color-rendering");
  }
  set colorRendering(value2) {
    this.setProperty("color-rendering", value2);
  }
  get colorScheme() {
    return this.getPropertyValue("color-scheme");
  }
  set colorScheme(value2) {
    this.setProperty("color-scheme", value2);
  }
  get columnCount() {
    return this.getPropertyValue("column-count");
  }
  set columnCount(value2) {
    this.setProperty("column-count", value2);
  }
  get columnFill() {
    return this.getPropertyValue("column-fill");
  }
  set columnFill(value2) {
    this.setProperty("column-fill", value2);
  }
  get columnGap() {
    return this.getPropertyValue("column-gap");
  }
  set columnGap(value2) {
    this.setProperty("column-gap", value2);
  }
  get columnRule() {
    return this.getPropertyValue("column-rule");
  }
  set columnRule(value2) {
    this.setProperty("column-rule", value2);
  }
  get columnRuleColor() {
    return this.getPropertyValue("column-rule-color");
  }
  set columnRuleColor(value2) {
    this.setProperty("column-rule-color", value2);
  }
  get columnRuleStyle() {
    return this.getPropertyValue("column-rule-style");
  }
  set columnRuleStyle(value2) {
    this.setProperty("column-rule-style", value2);
  }
  get columnRuleWidth() {
    return this.getPropertyValue("column-rule-width");
  }
  set columnRuleWidth(value2) {
    this.setProperty("column-rule-width", value2);
  }
  get columnSpan() {
    return this.getPropertyValue("column-span");
  }
  set columnSpan(value2) {
    this.setProperty("column-span", value2);
  }
  get columnWidth() {
    return this.getPropertyValue("column-width");
  }
  set columnWidth(value2) {
    this.setProperty("column-width", value2);
  }
  get columns() {
    return this.getPropertyValue("columns");
  }
  set columns(value2) {
    this.setProperty("columns", value2);
  }
  get contain() {
    return this.getPropertyValue("contain");
  }
  set contain(value2) {
    this.setProperty("contain", value2);
  }
  get containIntrinsicSize() {
    return this.getPropertyValue("contain-intrinsic-size");
  }
  set containIntrinsicSize(value2) {
    this.setProperty("contain-intrinsic-size", value2);
  }
  get content() {
    return this.getPropertyValue("content");
  }
  set content(value2) {
    this.setProperty("content", value2);
  }
  get contentVisibility() {
    return this.getPropertyValue("content-visibility");
  }
  set contentVisibility(value2) {
    this.setProperty("content-visibility", value2);
  }
  get counterIncrement() {
    return this.getPropertyValue("counter-increment");
  }
  set counterIncrement(value2) {
    this.setProperty("counter-increment", value2);
  }
  get counterReset() {
    return this.getPropertyValue("counter-reset");
  }
  set counterReset(value2) {
    this.setProperty("counter-reset", value2);
  }
  get counterSet() {
    return this.getPropertyValue("counter-set");
  }
  set counterSet(value2) {
    this.setProperty("counter-set", value2);
  }
  get containIntrinsicBlockSize() {
    return this.getPropertyValue("contain-intrinsic-block-size");
  }
  set containIntrinsicBlockSize(value2) {
    this.setProperty("contain-intrinsic-block-size", value2);
  }
  get containIntrinsicHeight() {
    return this.getPropertyValue("contain-intrinsic-height");
  }
  set containIntrinsicHeight(value2) {
    this.setProperty("contain-intrinsic-height", value2);
  }
  get containIntrinsicInlineSize() {
    return this.getPropertyValue("contain-intrinsic-inline-size");
  }
  set containIntrinsicInlineSize(value2) {
    this.setProperty("contain-intrinsic-inline-size", value2);
  }
  get containIntrinsicWidth() {
    return this.getPropertyValue("contain-intrinsic-width");
  }
  set containIntrinsicWidth(value2) {
    this.setProperty("contain-intrinsic-width", value2);
  }
  get cssFloat() {
    return this.getPropertyValue("css-float");
  }
  set cssFloat(value2) {
    this.setProperty("css-float", value2);
  }
  get cursor() {
    return this.getPropertyValue("cursor");
  }
  set cursor(value2) {
    this.setProperty("cursor", value2);
  }
  get cx() {
    return this.getPropertyValue("cx");
  }
  set cx(value2) {
    this.setProperty("cx", value2);
  }
  get cy() {
    return this.getPropertyValue("cy");
  }
  set cy(value2) {
    this.setProperty("cy", value2);
  }
  get d() {
    return this.getPropertyValue("d");
  }
  set d(value2) {
    this.setProperty("d", value2);
  }
  get direction() {
    return this.getPropertyValue("direction");
  }
  set direction(value2) {
    this.setProperty("direction", value2);
  }
  get display() {
    return this.getPropertyValue("display");
  }
  set display(value2) {
    this.setProperty("display", value2);
  }
  get dominantBaseline() {
    return this.getPropertyValue("dominant-baseline");
  }
  set dominantBaseline(value2) {
    this.setProperty("dominant-baseline", value2);
  }
  get emptyCells() {
    return this.getPropertyValue("empty-cells");
  }
  set emptyCells(value2) {
    this.setProperty("empty-cells", value2);
  }
  get fill() {
    return this.getPropertyValue("fill");
  }
  set fill(value2) {
    this.setProperty("fill", value2);
  }
  get fillOpacity() {
    return this.getPropertyValue("fill-opacity");
  }
  set fillOpacity(value2) {
    this.setProperty("fill-opacity", value2);
  }
  get fillRule() {
    return this.getPropertyValue("fill-rule");
  }
  set fillRule(value2) {
    this.setProperty("fill-rule", value2);
  }
  get filter() {
    return this.getPropertyValue("filter");
  }
  set filter(value2) {
    this.setProperty("filter", value2);
  }
  get flex() {
    return this.getPropertyValue("flex");
  }
  set flex(value2) {
    this.setProperty("flex", value2);
  }
  get flexBasis() {
    return this.getPropertyValue("flex-basis");
  }
  set flexBasis(value2) {
    this.setProperty("flex-basis", value2);
  }
  get flexDirection() {
    return this.getPropertyValue("flex-direction");
  }
  set flexDirection(value2) {
    this.setProperty("flex-direction", value2);
  }
  get flexFlow() {
    return this.getPropertyValue("flex-flow");
  }
  set flexFlow(value2) {
    this.setProperty("flex-flow", value2);
  }
  get flexGrow() {
    return this.getPropertyValue("flex-grow");
  }
  set flexGrow(value2) {
    this.setProperty("flex-grow", value2);
  }
  get flexShrink() {
    return this.getPropertyValue("flex-shrink");
  }
  set flexShrink(value2) {
    this.setProperty("flex-shrink", value2);
  }
  get flexWrap() {
    return this.getPropertyValue("flex-wrap");
  }
  set flexWrap(value2) {
    this.setProperty("flex-wrap", value2);
  }
  get float() {
    return this.getPropertyValue("float");
  }
  set float(value2) {
    this.setProperty("float", value2);
  }
  get floodColor() {
    return this.getPropertyValue("flood-color");
  }
  set floodColor(value2) {
    this.setProperty("flood-color", value2);
  }
  get floodOpacity() {
    return this.getPropertyValue("flood-opacity");
  }
  set floodOpacity(value2) {
    this.setProperty("flood-opacity", value2);
  }
  get font() {
    return this.getPropertyValue("font");
  }
  set font(value2) {
    this.setProperty("font", value2);
  }
  get fontDisplay() {
    return this.getPropertyValue("font-display");
  }
  set fontDisplay(value2) {
    this.setProperty("font-display", value2);
  }
  get fontFamily() {
    return this.getPropertyValue("font-family");
  }
  set fontFamily(value2) {
    this.setProperty("font-family", value2);
  }
  get fontFeatureSettings() {
    return this.getPropertyValue("font-feature-settings");
  }
  set fontFeatureSettings(value2) {
    this.setProperty("font-feature-settings", value2);
  }
  get fontKerning() {
    return this.getPropertyValue("font-kerning");
  }
  set fontKerning(value2) {
    this.setProperty("font-kerning", value2);
  }
  get fontOpticalSizing() {
    return this.getPropertyValue("font-optical-sizing");
  }
  set fontOpticalSizing(value2) {
    this.setProperty("font-optical-sizing", value2);
  }
  get fontSize() {
    return this.getPropertyValue("font-size");
  }
  set fontSize(value2) {
    this.setProperty("font-size", value2);
  }
  get fontStretch() {
    return this.getPropertyValue("font-stretch");
  }
  set fontStretch(value2) {
    this.setProperty("font-stretch", value2);
  }
  get fontStyle() {
    return this.getPropertyValue("font-style");
  }
  set fontStyle(value2) {
    this.setProperty("font-style", value2);
  }
  get fontVariant() {
    return this.getPropertyValue("font-variant");
  }
  set fontVariant(value2) {
    this.setProperty("font-variant", value2);
  }
  get fontVariantCaps() {
    return this.getPropertyValue("font-variant-caps");
  }
  set fontVariantCaps(value2) {
    this.setProperty("font-variant-caps", value2);
  }
  get fontVariantEastAsian() {
    return this.getPropertyValue("font-variant-east-asian");
  }
  set fontVariantEastAsian(value2) {
    this.setProperty("font-variant-east-asian", value2);
  }
  get fontVariantLigatures() {
    return this.getPropertyValue("font-variant-ligatures");
  }
  set fontVariantLigatures(value2) {
    this.setProperty("font-variant-ligatures", value2);
  }
  get fontVariantNumeric() {
    return this.getPropertyValue("font-variant-numeric");
  }
  set fontVariantNumeric(value2) {
    this.setProperty("font-variant-numeric", value2);
  }
  get fontVariationSettings() {
    return this.getPropertyValue("font-variation-settings");
  }
  set fontVariationSettings(value2) {
    this.setProperty("font-variation-settings", value2);
  }
  get fontPalette() {
    return this.getPropertyValue("font-palette");
  }
  set fontPalette(value2) {
    this.setProperty("font-palette", value2);
  }
  get fontSynthesisSmallCaps() {
    return this.getPropertyValue("font-synthesis-small-caps");
  }
  set fontSynthesisSmallCaps(value2) {
    this.setProperty("font-synthesis-small-caps", value2);
  }
  get fontSynthesisStyle() {
    return this.getPropertyValue("font-synthesis-style");
  }
  set fontSynthesisStyle(value2) {
    this.setProperty("font-synthesis-style", value2);
  }
  get fontSynthesisWeight() {
    return this.getPropertyValue("font-synthesis-weight");
  }
  set fontSynthesisWeight(value2) {
    this.setProperty("font-synthesis-weight", value2);
  }
  get fontWeight() {
    return this.getPropertyValue("font-weight");
  }
  set fontWeight(value2) {
    this.setProperty("font-weight", value2);
  }
  get gap() {
    return this.getPropertyValue("gap");
  }
  set gap(value2) {
    this.setProperty("gap", value2);
  }
  get grid() {
    return this.getPropertyValue("grid");
  }
  set grid(value2) {
    this.setProperty("grid", value2);
  }
  get gridArea() {
    return this.getPropertyValue("grid-area");
  }
  set gridArea(value2) {
    this.setProperty("grid-area", value2);
  }
  get gridAutoColumns() {
    return this.getPropertyValue("grid-auto-columns");
  }
  set gridAutoColumns(value2) {
    this.setProperty("grid-auto-columns", value2);
  }
  get gridAutoFlow() {
    return this.getPropertyValue("grid-auto-flow");
  }
  set gridAutoFlow(value2) {
    this.setProperty("grid-auto-flow", value2);
  }
  get gridAutoRows() {
    return this.getPropertyValue("grid-auto-rows");
  }
  set gridAutoRows(value2) {
    this.setProperty("grid-auto-rows", value2);
  }
  get gridColumn() {
    return this.getPropertyValue("grid-column");
  }
  set gridColumn(value2) {
    this.setProperty("grid-column", value2);
  }
  get gridColumnEnd() {
    return this.getPropertyValue("grid-column-end");
  }
  set gridColumnEnd(value2) {
    this.setProperty("grid-column-end", value2);
  }
  get gridColumnGap() {
    return this.getPropertyValue("grid-column-gap");
  }
  set gridColumnGap(value2) {
    this.setProperty("grid-column-gap", value2);
  }
  get gridColumnStart() {
    return this.getPropertyValue("grid-column-start");
  }
  set gridColumnStart(value2) {
    this.setProperty("grid-column-start", value2);
  }
  get gridGap() {
    return this.getPropertyValue("grid-gap");
  }
  set gridGap(value2) {
    this.setProperty("grid-gap", value2);
  }
  get gridRow() {
    return this.getPropertyValue("grid-row");
  }
  set gridRow(value2) {
    this.setProperty("grid-row", value2);
  }
  get gridRowEnd() {
    return this.getPropertyValue("grid-row-end");
  }
  set gridRowEnd(value2) {
    this.setProperty("grid-row-end", value2);
  }
  get gridRowGap() {
    return this.getPropertyValue("grid-row-gap");
  }
  set gridRowGap(value2) {
    this.setProperty("grid-row-gap", value2);
  }
  get gridRowStart() {
    return this.getPropertyValue("grid-row-start");
  }
  set gridRowStart(value2) {
    this.setProperty("grid-row-start", value2);
  }
  get gridTemplate() {
    return this.getPropertyValue("grid-template");
  }
  set gridTemplate(value2) {
    this.setProperty("grid-template", value2);
  }
  get gridTemplateAreas() {
    return this.getPropertyValue("grid-template-areas");
  }
  set gridTemplateAreas(value2) {
    this.setProperty("grid-template-areas", value2);
  }
  get gridTemplateColumns() {
    return this.getPropertyValue("grid-template-columns");
  }
  set gridTemplateColumns(value2) {
    this.setProperty("grid-template-columns", value2);
  }
  get gridTemplateRows() {
    return this.getPropertyValue("grid-template-rows");
  }
  set gridTemplateRows(value2) {
    this.setProperty("grid-template-rows", value2);
  }
  get height() {
    return this.getPropertyValue("height");
  }
  set height(value2) {
    this.setProperty("height", value2);
  }
  get hyphens() {
    return this.getPropertyValue("hyphens");
  }
  set hyphens(value2) {
    this.setProperty("hyphens", value2);
  }
  get imageOrientation() {
    return this.getPropertyValue("image-orientation");
  }
  set imageOrientation(value2) {
    this.setProperty("image-orientation", value2);
  }
  get imageRendering() {
    return this.getPropertyValue("image-rendering");
  }
  set imageRendering(value2) {
    this.setProperty("image-rendering", value2);
  }
  get inherits() {
    return this.getPropertyValue("inherits");
  }
  set inherits(value2) {
    this.setProperty("inherits", value2);
  }
  get initialValue() {
    return this.getPropertyValue("initial-value");
  }
  set initialValue(value2) {
    this.setProperty("initial-value", value2);
  }
  get inlineSize() {
    return this.getPropertyValue("inline-size");
  }
  set inlineSize(value2) {
    this.setProperty("inline-size", value2);
  }
  get isolation() {
    return this.getPropertyValue("isolation");
  }
  set isolation(value2) {
    this.setProperty("isolation", value2);
  }
  get insetBlockEnd() {
    return this.getPropertyValue("inset-block-end");
  }
  set insetBlockEnd(value2) {
    this.setProperty("inset-block-end", value2);
  }
  get insetBlockStart() {
    return this.getPropertyValue("inset-block-start");
  }
  set insetBlockStart(value2) {
    this.setProperty("inset-block-start", value2);
  }
  get insetInlineEnd() {
    return this.getPropertyValue("inset-inline-end");
  }
  set insetInlineEnd(value2) {
    this.setProperty("inset-inline-end", value2);
  }
  get insetInlineStart() {
    return this.getPropertyValue("inset-inline-start");
  }
  set insetInlineStart(value2) {
    this.setProperty("inset-inline-start", value2);
  }
  get justifyContent() {
    return this.getPropertyValue("justify-content");
  }
  set justifyContent(value2) {
    this.setProperty("justify-content", value2);
  }
  get justifyItems() {
    return this.getPropertyValue("justify-items");
  }
  set justifyItems(value2) {
    this.setProperty("justify-items", value2);
  }
  get justifySelf() {
    return this.getPropertyValue("justify-self");
  }
  set justifySelf(value2) {
    this.setProperty("justify-self", value2);
  }
  get left() {
    return this.getPropertyValue("left");
  }
  set left(value2) {
    this.setProperty("left", value2);
  }
  get letterSpacing() {
    return this.getPropertyValue("letter-spacing");
  }
  set letterSpacing(value2) {
    this.setProperty("letter-spacing", value2);
  }
  get lightingColor() {
    return this.getPropertyValue("lighting-color");
  }
  set lightingColor(value2) {
    this.setProperty("lighting-color", value2);
  }
  get lineBreak() {
    return this.getPropertyValue("line-break");
  }
  set lineBreak(value2) {
    this.setProperty("line-break", value2);
  }
  get lineHeight() {
    return this.getPropertyValue("line-height");
  }
  set lineHeight(value2) {
    this.setProperty("line-height", value2);
  }
  get listStyle() {
    return this.getPropertyValue("list-style");
  }
  set listStyle(value2) {
    this.setProperty("list-style", value2);
  }
  get listStyleImage() {
    return this.getPropertyValue("list-style-image");
  }
  set listStyleImage(value2) {
    this.setProperty("list-style-image", value2);
  }
  get listStylePosition() {
    return this.getPropertyValue("list-style-position");
  }
  set listStylePosition(value2) {
    this.setProperty("list-style-position", value2);
  }
  get listStyleType() {
    return this.getPropertyValue("list-style-type");
  }
  set listStyleType(value2) {
    this.setProperty("list-style-type", value2);
  }
  get margin() {
    return this.getPropertyValue("margin");
  }
  set margin(value2) {
    this.setProperty("margin", value2);
  }
  get marginBlockEnd() {
    return this.getPropertyValue("margin-block-end");
  }
  set marginBlockEnd(value2) {
    this.setProperty("margin-block-end", value2);
  }
  get marginBlockStart() {
    return this.getPropertyValue("margin-block-start");
  }
  set marginBlockStart(value2) {
    this.setProperty("margin-block-start", value2);
  }
  get marginBottom() {
    return this.getPropertyValue("margin-bottom");
  }
  set marginBottom(value2) {
    this.setProperty("margin-bottom", value2);
  }
  get marginInlineEnd() {
    return this.getPropertyValue("margin-inline-end");
  }
  set marginInlineEnd(value2) {
    this.setProperty("margin-inline-end", value2);
  }
  get marginInlineStart() {
    return this.getPropertyValue("margin-inline-start");
  }
  set marginInlineStart(value2) {
    this.setProperty("margin-inline-start", value2);
  }
  get marginLeft() {
    return this.getPropertyValue("margin-left");
  }
  set marginLeft(value2) {
    this.setProperty("margin-left", value2);
  }
  get marginRight() {
    return this.getPropertyValue("margin-right");
  }
  set marginRight(value2) {
    this.setProperty("margin-right", value2);
  }
  get marginTop() {
    return this.getPropertyValue("margin-top");
  }
  set marginTop(value2) {
    this.setProperty("margin-top", value2);
  }
  get marker() {
    return this.getPropertyValue("marker");
  }
  set marker(value2) {
    this.setProperty("marker", value2);
  }
  get markerEnd() {
    return this.getPropertyValue("marker-end");
  }
  set markerEnd(value2) {
    this.setProperty("marker-end", value2);
  }
  get markerMid() {
    return this.getPropertyValue("marker-mid");
  }
  set markerMid(value2) {
    this.setProperty("marker-mid", value2);
  }
  get markerStart() {
    return this.getPropertyValue("marker-start");
  }
  set markerStart(value2) {
    this.setProperty("marker-start", value2);
  }
  get mask() {
    return this.getPropertyValue("mask");
  }
  set mask(value2) {
    this.setProperty("mask", value2);
  }
  get maskType() {
    return this.getPropertyValue("mask-type");
  }
  set maskType(value2) {
    this.setProperty("mask-type", value2);
  }
  get maxBlockSize() {
    return this.getPropertyValue("max-block-size");
  }
  set maxBlockSize(value2) {
    this.setProperty("max-block-size", value2);
  }
  get maxHeight() {
    return this.getPropertyValue("max-height");
  }
  set maxHeight(value2) {
    this.setProperty("max-height", value2);
  }
  get maxInlineSize() {
    return this.getPropertyValue("max-inline-size");
  }
  set maxInlineSize(value2) {
    this.setProperty("max-inline-size", value2);
  }
  get maxWidth() {
    return this.getPropertyValue("max-width");
  }
  set maxWidth(value2) {
    this.setProperty("max-width", value2);
  }
  get maxZoom() {
    return this.getPropertyValue("max-zoom");
  }
  set maxZoom(value2) {
    this.setProperty("max-zoom", value2);
  }
  get minBlockSize() {
    return this.getPropertyValue("min-block-size");
  }
  set minBlockSize(value2) {
    this.setProperty("min-block-size", value2);
  }
  get minHeight() {
    return this.getPropertyValue("min-height");
  }
  set minHeight(value2) {
    this.setProperty("min-height", value2);
  }
  get minInlineSize() {
    return this.getPropertyValue("min-inline-size");
  }
  set minInlineSize(value2) {
    this.setProperty("min-inline-size", value2);
  }
  get minWidth() {
    return this.getPropertyValue("min-width");
  }
  set minWidth(value2) {
    this.setProperty("min-width", value2);
  }
  get minZoom() {
    return this.getPropertyValue("min-zoom");
  }
  set minZoom(value2) {
    this.setProperty("min-zoom", value2);
  }
  get mixBlendMode() {
    return this.getPropertyValue("mix-blend-mode");
  }
  set mixBlendMode(value2) {
    this.setProperty("mix-blend-mode", value2);
  }
  get objectFit() {
    return this.getPropertyValue("object-fit");
  }
  set objectFit(value2) {
    this.setProperty("object-fit", value2);
  }
  get objectPosition() {
    return this.getPropertyValue("object-position");
  }
  set objectPosition(value2) {
    this.setProperty("object-position", value2);
  }
  get offset() {
    return this.getPropertyValue("offset");
  }
  set offset(value2) {
    this.setProperty("offset", value2);
  }
  get offsetDistance() {
    return this.getPropertyValue("offset-distance");
  }
  set offsetDistance(value2) {
    this.setProperty("offset-distance", value2);
  }
  get offsetPath() {
    return this.getPropertyValue("offset-path");
  }
  set offsetPath(value2) {
    this.setProperty("offset-path", value2);
  }
  get offsetRotate() {
    return this.getPropertyValue("offset-rotate");
  }
  set offsetRotate(value2) {
    this.setProperty("offset-rotate", value2);
  }
  get opacity() {
    return this.getPropertyValue("opacity");
  }
  set opacity(value2) {
    this.setProperty("opacity", value2);
  }
  get order() {
    return this.getPropertyValue("order");
  }
  set order(value2) {
    this.setProperty("order", value2);
  }
  get orientation() {
    return this.getPropertyValue("orientation");
  }
  set orientation(value2) {
    this.setProperty("orientation", value2);
  }
  get orphans() {
    return this.getPropertyValue("orphans");
  }
  set orphans(value2) {
    this.setProperty("orphans", value2);
  }
  get outline() {
    return this.getPropertyValue("outline");
  }
  set outline(value2) {
    this.setProperty("outline", value2);
  }
  get outlineColor() {
    return this.getPropertyValue("outline-color");
  }
  set outlineColor(value2) {
    this.setProperty("outline-color", value2);
  }
  get outlineOffset() {
    return this.getPropertyValue("outline-offset");
  }
  set outlineOffset(value2) {
    this.setProperty("outline-offset", value2);
  }
  get outlineStyle() {
    return this.getPropertyValue("outline-style");
  }
  set outlineStyle(value2) {
    this.setProperty("outline-style", value2);
  }
  get outlineWidth() {
    return this.getPropertyValue("outline-width");
  }
  set outlineWidth(value2) {
    this.setProperty("outline-width", value2);
  }
  get overflow() {
    return this.getPropertyValue("overflow");
  }
  set overflow(value2) {
    this.setProperty("overflow", value2);
  }
  get overflowAnchor() {
    return this.getPropertyValue("overflow-anchor");
  }
  set overflowAnchor(value2) {
    this.setProperty("overflow-anchor", value2);
  }
  get overflowWrap() {
    return this.getPropertyValue("overflow-wrap");
  }
  set overflowWrap(value2) {
    this.setProperty("overflow-wrap", value2);
  }
  get overflowX() {
    return this.getPropertyValue("overflow-x");
  }
  set overflowX(value2) {
    this.setProperty("overflow-x", value2);
  }
  get overflowY() {
    return this.getPropertyValue("overflow-y");
  }
  set overflowY(value2) {
    this.setProperty("overflow-y", value2);
  }
  get overscrollBehavior() {
    return this.getPropertyValue("overscroll-behavior");
  }
  set overscrollBehavior(value2) {
    this.setProperty("overscroll-behavior", value2);
  }
  get overscrollBehaviorBlock() {
    return this.getPropertyValue("overscroll-behavior-block");
  }
  set overscrollBehaviorBlock(value2) {
    this.setProperty("overscroll-behavior-block", value2);
  }
  get overscrollBehaviorInline() {
    return this.getPropertyValue("overscroll-behavior-inline");
  }
  set overscrollBehaviorInline(value2) {
    this.setProperty("overscroll-behavior-inline", value2);
  }
  get overscrollBehaviorX() {
    return this.getPropertyValue("overscroll-behavior-x");
  }
  set overscrollBehaviorX(value2) {
    this.setProperty("overscroll-behavior-x", value2);
  }
  get overscrollBehaviorY() {
    return this.getPropertyValue("overscroll-behavior-y");
  }
  set overscrollBehaviorY(value2) {
    this.setProperty("overscroll-behavior-y", value2);
  }
  get overflowClipMargin() {
    return this.getPropertyValue("overflow-clip-margin");
  }
  set overflowClipMargin(value2) {
    this.setProperty("overflow-clip-margin", value2);
  }
  get padding() {
    return this.getPropertyValue("padding");
  }
  set padding(value2) {
    this.setProperty("padding", value2);
  }
  get paddingBlockEnd() {
    return this.getPropertyValue("padding-block-end");
  }
  set paddingBlockEnd(value2) {
    this.setProperty("padding-block-end", value2);
  }
  get paddingBlockStart() {
    return this.getPropertyValue("padding-block-start");
  }
  set paddingBlockStart(value2) {
    this.setProperty("padding-block-start", value2);
  }
  get paddingBottom() {
    return this.getPropertyValue("padding-bottom");
  }
  set paddingBottom(value2) {
    this.setProperty("padding-bottom", value2);
  }
  get paddingInlineEnd() {
    return this.getPropertyValue("padding-inline-end");
  }
  set paddingInlineEnd(value2) {
    this.setProperty("padding-inline-end", value2);
  }
  get paddingInlineStart() {
    return this.getPropertyValue("padding-inline-start");
  }
  set paddingInlineStart(value2) {
    this.setProperty("padding-inline-start", value2);
  }
  get paddingLeft() {
    return this.getPropertyValue("padding-left");
  }
  set paddingLeft(value2) {
    this.setProperty("padding-left", value2);
  }
  get paddingRight() {
    return this.getPropertyValue("padding-right");
  }
  set paddingRight(value2) {
    this.setProperty("padding-right", value2);
  }
  get paddingTop() {
    return this.getPropertyValue("padding-top");
  }
  set paddingTop(value2) {
    this.setProperty("padding-top", value2);
  }
  get page() {
    return this.getPropertyValue("page");
  }
  set page(value2) {
    this.setProperty("page", value2);
  }
  get pageBreakAfter() {
    return this.getPropertyValue("page-break-after");
  }
  set pageBreakAfter(value2) {
    this.setProperty("page-break-after", value2);
  }
  get pageBreakBefore() {
    return this.getPropertyValue("page-break-before");
  }
  set pageBreakBefore(value2) {
    this.setProperty("page-break-before", value2);
  }
  get pageBreakInside() {
    return this.getPropertyValue("page-break-inside");
  }
  set pageBreakInside(value2) {
    this.setProperty("page-break-inside", value2);
  }
  get pageOrientation() {
    return this.getPropertyValue("page-orientation");
  }
  set pageOrientation(value2) {
    this.setProperty("page-orientation", value2);
  }
  get paintOrder() {
    return this.getPropertyValue("paint-order");
  }
  set paintOrder(value2) {
    this.setProperty("paint-order", value2);
  }
  get perspective() {
    return this.getPropertyValue("perspective");
  }
  set perspective(value2) {
    this.setProperty("perspective", value2);
  }
  get perspectiveOrigin() {
    return this.getPropertyValue("perspective-origin");
  }
  set perspectiveOrigin(value2) {
    this.setProperty("perspective-origin", value2);
  }
  get placeContent() {
    return this.getPropertyValue("place-content");
  }
  set placeContent(value2) {
    this.setProperty("place-content", value2);
  }
  get placeItems() {
    return this.getPropertyValue("place-items");
  }
  set placeItems(value2) {
    this.setProperty("place-items", value2);
  }
  get placeSelf() {
    return this.getPropertyValue("place-self");
  }
  set placeSelf(value2) {
    this.setProperty("place-self", value2);
  }
  get pointerEvents() {
    return this.getPropertyValue("pointer-events");
  }
  set pointerEvents(value2) {
    this.setProperty("pointer-events", value2);
  }
  get position() {
    return this.getPropertyValue("position");
  }
  set position(value2) {
    this.setProperty("position", value2);
  }
  get quotes() {
    return this.getPropertyValue("quotes");
  }
  set quotes(value2) {
    this.setProperty("quotes", value2);
  }
  get r() {
    return this.getPropertyValue("r");
  }
  set r(value2) {
    this.setProperty("r", value2);
  }
  get resize() {
    return this.getPropertyValue("resize");
  }
  set resize(value2) {
    this.setProperty("resize", value2);
  }
  get right() {
    return this.getPropertyValue("right");
  }
  set right(value2) {
    this.setProperty("right", value2);
  }
  get rowGap() {
    return this.getPropertyValue("row-gap");
  }
  set rowGap(value2) {
    this.setProperty("row-gap", value2);
  }
  get rubyPosition() {
    return this.getPropertyValue("ruby-position");
  }
  set rubyPosition(value2) {
    this.setProperty("ruby-position", value2);
  }
  get rx() {
    return this.getPropertyValue("rx");
  }
  set rx(value2) {
    this.setProperty("rx", value2);
  }
  get ry() {
    return this.getPropertyValue("ry");
  }
  set ry(value2) {
    this.setProperty("ry", value2);
  }
  get scrollBehavior() {
    return this.getPropertyValue("scroll-behavior");
  }
  set scrollBehavior(value2) {
    this.setProperty("scroll-behavior", value2);
  }
  get scrollMargin() {
    return this.getPropertyValue("scroll-margin");
  }
  set scrollMargin(value2) {
    this.setProperty("scroll-margin", value2);
  }
  get scrollMarginBlock() {
    return this.getPropertyValue("scroll-margin-block");
  }
  set scrollMarginBlock(value2) {
    this.setProperty("scroll-margin-block", value2);
  }
  get scrollMarginBlockEnd() {
    return this.getPropertyValue("scroll-margin-block-end");
  }
  set scrollMarginBlockEnd(value2) {
    this.setProperty("scroll-margin-block-end", value2);
  }
  get scrollMarginBlockStart() {
    return this.getPropertyValue("scroll-margin-block-start");
  }
  set scrollMarginBlockStart(value2) {
    this.setProperty("scroll-margin-block-start", value2);
  }
  get scrollMarginBottom() {
    return this.getPropertyValue("scroll-margin-bottom");
  }
  set scrollMarginBottom(value2) {
    this.setProperty("scroll-margin-bottom", value2);
  }
  get scrollMarginInline() {
    return this.getPropertyValue("scroll-margin-inline");
  }
  set scrollMarginInline(value2) {
    this.setProperty("scroll-margin-inline", value2);
  }
  get scrollMarginInlineEnd() {
    return this.getPropertyValue("scroll-margin-inline-end");
  }
  set scrollMarginInlineEnd(value2) {
    this.setProperty("scroll-margin-inline-end", value2);
  }
  get scrollMarginInlineStart() {
    return this.getPropertyValue("scroll-margin-inline-start");
  }
  set scrollMarginInlineStart(value2) {
    this.setProperty("scroll-margin-inline-start", value2);
  }
  get scrollMarginLeft() {
    return this.getPropertyValue("scroll-margin-left");
  }
  set scrollMarginLeft(value2) {
    this.setProperty("scroll-margin-left", value2);
  }
  get scrollMarginRight() {
    return this.getPropertyValue("scroll-margin-right");
  }
  set scrollMarginRight(value2) {
    this.setProperty("scroll-margin-right", value2);
  }
  get scrollMarginTop() {
    return this.getPropertyValue("scroll-margin-top");
  }
  set scrollMarginTop(value2) {
    this.setProperty("scroll-margin-top", value2);
  }
  get scrollPadding() {
    return this.getPropertyValue("scroll-padding");
  }
  set scrollPadding(value2) {
    this.setProperty("scroll-padding", value2);
  }
  get scrollPaddingBlock() {
    return this.getPropertyValue("scroll-padding-block");
  }
  set scrollPaddingBlock(value2) {
    this.setProperty("scroll-padding-block", value2);
  }
  get scrollPaddingBlockEnd() {
    return this.getPropertyValue("scroll-padding-block-end");
  }
  set scrollPaddingBlockEnd(value2) {
    this.setProperty("scroll-padding-block-end", value2);
  }
  get scrollPaddingBlockStart() {
    return this.getPropertyValue("scroll-padding-block-start");
  }
  set scrollPaddingBlockStart(value2) {
    this.setProperty("scroll-padding-block-start", value2);
  }
  get scrollPaddingBottom() {
    return this.getPropertyValue("scroll-padding-bottom");
  }
  set scrollPaddingBottom(value2) {
    this.setProperty("scroll-padding-bottom", value2);
  }
  get scrollPaddingInline() {
    return this.getPropertyValue("scroll-padding-inline");
  }
  set scrollPaddingInline(value2) {
    this.setProperty("scroll-padding-inline", value2);
  }
  get scrollPaddingInlineEnd() {
    return this.getPropertyValue("scroll-padding-inline-end");
  }
  set scrollPaddingInlineEnd(value2) {
    this.setProperty("scroll-padding-inline-end", value2);
  }
  get scrollPaddingInlineStart() {
    return this.getPropertyValue("scroll-padding-inline-start");
  }
  set scrollPaddingInlineStart(value2) {
    this.setProperty("scroll-padding-inline-start", value2);
  }
  get scrollPaddingLeft() {
    return this.getPropertyValue("scroll-padding-left");
  }
  set scrollPaddingLeft(value2) {
    this.setProperty("scroll-padding-left", value2);
  }
  get scrollPaddingRight() {
    return this.getPropertyValue("scroll-padding-right");
  }
  set scrollPaddingRight(value2) {
    this.setProperty("scroll-padding-right", value2);
  }
  get scrollPaddingTop() {
    return this.getPropertyValue("scroll-padding-top");
  }
  set scrollPaddingTop(value2) {
    this.setProperty("scroll-padding-top", value2);
  }
  get scrollSnapAlign() {
    return this.getPropertyValue("scroll-snap-align");
  }
  set scrollSnapAlign(value2) {
    this.setProperty("scroll-snap-align", value2);
  }
  get scrollSnapStop() {
    return this.getPropertyValue("scroll-snap-stop");
  }
  set scrollSnapStop(value2) {
    this.setProperty("scroll-snap-stop", value2);
  }
  get scrollSnapType() {
    return this.getPropertyValue("scroll-snap-type");
  }
  set scrollSnapType(value2) {
    this.setProperty("scroll-snap-type", value2);
  }
  get shapeImageThreshold() {
    return this.getPropertyValue("shape-image-threshold");
  }
  set shapeImageThreshold(value2) {
    this.setProperty("shape-image-threshold", value2);
  }
  get shapeMargin() {
    return this.getPropertyValue("shape-margin");
  }
  set shapeMargin(value2) {
    this.setProperty("shape-margin", value2);
  }
  get shapeOutside() {
    return this.getPropertyValue("shape-outside");
  }
  set shapeOutside(value2) {
    this.setProperty("shape-outside", value2);
  }
  get shapeRendering() {
    return this.getPropertyValue("shape-rendering");
  }
  set shapeRendering(value2) {
    this.setProperty("shape-rendering", value2);
  }
  get size() {
    return this.getPropertyValue("size");
  }
  set size(value2) {
    this.setProperty("size", value2);
  }
  get speak() {
    return this.getPropertyValue("speak");
  }
  set speak(value2) {
    this.setProperty("speak", value2);
  }
  get src() {
    return this.getPropertyValue("src");
  }
  set src(value2) {
    this.setProperty("src", value2);
  }
  get stopColor() {
    return this.getPropertyValue("stop-color");
  }
  set stopColor(value2) {
    this.setProperty("stop-color", value2);
  }
  get stopOpacity() {
    return this.getPropertyValue("stop-opacity");
  }
  set stopOpacity(value2) {
    this.setProperty("stop-opacity", value2);
  }
  get stroke() {
    return this.getPropertyValue("stroke");
  }
  set stroke(value2) {
    this.setProperty("stroke", value2);
  }
  get strokeDasharray() {
    return this.getPropertyValue("stroke-dasharray");
  }
  set strokeDasharray(value2) {
    this.setProperty("stroke-dasharray", value2);
  }
  get strokeDashoffset() {
    return this.getPropertyValue("stroke-dashoffset");
  }
  set strokeDashoffset(value2) {
    this.setProperty("stroke-dashoffset", value2);
  }
  get strokeLinecap() {
    return this.getPropertyValue("stroke-linecap");
  }
  set strokeLinecap(value2) {
    this.setProperty("stroke-linecap", value2);
  }
  get strokeLinejoin() {
    return this.getPropertyValue("stroke-linejoin");
  }
  set strokeLinejoin(value2) {
    this.setProperty("stroke-linejoin", value2);
  }
  get strokeMiterlimit() {
    return this.getPropertyValue("stroke-miterlimit");
  }
  set strokeMiterlimit(value2) {
    this.setProperty("stroke-miterlimit", value2);
  }
  get strokeOpacity() {
    return this.getPropertyValue("stroke-opacity");
  }
  set strokeOpacity(value2) {
    this.setProperty("stroke-opacity", value2);
  }
  get strokeWidth() {
    return this.getPropertyValue("stroke-width");
  }
  set strokeWidth(value2) {
    this.setProperty("stroke-width", value2);
  }
  get syntax() {
    return this.getPropertyValue("syntax");
  }
  set syntax(value2) {
    this.setProperty("syntax", value2);
  }
  get scrollbarGutter() {
    return this.getPropertyValue("scrollbar-gutter");
  }
  set scrollbarGutter(value2) {
    this.setProperty("scrollbar-gutter", value2);
  }
  get tabSize() {
    return this.getPropertyValue("tab-size");
  }
  set tabSize(value2) {
    this.setProperty("tab-size", value2);
  }
  get tableLayout() {
    return this.getPropertyValue("table-layout");
  }
  set tableLayout(value2) {
    this.setProperty("table-layout", value2);
  }
  get textAlign() {
    return this.getPropertyValue("text-align");
  }
  set textAlign(value2) {
    this.setProperty("text-align", value2);
  }
  get textAlignLast() {
    return this.getPropertyValue("text-align-last");
  }
  set textAlignLast(value2) {
    this.setProperty("text-align-last", value2);
  }
  get textAnchor() {
    return this.getPropertyValue("text-anchor");
  }
  set textAnchor(value2) {
    this.setProperty("text-anchor", value2);
  }
  get textCombineUpright() {
    return this.getPropertyValue("text-combine-upright");
  }
  set textCombineUpright(value2) {
    this.setProperty("text-combine-upright", value2);
  }
  get textDecoration() {
    return this.getPropertyValue("text-decoration");
  }
  set textDecoration(value2) {
    this.setProperty("text-decoration", value2);
  }
  get textDecorationColor() {
    return this.getPropertyValue("text-decoration-color");
  }
  set textDecorationColor(value2) {
    this.setProperty("text-decoration-color", value2);
  }
  get textDecorationLine() {
    return this.getPropertyValue("text-decoration-line");
  }
  set textDecorationLine(value2) {
    this.setProperty("text-decoration-line", value2);
  }
  get textDecorationSkipInk() {
    return this.getPropertyValue("text-decoration-skip-ink");
  }
  set textDecorationSkipInk(value2) {
    this.setProperty("text-decoration-skip-ink", value2);
  }
  get textDecorationStyle() {
    return this.getPropertyValue("text-decoration-style");
  }
  set textDecorationStyle(value2) {
    this.setProperty("text-decoration-style", value2);
  }
  get textIndent() {
    return this.getPropertyValue("text-indent");
  }
  set textIndent(value2) {
    this.setProperty("text-indent", value2);
  }
  get textOrientation() {
    return this.getPropertyValue("text-orientation");
  }
  set textOrientation(value2) {
    this.setProperty("text-orientation", value2);
  }
  get textOverflow() {
    return this.getPropertyValue("text-overflow");
  }
  set textOverflow(value2) {
    this.setProperty("text-overflow", value2);
  }
  get textRendering() {
    return this.getPropertyValue("text-rendering");
  }
  set textRendering(value2) {
    this.setProperty("text-rendering", value2);
  }
  get textShadow() {
    return this.getPropertyValue("text-shadow");
  }
  set textShadow(value2) {
    this.setProperty("text-shadow", value2);
  }
  get textSizeAdjust() {
    return this.getPropertyValue("text-size-adjust");
  }
  set textSizeAdjust(value2) {
    this.setProperty("text-size-adjust", value2);
  }
  get textTransform() {
    return this.getPropertyValue("text-transform");
  }
  set textTransform(value2) {
    this.setProperty("text-transform", value2);
  }
  get textUnderlinePosition() {
    return this.getPropertyValue("text-underline-position");
  }
  set textUnderlinePosition(value2) {
    this.setProperty("text-underline-position", value2);
  }
  get top() {
    return this.getPropertyValue("top");
  }
  set top(value2) {
    this.setProperty("top", value2);
  }
  get touchAction() {
    return this.getPropertyValue("touch-action");
  }
  set touchAction(value2) {
    this.setProperty("touch-action", value2);
  }
  get transform() {
    return this.getPropertyValue("transform");
  }
  set transform(value2) {
    this.setProperty("transform", value2);
  }
  get transformBox() {
    return this.getPropertyValue("transform-box");
  }
  set transformBox(value2) {
    this.setProperty("transform-box", value2);
  }
  get transformOrigin() {
    return this.getPropertyValue("transform-origin");
  }
  set transformOrigin(value2) {
    this.setProperty("transform-origin", value2);
  }
  get transformStyle() {
    return this.getPropertyValue("transform-style");
  }
  set transformStyle(value2) {
    this.setProperty("transform-style", value2);
  }
  get transition() {
    return this.getPropertyValue("transition");
  }
  set transition(value2) {
    this.setProperty("transition", value2);
  }
  get transitionDelay() {
    return this.getPropertyValue("transition-delay");
  }
  set transitionDelay(value2) {
    this.setProperty("transition-delay", value2);
  }
  get transitionDuration() {
    return this.getPropertyValue("transition-duration");
  }
  set transitionDuration(value2) {
    this.setProperty("transition-duration", value2);
  }
  get transitionProperty() {
    return this.getPropertyValue("transition-property");
  }
  set transitionProperty(value2) {
    this.setProperty("transition-property", value2);
  }
  get transitionTimingFunction() {
    return this.getPropertyValue("transition-timing-function");
  }
  set transitionTimingFunction(value2) {
    this.setProperty("transition-timing-function", value2);
  }
  get textEmphasisColor() {
    return this.getPropertyValue("text-emphasis-color");
  }
  set textEmphasisColor(value2) {
    this.setProperty("text-emphasis-color", value2);
  }
  get textEmphasisPosition() {
    return this.getPropertyValue("text-emphasis-position");
  }
  set textEmphasisPosition(value2) {
    this.setProperty("text-emphasis-position", value2);
  }
  get textEmphasisStyle() {
    return this.getPropertyValue("text-emphasis-style");
  }
  set textEmphasisStyle(value2) {
    this.setProperty("text-emphasis-style", value2);
  }
  get unicodeBidi() {
    return this.getPropertyValue("unicode-bidi");
  }
  set unicodeBidi(value2) {
    this.setProperty("unicode-bidi", value2);
  }
  get unicodeRange() {
    return this.getPropertyValue("unicode-range");
  }
  set unicodeRange(value2) {
    this.setProperty("unicode-range", value2);
  }
  get userSelect() {
    return this.getPropertyValue("user-select");
  }
  set userSelect(value2) {
    this.setProperty("user-select", value2);
  }
  get userZoom() {
    return this.getPropertyValue("user-zoom");
  }
  set userZoom(value2) {
    this.setProperty("user-zoom", value2);
  }
  get vectorEffect() {
    return this.getPropertyValue("vector-effect");
  }
  set vectorEffect(value2) {
    this.setProperty("vector-effect", value2);
  }
  get verticalAlign() {
    return this.getPropertyValue("vertical-align");
  }
  set verticalAlign(value2) {
    this.setProperty("vertical-align", value2);
  }
  get visibility() {
    return this.getPropertyValue("visibility");
  }
  set visibility(value2) {
    this.setProperty("visibility", value2);
  }
  get whiteSpace() {
    return this.getPropertyValue("white-space");
  }
  set whiteSpace(value2) {
    this.setProperty("white-space", value2);
  }
  get widows() {
    return this.getPropertyValue("widows");
  }
  set widows(value2) {
    this.setProperty("widows", value2);
  }
  get width() {
    return this.getPropertyValue("width");
  }
  set width(value2) {
    this.setProperty("width", value2);
  }
  get willChange() {
    return this.getPropertyValue("will-change");
  }
  set willChange(value2) {
    this.setProperty("will-change", value2);
  }
  get wordBreak() {
    return this.getPropertyValue("word-break");
  }
  set wordBreak(value2) {
    this.setProperty("word-break", value2);
  }
  get wordSpacing() {
    return this.getPropertyValue("word-spacing");
  }
  set wordSpacing(value2) {
    this.setProperty("word-spacing", value2);
  }
  get wordWrap() {
    return this.getPropertyValue("word-wrap");
  }
  set wordWrap(value2) {
    this.setProperty("word-wrap", value2);
  }
  get writingMode() {
    return this.getPropertyValue("writing-mode");
  }
  set writingMode(value2) {
    this.setProperty("writing-mode", value2);
  }
  get x() {
    return this.getPropertyValue("x");
  }
  set x(value2) {
    this.setProperty("x", value2);
  }
  get y() {
    return this.getPropertyValue("y");
  }
  set y(value2) {
    this.setProperty("y", value2);
  }
  get zIndex() {
    return this.getPropertyValue("z-index");
  }
  set zIndex(value2) {
    this.setProperty("z-index", value2);
  }
  get zoom() {
    return this.getPropertyValue("zoom");
  }
  set zoom(value2) {
    this.setProperty("zoom", value2);
  }
  get containerType() {
    return this.getPropertyValue("container-type");
  }
  set containerType(value2) {
    this.setProperty("container-type", value2);
  }
  get containerName() {
    return this.getPropertyValue("container-name");
  }
  set containerName(value2) {
    this.setProperty("container-name", value2);
  }
}
class MouseEvent extends UIEvent {
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type, eventInit = null) {
    super(type, eventInit);
    this.altKey = (eventInit == null ? void 0 : eventInit.altKey) ?? false;
    this.button = (eventInit == null ? void 0 : eventInit.button) ?? 0;
    this.buttons = (eventInit == null ? void 0 : eventInit.buttons) ?? 0;
    this.clientX = (eventInit == null ? void 0 : eventInit.clientX) ?? 0;
    this.clientY = (eventInit == null ? void 0 : eventInit.clientY) ?? 0;
    this.ctrlKey = (eventInit == null ? void 0 : eventInit.ctrlKey) ?? false;
    this.metaKey = (eventInit == null ? void 0 : eventInit.metaKey) ?? false;
    this.movementX = (eventInit == null ? void 0 : eventInit.movementX) ?? 0;
    this.movementY = (eventInit == null ? void 0 : eventInit.movementY) ?? 0;
    this.region = (eventInit == null ? void 0 : eventInit.region) ?? "";
    this.relatedTarget = (eventInit == null ? void 0 : eventInit.relatedTarget) ?? null;
    this.screenX = (eventInit == null ? void 0 : eventInit.screenX) ?? 0;
    this.screenY = (eventInit == null ? void 0 : eventInit.screenY) ?? 0;
    this.shiftKey = (eventInit == null ? void 0 : eventInit.shiftKey) ?? false;
  }
}
class PointerEvent extends MouseEvent {
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type, eventInit = null) {
    super(type, eventInit);
    this.getCoalescedEvents = () => this.coalescedEvents;
    this.getPredictedEvents = () => this.predictedEvents;
    this.pointerId = (eventInit == null ? void 0 : eventInit.pointerId) ?? 0;
    this.width = (eventInit == null ? void 0 : eventInit.width) ?? 1;
    this.height = (eventInit == null ? void 0 : eventInit.height) ?? 1;
    this.pressure = (eventInit == null ? void 0 : eventInit.pressure) ?? 0;
    this.tangentialPressure = (eventInit == null ? void 0 : eventInit.tangentialPressure) ?? 0;
    this.tiltX = (eventInit == null ? void 0 : eventInit.tiltX) ?? 0;
    this.tiltY = (eventInit == null ? void 0 : eventInit.tiltY) ?? 0;
    this.twist = (eventInit == null ? void 0 : eventInit.twist) ?? 0;
    this.altitudeAngle = (eventInit == null ? void 0 : eventInit.altitudeAngle) ?? 0;
    this.azimuthAngle = (eventInit == null ? void 0 : eventInit.azimuthAngle) ?? 0;
    this.pointerType = (eventInit == null ? void 0 : eventInit.pointerType) ?? "";
    this.isPrimary = (eventInit == null ? void 0 : eventInit.isPrimary) ?? false;
    this.coalescedEvents = (eventInit == null ? void 0 : eventInit.coalescedEvents) ?? [];
    this.predictedEvents = (eventInit == null ? void 0 : eventInit.predictedEvents) ?? [];
  }
}
class FocusEvent extends UIEvent {
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type, eventInit = null) {
    super(type, eventInit);
    this.relatedTarget = (eventInit == null ? void 0 : eventInit.relatedTarget) ?? null;
  }
}
class HTMLElementUtility {
  /**
   * Triggers a blur event.
   *
   * @param element Element.
   */
  static blur(element) {
    if (element[ownerDocument][activeElement] !== element || !element[isConnected]) {
      return;
    }
    const relatedTarget = element[ownerDocument][nextActiveElement] ?? null;
    element[ownerDocument][activeElement] = null;
    element.dispatchEvent(new FocusEvent("blur", {
      relatedTarget,
      bubbles: false,
      composed: true
    }));
    element.dispatchEvent(new FocusEvent("focusout", {
      relatedTarget,
      bubbles: true,
      composed: true
    }));
  }
  /**
   * Triggers a focus event.
   *
   * @param element Element.
   */
  static focus(element) {
    if (element[ownerDocument][activeElement] === element || !element[isConnected]) {
      return;
    }
    element[ownerDocument][nextActiveElement] = element;
    const relatedTarget = element[ownerDocument][activeElement];
    if (element[ownerDocument][activeElement] !== null) {
      element[ownerDocument][activeElement].blur();
    }
    element[ownerDocument][nextActiveElement] = null;
    element[ownerDocument][activeElement] = element;
    element.dispatchEvent(new FocusEvent("focus", {
      relatedTarget,
      bubbles: false,
      composed: true
    }));
    element.dispatchEvent(new FocusEvent("focusin", {
      relatedTarget,
      bubbles: true,
      composed: true
    }));
  }
}
class HTMLElementNamedNodeMap extends ElementNamedNodeMap {
  /**
   * @override
   */
  setNamedItem(item2) {
    const replacedItem = super.setNamedItem(item2);
    if (item2[name] === "style" && this[ownerElement][style]) {
      this[ownerElement][style].cssText = item2[value];
    }
    return replacedItem || null;
  }
  /**
   * @override
   */
  [removeNamedItem](name$1) {
    const removedItem = super[removeNamedItem](name$1);
    if (removedItem && removedItem[name] === "style" && this[ownerElement][style]) {
      this[ownerElement][style].cssText = "";
    }
    return removedItem;
  }
}
class DatasetUtility {
  /**
   * Transforms a kebab cased string to camel case.
   *
   * @param text Text string.
   * @returns Camel cased string.
   */
  static kebabToCamelCase(text2) {
    const parts = text2.split("-");
    for (let i = 0, max2 = parts.length; i < max2; i++) {
      parts[i] = i > 0 ? parts[i].charAt(0).toUpperCase() + parts[i].slice(1) : parts[i];
    }
    return parts.join("");
  }
  /**
   * Transforms a camel cased string to kebab case.
   *
   * @param text Text string.
   * @returns Kebab cased string.
   */
  static camelCaseToKebab(text2) {
    return text2.toString().replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? "-" : "") + $.toLowerCase());
  }
}
class DatasetFactory {
  /**
   * @param element The parent element.
   */
  static createDataset(element) {
    const dataset = {};
    for (let i = 0, max2 = element[attributes].length; i < max2; i++) {
      const attribute = element[attributes][i];
      if (attribute[name].startsWith("data-")) {
        const key = DatasetUtility.kebabToCamelCase(attribute[name].replace("data-", ""));
        dataset[key] = attribute[value];
      }
    }
    return new Proxy(dataset, {
      get(dataset2, key) {
        const attribute = element[attributes].getNamedItem("data-" + DatasetUtility.camelCaseToKebab(key));
        if (attribute) {
          return dataset2[key] = attribute[value];
        }
        delete dataset2[key];
        return void 0;
      },
      set(dataset2, key, value2) {
        element.setAttribute("data-" + DatasetUtility.camelCaseToKebab(key), value2);
        dataset2[key] = value2;
        return true;
      },
      deleteProperty(dataset2, key) {
        element[attributes][removeNamedItem]("data-" + DatasetUtility.camelCaseToKebab(key));
        return delete dataset2[key];
      },
      ownKeys(dataset2) {
        const keys = [];
        const deleteKeys = [];
        for (let i = 0, max2 = element[attributes].length; i < max2; i++) {
          const attribute = element[attributes][i];
          if (attribute[name].startsWith("data-")) {
            const key = DatasetUtility.kebabToCamelCase(attribute[name].replace("data-", ""));
            keys.push(key);
            dataset2[key] = attribute[value];
            if (!dataset2[key]) {
              deleteKeys.push(key);
            }
          }
        }
        for (const key of deleteKeys) {
          delete dataset2[key];
        }
        return keys;
      },
      has(_dataset, key) {
        return !!element[attributes].getNamedItem("data-" + DatasetUtility.camelCaseToKebab(key));
      }
    });
  }
}
var __classPrivateFieldGet$B = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$y = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var _HTMLElement_dataset, _HTMLElement_customElementDefineCallback, _a$v, _b$g, _c$c, _d$8, _e$8, _f$6, _g$3, _h$2, _j$2, _k$1, _l$1, _m$1, _o$1;
let HTMLElement$1 = class HTMLElement2 extends Element$1 {
  constructor() {
    super(...arguments);
    this.oncopy = null;
    this.oncut = null;
    this.onpaste = null;
    this.oninvalid = null;
    this.onanimationcancel = null;
    this.onanimationend = null;
    this.onanimationiteration = null;
    this.onanimationstart = null;
    this.onbeforeinput = null;
    this.oninput = null;
    this.onchange = null;
    this.ongotpointercapture = null;
    this.onlostpointercapture = null;
    this.onpointercancel = null;
    this.onpointerdown = null;
    this.onpointerenter = null;
    this.onpointerleave = null;
    this.onpointermove = null;
    this.onpointerout = null;
    this.onpointerover = null;
    this.onpointerup = null;
    this.ontransitioncancel = null;
    this.ontransitionend = null;
    this.ontransitionrun = null;
    this.ontransitionstart = null;
    this[_a$v] = new HTMLElementNamedNodeMap(this);
    this[_b$g] = "";
    this[_c$c] = "inherit";
    this[_d$8] = false;
    this[_e$8] = 0;
    this[_f$6] = 0;
    this[_g$3] = 0;
    this[_h$2] = 0;
    this[_j$2] = 0;
    this[_k$1] = 0;
    this[_l$1] = 0;
    this[_m$1] = 0;
    this[_o$1] = null;
    _HTMLElement_dataset.set(this, null);
    _HTMLElement_customElementDefineCallback.set(this, null);
  }
  /**
   * Returns access key.
   *
   * @returns Access key.
   */
  get accessKey() {
    return this[accessKey];
  }
  /**
   * Sets access key.
   *
   * @param accessKey Access key.
   */
  set accessKey(accessKey$1) {
    this[accessKey] = accessKey$1;
  }
  /**
   * Returns content editable.
   *
   * @returns Content editable.
   */
  get contentEditable() {
    return this[contentEditable];
  }
  /**
   * Sets content editable.
   *
   * @param contentEditable Content editable.
   */
  set contentEditable(contentEditable$1) {
    this[contentEditable] = contentEditable$1;
  }
  /**
   * Returns is content editable.
   *
   * @returns Is content editable.
   */
  get isContentEditable() {
    return this[isContentEditable];
  }
  /**
   * Returns offset height.
   *
   * @returns Offset height.
   */
  get offsetHeight() {
    return this[offsetHeight];
  }
  /**
   * Returns offset width.
   *
   * @returns Offset width.
   */
  get offsetWidth() {
    return this[offsetWidth];
  }
  /**
   * Returns offset left.
   *
   * @returns Offset left.
   */
  get offsetLeft() {
    return this[offsetLeft];
  }
  /**
   * Returns offset top.
   *
   * @returns Offset top.
   */
  get offsetTop() {
    return this[offsetTop];
  }
  /**
   * Returns client height.
   *
   * @returns Client height.
   */
  get clientHeight() {
    return this[clientHeight];
  }
  /**
   * Returns client width.
   *
   * @returns Client width.
   */
  get clientWidth() {
    return this[clientWidth];
  }
  /**
   * Returns client left.
   *
   * @returns Client left.
   */
  get clientLeft() {
    return this[clientLeft];
  }
  /**
   * Returns client top.
   *
   * @returns Client top.
   */
  get clientTop() {
    return this[clientTop];
  }
  /**
   * Returns tab index.
   *
   * @returns Tab index.
   */
  get tabIndex() {
    const tabIndex = this.getAttribute("tabindex");
    return tabIndex !== null ? Number(tabIndex) : -1;
  }
  /**
   * Returns tab index.
   *
   * @param tabIndex Tab index.
   */
  set tabIndex(tabIndex) {
    if (tabIndex === -1) {
      this.removeAttribute("tabindex");
    } else {
      this.setAttribute("tabindex", String(tabIndex));
    }
  }
  /**
   * Returns inner text, which is the rendered appearance of text.
   *
   * @see https://html.spec.whatwg.org/multipage/dom.html#the-innertext-idl-attribute
   * @returns Inner text.
   */
  get innerText() {
    if (!this[isConnected]) {
      return this.textContent;
    }
    let result = "";
    for (const childNode of this[childNodes]) {
      if (childNode[nodeType] === NodeTypeEnum$1.elementNode) {
        const childElement = childNode;
        const computedStyle2 = this[ownerDocument][ownerWindow].getComputedStyle(childElement);
        if (childElement[tagName] !== "SCRIPT" && childElement[tagName] !== "STYLE") {
          const display = computedStyle2.display;
          if (display !== "none") {
            const textTransform = computedStyle2.textTransform;
            if ((display === "block" || display === "flex") && result) {
              result += "\n";
            }
            let text2 = childElement.innerText;
            switch (textTransform) {
              case "uppercase":
                text2 = text2.toUpperCase();
                break;
              case "lowercase":
                text2 = text2.toLowerCase();
                break;
              case "capitalize":
                text2 = text2.replace(/(^|\s)\S/g, (l2) => l2.toUpperCase());
                break;
            }
            result += text2;
          }
        }
      } else if (childNode[nodeType] === NodeTypeEnum$1.textNode) {
        result += childNode.textContent.replace(/[\n\r]/, "");
      }
    }
    return result;
  }
  /**
   * Sets the inner text, which is the rendered appearance of text.
   *
   * @see https://html.spec.whatwg.org/multipage/dom.html#the-innertext-idl-attribute
   * @param innerText Inner text.
   */
  set innerText(text2) {
    for (const child of this[childNodes].slice()) {
      this.removeChild(child);
    }
    const texts = text2.split(/[\n\r]/);
    for (let i = 0, max2 = texts.length; i < max2; i++) {
      if (i !== 0) {
        this.appendChild(this[ownerDocument].createElement("br"));
      }
      this.appendChild(this[ownerDocument].createTextNode(texts[i]));
    }
  }
  /**
   * Returns outer text.
   *
   * @see https://html.spec.whatwg.org/multipage/dom.html#the-innertext-idl-attribute
   * @returns HTML.
   */
  get outerText() {
    return this.innerText;
  }
  /**
   * Sets outer text.
   *
   * @see https://html.spec.whatwg.org/multipage/dom.html#the-innertext-idl-attribute
   * @param text Text.
   */
  set outerText(text2) {
    if (!this[parentNode]) {
      throw new DOMException("Failed to set the 'outerHTML' property on 'Element': This element has no parent node.");
    }
    const texts = text2.split(/[\n\r]/);
    for (let i = 0, max2 = texts.length; i < max2; i++) {
      if (i !== 0) {
        this[parentNode].insertBefore(this[ownerDocument].createElement("br"), this);
      }
      this[parentNode].insertBefore(this[ownerDocument].createTextNode(texts[i]), this);
    }
    this[parentNode].removeChild(this);
  }
  /**
   * Returns style.
   *
   * @returns Style.
   */
  get style() {
    if (!this[style]) {
      this[style] = new CSSStyleDeclaration(this);
    }
    return this[style];
  }
  /**
   * Sets style.
   *
   * @param cssText Style as text.
   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style#setting_styles
   */
  set style(cssText2) {
    this.style.cssText = typeof cssText2 === "string" ? cssText2 : "";
  }
  /**
   * Returns data set.
   *
   * @returns Data set.
   */
  get dataset() {
    return __classPrivateFieldSet$y(this, _HTMLElement_dataset, __classPrivateFieldGet$B(this, _HTMLElement_dataset, "f") ?? DatasetFactory.createDataset(this), "f");
  }
  /**
   * Returns direction.
   *
   * @returns Direction.
   */
  get dir() {
    return this.getAttribute("dir") || "";
  }
  /**
   * Returns direction.
   *
   * @param direction Direction.
   */
  set dir(direction) {
    this.setAttribute("dir", direction);
  }
  /**
   * Returns hidden.
   *
   * @returns Hidden.
   */
  get hidden() {
    return this.getAttribute("hidden") !== null;
  }
  /**
   * Returns hidden.
   *
   * @param hidden Hidden.
   */
  set hidden(hidden) {
    if (!hidden) {
      this.removeAttribute("hidden");
    } else {
      this.setAttribute("hidden", "");
    }
  }
  /**
   * Returns inert.
   *
   * @returns Inert.
   */
  get inert() {
    return this.getAttribute("inert") !== null;
  }
  /**
   * Returns inert.
   *
   * @param inert Inert.
   */
  set inert(inert) {
    if (!inert) {
      this.removeAttribute("inert");
    } else {
      this.setAttribute("inert", "");
    }
  }
  /**
   * Returns language.
   *
   * @returns Language.
   */
  get lang() {
    return this.getAttribute("lang") || "";
  }
  /**
   * Returns language.
   *
   * @param language Language.
   */
  set lang(lang) {
    this.setAttribute("lang", lang);
  }
  /**
   * Returns title.
   *
   * @returns Title.
   */
  get title() {
    return this.getAttribute("title") || "";
  }
  /**
   * Returns title.
   *
   * @param title Title.
   */
  set title(title) {
    this.setAttribute("title", title);
  }
  /**
   * Triggers a click event.
   */
  click() {
    const event = new PointerEvent("click", {
      bubbles: true,
      composed: true
    });
    event[target] = this;
    event[currentTarget] = this;
    this.dispatchEvent(event);
  }
  /**
   * Triggers a blur event.
   */
  blur() {
    HTMLElementUtility.blur(this);
  }
  /**
   * Triggers a focus event.
   */
  focus() {
    HTMLElementUtility.focus(this);
  }
  /**
   * @override
   */
  [(_HTMLElement_dataset = /* @__PURE__ */ new WeakMap(), _HTMLElement_customElementDefineCallback = /* @__PURE__ */ new WeakMap(), _a$v = attributes, _b$g = accessKey, _c$c = contentEditable, _d$8 = isContentEditable, _e$8 = offsetHeight, _f$6 = offsetWidth, _g$3 = offsetLeft, _h$2 = offsetTop, _j$2 = clientHeight, _k$1 = clientWidth, _l$1 = clientLeft, _m$1 = clientTop, _o$1 = style, cloneNode)](deep = false) {
    const clone2 = super[cloneNode](deep);
    clone2[accessKey] = this[accessKey];
    clone2[contentEditable] = this[contentEditable];
    clone2[isContentEditable] = this[isContentEditable];
    if (this[style]) {
      clone2.style.cssText = this[style].cssText;
    }
    return clone2;
  }
  /**
   * Connects this element to another element.
   *
   * @see https://html.spec.whatwg.org/multipage/dom.html#htmlelement
   * @param parentNode Parent node.
   */
  [connectToNode](parentNode$1 = null) {
    const localName$1 = this[localName];
    if (this.constructor === HTMLElement2 && localName$1.includes("-") && this[ownerDocument][ownerWindow].customElements[callbacks]) {
      const callbacks$1 = this[ownerDocument][ownerWindow].customElements[callbacks];
      if (parentNode$1 && !__classPrivateFieldGet$B(this, _HTMLElement_customElementDefineCallback, "f")) {
        const callback = () => {
          if (this[parentNode]) {
            const newElement = this[ownerDocument].createElement(localName$1);
            newElement[childNodes] = this[childNodes];
            newElement[children] = this[children];
            newElement[isConnected] = this[isConnected];
            newElement[rootNode] = this[rootNode];
            newElement[formNode] = this[formNode];
            newElement[selectNode] = this[selectNode];
            newElement[textAreaNode] = this[textAreaNode];
            newElement[observers] = this[observers];
            newElement[isValue] = this[isValue];
            for (let i = 0, max2 = this[attributes].length; i < max2; i++) {
              newElement[attributes].setNamedItem(this[attributes][i]);
            }
            this[childNodes] = new NodeList();
            this[children] = new HTMLCollection();
            this[rootNode] = null;
            this[formNode] = null;
            this[selectNode] = null;
            this[textAreaNode] = null;
            this[observers] = [];
            this[isValue] = null;
            this[attributes] = new HTMLElementNamedNodeMap(this);
            for (let i = 0, max2 = this[parentNode][childNodes].length; i < max2; i++) {
              if (this[parentNode][childNodes][i] === this) {
                this[parentNode][childNodes][i] = newElement;
                break;
              }
            }
            if (this[parentNode][children]) {
              for (let i = 0, max2 = this[parentNode][children].length; i < max2; i++) {
                if (this[parentNode][children][i] === this) {
                  this[parentNode][children][i] = newElement;
                  break;
                }
              }
            }
            if (newElement[isConnected] && newElement.connectedCallback) {
              const result = newElement.connectedCallback();
              if (result instanceof Promise) {
                const asyncTaskManager$1 = this[ownerDocument][ownerWindow][asyncTaskManager];
                const taskID = asyncTaskManager$1.startTask();
                result.then(() => asyncTaskManager$1.endTask(taskID)).catch(() => asyncTaskManager$1.endTask(taskID));
              }
            }
            this[connectToNode](null);
          }
        };
        callbacks$1[localName$1] = callbacks$1[localName$1] || [];
        callbacks$1[localName$1].push(callback);
        __classPrivateFieldSet$y(this, _HTMLElement_customElementDefineCallback, callback, "f");
      } else if (!parentNode$1 && callbacks$1[localName$1] && __classPrivateFieldGet$B(this, _HTMLElement_customElementDefineCallback, "f")) {
        const index = callbacks$1[localName$1].indexOf(__classPrivateFieldGet$B(this, _HTMLElement_customElementDefineCallback, "f"));
        if (index !== -1) {
          callbacks$1[localName$1].splice(index, 1);
        }
        if (!callbacks$1[localName$1].length) {
          delete callbacks$1[localName$1];
        }
        __classPrivateFieldSet$y(this, _HTMLElement_customElementDefineCallback, null, "f");
      }
    }
    super[connectToNode](parentNode$1);
  }
};
var _a$u;
class HTMLTemplateElement extends HTMLElement$1 {
  constructor() {
    super(...arguments);
    this[_a$u] = this[ownerDocument].createDocumentFragment();
  }
  /**
   * Returns content.
   *
   * @returns Content.
   */
  get content() {
    return this[content];
  }
  /**
   * @override
   */
  get innerHTML() {
    return this.getInnerHTML();
  }
  /**
   * @override
   */
  set innerHTML(html) {
    const content$1 = this[content];
    for (const child of content$1[childNodes].slice()) {
      this[content].removeChild(child);
    }
    XMLParser.parse(this[ownerDocument], html, {
      rootNode: this[content]
    });
  }
  /**
   * @override
   */
  get firstChild() {
    return this[content].firstChild;
  }
  /**
   * @override
   */
  get lastChild() {
    return this[content].lastChild;
  }
  /**
   * @override
   */
  getInnerHTML(options2) {
    const xmlSerializer = new XMLSerializer({
      includeShadowRoots: options2 && options2.includeShadowRoots,
      escapeEntities: false
    });
    const content$1 = this[content];
    let xml = "";
    for (const node2 of content$1[childNodes]) {
      xml += xmlSerializer.serializeToString(node2);
    }
    return xml;
  }
  /**
   * @override
   */
  [(_a$u = content, appendChild)](node2) {
    return this[content].appendChild(node2);
  }
  /**
   * @override
   */
  [removeChild](node2) {
    return this[content].removeChild(node2);
  }
  /**
   * @override
   */
  [insertBefore](newNode, referenceNode) {
    return this[content].insertBefore(newNode, referenceNode);
  }
  /**
   * @override
   */
  [replaceChild](newChild, oldChild) {
    return this[content].replaceChild(newChild, oldChild);
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    const clone2 = super[cloneNode](deep);
    clone2[content] = this[content].cloneNode(deep);
    return clone2;
  }
}
class SubmitEvent extends Event {
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type, eventInit = null) {
    super(type, eventInit);
    this.submitter = (eventInit == null ? void 0 : eventInit.submitter) ?? null;
  }
}
class RadioNodeList extends NodeList {
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    for (const node2 of this) {
      if (node2.checked) {
        return node2.value;
      }
    }
    return null;
  }
}
var _a$t;
class HTMLFormControlsCollection extends Array {
  constructor() {
    super(...arguments);
    this[_a$t] = {};
  }
  /**
   * Returns item by index.
   *
   * @param index Index.
   */
  item(index) {
    return index >= 0 && this[index] ? this[index] : null;
  }
  /**
   * Returns named item.
   *
   * @param name Name.
   * @returns Node.
   */
  namedItem(name2) {
    if (this[namedItems][name2] && this[namedItems][name2].length) {
      if (this[namedItems][name2].length === 1) {
        return this[namedItems][name2][0];
      }
      return this[namedItems][name2];
    }
    return null;
  }
  /**
   * Appends named item.
   *
   * @param node Node.
   * @param name Name.
   */
  [(_a$t = namedItems, appendNamedItem)](node2, name2) {
    if (name2) {
      this[namedItems][name2] = this[namedItems][name2] || new RadioNodeList();
      if (!this[namedItems][name2].includes(node2)) {
        this[namedItems][name2].push(node2);
      }
      if (this[isValidPropertyName](name2)) {
        this[name2] = this[namedItems][name2].length > 1 ? this[namedItems][name2] : this[namedItems][name2][0];
      }
    }
  }
  /**
   * Appends named item.
   *
   * @param node Node.
   * @param name Name.
   */
  [removeNamedItem](node2, name2) {
    if (name2 && this[namedItems][name2]) {
      const index = this[namedItems][name2].indexOf(node2);
      if (index > -1) {
        this[namedItems][name2].splice(index, 1);
        if (this[namedItems][name2].length === 0) {
          delete this[namedItems][name2];
          if (this.hasOwnProperty(name2) && this[isValidPropertyName](name2)) {
            delete this[name2];
          }
        } else if (this[isValidPropertyName](name2)) {
          this[name2] = this[namedItems][name2].length > 1 ? this[namedItems][name2] : this[namedItems][name2][0];
        }
      }
    }
  }
  /**
   * Returns "true" if the property name is valid.
   *
   * @param name Name.
   * @returns True if the property name is valid.
   */
  [isValidPropertyName](name2) {
    return !!name2 && !this.constructor.prototype.hasOwnProperty(name2) && !Array.prototype.hasOwnProperty(name2) && (isNaN(Number(name2)) || name2.includes("."));
  }
}
let NotSupported$b = class NotSupported2 {
};
class BrowserFrameFactory {
  /**
   * Creates a new frame.
   *
   * @param parentFrame Parent frame.
   * @returns Frame.
   */
  static createChildFrame(parentFrame) {
    const frame = new parentFrame.constructor(parentFrame.page);
    frame.parentFrame = parentFrame;
    parentFrame.childFrames.push(frame);
    return frame;
  }
  /**
   * Aborts all ongoing operations and destroys the frame.
   *
   * @param frame Frame.
   */
  static destroyFrame(frame) {
    return new Promise((resolve3, reject) => {
      if (!frame.window) {
        resolve3();
        return;
      }
      if (frame.parentFrame) {
        const index = frame.parentFrame.childFrames.indexOf(frame);
        if (index !== -1) {
          frame.parentFrame.childFrames.splice(index, 1);
        }
      }
      if (!frame.childFrames.length) {
        if (frame.window && frame.window[mutationObservers]) {
          for (const mutationObserver of frame.window[mutationObservers]) {
            mutationObserver.disconnect();
          }
          frame.window[mutationObservers] = [];
        }
        return frame[asyncTaskManager].destroy().then(() => {
          var _a2;
          (_a2 = frame[exceptionObserver]) == null ? void 0 : _a2.disconnect();
          if (frame.window) {
            frame.window[destroy]();
            frame.page = null;
            frame.window = null;
            frame[openerFrame] = null;
            frame[openerWindow] = null;
          }
          resolve3();
        }).catch((error2) => reject(error2));
      }
      Promise.all(frame.childFrames.slice().map((childFrame) => this.destroyFrame(childFrame))).then(() => {
        if (frame.window && frame.window[mutationObservers]) {
          for (const mutationObserver of frame.window[mutationObservers]) {
            mutationObserver.disconnect();
          }
          frame.window[mutationObservers] = [];
        }
        return frame[asyncTaskManager].destroy().then(() => {
          var _a2;
          (_a2 = frame[exceptionObserver]) == null ? void 0 : _a2.disconnect();
          if (frame.window) {
            const listeners$1 = frame[listeners];
            frame.window[destroy]();
            frame.page = null;
            frame.window = null;
            frame[listeners] = null;
            frame[openerFrame] = null;
            frame[openerWindow] = null;
            for (const listener of listeners$1.navigation) {
              listener();
            }
          }
          resolve3();
        });
      }).catch((error2) => reject(error2));
    });
  }
}
class BrowserFrameURL {
  /**
   * Returns relative URL.
   *
   * @param frame Frame.
   * @param url URL.
   * @returns Relative URL.
   */
  static getRelativeURL(frame, url) {
    url = url || "about:blank";
    if (url.startsWith("about:") || url.startsWith("javascript:")) {
      return new URL_1(url);
    }
    try {
      return new URL_1(url, frame.window.location.href);
    } catch (e2) {
      return new URL_1("about:blank");
    }
  }
}
var BrowserNavigationCrossOriginPolicyEnum;
(function(BrowserNavigationCrossOriginPolicyEnum2) {
  BrowserNavigationCrossOriginPolicyEnum2["anyOrigin"] = "anyOrigin";
  BrowserNavigationCrossOriginPolicyEnum2["sameOrigin"] = "sameOrigin";
  BrowserNavigationCrossOriginPolicyEnum2["strictOrigin"] = "strictOrigin";
})(BrowserNavigationCrossOriginPolicyEnum || (BrowserNavigationCrossOriginPolicyEnum = {}));
const BrowserNavigationCrossOriginPolicyEnum$1 = BrowserNavigationCrossOriginPolicyEnum;
class Script {
  /**
   *
   * @param code
   */
  constructor(code2) {
    this.code = code2;
  }
  /**
   *
   * @param context
   */
  runInContext(context) {
    const evaluate = (code2) => {
      globalThis.eval(code2);
    };
    evaluate.call(context, this.code);
  }
}
const contextSymbol = Symbol("context");
const isContext = (context) => {
  return context[contextSymbol] === true;
};
const createContext = (context) => {
  context[contextSymbol] = true;
  return context;
};
const VM = { Script, isContext, createContext };
class BrowserFrameScriptEvaluator {
  /**
   * Evaluates code or a VM Script in the frame's context.
   *
   * @param frame Frame.
   * @param script Script.
   * @returns Result.
   */
  static evaluate(frame, script) {
    if (!frame.window) {
      throw new Error('The frame has been destroyed, the "window" property is not set.');
    }
    script = typeof script === "string" ? new Script(script) : script;
    return script.runInContext(frame.window);
  }
}
class BrowserFrameExceptionObserver {
  constructor() {
    this.browserFrame = null;
    this.uncaughtExceptionListener = null;
    this.uncaughtRejectionListener = null;
  }
  /**
   * Observes the Node process for uncaught exceptions.
   *
   * @param browserFrame Browser frame.
   */
  observe(browserFrame) {
    if (this.browserFrame) {
      throw new Error("Already observing.");
    }
    this.browserFrame = browserFrame;
    this.constructor.listenerCount++;
    this.uncaughtExceptionListener = (error2, origin) => {
      if (origin === "unhandledRejection") {
        return;
      }
      if (!this.browserFrame.window) {
        throw new Error("Browser frame was not closed correctly. Window is undefined on browser frame, but exception observer is still watching.");
      }
      if (error2 instanceof this.browserFrame.window.Error || error2 instanceof this.browserFrame.window.DOMException) {
        this.browserFrame.window.console.error(error2);
        this.browserFrame.window.dispatchEvent(new this.browserFrame.window.ErrorEvent("error", { error: error2, message: error2.message }));
      } else if (process.listenerCount("uncaughtException") === this.constructor.listenerCount) {
        console.error(error2);
        process.exit(1);
      }
    };
    this.uncaughtRejectionListener = (error2) => {
      if (!this.browserFrame.window) {
        throw new Error("Browser frame was not closed correctly. Window is undefined on browser frame, but exception observer is still watching.");
      }
      if (error2 instanceof this.browserFrame.window.Error || error2 instanceof this.browserFrame.window.DOMException) {
        this.browserFrame.window.console.error(error2);
        this.browserFrame.window.dispatchEvent(new this.browserFrame.window.ErrorEvent("error", { error: error2, message: error2.message }));
      } else if (process.listenerCount("unhandledRejection") === this.constructor.listenerCount) {
        console.error(error2);
        process.exit(1);
      }
    };
    process.on("uncaughtException", this.uncaughtExceptionListener);
    process.on("unhandledRejection", this.uncaughtRejectionListener);
  }
  /**
   * Disconnects observer.
   */
  disconnect() {
    if (!this.browserFrame) {
      return;
    }
    this.constructor.listenerCount--;
    process.off("uncaughtException", this.uncaughtExceptionListener);
    process.off("unhandledRejection", this.uncaughtRejectionListener);
    this.uncaughtExceptionListener = null;
    this.uncaughtRejectionListener = null;
    this.browserFrame = null;
  }
}
BrowserFrameExceptionObserver.listenerCount = 0;
var _a$s, _b$f, _c$b, _d$7, _e$7, _f$5;
class DetachedBrowserFrame {
  /**
   * Constructor.
   *
   * @param page Page.
   * @param [window] Window.
   */
  constructor(page) {
    var _a2, _b2;
    this.childFrames = [];
    this.parentFrame = null;
    this[_a$s] = new AsyncTaskManager();
    this[_b$f] = null;
    this[_c$b] = { navigation: [] };
    this[_d$7] = null;
    this[_e$7] = null;
    this[_f$5] = false;
    this.page = page;
    if ((_b2 = (_a2 = page.context.browser.contexts[0]) == null ? void 0 : _a2.pages[0]) == null ? void 0 : _b2.mainFrame) {
      this.window = new this.page.context.browser.windowClass(this);
    }
    if (page.context.browser.settings.errorCapture === BrowserErrorCaptureEnum$1.processLevel) {
      this[exceptionObserver] = new BrowserFrameExceptionObserver();
      this[exceptionObserver].observe(this);
    }
  }
  /**
   * Returns the content.
   *
   * @returns Content.
   */
  get content() {
    if (!this.window) {
      throw new Error('The frame has been destroyed, the "window" property is not set.');
    }
    return this.window.document.documentElement.outerHTML;
  }
  /**
   * Sets the content.
   *
   * @param content Content.
   */
  set content(content2) {
    if (!this.window) {
      throw new Error('The frame has been destroyed, the "window" property is not set.');
    }
    this.window.document[isFirstWrite] = true;
    this.window.document[isFirstWriteAfterOpen] = false;
    this.window.document.open();
    this.window.document.write(content2);
  }
  /**
   * Returns the URL.
   *
   * @returns URL.
   */
  get url() {
    if (!this.window) {
      throw new Error('The frame has been destroyed, the "window" property is not set.');
    }
    return this.window.location.href;
  }
  /**
   * Sets the content.
   *
   * @param url URL.
   */
  set url(url) {
    if (!this.window) {
      throw new Error('The frame has been destroyed, the "window" property is not set.');
    }
    this.window.location[setURL](this, BrowserFrameURL.getRelativeURL(this, url).href);
  }
  /**
   * Returns document.
   *
   * @returns Document.
   */
  get document() {
    var _a2;
    return ((_a2 = this.window) == null ? void 0 : _a2.document) ?? null;
  }
  /**
   * Returns a promise that is resolved when all resources has been loaded, fetch has completed, and all async tasks such as timers are complete.
   */
  async waitUntilComplete() {
    await Promise.all([
      this[asyncTaskManager].waitUntilComplete(),
      ...this.childFrames.map((frame) => frame.waitUntilComplete())
    ]);
  }
  /**
   * Returns a promise that is resolved when the frame has navigated and the response HTML has been written to the document.
   */
  waitForNavigation() {
    return new Promise((resolve3) => this[listeners].navigation.push(resolve3));
  }
  /**
   * Aborts all ongoing operations.
   */
  abort() {
    if (!this.childFrames.length) {
      return this[asyncTaskManager].abort();
    }
    return new Promise((resolve3, reject) => {
      Promise.all(this.childFrames.map((frame) => frame.abort()).concat([this[asyncTaskManager].abort()])).then(() => resolve3()).catch(reject);
    });
  }
  /**
   * Evaluates code or a VM Script in the page's context.
   *
   * @param script Script.
   * @returns Result.
   */
  evaluate(script) {
    return BrowserFrameScriptEvaluator.evaluate(this, script);
  }
  /**
   * Go to a page.
   *
   * @param url URL.
   * @param [options] Options.
   * @returns Response.
   */
  goto(url, options2) {
    return BrowserFrameNavigator.navigate({
      windowClass: this.page.context.browser.windowClass,
      frame: this,
      url,
      goToOptions: options2
    });
  }
  /**
   * Reloads the current frame.
   *
   * @param [options] Options.
   * @returns Response.
   */
  reload(options2) {
    return BrowserFrameNavigator.navigate({
      windowClass: this.page.context.browser.windowClass,
      frame: this,
      url: this.url,
      goToOptions: options2
    });
  }
}
_a$s = asyncTaskManager, _b$f = exceptionObserver, _c$b = listeners, _d$7 = openerFrame, _e$7 = openerWindow, _f$5 = popup;
class BrowserFrameValidator {
  /**
   * Returns true if the frame navigation complies with the cross origin policy.
   *
   * @param frame Frame.
   * @param toURL URL.
   * @returns True if the frame navigation complies with the cross origin policy.
   */
  static validateCrossOriginPolicy(frame, toURL) {
    const settings = frame.page.context.browser.settings;
    let fromURL = frame.page.mainFrame.window.location;
    if (frame[openerFrame]) {
      fromURL = frame[openerFrame].window.location;
    } else if (frame.parentFrame) {
      fromURL = frame.parentFrame.window.location;
    }
    if (settings.navigation.crossOriginPolicy === BrowserNavigationCrossOriginPolicyEnum$1.sameOrigin && fromURL.protocol !== "about:" && toURL.protocol !== "about:" && toURL.protocol !== "javascript:" && fromURL.origin !== toURL.origin) {
      return false;
    }
    if (settings.navigation.crossOriginPolicy === BrowserNavigationCrossOriginPolicyEnum$1.strictOrigin && fromURL.protocol === "https:" && toURL.protocol === "http:") {
      return false;
    }
    return true;
  }
  /**
   * Returns true if navigation is allowed for the frame.
   *
   * @param frame Frame.
   * @returns True if navigation is allowed for the frame.
   */
  static validateFrameNavigation(frame) {
    const settings = frame.page.context.browser.settings;
    if (frame instanceof DetachedBrowserFrame && frame.page.context === frame.page.context.browser.defaultContext && frame.page.context.pages[0] === frame.page && frame.page.mainFrame === frame) {
      return false;
    }
    if (settings.navigation.disableMainFrameNavigation && frame.page.mainFrame === frame) {
      return false;
    }
    if (settings.navigation.disableChildFrameNavigation && frame.page.mainFrame !== frame) {
      return false;
    }
    if (settings.navigation.disableChildPageNavigation && !!frame[openerFrame]) {
      return false;
    }
    return true;
  }
}
class BrowserFrameNavigator {
  /**
   * Navigates to a page.
   *
   * @throws Error if the request can't be resolved (because of SSL error or similar). It will not throw if the response is not ok.
   * @param options Options.
   * @param options.windowClass Window class.
   * @param options.frame Frame.
   * @param options.url URL.
   * @param [options.formData] Form data.
   * @param [options.method] Method.
   * @param [options.goToOptions] Go to options.
   * @returns Response.
   */
  static async navigate(options2) {
    var _a2, _b2;
    const { windowClass, frame, url, formData, method, goToOptions } = options2;
    const referrer$1 = (goToOptions == null ? void 0 : goToOptions.referrer) || frame.window.location.origin;
    const targetURL = BrowserFrameURL.getRelativeURL(frame, url);
    if (!frame.window) {
      throw new Error('The frame has been destroyed, the "window" property is not set.');
    }
    if (targetURL.protocol === "javascript:") {
      if (frame && !frame.page.context.browser.settings.disableJavaScriptEvaluation) {
        const readyStateManager$12 = frame.window[readyStateManager];
        readyStateManager$12.startTask();
        await new Promise((resolve3) => frame.page.mainFrame.window.setTimeout(resolve3));
        const code2 = "//# sourceURL=" + frame.url + "\n" + targetURL.href.replace("javascript:", "");
        if (frame.page.context.browser.settings.disableErrorCapturing || frame.page.context.browser.settings.errorCapture !== BrowserErrorCaptureEnum$1.tryAndCatch) {
          frame.window.eval(code2);
        } else {
          WindowErrorUtility.captureError(frame.window, () => frame.window.eval(code2));
        }
        readyStateManager$12.endTask();
      }
      return null;
    }
    if (!BrowserFrameValidator.validateCrossOriginPolicy(frame, targetURL)) {
      return null;
    }
    if (!BrowserFrameValidator.validateFrameNavigation(frame)) {
      if (!frame.page.context.browser.settings.navigation.disableFallbackToSetURL) {
        frame.window.location[setURL](frame, targetURL.href);
      }
      return null;
    }
    const width2 = frame.window.innerWidth;
    const height2 = frame.window.innerHeight;
    const devicePixelRatio = frame.window.devicePixelRatio;
    const parentWindow = frame.window.parent !== frame.window ? frame.window.parent : null;
    const topWindow = frame.window.top !== frame.window ? frame.window.top : null;
    for (const childFrame of frame.childFrames) {
      BrowserFrameFactory.destroyFrame(childFrame);
    }
    frame.childFrames = [];
    frame.window[destroy]();
    frame[asyncTaskManager].destroy();
    frame[asyncTaskManager] = new AsyncTaskManager();
    frame.window = new windowClass(frame, { url: targetURL.href, width: width2, height: height2 });
    frame.window.parent = parentWindow;
    frame.window.top = topWindow;
    frame.window.devicePixelRatio = devicePixelRatio;
    if (referrer$1) {
      frame.window.document[referrer] = referrer$1;
    }
    if (targetURL.protocol === "about:") {
      return null;
    }
    const readyStateManager$1 = frame.window[readyStateManager];
    readyStateManager$1.startTask();
    const abortController = new NotSupported$b();
    let response;
    let responseText;
    const timeout = frame.window.setTimeout(() => abortController.abort(new Error("Request timed out.")), (goToOptions == null ? void 0 : goToOptions.timeout) ?? 3e4);
    const finalize = () => {
      frame.window.clearTimeout(timeout);
      readyStateManager$1.endTask();
      const listeners$1 = frame[listeners].navigation;
      frame[listeners].navigation = [];
      for (const listener of listeners$1) {
        listener();
      }
    };
    try {
      response = await frame.window.fetch(targetURL.href, {
        referrer: referrer$1,
        referrerPolicy: (goToOptions == null ? void 0 : goToOptions.referrerPolicy) || "origin",
        signal: abortController.signal,
        method: method || (formData ? "POST" : "GET"),
        headers: (goToOptions == null ? void 0 : goToOptions.hard) ? { "Cache-Control": "no-cache" } : void 0,
        body: formData
      });
      if (frame.parentFrame) {
        const originURL = frame.parentFrame.window.location;
        const xFrameOptions = (_b2 = (_a2 = response.headers) == null ? void 0 : _a2.get("X-Frame-Options")) == null ? void 0 : _b2.toLowerCase();
        const isSameOrigin = originURL.origin === targetURL.origin || targetURL.origin === "null";
        if (xFrameOptions === "deny" || xFrameOptions === "sameorigin" && !isSameOrigin) {
          throw new Error(`Refused to display '${url}' in a frame because it set 'X-Frame-Options' to '${xFrameOptions}'.`);
        }
      }
      responseText = await response.text();
    } catch (error2) {
      finalize();
      throw error2;
    }
    if (!response.ok) {
      frame.page.console.error(`GET ${targetURL.href} ${response.status} (${response.statusText})`);
    }
    frame.window.requestAnimationFrame(() => frame.content = responseText);
    await new Promise((resolve3) => frame.window.requestAnimationFrame(() => {
      finalize();
      resolve3(null);
    }));
    return response;
  }
}
let Buffer$1 = class Buffer2 {
  /**
   *
   */
  static from() {
    return new Buffer2();
  }
};
var _a$r;
class Blob {
  /**
   * Constructor.
   *
   * @param bits Bits.
   * @param [options] Options.
   * @param [options.type] MIME type.
   */
  constructor(bits, options2) {
    this.type = "";
    this[_a$r] = null;
    const buffers = [];
    if (bits) {
      for (const bit of bits) {
        let buffer$1;
        if (bit instanceof ArrayBuffer) {
          buffer$1 = Buffer$1.from(new Uint8Array(bit));
        } else if (bit instanceof Blob) {
          buffer$1 = bit[buffer];
        } else if (bit instanceof Buffer$1) {
          buffer$1 = bit;
        } else if (ArrayBuffer.isView(bit)) {
          buffer$1 = Buffer$1.from(new Uint8Array(bit.buffer, bit.byteOffset, bit.byteLength));
        } else {
          buffer$1 = Buffer$1.from(typeof bit === "string" ? bit : String(bit));
        }
        buffers.push(buffer$1);
      }
    }
    this[buffer] = Buffer$1.concat(buffers);
    if (options2 && options2.type && options2.type.match(/^[\u0020-\u007E]*$/)) {
      this.type = String(options2.type).toLowerCase();
    }
  }
  /**
   * Returns size.
   *
   * @returns Size.
   */
  get size() {
    return this[buffer].length;
  }
  /**
   * Slices the blob.
   *
   * @param start Start.
   * @param end End.
   * @param contentType Content type.
   * @returns New Blob.
   */
  slice(start2 = 0, end2 = null, contentType = "") {
    const size = this.size;
    let relativeStart;
    let relativeEnd;
    let relativeContentType;
    if (start2 === void 0) {
      relativeStart = 0;
    } else if (start2 < 0) {
      relativeStart = Math.max(size + start2, 0);
    } else {
      relativeStart = Math.min(start2, size);
    }
    if (end2 === null) {
      relativeEnd = size;
    } else if (end2 < 0) {
      relativeEnd = Math.max(size + end2, 0);
    } else {
      relativeEnd = Math.min(end2, size);
    }
    if (contentType === void 0) {
      relativeContentType = "";
    } else {
      relativeContentType = contentType;
    }
    const span2 = Math.max(relativeEnd - relativeStart, 0);
    const buffer$1 = this[buffer];
    const slicedBuffer = buffer$1.slice(relativeStart, relativeStart + span2);
    const blob = new Blob([], { type: relativeContentType });
    blob[buffer] = slicedBuffer;
    return blob;
  }
  /**
   * Returns a Promise that resolves to a ArrayBuffer.
   *
   * @returns ArrayBuffer.
   */
  // Reference:
  // https://github.com/web-std/io/blob/c88170bf24f064adfbb3586a21fb76650ca5a9ab/packages/blob/src/blob.js#L139-L148
  // https://stackoverflow.com/questions/8609289/convert-a-binary-nodejs-buffer-to-javascript-arraybuffer
  /**
   *
   */
  async arrayBuffer() {
    return new Uint8Array(this[buffer]).buffer;
  }
  /**
   * Returns a Promise that resolves to a text.
   *
   * @returns Text.
   */
  async text() {
    return this[buffer].toString();
  }
  /**
   * Returns the object converted to string.
   *
   * @returns String.
   */
  toString() {
    return "[object Blob]";
  }
}
_a$r = buffer;
class File extends Blob {
  /**
   * Constructor.
   *
   * @param bits File bits.
   * @param name File name.
   * @param [options] Options.
   * @param [options.type] MIME type.
   * @param [options.lastModifier] Last modified. Defaults to Date.now().
   * @param options.lastModified
   */
  constructor(bits, name2, options2) {
    super(bits, options2);
    this.lastModified = null;
    this.name = null;
    this.name = name2.replace(/\//g, ":");
    this.lastModified = options2 && options2.lastModified ? options2.lastModified : Date.now();
  }
}
var __classPrivateFieldGet$A = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$x = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var _FormData_instances, _FormData_entries, _FormData_parseValue;
const SUBMITTABLE_ELEMENTS = ["BUTTON", "INPUT", "OBJECT", "SELECT", "TEXTAREA"];
class FormData {
  /**
   * Constructor.
   *
   * @param [form] Form.
   */
  constructor(form) {
    _FormData_instances.add(this);
    _FormData_entries.set(this, []);
    if (form) {
      for (const name2 of Object.keys(form[elements][namedItems])) {
        let radioNodeList = form[elements][namedItems][name2];
        if (radioNodeList[0][tagName] === "INPUT" && (radioNodeList[0].type === "checkbox" || radioNodeList[0].type === "radio")) {
          const newRadioNodeList = new RadioNodeList();
          for (const node2 of radioNodeList) {
            if (node2.checked) {
              newRadioNodeList.push(node2);
              break;
            }
          }
          radioNodeList = newRadioNodeList;
        }
        for (const node2 of radioNodeList) {
          if (node2.name && SUBMITTABLE_ELEMENTS.includes(node2[tagName])) {
            if (node2[tagName] === "INPUT" && node2.type === "file") {
              if (node2[files].length === 0) {
                this.append(node2.name, new File([], "", { type: "application/octet-stream" }));
              } else {
                for (const file of node2[files]) {
                  this.append(node2.name, file);
                }
              }
            } else if (node2.value) {
              this.append(node2.name, node2.value);
            }
          }
        }
      }
    }
  }
  /**
   * For each.
   *
   * @param callback Callback.
   */
  forEach(callback) {
    for (const entry2 of __classPrivateFieldGet$A(this, _FormData_entries, "f")) {
      callback.call(this, entry2.value, entry2.name, this);
    }
  }
  /**
   * Appends a new value onto an existing key.
   *
   * @param name Name.
   * @param value Value.
   * @param [filename] Filename.
   */
  append(name2, value2, filename) {
    __classPrivateFieldGet$A(this, _FormData_entries, "f").push({
      name: name2,
      value: __classPrivateFieldGet$A(this, _FormData_instances, "m", _FormData_parseValue).call(this, value2, filename)
    });
  }
  /**
   * Removes a value.
   *
   * @param name Name.
   */
  delete(name2) {
    const newEntries = [];
    for (const entry2 of __classPrivateFieldGet$A(this, _FormData_entries, "f")) {
      if (entry2.name !== name2) {
        newEntries.push(entry2);
      }
    }
    __classPrivateFieldSet$x(this, _FormData_entries, newEntries, "f");
  }
  /**
   * Returns value.
   *
   * @param name Name.
   * @returns Value.
   */
  get(name2) {
    for (const entry2 of __classPrivateFieldGet$A(this, _FormData_entries, "f")) {
      if (entry2.name === name2) {
        return entry2.value;
      }
    }
    return null;
  }
  /**
   * Returns all values associated with the given name.
   *
   * @param name Name.
   * @returns Values.
   */
  getAll(name2) {
    const values = [];
    for (const entry2 of __classPrivateFieldGet$A(this, _FormData_entries, "f")) {
      if (entry2.name === name2) {
        values.push(entry2.value);
      }
    }
    return values;
  }
  /**
   * Returns whether a FormData object contains a certain key.
   *
   * @param name Name.
   * @returns "true" if the FormData object contains the key.
   */
  has(name2) {
    for (const entry2 of __classPrivateFieldGet$A(this, _FormData_entries, "f")) {
      if (entry2.name === name2) {
        return true;
      }
    }
    return false;
  }
  /**
   * Sets a new value for an existing key inside a FormData object, or adds the key/value if it does not already exist.
   *
   * @param name Name.
   * @param value Value.
   * @param [filename] Filename.
   */
  set(name2, value2, filename) {
    for (const entry2 of __classPrivateFieldGet$A(this, _FormData_entries, "f")) {
      if (entry2.name === name2) {
        entry2.value = __classPrivateFieldGet$A(this, _FormData_instances, "m", _FormData_parseValue).call(this, value2, filename);
        return;
      }
    }
    this.append(name2, value2);
  }
  /**
   * Returns an iterator, allowing you to go through all keys of the key/value pairs contained in this object.
   *
   * @returns Iterator.
   */
  *keys() {
    for (const entry2 of __classPrivateFieldGet$A(this, _FormData_entries, "f")) {
      yield entry2.name;
    }
  }
  /**
   * Returns an iterator, allowing you to go through all values of the key/value pairs contained in this object.
   *
   * @returns Iterator.
   */
  *values() {
    for (const entry2 of __classPrivateFieldGet$A(this, _FormData_entries, "f")) {
      yield entry2.value;
    }
  }
  /**
   * Returns an iterator, allowing you to go through all key/value pairs contained in this object.
   *
   * @returns Iterator.
   */
  *entries() {
    for (const entry2 of __classPrivateFieldGet$A(this, _FormData_entries, "f")) {
      yield [entry2.name, entry2.value];
    }
  }
  /**
   * Iterator.
   *
   * @returns Iterator.
   */
  *[(_FormData_entries = /* @__PURE__ */ new WeakMap(), _FormData_instances = /* @__PURE__ */ new WeakSet(), Symbol.iterator)]() {
    for (const entry2 of __classPrivateFieldGet$A(this, _FormData_entries, "f")) {
      yield [entry2.name, entry2.value];
    }
  }
}
_FormData_parseValue = function _FormData_parseValue2(value2, filename) {
  if (value2 instanceof Blob && !(value2 instanceof File)) {
    const file = new File([], "blob", { type: value2.type });
    file[buffer] = value2[buffer];
    return file;
  }
  if (value2 instanceof File) {
    if (filename) {
      const file = new File([], filename, { type: value2.type, lastModified: value2.lastModified });
      file[buffer] = value2[buffer];
      return file;
    }
    return value2;
  }
  return String(value2);
};
var __classPrivateFieldSet$w = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$z = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HTMLFormElement_instances, _HTMLFormElement_browserFrame, _HTMLFormElement_submit, _a$q, _b$e, _c$a;
let HTMLFormElement$1 = class HTMLFormElement extends HTMLElement$1 {
  /**
   * Constructor.
   *
   * @param browserFrame Browser frame.
   */
  constructor(browserFrame) {
    super();
    _HTMLFormElement_instances.add(this);
    this[_a$q] = new HTMLFormControlsCollection();
    this[_b$e] = 0;
    this[_c$a] = this;
    this.onformdata = null;
    this.onreset = null;
    this.onsubmit = null;
    _HTMLFormElement_browserFrame.set(this, void 0);
    __classPrivateFieldSet$w(this, _HTMLFormElement_browserFrame, browserFrame, "f");
  }
  /**
   * Returns elements.
   *
   * @returns Elements.
   */
  get elements() {
    return this[elements];
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get length() {
    return this[length$1];
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this.getAttribute("name") || "";
  }
  /**
   * Sets name.
   *
   * @param name Name.
   */
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * Returns method.
   *
   * @returns Method.
   */
  get method() {
    return this.getAttribute("method") || "get";
  }
  /**
   * Sets method.
   *
   * @param method Method.
   */
  set method(method) {
    this.setAttribute("method", method);
  }
  /**
   * Returns target.
   *
   * @returns Target.
   */
  get target() {
    return this.getAttribute("target") || "";
  }
  /**
   * Sets target.
   *
   * @param target Target.
   */
  set target(target2) {
    this.setAttribute("target", target2);
  }
  /**
   * Returns action.
   *
   * @returns Action.
   */
  get action() {
    if (!this.hasAttribute("action")) {
      return this[ownerDocument].location.href;
    }
    try {
      return new URL(this.getAttribute("action"), this[ownerDocument].location.href).href;
    } catch (e2) {
      return "";
    }
  }
  /**
   * Sets action.
   *
   * @param action Action.
   */
  set action(action) {
    this.setAttribute("action", action);
  }
  /**
   * Returns encoding.
   *
   * @returns Encoding.
   */
  get encoding() {
    return this.getAttribute("encoding") || "";
  }
  /**
   * Sets encoding.
   *
   * @param encoding Encoding.
   */
  set encoding(encoding2) {
    this.setAttribute("encoding", encoding2);
  }
  /**
   * Returns enctype.
   *
   * @returns Enctype.
   */
  get enctype() {
    return this.getAttribute("enctype") || "";
  }
  /**
   * Sets enctype.
   *
   * @param enctype Enctype.
   */
  set enctype(enctype) {
    this.setAttribute("enctype", enctype);
  }
  /**
   * Returns autocomplete.
   *
   * @returns Autocomplete.
   */
  get autocomplete() {
    return this.getAttribute("autocomplete") || "";
  }
  /**
   * Sets autocomplete.
   *
   * @param autocomplete Autocomplete.
   */
  set autocomplete(autocomplete) {
    this.setAttribute("autocomplete", autocomplete);
  }
  /**
   * Returns accept charset.
   *
   * @returns Accept charset.
   */
  get acceptCharset() {
    return this.getAttribute("acceptcharset") || "";
  }
  /**
   * Sets accept charset.
   *
   * @param acceptCharset Accept charset.
   */
  set acceptCharset(acceptCharset) {
    this.setAttribute("acceptcharset", acceptCharset);
  }
  /**
   * Returns no validate.
   *
   * @returns No validate.
   */
  get noValidate() {
    return this.getAttribute("novalidate") !== null;
  }
  /**
   * Sets no validate.
   *
   * @param noValidate No validate.
   */
  set noValidate(noValidate) {
    if (!noValidate) {
      this.removeAttribute("novalidate");
    } else {
      this.setAttribute("novalidate", "");
    }
  }
  /**
   * Submits form. No submit event is raised. In particular, the form's "submit" event handler is not run.
   */
  submit() {
    __classPrivateFieldGet$z(this, _HTMLFormElement_instances, "m", _HTMLFormElement_submit).call(this);
  }
  /**
   * Submits form, reports validity and raises submit event.
   *
   * @param [submitter] Submitter.
   */
  requestSubmit(submitter) {
    const noValidate = (submitter == null ? void 0 : submitter.formNoValidate) || this.noValidate;
    if (noValidate || this.checkValidity()) {
      this.dispatchEvent(new SubmitEvent("submit", { bubbles: true, cancelable: true, submitter: submitter || this }));
      __classPrivateFieldGet$z(this, _HTMLFormElement_instances, "m", _HTMLFormElement_submit).call(this, submitter);
    }
  }
  /**
   * Resets form.
   */
  reset() {
    for (const element of this[elements]) {
      if (element[tagName] === "INPUT" || element[tagName] === "TEXTAREA") {
        element[value] = null;
        element[checked] = null;
      } else if (element[tagName] === "TEXTAREA") {
        element[value] = null;
      } else if (element[tagName] === "SELECT") {
        let hasSelectedAttribute = false;
        for (const option of element.options) {
          if (option.hasAttribute("selected")) {
            hasSelectedAttribute = true;
            option.selected = true;
            break;
          }
        }
        if (!hasSelectedAttribute && element.options.length > 0) {
          element.options[0].selected = true;
        }
      }
    }
    this.dispatchEvent(new Event("reset", { bubbles: true, cancelable: true }));
  }
  /**
   * Checks validity.
   *
   * @returns "true" if validation does'nt fail.
   */
  checkValidity() {
    const radioValidationState = {};
    let isFormValid = true;
    for (const element of this[elements]) {
      if (element[tagName] === "INPUT" && element.type === "radio" && element.name) {
        if (!radioValidationState[element.name]) {
          radioValidationState[element.name] = true;
          if (!element.checkValidity()) {
            isFormValid = false;
          }
        }
      } else if (!element.checkValidity()) {
        isFormValid = false;
      }
    }
    return isFormValid;
  }
  /**
   * Reports validity.
   *
   * @returns "true" if validation does'nt fail.
   */
  reportValidity() {
    return this.checkValidity();
  }
  /**
   * @override
   */
  [(_HTMLFormElement_browserFrame = /* @__PURE__ */ new WeakMap(), _HTMLFormElement_instances = /* @__PURE__ */ new WeakSet(), _a$q = elements, _b$e = length$1, _c$a = formNode, cloneNode)](deep = false) {
    return super[cloneNode](deep);
  }
  /**
   * Appends a form control item.
   *
   * @param node Node.
   * @param name Name
   */
  [appendFormControlItem](node2, name2) {
    const elements$1 = this[elements];
    if (!elements$1.includes(node2)) {
      this[elements$1.length] = node2;
      elements$1.push(node2);
      this[length$1] = elements$1.length;
    }
    elements$1[appendNamedItem](node2, name2);
    if (this[isValidPropertyName](name2)) {
      this[name2] = elements$1[name2];
    }
  }
  /**
   * Remove a form control item.
   *
   * @param node Node.
   * @param name Name.
   */
  [removeFormControlItem](node2, name2) {
    const elements$1 = this[elements];
    const index = elements$1.indexOf(node2);
    if (index !== -1) {
      elements$1.splice(index, 1);
      for (let i = index; i < this[length$1]; i++) {
        this[i] = this[i + 1];
      }
      delete this[this[length$1] - 1];
      this[length$1]--;
    }
    elements$1[removeNamedItem](node2, name2);
    if (this[isValidPropertyName](name2)) {
      if (elements$1[name2]) {
        this[name2] = elements$1[name2];
      } else {
        delete this[name2];
      }
    }
  }
  /**
   * Returns "true" if the property name is valid.
   *
   * @param name Name.
   * @returns True if the property name is valid.
   */
  [isValidPropertyName](name2) {
    return !!name2 && !HTMLFormElement.prototype.hasOwnProperty(name2) && !HTMLElement$1.prototype.hasOwnProperty(name2) && !Element$1.prototype.hasOwnProperty(name2) && !Node2.prototype.hasOwnProperty(name2) && (isNaN(Number(name2)) || name2.includes("."));
  }
};
_HTMLFormElement_submit = function _HTMLFormElement_submit2(submitter) {
  const action = (submitter == null ? void 0 : submitter.hasAttribute("formaction")) ? (submitter == null ? void 0 : submitter.formAction) || this.action : this.action;
  if (!action) {
    this[ownerDocument].location.hash = "#blocked";
    return;
  }
  const method = (submitter == null ? void 0 : submitter.formMethod) || this.method;
  const formData = new FormData(this);
  let targetFrame;
  switch ((submitter == null ? void 0 : submitter.formTarget) || this.target) {
    default:
    case "_self":
      targetFrame = __classPrivateFieldGet$z(this, _HTMLFormElement_browserFrame, "f");
      break;
    case "_top":
      targetFrame = __classPrivateFieldGet$z(this, _HTMLFormElement_browserFrame, "f").page.mainFrame;
      break;
    case "_parent":
      targetFrame = __classPrivateFieldGet$z(this, _HTMLFormElement_browserFrame, "f").parentFrame ?? __classPrivateFieldGet$z(this, _HTMLFormElement_browserFrame, "f");
      break;
    case "_blank":
      const newPage = __classPrivateFieldGet$z(this, _HTMLFormElement_browserFrame, "f").page.context.newPage();
      targetFrame = newPage.mainFrame;
      targetFrame[openerFrame] = __classPrivateFieldGet$z(this, _HTMLFormElement_browserFrame, "f");
      break;
  }
  if (method === "get") {
    const url = new URL(action);
    for (const [key, value2] of formData) {
      if (typeof value2 === "string") {
        url.searchParams.append(key, value2);
      }
    }
    BrowserFrameNavigator.navigate({
      windowClass: this[ownerDocument][defaultView].constructor,
      frame: targetFrame,
      url: url.href,
      goToOptions: {
        referrer: __classPrivateFieldGet$z(this, _HTMLFormElement_browserFrame, "f").page.mainFrame.window.location.origin
      }
    });
    return;
  }
  BrowserFrameNavigator.navigate({
    windowClass: this[ownerDocument][defaultView].constructor,
    frame: targetFrame,
    method,
    url: action,
    formData,
    goToOptions: {
      referrer: __classPrivateFieldGet$z(this, _HTMLFormElement_browserFrame, "f").page.mainFrame.window.location.origin
    }
  });
};
class HTMLUnknownElement extends HTMLElement$1 {
}
var HTMLInputElementSelectionDirectionEnum;
(function(HTMLInputElementSelectionDirectionEnum2) {
  HTMLInputElementSelectionDirectionEnum2["none"] = "none";
  HTMLInputElementSelectionDirectionEnum2["forward"] = "forward";
  HTMLInputElementSelectionDirectionEnum2["backward"] = "backward";
})(HTMLInputElementSelectionDirectionEnum || (HTMLInputElementSelectionDirectionEnum = {}));
const HTMLInputElementSelectionDirectionEnum$1 = HTMLInputElementSelectionDirectionEnum;
var HTMLInputElementSelectionModeEnum;
(function(HTMLInputElementSelectionModeEnum2) {
  HTMLInputElementSelectionModeEnum2["preserve"] = "preserve";
  HTMLInputElementSelectionModeEnum2["select"] = "select";
  HTMLInputElementSelectionModeEnum2["start"] = "start";
  HTMLInputElementSelectionModeEnum2["end"] = "end";
})(HTMLInputElementSelectionModeEnum || (HTMLInputElementSelectionModeEnum = {}));
const HTMLInputElementSelectionModeEnum$1 = HTMLInputElementSelectionModeEnum;
class HTMLLabelElementUtility {
  /**
   * Returns label elements for a form element.
   *
   * @param element Element to get labels for.
   * @returns Label elements.
   */
  static getAssociatedLabelElements(element) {
    const id = element.id;
    let labels;
    if (id) {
      const rootNode2 = element.getRootNode();
      labels = rootNode2.querySelectorAll(`label[for="${id}"]`);
    } else {
      labels = new NodeList();
    }
    let parent = element[parentNode];
    while (parent) {
      if (parent["tagName"] === "LABEL") {
        labels.push(parent);
        break;
      }
      parent = parent[parentNode];
    }
    return labels;
  }
}
class HTMLTextAreaElementNamedNodeMap extends HTMLElementNamedNodeMap {
  /**
   * @override
   */
  setNamedItem(item2) {
    const replacedItem = super.setNamedItem(item2);
    if ((item2[name] === "id" || item2[name] === "name") && this[ownerElement][formNode]) {
      if (replacedItem && replacedItem[value]) {
        this[ownerElement][formNode][removeFormControlItem](this[ownerElement], replacedItem[value]);
      }
      if (item2[value]) {
        this[ownerElement][formNode][appendFormControlItem](this[ownerElement], item2[value]);
      }
    }
    return replacedItem || null;
  }
  /**
   * @override
   */
  [removeNamedItem](name$1) {
    const removedItem = super[removeNamedItem](name$1);
    if (removedItem && (removedItem[name] === "id" || removedItem[name] === "name") && this[ownerElement][formNode]) {
      this[ownerElement][formNode][removeFormControlItem](this[ownerElement], removedItem[value]);
    }
    return removedItem;
  }
}
var __classPrivateFieldSet$v = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$y = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HTMLTextAreaElement_selectionStart, _HTMLTextAreaElement_selectionEnd, _HTMLTextAreaElement_selectionDirection, _a$p, _b$d, _c$9, _d$6, _e$6;
class HTMLTextAreaElement extends HTMLElement$1 {
  constructor() {
    super(...arguments);
    this.type = "textarea";
    this.oninput = null;
    this.onselectionchange = null;
    this[_a$p] = new HTMLTextAreaElementNamedNodeMap(this);
    this[_b$d] = "";
    this[_c$9] = new ValidityState(this);
    this[_d$6] = null;
    this[_e$6] = this;
    _HTMLTextAreaElement_selectionStart.set(this, null);
    _HTMLTextAreaElement_selectionEnd.set(this, null);
    _HTMLTextAreaElement_selectionDirection.set(this, HTMLInputElementSelectionDirectionEnum$1.none);
  }
  /**
   * Returns validation message.
   *
   * @returns Validation message.
   */
  get validationMessage() {
    return this[validationMessage];
  }
  /**
   * Returns validity.
   *
   * @returns Validity.
   */
  get validity() {
    return this[validity];
  }
  /**
   * Returns the default value.
   *
   * @returns Default value.
   */
  get defaultValue() {
    return this.textContent;
  }
  /**
   * Sets the default value.
   *
   * @param defaultValue Default value.
   */
  set defaultValue(defaultValue) {
    this.textContent = defaultValue;
  }
  /**
   * Returns minlength.
   *
   * @returns Min length.
   */
  get minLength() {
    const minLength = this.getAttribute("minlength");
    if (minLength !== null) {
      return parseInt(minLength);
    }
    return -1;
  }
  /**
   * Sets minlength.
   *
   * @param minLength Min length.
   */
  set minLength(minlength) {
    this.setAttribute("minlength", String(minlength));
  }
  /**
   * Returns maxlength.
   *
   * @returns Max length.
   */
  get maxLength() {
    const maxLength = this.getAttribute("maxlength");
    if (maxLength !== null) {
      return parseInt(maxLength);
    }
    return -1;
  }
  /**
   * Sets maxlength.
   *
   * @param maxlength Max length.
   */
  set maxLength(maxLength) {
    this.setAttribute("maxlength", String(maxLength));
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this.getAttribute("name") || "";
  }
  /**
   * Sets name.
   *
   * @param name Name.
   */
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * Returns placeholder.
   *
   * @returns Placeholder.
   */
  get placeholder() {
    return this.getAttribute("placeholder") || "";
  }
  /**
   * Sets placeholder.
   *
   * @param placeholder Placeholder.
   */
  set placeholder(placeholder) {
    this.setAttribute("placeholder", placeholder);
  }
  /**
   * Returns inputmode.
   *
   * @returns Inputmode.
   */
  get inputmode() {
    return this.getAttribute("inputmode") || "";
  }
  /**
   * Sets inputmode.
   *
   * @param inputmode Inputmode.
   */
  set inputmode(inputmode) {
    this.setAttribute("inputmode", inputmode);
  }
  /**
   * Returns cols.
   *
   * @returns Cols.
   */
  get cols() {
    return this.getAttribute("cols") || "";
  }
  /**
   * Sets cols.
   *
   * @param cols Cols.
   */
  set cols(cols) {
    this.setAttribute("cols", cols);
  }
  /**
   * Returns rows.
   *
   * @returns Rows.
   */
  get rows() {
    return this.getAttribute("rows") || "";
  }
  /**
   * Sets rows.
   *
   * @param rows Rows.
   */
  set rows(rows) {
    this.setAttribute("rows", rows);
  }
  /**
   * Returns autocomplete.
   *
   * @returns Autocomplete.
   */
  get autocomplete() {
    return this.getAttribute("autocomplete") || "";
  }
  /**
   * Sets autocomplete.
   *
   * @param autocomplete Autocomplete.
   */
  set autocomplete(autocomplete) {
    this.setAttribute("autocomplete", autocomplete);
  }
  /**
   * Returns readOnly.
   *
   * @returns ReadOnly.
   */
  get readOnly() {
    return this.getAttribute("readonly") !== null;
  }
  /**
   * Sets readOnly.
   *
   * @param readOnly ReadOnly.
   */
  set readOnly(readOnly) {
    if (!readOnly) {
      this.removeAttribute("readonly");
    } else {
      this.setAttribute("readonly", "");
    }
  }
  /**
   * Returns disabled.
   *
   * @returns Disabled.
   */
  get disabled() {
    return this.getAttribute("disabled") !== null;
  }
  /**
   * Sets disabled.
   *
   * @param disabled Disabled.
   */
  set disabled(disabled) {
    if (!disabled) {
      this.removeAttribute("disabled");
    } else {
      this.setAttribute("disabled", "");
    }
  }
  /**
   * Returns autofocus.
   *
   * @returns Autofocus.
   */
  get autofocus() {
    return this.getAttribute("autofocus") !== null;
  }
  /**
   * Sets autofocus.
   *
   * @param autofocus Autofocus.
   */
  set autofocus(autofocus) {
    if (!autofocus) {
      this.removeAttribute("autofocus");
    } else {
      this.setAttribute("autofocus", "");
    }
  }
  /**
   * Returns required.
   *
   * @returns Required.
   */
  get required() {
    return this.getAttribute("required") !== null;
  }
  /**
   * Sets required.
   *
   * @param required Required.
   */
  set required(required) {
    if (!required) {
      this.removeAttribute("required");
    } else {
      this.setAttribute("required", "");
    }
  }
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    if (this[value] === null) {
      return this.textContent;
    }
    return this[value];
  }
  /**
   * Sets value.
   *
   * @param value Value.
   */
  set value(value$1) {
    const oldValue = this[value];
    this[value] = value$1;
    if (oldValue !== this[value]) {
      __classPrivateFieldSet$v(this, _HTMLTextAreaElement_selectionStart, this[value].length, "f");
      __classPrivateFieldSet$v(this, _HTMLTextAreaElement_selectionEnd, this[value].length, "f");
      __classPrivateFieldSet$v(this, _HTMLTextAreaElement_selectionDirection, HTMLInputElementSelectionDirectionEnum$1.none, "f");
    }
  }
  /**
   * Returns selection start.
   *
   * @returns Selection start.
   */
  get selectionStart() {
    if (__classPrivateFieldGet$y(this, _HTMLTextAreaElement_selectionStart, "f") === null) {
      return this.value.length;
    }
    return __classPrivateFieldGet$y(this, _HTMLTextAreaElement_selectionStart, "f");
  }
  /**
   * Sets selection start.
   *
   * @param start Start.
   */
  set selectionStart(start2) {
    this.setSelectionRange(start2, Math.max(start2, this.selectionEnd), __classPrivateFieldGet$y(this, _HTMLTextAreaElement_selectionDirection, "f"));
  }
  /**
   * Returns selection end.
   *
   * @returns Selection end.
   */
  get selectionEnd() {
    if (__classPrivateFieldGet$y(this, _HTMLTextAreaElement_selectionEnd, "f") === null) {
      return this.value.length;
    }
    return __classPrivateFieldGet$y(this, _HTMLTextAreaElement_selectionEnd, "f");
  }
  /**
   * Sets selection end.
   *
   * @param end End.
   */
  set selectionEnd(end2) {
    this.setSelectionRange(this.selectionStart, end2, __classPrivateFieldGet$y(this, _HTMLTextAreaElement_selectionDirection, "f"));
  }
  /**
   * Returns selection direction.
   *
   * @returns Selection direction.
   */
  get selectionDirection() {
    return __classPrivateFieldGet$y(this, _HTMLTextAreaElement_selectionDirection, "f");
  }
  /**
   * Sets selection direction.
   *
   * @param direction Direction.
   */
  set selectionDirection(direction) {
    this.setSelectionRange(this.selectionStart, this.selectionEnd, direction);
  }
  /**
   * Returns the parent form element.
   *
   * @returns Form.
   */
  get form() {
    return this[formNode];
  }
  /**
   * Returns text length.
   *
   * @param Text Length.
   */
  get textLength() {
    return this.value.length;
  }
  /**
   * Returns the associated label elements.
   *
   * @returns Label elements.
   */
  get labels() {
    return HTMLLabelElementUtility.getAssociatedLabelElements(this);
  }
  /**
   * Selects the text.
   */
  select() {
    __classPrivateFieldSet$v(this, _HTMLTextAreaElement_selectionStart, 0, "f");
    __classPrivateFieldSet$v(this, _HTMLTextAreaElement_selectionEnd, this.value.length, "f");
    __classPrivateFieldSet$v(this, _HTMLTextAreaElement_selectionDirection, HTMLInputElementSelectionDirectionEnum$1.none, "f");
    this.dispatchEvent(new Event("select", { bubbles: true, cancelable: true }));
  }
  /**
   * Set selection range.
   *
   * @param start Start.
   * @param end End.
   * @param [direction="none"] Direction.
   */
  setSelectionRange(start2, end2, direction = "none") {
    __classPrivateFieldSet$v(this, _HTMLTextAreaElement_selectionEnd, Math.min(end2, this.value.length), "f");
    __classPrivateFieldSet$v(this, _HTMLTextAreaElement_selectionStart, Math.min(start2, this.selectionEnd), "f");
    __classPrivateFieldSet$v(this, _HTMLTextAreaElement_selectionDirection, direction === HTMLInputElementSelectionDirectionEnum$1.forward || direction === HTMLInputElementSelectionDirectionEnum$1.backward ? direction : HTMLInputElementSelectionDirectionEnum$1.none, "f");
    this.dispatchEvent(new Event("select", { bubbles: true, cancelable: true }));
  }
  /**
   * Set range text.
   *
   * @param replacement Replacement.
   * @param [start] Start.
   * @param [end] End.
   * @param [direction] Direction.
   * @param selectionMode
   */
  setRangeText(replacement, start2 = null, end2 = null, selectionMode = HTMLInputElementSelectionModeEnum$1.preserve) {
    if (start2 === null) {
      start2 = __classPrivateFieldGet$y(this, _HTMLTextAreaElement_selectionStart, "f");
    }
    if (end2 === null) {
      end2 = __classPrivateFieldGet$y(this, _HTMLTextAreaElement_selectionEnd, "f");
    }
    if (start2 > end2) {
      throw new DOMException("The index is not in the allowed range.", DOMExceptionNameEnum$1.invalidStateError);
    }
    start2 = Math.min(start2, this.value.length);
    end2 = Math.min(end2, this.value.length);
    const val = this.value;
    let selectionStart = __classPrivateFieldGet$y(this, _HTMLTextAreaElement_selectionStart, "f");
    let selectionEnd = __classPrivateFieldGet$y(this, _HTMLTextAreaElement_selectionEnd, "f");
    this.value = val.slice(0, start2) + replacement + val.slice(end2);
    const newEnd = start2 + this.value.length;
    switch (selectionMode) {
      case HTMLInputElementSelectionModeEnum$1.select:
        this.setSelectionRange(start2, newEnd);
        break;
      case HTMLInputElementSelectionModeEnum$1.start:
        this.setSelectionRange(start2, start2);
        break;
      case HTMLInputElementSelectionModeEnum$1.end:
        this.setSelectionRange(newEnd, newEnd);
        break;
      default:
        const delta = replacement.length - (end2 - start2);
        if (selectionStart > end2) {
          selectionStart += delta;
        } else if (selectionStart > start2) {
          selectionStart = start2;
        }
        if (selectionEnd > end2) {
          selectionEnd += delta;
        } else if (selectionEnd > start2) {
          selectionEnd = newEnd;
        }
        this.setSelectionRange(selectionStart, selectionEnd);
        break;
    }
  }
  /**
   * Sets validation message.
   *
   * @param message Message.
   */
  setCustomValidity(message) {
    this[validationMessage] = String(message);
  }
  /**
   * Checks validity.
   *
   * @returns "true" if the field is valid.
   */
  checkValidity() {
    const valid = this.disabled || this.readOnly || this[validity].valid;
    if (!valid) {
      this.dispatchEvent(new Event("invalid", { bubbles: true, cancelable: true }));
    }
    return valid;
  }
  /**
   * Reports validity.
   *
   * @returns "true" if the field is valid.
   */
  reportValidity() {
    return this.checkValidity();
  }
  /**
   * @override
   */
  [(_HTMLTextAreaElement_selectionStart = /* @__PURE__ */ new WeakMap(), _HTMLTextAreaElement_selectionEnd = /* @__PURE__ */ new WeakMap(), _HTMLTextAreaElement_selectionDirection = /* @__PURE__ */ new WeakMap(), _a$p = attributes, _b$d = validationMessage, _c$9 = validity, _d$6 = value, _e$6 = textAreaNode, cloneNode)](deep = false) {
    const clone2 = super[cloneNode](deep);
    clone2[value] = this[value];
    __classPrivateFieldSet$v(clone2, _HTMLTextAreaElement_selectionStart, __classPrivateFieldGet$y(this, _HTMLTextAreaElement_selectionStart, "f"), "f");
    __classPrivateFieldSet$v(clone2, _HTMLTextAreaElement_selectionEnd, __classPrivateFieldGet$y(this, _HTMLTextAreaElement_selectionEnd, "f"), "f");
    __classPrivateFieldSet$v(clone2, _HTMLTextAreaElement_selectionDirection, __classPrivateFieldGet$y(this, _HTMLTextAreaElement_selectionDirection, "f"), "f");
    return clone2;
  }
  /**
   * Resets selection.
   */
  [resetSelection]() {
    if (this[value] === null) {
      __classPrivateFieldSet$v(this, _HTMLTextAreaElement_selectionStart, null, "f");
      __classPrivateFieldSet$v(this, _HTMLTextAreaElement_selectionEnd, null, "f");
      __classPrivateFieldSet$v(this, _HTMLTextAreaElement_selectionDirection, HTMLInputElementSelectionDirectionEnum$1.none, "f");
    }
  }
  /**
   * @override
   */
  [connectToNode](parentNode2 = null) {
    const oldFormNode = this[formNode];
    super[connectToNode](parentNode2);
    if (oldFormNode !== this[formNode]) {
      if (oldFormNode) {
        oldFormNode[removeFormControlItem](this, this.name);
        oldFormNode[removeFormControlItem](this, this.id);
      }
      if (this[formNode]) {
        this[formNode][appendFormControlItem](this, this.name);
        this[formNode][appendFormControlItem](this, this.id);
      }
    }
  }
}
const EMAIL_REGEXP = /^([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x22([^\x0d\x22\x5c\x80-\xff]|\x5c[\x00-\x7f])*\x22)(\x2e([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x22([^\x0d\x22\x5c\x80-\xff]|\x5c[\x00-\x7f])*\x22))*\x40([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x5b([^\x0d\x5b-\x5d\x80-\xff]|\x5c[\x00-\x7f])*\x5d)(\x2e([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x5b([^\x0d\x5b-\x5d\x80-\xff]|\x5c[\x00-\x7f])*\x5d))*$/;
const URL_REGEXP = /^(?:(?:https?|HTTPS?|ftp|FTP):\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-zA-Z\u00a1-\uffff0-9]-*)*[a-zA-Z\u00a1-\uffff0-9]+)(?:\.(?:[a-zA-Z\u00a1-\uffff0-9]-*)*[a-zA-Z\u00a1-\uffff0-9]+)*)(?::\d{2,5})?(?:[\/?#]\S*)?$/;
class ValidityState {
  /**
   * Constructor.
   *
   * @param element Input element.
   */
  constructor(element) {
    this.element = element;
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get badInput() {
    return this.element instanceof HTMLInputElement && (this.element.type === "number" || this.element.type === "range") && this.element.value.length > 0 && !/^[-+]?(?:\d+|\d*[.,]\d+)$/.test(this.element.value);
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get customError() {
    return this.element[validationMessage].length > 0;
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get patternMismatch() {
    return this.element instanceof HTMLInputElement && this.element.hasAttribute("pattern") && this.element.value.length > 0 && this.element.value.replace(new RegExp(this.element.getAttribute("pattern")), "").length > 0;
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get rangeOverflow() {
    return this.element instanceof HTMLInputElement && this.element.hasAttribute("max") && (this.element.type === "number" || this.element.type === "range") && this.element.value.length > 0 && Number(this.element.value) > Number(this.element.getAttribute("max"));
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get rangeUnderflow() {
    return this.element instanceof HTMLInputElement && this.element.hasAttribute("min") && (this.element.type === "number" || this.element.type === "range") && this.element.value.length > 0 && Number(this.element.value) < Number(this.element.getAttribute("min"));
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get stepMismatch() {
    return this.element instanceof HTMLInputElement && (this.element.type === "number" || this.element.type === "range") && (this.element.hasAttribute("step") && this.element.getAttribute("step") !== "any" && Number(this.element.value) % Number(this.element.getAttribute("step")) !== 0 || !this.element.hasAttribute("step") && Number(this.element.value) % 1 !== 0);
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get tooLong() {
    return (this.element instanceof HTMLInputElement || this.element instanceof HTMLTextAreaElement) && this.element.maxLength > 0 && this.element.value.length > this.element.maxLength;
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get tooShort() {
    return (this.element instanceof HTMLInputElement || this.element instanceof HTMLTextAreaElement) && this.element.minLength > 0 && this.element.value.length > 0 && this.element.value.length < this.element.minLength;
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get typeMismatch() {
    return this.element instanceof HTMLInputElement && this.element.value.length > 0 && (this.element.type === "email" && !EMAIL_REGEXP.test(this.element.value) || this.element.type === "url" && !URL_REGEXP.test(this.element.value));
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get valueMissing() {
    if (!this.element.required) {
      return false;
    }
    if (this.element instanceof HTMLInputElement) {
      if (this.element.type === "checkbox") {
        return !this.element.checked;
      } else if (this.element.type === "radio") {
        if (this.element.checked) {
          return false;
        }
        if (!this.element.name) {
          return true;
        }
        const root = this.element[formNode] || this.element.getRootNode();
        return !root || !root.querySelector(`input[name="${this.element.name}"]:checked`);
      }
    }
    return this.element.value.length === 0;
  }
  /**
   * Returns validity.
   *
   * @returns "true" if valid.
   */
  get valid() {
    return !this.badInput && !this.customError && !this.patternMismatch && !this.rangeOverflow && !this.rangeUnderflow && !this.stepMismatch && !this.tooLong && !this.tooShort && !this.typeMismatch && !this.valueMissing;
  }
}
const NEW_LINES_REGEXP = /[\n\r]/gm;
const parseInts = (a) => a.map((v2) => parseInt(v2, 10));
class HTMLInputElementValueSanitizer {
  /**
   * Sanitizes a value.
   *
   * @param input Input.
   * @param value Value.
   */
  static sanitize(input, value2) {
    switch (input.type) {
      case "password":
      case "search":
      case "tel":
      case "text":
        return value2.replace(NEW_LINES_REGEXP, "");
      case "color":
        return /^#[a-fA-F\d]{6}$/.test(value2) ? value2.toLowerCase() : "#000000";
      case "email":
        if (input.multiple) {
          return value2.split(",").map((token) => token.trim()).join(",");
        }
        return value2.trim().replace(NEW_LINES_REGEXP, "");
      case "number":
        return !isNaN(Number.parseFloat(value2)) ? value2 : "";
      case "range": {
        const number = Number.parseFloat(value2);
        const min2 = parseFloat(input.min) || 0;
        const max2 = parseFloat(input.max) || 100;
        if (isNaN(number)) {
          return max2 < min2 ? String(min2) : String((min2 + max2) / 2);
        } else if (number < min2) {
          return String(min2);
        } else if (number > max2) {
          return String(max2);
        }
        return value2;
      }
      case "url":
        return value2.trim().replace(NEW_LINES_REGEXP, "");
      case "date":
        value2 = this.sanitizeDate(value2);
        return value2 && this.checkBoundaries(value2, input.min, input.max) ? value2 : "";
      case "datetime-local": {
        const match2 = value2.match(/^(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d)(?::(\d\d)(?:\.(\d{1,3}))?)?$/);
        if (!match2) {
          return "";
        }
        const dateString = this.sanitizeDate(value2.slice(0, 10));
        let timeString = this.sanitizeTime(value2.slice(11));
        if (!(dateString && timeString)) {
          return "";
        }
        if (match2[6] !== void 0) {
          if (timeString.indexOf(".") !== -1) {
            timeString = timeString.replace(/(?:\.0*|(\.\d+?)0+)$/, "$1");
          }
          timeString = timeString.replace(/(\d\d:\d\d)(:00)$/, "$1");
        }
        return dateString + "T" + timeString;
      }
      case "month":
        if (!(value2.match(/^(\d\d\d\d)-(\d\d)$/) && this.parseMonthComponent(value2))) {
          return "";
        }
        return this.checkBoundaries(value2, input.min, input.max) ? value2 : "";
      case "time": {
        value2 = this.sanitizeTime(value2);
        return value2 && this.checkBoundaries(value2, input.min, input.max) ? value2 : "";
      }
      case "week": {
        const match2 = value2.match(/^(\d\d\d\d)-W(\d\d)$/);
        if (!match2) {
          return "";
        }
        const [intY, intW] = parseInts(match2.slice(1, 3));
        if (intY <= 0 || intW < 1 || intW > 53) {
          return "";
        }
        const lastWeek = this.lastIsoWeekOfYear(intY);
        if (intW < 1 || intW > 52 + lastWeek) {
          return "";
        }
        if (!this.checkBoundaries(value2, input.min, input.max)) {
          return "";
        }
        return value2;
      }
    }
    return value2;
  }
  /**
   * Checks if a value is within the boundaries of min and max.
   *
   * @param value
   * @param min
   * @param max
   */
  static checkBoundaries(value2, min2, max2) {
    if (min2 && min2 > value2) {
      return false;
    } else if (max2 && max2 < value2) {
      return false;
    }
    return true;
  }
  /**
   * Parses the month component of a date string.
   *
   * @param value
   */
  static parseMonthComponent(value2) {
    const [Y, M] = value2.split("-");
    const [intY, intM] = parseInts([Y, M]);
    if (isNaN(intY) || isNaN(intM) || intY <= 0 || intM < 1 || intM > 12) {
      return "";
    }
    return value2;
  }
  /**
   * Sanitizes a date string.
   *
   * @param value
   */
  static sanitizeDate(value2) {
    const match2 = value2.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (!match2) {
      return "";
    }
    const month = this.parseMonthComponent(value2.slice(0, 7));
    if (!month) {
      return "";
    }
    const [intY, intM, intD] = parseInts(match2.slice(1, 4));
    if (intD < 1 || intD > 31) {
      return "";
    }
    const lastDayOfMonth = new Date(intY, intM, 0).getDate();
    if (intD > lastDayOfMonth) {
      return "";
    }
    return value2;
  }
  /**
   * Sanitizes a time string.
   *
   * @param value
   */
  static sanitizeTime(value2) {
    const match2 = value2.match(/^(\d{2}):(\d{2})(?::(\d{2}(?:\.(\d{1,3}))?))?$/);
    if (!match2) {
      return "";
    }
    const [intH, intM] = parseInts(match2.slice(1, 3));
    const ms = parseFloat(match2[3] || "0") * 1e3;
    if (intH > 23 || intM > 59 || ms > 59999) {
      return "";
    }
    if (ms === 0) {
      return `${match2[1]}:${match2[2]}`;
    } else {
      return `${match2[1]}:${match2[2]}${ms >= 1e4 ? `:${ms / 1e3}` : `:0${ms / 1e3}`}`;
    }
  }
}
HTMLInputElementValueSanitizer.lastIsoWeekOfYear = (year) => {
  const date = new Date(+year, 11, 31);
  const day = (date.getDay() + 6) % 7;
  date.setDate(date.getDate() - day + 3);
  const firstThursday = date.getTime();
  date.setMonth(0, 1);
  if (date.getDay() !== 4) {
    date.setMonth(0, 1 + (4 - date.getDay() + 7) % 7);
  }
  return 1 + Math.ceil((firstThursday - date.getTime()) / 6048e5);
};
class HTMLInputElementValueStepping {
  /**
   * Steps up or down.
   *
   * @param type Type.
   * @param value Value.
   * @param direction Direction.
   * @param [increment] Increment.
   * @returns New value.
   */
  static step(type, value2, direction, increment2) {
    switch (type) {
      case "number":
        return String(Number(value2) + (increment2 !== void 0 ? increment2 * direction : direction));
      case "date":
      case "month":
      case "week":
      case "time":
      case "datetime-local":
      case "range":
        return null;
      default:
        throw new DOMException("This form element is not steppable.");
    }
  }
}
class FileList extends Array {
  /**
   * Constructor.
   */
  constructor() {
    super(0);
  }
  /**
   * Returns `Symbol.toStringTag`.
   *
   * @returns `Symbol.toStringTag`.
   */
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  /**
   * Returns item by index.
   *
   * @param index Index.
   * @returns Item.
   */
  item(index) {
    return this[index] || null;
  }
}
class HTMLInputElementDateUtility {
  /**
   * Returns iso week number from given date
   *
   * @see https://stackoverflow.com/a/6117889
   * @param date Date or number.
   * @returns Iso-week string.
   */
  static dateIsoWeek(date) {
    date = typeof date === "number" ? new Date(date) : date;
    date = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    date.setUTCDate(date.getUTCDate() + 4 - (date.getUTCDay() || 7));
    const yearStart = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil(((date - yearStart) / 864e5 + 1) / 7);
    return `${date.getUTCFullYear()}-W${weekNo < 10 ? "0" : ""}${weekNo}`;
  }
  /**
   * Returns a date object for monday of given iso week string (\d\d\d\d-W\d\d)
   *
   * @param isoWeek Iso-week string.
   * @returns Date.
   */
  static isoWeekDate(isoWeek) {
    const [, Y, W] = isoWeek.match(/^(\d{4})-W(\d{2})$/) || [];
    if (!Y || !W || Number(W) > 53 || Number(W) < 1) {
      return /* @__PURE__ */ new Date("x");
    }
    const date = /* @__PURE__ */ new Date(`${Y}-01-01T00:00Z`);
    const jan4th = /* @__PURE__ */ new Date(`${Y}-01-04T00:00Z`);
    const jan4thDay = (jan4th.getUTCDay() + 6) % 7;
    const ordinalDate = 1 + (Number(W) - 1) * 7 - jan4thDay + 3;
    date.setUTCDate(ordinalDate);
    if (date.getUTCFullYear() > Number(Y)) {
      return /* @__PURE__ */ new Date("x");
    }
    return date;
  }
}
class HTMLInputElementNamedNodeMap extends HTMLElementNamedNodeMap {
  /**
   * @override
   */
  setNamedItem(item2) {
    const replacedItem = super.setNamedItem(item2);
    if ((item2[name] === "id" || item2[name] === "name") && this[ownerElement][formNode]) {
      if (replacedItem && replacedItem[value]) {
        this[ownerElement][formNode][removeFormControlItem](this[ownerElement], replacedItem[value]);
      }
      if (item2[value]) {
        this[ownerElement][formNode][appendFormControlItem](this[ownerElement], item2[value]);
      }
    }
    return replacedItem || null;
  }
  /**
   * @override
   */
  [removeNamedItem](name$1) {
    const removedItem = super[removeNamedItem](name$1);
    if (removedItem && (removedItem[name] === "id" || removedItem[name] === "name") && this[ownerElement][formNode]) {
      this[ownerElement][formNode][removeFormControlItem](this[ownerElement], removedItem[value]);
    }
    return removedItem;
  }
}
var __classPrivateFieldGet$x = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$u = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var _HTMLInputElement_instances, _HTMLInputElement_selectionStart, _HTMLInputElement_selectionEnd, _HTMLInputElement_selectionDirection, _HTMLInputElement_isSelectionSupported, _HTMLInputElement_setChecked, _a$o, _b$c, _c$8, _d$5, _e$5, _f$4, _g$2, _h$1, _j$1;
class HTMLInputElement extends HTMLElement$1 {
  constructor() {
    super(...arguments);
    _HTMLInputElement_instances.add(this);
    this.oninput = null;
    this.oninvalid = null;
    this.onselectionchange = null;
    this[_a$o] = new HTMLInputElementNamedNodeMap(this);
    this[_b$c] = null;
    this[_c$8] = 0;
    this[_d$5] = 0;
    this[_e$5] = false;
    this[_f$4] = null;
    this[_g$2] = "";
    this[_h$1] = new ValidityState(this);
    this[_j$1] = new FileList();
    _HTMLInputElement_selectionStart.set(this, null);
    _HTMLInputElement_selectionEnd.set(this, null);
    _HTMLInputElement_selectionDirection.set(this, HTMLInputElementSelectionDirectionEnum$1.none);
  }
  /**
   * Returns default checked.
   *
   * @returns Default checked.
   */
  get defaultChecked() {
    return this[defaultChecked];
  }
  /**
   * Sets default checked.
   *
   * @param defaultChecked Default checked.
   */
  set defaultChecked(defaultChecked$1) {
    this[defaultChecked] = defaultChecked$1;
  }
  /**
   * Returns files.
   *
   * @returns Files.
   */
  get files() {
    return this[files];
  }
  /**
   * Sets files.
   *
   * @param files Files.
   */
  set files(files$1) {
    this[files] = files$1;
  }
  /**
   * Returns form action.
   *
   * @returns Form action.
   */
  get formAction() {
    if (!this.hasAttribute("formaction")) {
      return this[ownerDocument].location.href;
    }
    try {
      return new URL_1(this.getAttribute("formaction"), this[ownerDocument].location.href).href;
    } catch (e2) {
      return "";
    }
  }
  /**
   * Sets form action.
   *
   * @param formAction Form action.
   */
  set formAction(formAction) {
    this.setAttribute("formaction", formAction);
  }
  /**
   * Returns form enctype.
   *
   * @returns Form enctype.
   */
  get formEnctype() {
    return this.getAttribute("formenctype") || "";
  }
  /**
   * Sets form enctype.
   *
   * @param formEnctype Form enctype.
   */
  set formEnctype(formEnctype) {
    this.setAttribute("formenctype", formEnctype);
  }
  /**
   * Returns form method.
   *
   * @returns Form method.
   */
  get formMethod() {
    return this.getAttribute("formmethod") || "";
  }
  /**
   * Sets form method.
   *
   * @param formMethod Form method.
   */
  set formMethod(formMethod) {
    this.setAttribute("formmethod", formMethod);
  }
  /**
   * Returns no validate.
   *
   * @returns No validate.
   */
  get formNoValidate() {
    return this.getAttribute("formnovalidate") !== null;
  }
  /**
   * Sets no validate.
   *
   * @param formNoValidate No validate.
   */
  set formNoValidate(formNoValidate) {
    if (!formNoValidate) {
      this.removeAttribute("formnovalidate");
    } else {
      this.setAttribute("formnovalidate", "");
    }
  }
  /**
   * Returns form target.
   *
   * @returns Form target.
   */
  get formTarget() {
    return this.getAttribute("formtarget") || "";
  }
  /**
   * Sets form target.
   *
   * @param formTarget Form target.
   */
  set formTarget(formTarget) {
    this.setAttribute("formtarget", formTarget);
  }
  /**
   * Returns the parent form element.
   *
   * @returns Form.
   */
  get form() {
    if (this[formNode]) {
      return this[formNode];
    }
    if (!this.isConnected) {
      return null;
    }
    const formID = this.getAttribute("form");
    return formID ? this[ownerDocument].getElementById(formID) : null;
  }
  /**
   * Returns validation message.
   *
   * @returns Validation message.
   */
  get validationMessage() {
    return this[validationMessage];
  }
  /**
   * Returns validity.
   *
   * @returns Validity.
   */
  get validity() {
    return this[validity];
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    return this[height];
  }
  /**
   * Sets height.
   *
   * @param height Height.
   */
  set height(height$1) {
    this[height] = height$1;
    this.setAttribute("height", String(height$1));
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    return this[width];
  }
  /**
   * Sets width.
   *
   * @param width Width.
   */
  set width(width$1) {
    this[width] = width$1;
    this.setAttribute("width", String(width$1));
  }
  /**
   * Returns size.
   *
   * @returns Size.
   */
  get size() {
    const size = this.getAttribute("size");
    if (size !== null) {
      return parseInt(size);
    }
    return 20;
  }
  /**
   * Sets size.
   *
   * @param size Size.
   */
  set size(size) {
    this.setAttribute("size", String(size));
  }
  /**
   * Returns minlength.
   *
   * @returns Min length.
   */
  get minLength() {
    const minLength = this.getAttribute("minlength");
    if (minLength !== null) {
      return parseInt(minLength);
    }
    return -1;
  }
  /**
   * Sets minlength.
   *
   * @param minLength Min length.
   */
  set minLength(minlength) {
    this.setAttribute("minlength", String(minlength));
  }
  /**
   * Returns maxlength.
   *
   * @returns Max length.
   */
  get maxLength() {
    const maxLength = this.getAttribute("maxlength");
    if (maxLength !== null) {
      return parseInt(maxLength);
    }
    return -1;
  }
  /**
   * Sets maxlength.
   *
   * @param maxlength Max length.
   */
  set maxLength(maxLength) {
    this.setAttribute("maxlength", String(maxLength));
  }
  /**
   * Returns type.
   *
   * @returns Type. Defaults to "text".
   */
  get type() {
    return this.getAttribute("type") || "text";
  }
  /**
   * Sets type.
   *
   * @param type Type.
   */
  set type(type) {
    this.setAttribute("type", type.toLowerCase());
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this.getAttribute("name") || "";
  }
  /**
   * Sets name.
   *
   * @param name Name.
   */
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * Returns alt.
   *
   * @returns Alt.
   */
  get alt() {
    return this.getAttribute("alt") || "";
  }
  /**
   * Sets alt.
   *
   * @param alt Alt.
   */
  set alt(alt) {
    this.setAttribute("alt", alt);
  }
  /**
   * Returns min.
   *
   * @returns Min.
   */
  get min() {
    return this.getAttribute("min") || "";
  }
  /**
   * Sets min.
   *
   * @param min Min.
   */
  set min(min2) {
    this.setAttribute("min", min2);
  }
  /**
   * Returns max.
   *
   * @returns Max.
   */
  get max() {
    return this.getAttribute("max") || "";
  }
  /**
   * Sets max.
   *
   * @param max Max.
   */
  set max(max2) {
    this.setAttribute("max", max2);
  }
  /**
   * Returns pattern.
   *
   * @returns Pattern.
   */
  get pattern() {
    return this.getAttribute("pattern") || "";
  }
  /**
   * Sets pattern.
   *
   * @param pattern Pattern.
   */
  set pattern(pattern) {
    this.setAttribute("pattern", pattern);
  }
  /**
   * Returns placeholder.
   *
   * @returns Placeholder.
   */
  get placeholder() {
    return this.getAttribute("placeholder") || "";
  }
  /**
   * Sets placeholder.
   *
   * @param placeholder Placeholder.
   */
  set placeholder(placeholder) {
    this.setAttribute("placeholder", placeholder);
  }
  /**
   * Returns step.
   *
   * @returns Step.
   */
  get step() {
    return this.getAttribute("step") || "";
  }
  /**
   * Sets step.
   *
   * @param step Step.
   */
  set step(step) {
    this.setAttribute("step", step);
  }
  /**
   * Returns inputmode.
   *
   * @returns Inputmode.
   */
  get inputmode() {
    return this.getAttribute("inputmode") || "";
  }
  /**
   * Sets inputmode.
   *
   * @param inputmode Inputmode.
   */
  set inputmode(inputmode) {
    this.setAttribute("inputmode", inputmode);
  }
  /**
   * Returns accept.
   *
   * @returns Accept.
   */
  get accept() {
    return this.getAttribute("accept") || "";
  }
  /**
   * Sets accept.
   *
   * @param accept Accept.
   */
  set accept(accept) {
    this.setAttribute("accept", accept);
  }
  /**
   * Returns allowdirs.
   *
   * @returns Allowdirs.
   */
  get allowdirs() {
    return this.getAttribute("allowdirs") || "";
  }
  /**
   * Sets allowdirs.
   *
   * @param allowdirs Allowdirs.
   */
  set allowdirs(allowdirs) {
    this.setAttribute("allowdirs", allowdirs);
  }
  /**
   * Returns autocomplete.
   *
   * @returns Autocomplete.
   */
  get autocomplete() {
    return this.getAttribute("autocomplete") || "";
  }
  /**
   * Sets autocomplete.
   *
   * @param autocomplete Autocomplete.
   */
  set autocomplete(autocomplete) {
    this.setAttribute("autocomplete", autocomplete);
  }
  /**
   * Returns src.
   *
   * @returns Src.
   */
  get src() {
    return this.getAttribute("src") || "";
  }
  /**
   * Sets src.
   *
   * @param src Src.
   */
  set src(src) {
    this.setAttribute("src", src);
  }
  /**
   * Returns defaultValue.
   *
   * @returns Defaultvalue.
   */
  get defaultValue() {
    return this.getAttribute("value") || "";
  }
  /**
   * Sets defaultValue.
   *
   * @param defaultValue Defaultvalue.
   */
  set defaultValue(defaultValue) {
    this.setAttribute("value", defaultValue);
  }
  /**
   * Returns read only.
   *
   * @returns Read only.
   */
  get readOnly() {
    return this.getAttribute("readonly") !== null;
  }
  /**
   * Sets read only.
   *
   * @param readOnly Read only.
   */
  set readOnly(readOnly) {
    if (!readOnly) {
      this.removeAttribute("readonly");
    } else {
      this.setAttribute("readonly", "");
    }
  }
  /**
   * Returns disabled.
   *
   * @returns Disabled.
   */
  get disabled() {
    return this.getAttribute("disabled") !== null;
  }
  /**
   * Sets disabled.
   *
   * @param disabled Disabled.
   */
  set disabled(disabled) {
    if (!disabled) {
      this.removeAttribute("disabled");
    } else {
      this.setAttribute("disabled", "");
    }
  }
  /**
   * Returns autofocus.
   *
   * @returns Autofocus.
   */
  get autofocus() {
    return this.getAttribute("autofocus") !== null;
  }
  /**
   * Sets autofocus.
   *
   * @param autofocus Autofocus.
   */
  set autofocus(autofocus) {
    if (!autofocus) {
      this.removeAttribute("autofocus");
    } else {
      this.setAttribute("autofocus", "");
    }
  }
  /**
   * Returns required.
   *
   * @returns Required.
   */
  get required() {
    return this.getAttribute("required") !== null;
  }
  /**
   * Sets required.
   *
   * @param required Required.
   */
  set required(required) {
    if (!required) {
      this.removeAttribute("required");
    } else {
      this.setAttribute("required", "");
    }
  }
  /**
   * Returns indeterminate.
   *
   * @returns Indeterminate.
   */
  get indeterminate() {
    return this.getAttribute("indeterminate") !== null;
  }
  /**
   * Sets indeterminate.
   *
   * @param indeterminate Indeterminate.
   */
  set indeterminate(indeterminate) {
    if (!indeterminate) {
      this.removeAttribute("indeterminate");
    } else {
      this.setAttribute("indeterminate", "");
    }
  }
  /**
   * Returns multiple.
   *
   * @returns Multiple.
   */
  get multiple() {
    return this.getAttribute("multiple") !== null;
  }
  /**
   * Sets multiple.
   *
   * @param multiple Multiple.
   */
  set multiple(multiple) {
    if (!multiple) {
      this.removeAttribute("multiple");
    } else {
      this.setAttribute("multiple", "");
    }
  }
  /**
   * Returns checked.
   *
   * @returns Checked.
   */
  get checked() {
    if (this[checked] !== null) {
      return this[checked];
    }
    return this.getAttribute("checked") !== null;
  }
  /**
   * Sets checked.
   *
   * @param checked Checked.
   */
  set checked(checked2) {
    __classPrivateFieldGet$x(this, _HTMLInputElement_instances, "m", _HTMLInputElement_setChecked).call(this, checked2);
  }
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    switch (this.type) {
      case "hidden":
      case "submit":
      case "image":
      case "reset":
      case "button":
        return this.getAttribute("value") || "";
      case "checkbox":
      case "radio":
        const attritube = this.getAttribute("value");
        return attritube !== null ? attritube : "on";
      case "file":
        return this[files].length > 0 ? "/fake/path/" + this[files][0].name : "";
    }
    if (this[value] === null) {
      return this.getAttribute("value") || "";
    }
    return this[value];
  }
  /**
   * Sets value.
   *
   * @param value Value.
   */
  set value(value$1) {
    value$1 = String(value$1);
    switch (this.type) {
      case "hidden":
      case "submit":
      case "image":
      case "reset":
      case "button":
      case "checkbox":
      case "radio":
        this.setAttribute("value", value$1);
        break;
      case "file":
        if (value$1 !== "") {
          throw new DOMException('Input elements of type "file" may only programmatically set the value to empty string.', DOMExceptionNameEnum$1.invalidStateError);
        }
        break;
      default:
        const oldValue = this.value;
        this[value] = HTMLInputElementValueSanitizer.sanitize(this, value$1);
        if (oldValue !== this[value]) {
          __classPrivateFieldSet$u(this, _HTMLInputElement_selectionStart, this[value].length, "f");
          __classPrivateFieldSet$u(this, _HTMLInputElement_selectionEnd, this[value].length, "f");
          __classPrivateFieldSet$u(this, _HTMLInputElement_selectionDirection, HTMLInputElementSelectionDirectionEnum$1.none, "f");
        }
        break;
    }
  }
  /**
   * Returns selection start.
   *
   * @returns Selection start.
   */
  get selectionStart() {
    if (!__classPrivateFieldGet$x(this, _HTMLInputElement_instances, "m", _HTMLInputElement_isSelectionSupported).call(this)) {
      return null;
    }
    if (__classPrivateFieldGet$x(this, _HTMLInputElement_selectionStart, "f") === null) {
      return this.value.length;
    }
    return __classPrivateFieldGet$x(this, _HTMLInputElement_selectionStart, "f");
  }
  /**
   * Sets selection start.
   *
   * @param start Start.
   */
  set selectionStart(start2) {
    if (!__classPrivateFieldGet$x(this, _HTMLInputElement_instances, "m", _HTMLInputElement_isSelectionSupported).call(this)) {
      throw new DOMException(`The input element's type (${this.type}) does not support selection.`, DOMExceptionNameEnum$1.invalidStateError);
    }
    this.setSelectionRange(start2, Math.max(start2, this.selectionEnd), __classPrivateFieldGet$x(this, _HTMLInputElement_selectionDirection, "f"));
  }
  /**
   * Returns selection end.
   *
   * @returns Selection end.
   */
  get selectionEnd() {
    if (!__classPrivateFieldGet$x(this, _HTMLInputElement_instances, "m", _HTMLInputElement_isSelectionSupported).call(this)) {
      return null;
    }
    if (__classPrivateFieldGet$x(this, _HTMLInputElement_selectionEnd, "f") === null) {
      return this.value.length;
    }
    return __classPrivateFieldGet$x(this, _HTMLInputElement_selectionEnd, "f");
  }
  /**
   * Sets selection end.
   *
   * @param end End.
   */
  set selectionEnd(end2) {
    if (!__classPrivateFieldGet$x(this, _HTMLInputElement_instances, "m", _HTMLInputElement_isSelectionSupported).call(this)) {
      throw new DOMException(`The input element's type (${this.type}) does not support selection.`, DOMExceptionNameEnum$1.invalidStateError);
    }
    this.setSelectionRange(this.selectionStart, end2, __classPrivateFieldGet$x(this, _HTMLInputElement_selectionDirection, "f"));
  }
  /**
   * Returns selection direction.
   *
   * @returns Selection direction.
   */
  get selectionDirection() {
    if (!__classPrivateFieldGet$x(this, _HTMLInputElement_instances, "m", _HTMLInputElement_isSelectionSupported).call(this)) {
      return null;
    }
    return __classPrivateFieldGet$x(this, _HTMLInputElement_selectionDirection, "f");
  }
  /**
   * Sets selection direction.
   *
   * @param direction Direction.
   */
  set selectionDirection(direction) {
    if (!__classPrivateFieldGet$x(this, _HTMLInputElement_instances, "m", _HTMLInputElement_isSelectionSupported).call(this)) {
      throw new DOMException(`The input element's type (${this.type}) does not support selection.`, DOMExceptionNameEnum$1.invalidStateError);
    }
    this.setSelectionRange(__classPrivateFieldGet$x(this, _HTMLInputElement_selectionStart, "f"), __classPrivateFieldGet$x(this, _HTMLInputElement_selectionEnd, "f"), direction);
  }
  /**
   * Returns "true" if it will validate.
   *
   * @returns "true" if it will validate.
   */
  get willValidate() {
    return this.type !== "hidden" && this.type !== "reset" && this.type !== "button" && !this.disabled && !this["readOnly"];
  }
  /**
   * Returns value as Date.
   *
   * @returns Date.
   */
  get valueAsDate() {
    switch (this.type) {
      case "date":
      case "month":
        return isNaN(new Date(String(this.value)).getTime()) ? null : new Date(this.value);
      case "week": {
        const d = HTMLInputElementDateUtility.isoWeekDate(this.value);
        return isNaN(d.getTime()) ? null : d;
      }
      case "time": {
        const d = /* @__PURE__ */ new Date(`1970-01-01T${this.value}Z`);
        return isNaN(d.getTime()) ? null : d;
      }
      default:
        return null;
    }
  }
  /**
   * Sets value from a Date.
   *
   * @param value Date.
   */
  set valueAsDate(value2) {
    if (!["date", "month", "time", "week"].includes(this.type)) {
      throw new DOMException("Failed to set the 'valueAsDate' property on 'HTMLInputElement': This input element does not support Date values.", DOMExceptionNameEnum$1.invalidStateError);
    }
    if (typeof value2 !== "object") {
      throw new TypeError("Failed to set the 'valueAsDate' property on 'HTMLInputElement': Failed to convert value to 'object'.");
    } else if (value2 && !(value2 instanceof Date)) {
      throw new TypeError("Failed to set the 'valueAsDate' property on 'HTMLInputElement': The provided value is not a Date.");
    } else if (value2 === null || isNaN(value2.getTime())) {
      this.value = "";
      return;
    }
    switch (this.type) {
      case "date":
        this.value = value2.toISOString().split("T")[0];
        break;
      case "month":
        this.value = value2.toISOString().split("T")[0].slice(0, -3);
        break;
      case "time":
        this.value = value2.toISOString().split("T")[1].slice(0, 5);
        break;
      case "week":
        this.value = HTMLInputElementDateUtility.dateIsoWeek(value2);
        break;
    }
  }
  /**
   * Returns value as number.
   *
   * @returns Number.
   */
  get valueAsNumber() {
    const value2 = this.value;
    if (!this.type.match(/^(range|number|date|datetime-local|month|time|week)$/) || !value2) {
      return NaN;
    }
    switch (this.type) {
      case "number":
        return parseFloat(value2);
      case "range": {
        const number = parseFloat(value2);
        const min2 = parseFloat(this.min) || 0;
        const max2 = parseFloat(this.max) || 100;
        if (isNaN(number)) {
          return max2 < min2 ? min2 : (min2 + max2) / 2;
        } else if (number < min2) {
          return min2;
        } else if (number > max2) {
          return max2;
        }
        return number;
      }
      case "date":
        return new Date(value2).getTime();
      case "datetime-local":
        return new Date(value2).getTime() - new Date(value2).getTimezoneOffset() * 6e4;
      case "month":
        return (new Date(value2).getUTCFullYear() - 1970) * 12 + new Date(value2).getUTCMonth();
      case "time":
        return (/* @__PURE__ */ new Date("1970-01-01T" + value2)).getTime() - (/* @__PURE__ */ new Date("1970-01-01T00:00:00")).getTime();
      case "week": {
        const match2 = value2.match(/^(\d{4})-W(\d{2})$/);
        if (!match2) {
          return NaN;
        }
        const d = new Date(Date.UTC(parseInt(match2[1], 10), 0));
        const day = d.getUTCDay();
        const diff2 = ((day === 0 ? -6 : 1) - day) * 864e5 + parseInt(match2[2], 10) * 6048e5;
        return d.getTime() + diff2;
      }
    }
  }
  /**
   * Sets value from a number.
   *
   * @param value number.
   */
  set valueAsNumber(value2) {
    switch (this.type) {
      case "number":
      case "range":
        this.value = Number(value2).toString();
        break;
      case "date":
      case "datetime-local": {
        const d = new Date(Number(value2));
        if (isNaN(d.getTime())) {
          this.value = "";
          break;
        }
        if (this.type == "date") {
          this.value = d.toISOString().slice(0, 10);
        } else {
          this.value = d.toISOString().slice(0, -1);
        }
        break;
      }
      case "month":
        if (!Number.isInteger(value2) || value2 < 0) {
          this.value = "";
        } else {
          this.value = new Date(Date.UTC(1970, Number(value2))).toISOString().slice(0, 7);
        }
        break;
      case "time":
        if (!Number.isInteger(value2) || value2 < 0) {
          this.value = "";
        } else {
          this.value = new Date(Number(value2)).toISOString().slice(11, -1);
        }
        break;
      case "week": {
        const d = new Date(Number(value2));
        this.value = isNaN(d.getTime()) ? "" : HTMLInputElementDateUtility.dateIsoWeek(d);
        break;
      }
      default:
        throw new DOMException("Failed to set the 'valueAsNumber' property on 'HTMLInputElement': This input element does not support Number values.", DOMExceptionNameEnum$1.invalidStateError);
    }
  }
  /**
   * Returns the associated label elements.
   *
   * @returns Label elements.
   */
  get labels() {
    return HTMLLabelElementUtility.getAssociatedLabelElements(this);
  }
  /**
   * Sets validation message.
   *
   * @param message Message.
   */
  setCustomValidity(message) {
    this[validationMessage] = String(message);
  }
  /**
   * Selects the text.
   */
  select() {
    if (!__classPrivateFieldGet$x(this, _HTMLInputElement_instances, "m", _HTMLInputElement_isSelectionSupported).call(this)) {
      return null;
    }
    __classPrivateFieldSet$u(this, _HTMLInputElement_selectionStart, 0, "f");
    __classPrivateFieldSet$u(this, _HTMLInputElement_selectionEnd, this.value.length, "f");
    __classPrivateFieldSet$u(this, _HTMLInputElement_selectionDirection, HTMLInputElementSelectionDirectionEnum$1.none, "f");
    this.dispatchEvent(new Event("select", { bubbles: true, cancelable: true }));
  }
  /**
   * Set selection range.
   *
   * @param start Start.
   * @param end End.
   * @param [direction="none"] Direction.
   */
  setSelectionRange(start2, end2, direction = "none") {
    if (!__classPrivateFieldGet$x(this, _HTMLInputElement_instances, "m", _HTMLInputElement_isSelectionSupported).call(this)) {
      throw new DOMException(`The input element's type (${this.type}) does not support selection.`, DOMExceptionNameEnum$1.invalidStateError);
    }
    __classPrivateFieldSet$u(this, _HTMLInputElement_selectionEnd, Math.min(end2, this.value.length), "f");
    __classPrivateFieldSet$u(this, _HTMLInputElement_selectionStart, Math.min(start2, __classPrivateFieldGet$x(this, _HTMLInputElement_selectionEnd, "f")), "f");
    __classPrivateFieldSet$u(this, _HTMLInputElement_selectionDirection, direction === HTMLInputElementSelectionDirectionEnum$1.forward || direction === HTMLInputElementSelectionDirectionEnum$1.backward ? direction : HTMLInputElementSelectionDirectionEnum$1.none, "f");
    this.dispatchEvent(new Event("select", { bubbles: true, cancelable: true }));
  }
  /**
   * Set range text.
   *
   * @param replacement Replacement.
   * @param [start] Start.
   * @param [end] End.
   * @param [direction] Direction.
   * @param selectionMode
   */
  setRangeText(replacement, start2 = null, end2 = null, selectionMode = HTMLInputElementSelectionModeEnum$1.preserve) {
    if (!__classPrivateFieldGet$x(this, _HTMLInputElement_instances, "m", _HTMLInputElement_isSelectionSupported).call(this)) {
      throw new DOMException(`The input element's type (${this.type}) does not support selection.`, DOMExceptionNameEnum$1.invalidStateError);
    }
    if (start2 === null) {
      start2 = __classPrivateFieldGet$x(this, _HTMLInputElement_selectionStart, "f");
    }
    if (end2 === null) {
      end2 = __classPrivateFieldGet$x(this, _HTMLInputElement_selectionEnd, "f");
    }
    if (start2 > end2) {
      throw new DOMException("The index is not in the allowed range.", DOMExceptionNameEnum$1.invalidStateError);
    }
    start2 = Math.min(start2, this.value.length);
    end2 = Math.min(end2, this.value.length);
    const val = this.value;
    let selectionStart = __classPrivateFieldGet$x(this, _HTMLInputElement_selectionStart, "f");
    let selectionEnd = __classPrivateFieldGet$x(this, _HTMLInputElement_selectionEnd, "f");
    this.value = val.slice(0, start2) + replacement + val.slice(end2);
    const newEnd = start2 + this.value.length;
    switch (selectionMode) {
      case HTMLInputElementSelectionModeEnum$1.select:
        this.setSelectionRange(start2, newEnd);
        break;
      case HTMLInputElementSelectionModeEnum$1.start:
        this.setSelectionRange(start2, start2);
        break;
      case HTMLInputElementSelectionModeEnum$1.end:
        this.setSelectionRange(newEnd, newEnd);
        break;
      default:
        const delta = replacement.length - (end2 - start2);
        if (selectionStart > end2) {
          selectionStart += delta;
        } else if (selectionStart > start2) {
          selectionStart = start2;
        }
        if (selectionEnd > end2) {
          selectionEnd += delta;
        } else if (selectionEnd > start2) {
          selectionEnd = newEnd;
        }
        this.setSelectionRange(selectionStart, selectionEnd);
        break;
    }
  }
  /**
   * Checks validity.
   *
   * @returns "true" if the field is valid.
   */
  checkValidity() {
    const valid = this.disabled || this.readOnly || this.type === "hidden" || this.type === "reset" || this.type === "button" || this[validity].valid;
    if (!valid) {
      this.dispatchEvent(new Event("invalid", { bubbles: true, cancelable: true }));
    }
    return valid;
  }
  /**
   * Reports validity.
   *
   * @returns "true" if the field is valid.
   */
  reportValidity() {
    return this.checkValidity();
  }
  /**
   * Steps up.
   *
   * @param [increment] Increment.
   */
  stepUp(increment2) {
    const newValue = HTMLInputElementValueStepping.step(this.type, this.value, 1, increment2);
    if (newValue !== null) {
      this.value = newValue;
    }
  }
  /**
   * Steps down.
   *
   * @param [increment] Increment.
   */
  stepDown(increment2) {
    const newValue = HTMLInputElementValueStepping.step(this.type, this.value, -1, increment2);
    if (newValue !== null) {
      this.value = newValue;
    }
  }
  /**
   * @override
   */
  [(_HTMLInputElement_selectionStart = /* @__PURE__ */ new WeakMap(), _HTMLInputElement_selectionEnd = /* @__PURE__ */ new WeakMap(), _HTMLInputElement_selectionDirection = /* @__PURE__ */ new WeakMap(), _HTMLInputElement_instances = /* @__PURE__ */ new WeakSet(), _a$o = attributes, _b$c = value, _c$8 = height, _d$5 = width, _e$5 = defaultChecked, _f$4 = checked, _g$2 = validationMessage, _h$1 = validity, _j$1 = files, cloneNode)](deep = false) {
    const clone2 = super[cloneNode](deep);
    clone2.formAction = this.formAction;
    clone2.formMethod = this.formMethod;
    clone2[value] = this[value];
    clone2[height] = this[height];
    clone2[width] = this[width];
    clone2[defaultChecked] = this[defaultChecked];
    clone2[files] = this[files].slice();
    __classPrivateFieldSet$u(clone2, _HTMLInputElement_selectionStart, __classPrivateFieldGet$x(this, _HTMLInputElement_selectionStart, "f"), "f");
    __classPrivateFieldSet$u(clone2, _HTMLInputElement_selectionEnd, __classPrivateFieldGet$x(this, _HTMLInputElement_selectionEnd, "f"), "f");
    __classPrivateFieldSet$u(clone2, _HTMLInputElement_selectionDirection, __classPrivateFieldGet$x(this, _HTMLInputElement_selectionDirection, "f"), "f");
    return clone2;
  }
  /**
   * @override
   */
  dispatchEvent(event) {
    if (event.type === "click" && event instanceof MouseEvent && event.eventPhase === EventPhaseEnum$1.none && this.disabled) {
      return false;
    }
    let previousCheckedValue = null;
    if ((event.eventPhase === EventPhaseEnum$1.atTarget || event.eventPhase === EventPhaseEnum$1.bubbling) && event.type === "click" && event instanceof MouseEvent) {
      const inputType = this.type;
      if (inputType === "checkbox" || inputType === "radio") {
        previousCheckedValue = this.checked;
        __classPrivateFieldGet$x(this, _HTMLInputElement_instances, "m", _HTMLInputElement_setChecked).call(this, inputType === "checkbox" ? !previousCheckedValue : true);
      }
    }
    const returnValue2 = super.dispatchEvent(event);
    if (!event.defaultPrevented && (event.eventPhase === EventPhaseEnum$1.atTarget || event.eventPhase === EventPhaseEnum$1.bubbling) && event.type === "click" && event instanceof MouseEvent && this[isConnected]) {
      const inputType = this.type;
      if (!this.readOnly || inputType === "checkbox" || inputType === "radio") {
        if (inputType === "checkbox" || inputType === "radio") {
          this.dispatchEvent(new Event("input", { bubbles: true, cancelable: true }));
          this.dispatchEvent(new Event("change", { bubbles: true, cancelable: true }));
        } else if (inputType === "submit") {
          const form = this.form;
          if (form) {
            form.requestSubmit(this);
          }
        } else if (inputType === "reset" && this[isConnected]) {
          const form = this.form;
          if (form) {
            form.reset();
          }
        }
      }
    }
    if (event.defaultPrevented && (event.eventPhase === EventPhaseEnum$1.atTarget || event.eventPhase === EventPhaseEnum$1.bubbling) && event.type === "click" && event instanceof MouseEvent && previousCheckedValue !== null) {
      const inputType = this.type;
      if (inputType === "checkbox" || inputType === "radio") {
        __classPrivateFieldGet$x(this, _HTMLInputElement_instances, "m", _HTMLInputElement_setChecked).call(this, previousCheckedValue);
      }
    }
    return returnValue2;
  }
  /**
   * @override
   */
  [connectToNode](parentNode2 = null) {
    const oldFormNode = this[formNode];
    super[connectToNode](parentNode2);
    if (oldFormNode !== this[formNode]) {
      if (oldFormNode) {
        oldFormNode[removeFormControlItem](this, this.name);
        oldFormNode[removeFormControlItem](this, this.id);
      }
      if (this[formNode]) {
        this[formNode][appendFormControlItem](this, this.name);
        this[formNode][appendFormControlItem](this, this.id);
      }
    }
  }
}
_HTMLInputElement_isSelectionSupported = function _HTMLInputElement_isSelectionSupported2() {
  const inputType = this.type;
  return inputType === "text" || inputType === "search" || inputType === "url" || inputType === "tel" || inputType === "password";
}, _HTMLInputElement_setChecked = function _HTMLInputElement_setChecked2(checked$1) {
  this[checked] = checked$1;
  if (checked$1 && this.type === "radio" && this.name) {
    const root = this[formNode] || this.getRootNode();
    const radioButtons = root.querySelectorAll(`input[type="radio"][name="${this.name}"]`);
    for (const radioButton of radioButtons) {
      if (radioButton !== this) {
        radioButton[checked] = false;
      }
    }
  }
};
var __classPrivateFieldSet$t = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$w = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HTMLOptionsCollection_selectElement;
class HTMLOptionsCollection extends HTMLCollection {
  /**
   *
   * @param selectElement
   */
  constructor(selectElement) {
    super();
    _HTMLOptionsCollection_selectElement.set(this, void 0);
    __classPrivateFieldSet$t(this, _HTMLOptionsCollection_selectElement, selectElement, "f");
  }
  /**
   * Returns selectedIndex.
   *
   * @returns SelectedIndex.
   */
  get selectedIndex() {
    return __classPrivateFieldGet$w(this, _HTMLOptionsCollection_selectElement, "f").selectedIndex;
  }
  /**
   * Sets selectedIndex.
   *
   * @param selectedIndex SelectedIndex.
   */
  set selectedIndex(selectedIndex) {
    __classPrivateFieldGet$w(this, _HTMLOptionsCollection_selectElement, "f").selectedIndex = selectedIndex;
  }
  /**
   * Returns item by index.
   *
   * @param index Index.
   */
  item(index) {
    return this[index];
  }
  /**
   *
   * @param element
   * @param before
   */
  add(element, before) {
    if (!before && before !== 0) {
      __classPrivateFieldGet$w(this, _HTMLOptionsCollection_selectElement, "f").appendChild(element);
      return;
    }
    if (!Number.isNaN(Number(before))) {
      if (before < 0) {
        return;
      }
      __classPrivateFieldGet$w(this, _HTMLOptionsCollection_selectElement, "f").insertBefore(element, this[before]);
      return;
    }
    const index = this.indexOf(before);
    if (index === -1) {
      throw new DOMException("Failed to execute 'add' on 'DOMException': The node before which the new node is to be inserted is not a child of this node.");
    }
    __classPrivateFieldGet$w(this, _HTMLOptionsCollection_selectElement, "f").insertBefore(element, this[index]);
  }
  /**
   * Removes indexed element from collection.
   *
   * @param index Index.
   */
  remove(index) {
    if (this[index]) {
      __classPrivateFieldGet$w(this, _HTMLOptionsCollection_selectElement, "f").removeChild(this[index]);
    }
  }
}
_HTMLOptionsCollection_selectElement = /* @__PURE__ */ new WeakMap();
class HTMLSelectElementNamedNodeMap extends HTMLElementNamedNodeMap {
  /**
   * @override
   */
  setNamedItem(item2) {
    const replacedItem = super.setNamedItem(item2);
    if ((item2[name] === "id" || item2[name] === "name") && this[ownerElement][formNode]) {
      if (replacedItem && replacedItem[value]) {
        this[ownerElement][formNode][removeFormControlItem](this[ownerElement], replacedItem[value]);
      }
      if (item2[value]) {
        this[ownerElement][formNode][appendFormControlItem](this[ownerElement], item2[value]);
      }
    }
    return replacedItem || null;
  }
  /**
   * @override
   */
  [removeNamedItem](name$1) {
    const removedItem = super[removeNamedItem](name$1);
    if (removedItem && (removedItem[name] === "id" || removedItem[name] === "name") && this[ownerElement][formNode]) {
      this[ownerElement][formNode][removeFormControlItem](this[ownerElement], removedItem[value]);
    }
    return removedItem;
  }
}
var __classPrivateFieldGet$v = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HTMLSelectElement_instances, _HTMLSelectElement_getDisplaySize, _a$n, _b$b, _c$7, _d$4, _e$4, _f$3;
class HTMLSelectElement extends HTMLElement$1 {
  constructor() {
    super(...arguments);
    _HTMLSelectElement_instances.add(this);
    this[_a$n] = new HTMLSelectElementNamedNodeMap(this);
    this[_b$b] = "";
    this[_c$7] = new ValidityState(this);
    this[_d$4] = this;
    this[_e$4] = 0;
    this[_f$3] = new HTMLOptionsCollection(this);
    this.onchange = null;
    this.oninput = null;
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get length() {
    return this[length$1];
  }
  /**
   * Returns options.
   *
   * @returns Options.
   */
  get options() {
    return this[options];
  }
  /**
   * Returns validation message.
   *
   * @returns Validation message.
   */
  get validationMessage() {
    return this[validationMessage];
  }
  /**
   * Returns validity.
   *
   * @returns Validity.
   */
  get validity() {
    return this[validity];
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this.getAttribute("name") || "";
  }
  /**
   * Sets name.
   *
   * @param name Name.
   */
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * Returns disabled.
   *
   * @returns Disabled.
   */
  get disabled() {
    return this.getAttribute("disabled") !== null;
  }
  /**
   * Sets disabled.
   *
   * @param disabled Disabled.
   */
  set disabled(disabled) {
    if (!disabled) {
      this.removeAttribute("disabled");
    } else {
      this.setAttribute("disabled", "");
    }
  }
  /**
   * Returns multiple.
   *
   * @returns Multiple.
   */
  get multiple() {
    return this.getAttribute("multiple") !== null;
  }
  /**
   * Sets multiple.
   *
   * @param multiple Multiple.
   */
  set multiple(multiple) {
    if (!multiple) {
      this.removeAttribute("multiple");
    } else {
      this.setAttribute("multiple", "");
    }
  }
  /**
   * Returns autofocus.
   *
   * @returns Autofocus.
   */
  get autofocus() {
    return this.getAttribute("autofocus") !== null;
  }
  /**
   * Sets autofocus.
   *
   * @param autofocus Autofocus.
   */
  set autofocus(autofocus) {
    if (!autofocus) {
      this.removeAttribute("autofocus");
    } else {
      this.setAttribute("autofocus", "");
    }
  }
  /**
   * Returns required.
   *
   * @returns Required.
   */
  get required() {
    return this.getAttribute("required") !== null;
  }
  /**
   * Sets required.
   *
   * @param required Required.
   */
  set required(required) {
    if (!required) {
      this.removeAttribute("required");
    } else {
      this.setAttribute("required", "");
    }
  }
  /**
   * Returns type.
   *
   * @returns type.
   */
  get type() {
    return this.hasAttributeNS(null, "multiple") ? "select-multiple" : "select-one";
  }
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    for (let i = 0, max2 = this[options].length; i < max2; i++) {
      const option = this[options][i];
      if (option[selectedness]) {
        return option.value;
      }
    }
    return "";
  }
  /**
   * Sets value.
   *
   * @param value Value.
   */
  set value(value2) {
    for (let i = 0, max2 = this[options].length; i < max2; i++) {
      const option = this[options][i];
      if (option.value === value2) {
        option[selectedness] = true;
        option[dirtyness] = true;
      } else {
        option[selectedness] = false;
      }
    }
  }
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get selectedIndex() {
    for (let i = 0, max2 = this[options].length; i < max2; i++) {
      if (this[options][i][selectedness]) {
        return i;
      }
    }
    return -1;
  }
  /**
   * Sets value.
   *
   * @param selectedIndex Selected index.
   */
  set selectedIndex(selectedIndex) {
    if (typeof selectedIndex === "number" && !isNaN(selectedIndex)) {
      for (let i = 0, max2 = this[options].length; i < max2; i++) {
        this[options][i][selectedness] = false;
      }
      const selectedOption = this[options][selectedIndex];
      if (selectedOption) {
        selectedOption[selectedness] = true;
        selectedOption[dirtyness] = true;
      }
    }
  }
  /**
   * Returns selected options.
   *
   * @returns HTMLCollection.
   */
  get selectedOptions() {
    const selectedOptions = new HTMLCollection();
    for (let i = 0, max2 = this[options].length; i < max2; i++) {
      if (this[options][i][selectedness]) {
        selectedOptions.push(this[options][i]);
      }
    }
    return selectedOptions;
  }
  /**
   * Returns the associated label elements.
   *
   * @returns Label elements.
   */
  get labels() {
    return HTMLLabelElementUtility.getAssociatedLabelElements(this);
  }
  /**
   * Returns the parent form element.
   *
   * @returns Form.
   */
  get form() {
    return this[formNode];
  }
  /**
   * Returns "true" if it will validate.
   *
   * @returns "true" if it will validate.
   */
  get willValidate() {
    return this.type !== "hidden" && this.type !== "reset" && this.type !== "button" && !this.disabled && !this["readOnly"];
  }
  /**
   * Returns item from options collection by index.
   *
   * @param index Index.
   */
  item(index) {
    return this[options].item(index);
  }
  /**
   * Adds new option to options collection.
   *
   * @param element HTMLOptionElement to add.
   * @param before HTMLOptionElement or index number.
   */
  add(element, before) {
    this[options].add(element, before);
  }
  /**
   * Removes indexed element from collection or the select element.
   *
   * @param [index] Index.
   */
  remove(index) {
    if (typeof index === "number") {
      this[options].remove(index);
    } else {
      super.remove();
    }
  }
  /**
   * Sets validation message.
   *
   * @param message Message.
   */
  setCustomValidity(message) {
    this[validationMessage] = String(message);
  }
  /**
   * Checks validity.
   *
   * @returns "true" if the field is valid.
   */
  checkValidity() {
    const valid = this.disabled || this[validity].valid;
    if (!valid) {
      this.dispatchEvent(new Event("invalid", { bubbles: true, cancelable: true }));
    }
    return valid;
  }
  /**
   * Reports validity.
   *
   * @returns "true" if the field is valid.
   */
  reportValidity() {
    return this.checkValidity();
  }
  /**
   * Updates option item.
   *
   * Based on:
   * https://github.com/jsdom/jsdom/blob/master/lib/jsdom/living/nodes/HTMLSelectElement-impl.js
   *
   * @see https://html.spec.whatwg.org/multipage/form-elements.html#selectedness-setting-algorithm
   * @param [selectedOption] Selected option.
   */
  [(_HTMLSelectElement_instances = /* @__PURE__ */ new WeakSet(), _a$n = attributes, _b$b = validationMessage, _c$7 = validity, _d$4 = selectNode, _e$4 = length$1, _f$3 = options, updateOptionItems)](selectedOption) {
    const optionElements = this.getElementsByTagName("option");
    if (optionElements.length < this[options].length) {
      this[options].splice(this[options].length - 1, this[options].length - optionElements.length);
      for (let i = optionElements.length - 1, max2 = this[length$1]; i < max2; i++) {
        delete this[i];
      }
    }
    const isMultiple = this.hasAttributeNS(null, "multiple");
    const selected = [];
    for (let i = 0; i < optionElements.length; i++) {
      this[options][i] = optionElements[i];
      this[i] = optionElements[i];
      if (!isMultiple) {
        if (selectedOption) {
          optionElements[i][selectedness] = optionElements[i] === selectedOption;
        }
        if (optionElements[i][selectedness]) {
          selected.push(optionElements[i]);
        }
      }
    }
    this[length$1] = optionElements.length;
    const size = __classPrivateFieldGet$v(this, _HTMLSelectElement_instances, "m", _HTMLSelectElement_getDisplaySize).call(this);
    if (size === 1 && !selected.length) {
      for (let i = 0, max2 = optionElements.length; i < max2; i++) {
        const option = optionElements[i];
        let disabled = option.hasAttributeNS(null, "disabled");
        const parentNode$1 = option[parentNode];
        if (parentNode$1 && parentNode$1[nodeType] === NodeTypeEnum$1.elementNode && parentNode$1[tagName] === "OPTGROUP" && parentNode$1.hasAttributeNS(null, "disabled")) {
          disabled = true;
        }
        if (!disabled) {
          option[selectedness] = true;
          break;
        }
      }
    } else if (selected.length >= 2) {
      for (let i = 0, max2 = optionElements.length; i < max2; i++) {
        optionElements[i][selectedness] = i === selected.length - 1;
      }
    }
  }
  /**
   * @override
   */
  [connectToNode](parentNode2 = null) {
    const oldFormNode = this[formNode];
    super[connectToNode](parentNode2);
    if (oldFormNode !== this[formNode]) {
      if (oldFormNode) {
        oldFormNode[removeFormControlItem](this, this.name);
        oldFormNode[removeFormControlItem](this, this.id);
      }
      if (this[formNode]) {
        this[formNode][appendFormControlItem](this, this.name);
        this[formNode][appendFormControlItem](this, this.id);
      }
    }
  }
}
_HTMLSelectElement_getDisplaySize = function _HTMLSelectElement_getDisplaySize2() {
  if (this.hasAttributeNS(null, "size")) {
    const size = parseInt(this.getAttribute("size"));
    if (!isNaN(size) && size >= 0) {
      return size;
    }
  }
  return this.hasAttributeNS(null, "multiple") ? 4 : 1;
};
var __classPrivateFieldSet$s = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$u = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HTMLLinkElementNamedNodeMap_styleSheetLoader;
class HTMLLinkElementNamedNodeMap extends HTMLElementNamedNodeMap {
  /**
   * Constructor.
   *
   * @param ownerElement Owner element.
   * @param stylesheetLoader Stylesheet loader.
   * @param styleSheetLoader
   */
  constructor(ownerElement2, styleSheetLoader) {
    super(ownerElement2);
    _HTMLLinkElementNamedNodeMap_styleSheetLoader.set(this, void 0);
    __classPrivateFieldSet$s(this, _HTMLLinkElementNamedNodeMap_styleSheetLoader, styleSheetLoader, "f");
  }
  /**
   * @override
   */
  setNamedItem(item2) {
    const replacedItem = super.setNamedItem(item2);
    if (item2[name] === "rel" && this[ownerElement][relList]) {
      this[ownerElement][relList][updateIndices]();
    }
    if (item2[name] === "rel") {
      __classPrivateFieldGet$u(this, _HTMLLinkElementNamedNodeMap_styleSheetLoader, "f").loadStyleSheet(this[ownerElement].getAttribute("href"), item2[value]);
    } else if (item2[name] === "href") {
      __classPrivateFieldGet$u(this, _HTMLLinkElementNamedNodeMap_styleSheetLoader, "f").loadStyleSheet(item2[value], this[ownerElement].getAttribute("rel"));
    }
    return replacedItem || null;
  }
  /**
   * @override
   */
  [(_HTMLLinkElementNamedNodeMap_styleSheetLoader = /* @__PURE__ */ new WeakMap(), removeNamedItem)](name$1) {
    const removedItem = super[removeNamedItem](name$1);
    if (removedItem && removedItem[name] === "rel" && this[ownerElement][relList]) {
      this[ownerElement][relList][updateIndices]();
    }
    return removedItem;
  }
}
let NotSupported$a = class NotSupported3 {
};
class CSSRule {
  constructor() {
    this.parentRule = null;
    this.parentStyleSheet = null;
    this.type = null;
  }
  /**
   * Returns selector text.
   *
   * @returns Selector text.
   */
  get cssText() {
    return "";
  }
}
CSSRule.CONTAINER_RULE = CSSRuleTypeEnum$1.containerRule;
CSSRule.STYLE_RULE = CSSRuleTypeEnum$1.styleRule;
CSSRule.IMPORT_RULE = CSSRuleTypeEnum$1.importRule;
CSSRule.MEDIA_RULE = CSSRuleTypeEnum$1.mediaRule;
CSSRule.FONT_FACE_RULE = CSSRuleTypeEnum$1.fontFaceRule;
CSSRule.PAGE_RULE = CSSRuleTypeEnum$1.pageRule;
CSSRule.KEYFRAMES_RULE = CSSRuleTypeEnum$1.keyframesRule;
CSSRule.KEYFRAME_RULE = CSSRuleTypeEnum$1.keyframeRule;
CSSRule.NAMESPACE_RULE = CSSRuleTypeEnum$1.namespaceRule;
CSSRule.COUNTER_STYLE_RULE = CSSRuleTypeEnum$1.counterStyleRule;
CSSRule.SUPPORTS_RULE = CSSRuleTypeEnum$1.supportsRule;
CSSRule.DOCUMENT_RULE = CSSRuleTypeEnum$1.documentRule;
CSSRule.FONT_FEATURE_VALUES_RULE = CSSRuleTypeEnum$1.fontFeatureValuesRule;
CSSRule.REGION_STYLE_RULE = CSSRuleTypeEnum$1.regionStyleRule;
var __classPrivateFieldGet$t = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$r = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var _CSSStyleRule_style, _a$m;
class CSSStyleRule extends CSSRule {
  constructor() {
    super(...arguments);
    this.type = CSSRule.STYLE_RULE;
    this.selectorText = "";
    this.styleMap = /* @__PURE__ */ new Map();
    this[_a$m] = "";
    _CSSStyleRule_style.set(this, null);
  }
  /**
   * Returns style.
   *
   * @returns Style.
   */
  get style() {
    if (!__classPrivateFieldGet$t(this, _CSSStyleRule_style, "f")) {
      __classPrivateFieldSet$r(this, _CSSStyleRule_style, new CSSStyleDeclaration(), "f");
      __classPrivateFieldGet$t(this, _CSSStyleRule_style, "f").parentRule = this;
      __classPrivateFieldGet$t(this, _CSSStyleRule_style, "f").cssText = this[cssText];
    }
    return __classPrivateFieldGet$t(this, _CSSStyleRule_style, "f");
  }
  /**
   * Returns css text.
   *
   * @returns CSS text.
   */
  get cssText() {
    return `${this.selectorText} { ${this.style.cssText} }`;
  }
}
_CSSStyleRule_style = /* @__PURE__ */ new WeakMap(), _a$m = cssText;
var __classPrivateFieldGet$s = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$q = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var _CSSKeyframeRule_style, _a$l;
class CSSKeyframeRule extends CSSRule {
  constructor() {
    super(...arguments);
    this.type = CSSRule.KEYFRAME_RULE;
    this[_a$l] = "";
    _CSSKeyframeRule_style.set(this, null);
  }
  /**
   * Returns style.
   *
   * @returns Style.
   */
  get style() {
    if (!__classPrivateFieldGet$s(this, _CSSKeyframeRule_style, "f")) {
      __classPrivateFieldSet$q(this, _CSSKeyframeRule_style, new CSSStyleDeclaration(), "f");
      __classPrivateFieldGet$s(this, _CSSKeyframeRule_style, "f").parentRule = this;
      __classPrivateFieldGet$s(this, _CSSKeyframeRule_style, "f").cssText = this[cssText];
    }
    return __classPrivateFieldGet$s(this, _CSSKeyframeRule_style, "f");
  }
  /**
   * Returns css text.
   *
   * @returns CSS text.
   */
  get cssText() {
    return `${this.keyText} { ${this.style.cssText} }`;
  }
}
_CSSKeyframeRule_style = /* @__PURE__ */ new WeakMap(), _a$l = cssText;
const CSS_RULE_REGEXP = /([^{]+){([^}]+)}/;
class CSSKeyframesRule extends CSSRule {
  constructor() {
    super(...arguments);
    this.type = CSSRule.KEYFRAMES_RULE;
    this.cssRules = [];
    this.name = null;
  }
  /**
   * Returns css text.
   *
   * @returns CSS text.
   */
  get cssText() {
    let cssText2 = "";
    for (const cssRule of this.cssRules) {
      cssText2 += cssRule.cssText + " ";
    }
    return `@keyframes ${this.name} { ${cssText2}}`;
  }
  /**
   * Appends a rule.
   *
   * @param rule Rule. E.g. "0% { transform: rotate(360deg); }".
   */
  appendRule(rule) {
    const match2 = rule.match(CSS_RULE_REGEXP);
    if (match2) {
      const cssRule = new CSSKeyframeRule();
      const style2 = new CSSStyleDeclaration();
      cssRule.parentRule = this;
      cssRule.keyText = match2[1].trim();
      style2.cssText = match2[2].trim();
      style2.parentRule = this;
      cssRule.style = style2;
    }
  }
  /**
   * Removes a rule.
   *
   * @param rule Rule. E.g. "0%".
   */
  deleteRule(rule) {
    for (let i = 0, max2 = this.cssRules.length; i < max2; i++) {
      if (this.cssRules[i].keyText === rule) {
        this.cssRules.splice(i, 1);
        break;
      }
    }
  }
}
class MediaList {
  constructor() {
    this.length = 0;
  }
  /**
   * Media text.
   *
   * @returns Media text.
   */
  get mediaText() {
    const mediaText = [];
    for (let i = 0; i < this.length; i++) {
      mediaText.push(this[i]);
    }
    return mediaText.join(", ");
  }
  /**
   * Returns item.
   *
   * @param index Index.
   * @returns Item.
   */
  item(index) {
    return this[index] || "";
  }
  /**
   * Appends a medium.
   *
   * @param medium Medium.
   */
  appendMedium(medium2) {
    this[this.length] = medium2;
    this.length++;
  }
  /**
   * Deletes a medium.
   *
   * @param medium Medium.
   */
  deleteMedium(medium2) {
    let isDeleted = false;
    for (let i = 0; i < this.length; i++) {
      if (isDeleted) {
        this[i - 1] = this[i];
      }
      if (this[i] === medium2) {
        isDeleted = true;
      }
    }
    if (isDeleted) {
      this.length--;
    }
  }
}
class CSSMediaRule extends CSSRule {
  constructor() {
    super(...arguments);
    this.type = CSSRule.MEDIA_RULE;
    this.cssRules = [];
    this.media = new MediaList();
  }
  /**
   * Returns css text.
   *
   * @returns CSS text.
   */
  get cssText() {
    let cssText2 = "";
    for (const cssRule of this.cssRules) {
      cssText2 += cssRule.cssText;
    }
    return `@media ${this.conditionText} { ${cssText2} }`;
  }
  /**
   * Returns conditional text.
   *
   * @returns Conditional text.
   */
  get conditionText() {
    return this.media.mediaText;
  }
}
class CSSContainerRule extends CSSRule {
  constructor() {
    super(...arguments);
    this.type = CSSRule.CONTAINER_RULE;
    this.cssRules = [];
    this.conditionText = "";
  }
  /**
   * Returns css text.
   *
   * @returns CSS text.
   */
  get cssText() {
    let cssText2 = "";
    for (const cssRule of this.cssRules) {
      cssText2 += cssRule.cssText;
    }
    return `@container ${this.conditionText} { ${cssText2} }`;
  }
}
class CSSSupportsRule extends CSSRule {
  constructor() {
    super(...arguments);
    this.type = CSSRule.SUPPORTS_RULE;
    this.cssRules = [];
    this.conditionText = "";
  }
  /**
   * Returns css text.
   *
   * @returns CSS text.
   */
  get cssText() {
    let cssText2 = "";
    for (const cssRule of this.cssRules) {
      cssText2 += cssRule.cssText;
    }
    return `@supports ${this.conditionText} { ${cssText2} }`;
  }
}
const COMMENT_REGEXP = /\/\*[\s\S]*?\*\//gm;
class CSSParser {
  /**
   * Parses HTML and returns a root element.
   *
   * @param parentStyleSheet Parent style sheet.
   * @param cssText CSS code.
   * @returns Root element.
   */
  static parseFromString(parentStyleSheet, cssText$1) {
    const css = cssText$1.replace(COMMENT_REGEXP, "");
    const cssRules = [];
    const regExp = /{|}/gm;
    const stack = [];
    let parentRule = null;
    let lastIndex = 0;
    let match2;
    while (match2 = regExp.exec(css)) {
      if (match2[0] === "{") {
        const selectorText = css.substring(lastIndex, match2.index).trim();
        if (selectorText.startsWith("@keyframes") || selectorText.startsWith("@-webkit-keyframes")) {
          const newRule = new CSSKeyframesRule();
          newRule.name = selectorText.replace(/@(-webkit-){0,1}keyframes +/, "");
          newRule.parentStyleSheet = parentStyleSheet;
          cssRules.push(newRule);
          parentRule = newRule;
        } else if (selectorText.startsWith("@media")) {
          const mediums = selectorText.replace("@media", "").split(",");
          const newRule = new CSSMediaRule();
          for (const medium2 of mediums) {
            newRule.media.appendMedium(medium2.trim());
          }
          newRule.parentStyleSheet = parentStyleSheet;
          cssRules.push(newRule);
          parentRule = newRule;
        } else if (selectorText.startsWith("@container") || selectorText.startsWith("@-webkit-container")) {
          const conditionText = selectorText.replace(/@(-webkit-){0,1}container +/, "");
          const newRule = new CSSContainerRule();
          newRule.conditionText = conditionText;
          newRule.parentStyleSheet = parentStyleSheet;
          cssRules.push(newRule);
          parentRule = newRule;
        } else if (selectorText.startsWith("@supports") || selectorText.startsWith("@-webkit-supports")) {
          const conditionText = selectorText.replace(/@(-webkit-){0,1}supports +/, "");
          const newRule = new CSSSupportsRule();
          newRule.conditionText = conditionText;
          newRule.parentStyleSheet = parentStyleSheet;
          cssRules.push(newRule);
          parentRule = newRule;
        } else if (selectorText.startsWith("@")) {
          const newRule = new CSSRule();
          newRule.parentStyleSheet = parentStyleSheet;
          parentRule = newRule;
        } else if (parentRule && parentRule.type === CSSRule.KEYFRAMES_RULE) {
          const newRule = new CSSKeyframeRule();
          newRule.keyText = selectorText.trim();
          newRule.parentStyleSheet = parentStyleSheet;
          newRule.parentRule = parentRule;
          parentRule.cssRules.push(newRule);
          parentRule = newRule;
        } else if (parentRule && (parentRule.type === CSSRule.MEDIA_RULE || parentRule.type === CSSRule.CONTAINER_RULE || parentRule.type === CSSRule.SUPPORTS_RULE)) {
          if (this.validateSelectorText(selectorText)) {
            const newRule = new CSSStyleRule();
            newRule.selectorText = selectorText;
            newRule.parentStyleSheet = parentStyleSheet;
            newRule.parentRule = parentRule;
            parentRule.cssRules.push(newRule);
            parentRule = newRule;
          }
        } else {
          if (this.validateSelectorText(selectorText)) {
            const newRule = new CSSStyleRule();
            newRule.selectorText = selectorText;
            newRule.parentStyleSheet = parentStyleSheet;
            newRule.parentRule = parentRule;
            if (!parentRule) {
              cssRules.push(newRule);
            }
            parentRule = newRule;
          }
        }
        stack.push(parentRule);
      } else {
        if (parentRule) {
          const cssText$12 = css.substring(lastIndex, match2.index).trim().replace(/([^;])$/, "$1;");
          switch (parentRule.type) {
            case CSSRule.FONT_FACE_RULE:
            case CSSRule.KEYFRAME_RULE:
            case CSSRule.STYLE_RULE:
              parentRule[cssText] = cssText$12;
              break;
          }
        }
        stack.pop();
        parentRule = stack[stack.length - 1] || null;
      }
      lastIndex = match2.index + 1;
    }
    return cssRules;
  }
  /**
   * Validates a selector text.
   *
   * @see https://www.w3.org/TR/CSS21/syndata.html#rule-sets
   * @param selectorText Selector text.
   * @returns True if valid, false otherwise.
   */
  static validateSelectorText(selectorText) {
    try {
      SelectorParser.getSelectorGroups(selectorText);
    } catch (e2) {
      return false;
    }
    return true;
  }
}
var __classPrivateFieldGet$r = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$p = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var _CSSStyleSheet_currentText;
class CSSStyleSheet {
  /**
   * Constructor.
   *
   * @param [options] Options.
   * @param [options.media] Media.
   * @param [options.title] Title.
   * @param [options.alternate] Alternate.
   * @param [options.disabled] Disabled.
   */
  constructor(options2) {
    this.value = null;
    this.name = null;
    this.namespaceURI = null;
    this.cssRules = [];
    _CSSStyleSheet_currentText.set(this, null);
    this.media = options2 && options2.media ? options2.media : "";
    this.title = options2 && options2.title ? options2.title : "";
    this.alternate = options2 && options2.alternate ? options2.alternate : false;
    this.disabled = options2 && options2.disabled ? options2.disabled : false;
  }
  /**
   * Inserts a rule.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/insertRule
   * @param rule Rule.
   * @param [index] Index.
   * @returns The newly inserterted rule's index.
   */
  insertRule(rule, index) {
    const rules = CSSParser.parseFromString(this, rule);
    if (rules.length === 0) {
      throw new DOMException("Invalid CSS rule.", DOMExceptionNameEnum$1.hierarchyRequestError);
    }
    if (rules.length > 1) {
      throw new DOMException("Only one rule is allowed to be added.", DOMExceptionNameEnum$1.syntaxError);
    }
    if (index !== void 0) {
      if (index > this.cssRules.length) {
        throw new DOMException("Index is more than the length of CSSRuleList.", DOMExceptionNameEnum$1.indexSizeError);
      }
      this.cssRules.splice(index, 0, rules[0]);
      return index;
    }
    const newIndex = this.cssRules.length;
    this.cssRules.push(rules[0]);
    return newIndex;
  }
  /**
   * Removes a rule.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/deleteRule
   * @param index Index.
   */
  deleteRule(index) {
    delete this.cssRules[index];
  }
  /**
   * Replaces all CSS rules.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/replace
   * @param text CSS text.
   * @returns Promise.
   */
  async replace(text2) {
    this.replaceSync(text2);
  }
  /**
   * Replaces all CSS rules.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/replaceSync
   * @param text CSS text.
   */
  replaceSync(text2) {
    if (__classPrivateFieldGet$r(this, _CSSStyleSheet_currentText, "f") !== text2) {
      __classPrivateFieldSet$p(this, _CSSStyleSheet_currentText, text2, "f");
      this.cssRules = CSSParser.parseFromString(this, text2);
    }
  }
}
_CSSStyleSheet_currentText = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet$o = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$q = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HTMLLinkElementStyleSheetLoader_element, _HTMLLinkElementStyleSheetLoader_browserFrame, _HTMLLinkElementStyleSheetLoader_loadedStyleSheetURL;
class HTMLLinkElementStyleSheetLoader {
  /**
   * Constructor.
   *
   * @param options Options.
   * @param options.element Element.
   * @param options.browserFrame Browser frame.
   */
  constructor(options2) {
    _HTMLLinkElementStyleSheetLoader_element.set(this, void 0);
    _HTMLLinkElementStyleSheetLoader_browserFrame.set(this, void 0);
    _HTMLLinkElementStyleSheetLoader_loadedStyleSheetURL.set(this, null);
    __classPrivateFieldSet$o(this, _HTMLLinkElementStyleSheetLoader_element, options2.element, "f");
    __classPrivateFieldSet$o(this, _HTMLLinkElementStyleSheetLoader_browserFrame, options2.browserFrame, "f");
  }
  /**
   * Returns a URL relative to the given Location object.
   *
   * @param url URL.
   * @param rel Rel.
   */
  async loadStyleSheet(url, rel) {
    const element = __classPrivateFieldGet$q(this, _HTMLLinkElementStyleSheetLoader_element, "f");
    const browserSettings = __classPrivateFieldGet$q(this, _HTMLLinkElementStyleSheetLoader_browserFrame, "f").page.context.browser.settings;
    const window2 = element[ownerDocument][ownerWindow];
    if (!url || !rel || rel.toLowerCase() !== "stylesheet" || !element[isConnected]) {
      return;
    }
    let absoluteURL;
    try {
      absoluteURL = new URL(url, window2.location.href).href;
    } catch (error3) {
      return;
    }
    if (__classPrivateFieldGet$q(this, _HTMLLinkElementStyleSheetLoader_loadedStyleSheetURL, "f") === absoluteURL) {
      return;
    }
    if (browserSettings.disableCSSFileLoading) {
      if (browserSettings.handleDisabledFileLoadingAsSuccess) {
        element.dispatchEvent(new Event("load"));
      } else {
        WindowErrorUtility.dispatchError(element, new DOMException(`Failed to load external stylesheet "${absoluteURL}". CSS file loading is disabled.`, DOMExceptionNameEnum$1.notSupportedError));
      }
      return;
    }
    const resourceFetch = new NotSupported$a({
      browserFrame: __classPrivateFieldGet$q(this, _HTMLLinkElementStyleSheetLoader_browserFrame, "f"),
      window: window2
    });
    const readyStateManager$1 = window2[readyStateManager];
    __classPrivateFieldSet$o(this, _HTMLLinkElementStyleSheetLoader_loadedStyleSheetURL, absoluteURL, "f");
    readyStateManager$1.startTask();
    let code2 = null;
    let error2 = null;
    try {
      code2 = await resourceFetch.fetch(absoluteURL);
    } catch (e2) {
      error2 = e2;
    }
    readyStateManager$1.endTask();
    if (error2) {
      WindowErrorUtility.dispatchError(element, error2);
    } else {
      const styleSheet = new CSSStyleSheet();
      styleSheet.replaceSync(code2);
      element[sheet] = styleSheet;
      element.dispatchEvent(new Event("load"));
    }
  }
}
_HTMLLinkElementStyleSheetLoader_element = /* @__PURE__ */ new WeakMap(), _HTMLLinkElementStyleSheetLoader_browserFrame = /* @__PURE__ */ new WeakMap(), _HTMLLinkElementStyleSheetLoader_loadedStyleSheetURL = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet$n = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$p = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HTMLLinkElement_styleSheetLoader, _a$k, _b$a, _c$6;
let HTMLLinkElement$1 = class HTMLLinkElement extends HTMLElement$1 {
  /**
   * Constructor.
   *
   * @param browserFrame Browser frame.
   */
  constructor(browserFrame) {
    super();
    this.onerror = null;
    this.onload = null;
    this[_a$k] = null;
    this[_b$a] = true;
    this[_c$6] = null;
    _HTMLLinkElement_styleSheetLoader.set(this, void 0);
    __classPrivateFieldSet$n(this, _HTMLLinkElement_styleSheetLoader, new HTMLLinkElementStyleSheetLoader({
      element: this,
      browserFrame
    }), "f");
    this[attributes] = new HTMLLinkElementNamedNodeMap(this, __classPrivateFieldGet$p(this, _HTMLLinkElement_styleSheetLoader, "f"));
  }
  /**
   * Returns sheet.
   */
  get sheet() {
    return this[sheet];
  }
  /**
   * Returns rel list.
   *
   * @returns Rel list.
   */
  get relList() {
    if (!this[relList]) {
      this[relList] = new DOMTokenList(this, "rel");
    }
    return this[relList];
  }
  /**
   * Returns as.
   *
   * @returns As.
   */
  get as() {
    return this.getAttribute("as") || "";
  }
  /**
   * Sets crossOrigin.
   *
   * @param crossOrigin CrossOrigin.
   */
  set as(as) {
    this.setAttribute("as", as);
  }
  /**
   * Returns crossOrigin.
   *
   * @returns CrossOrigin.
   */
  get crossOrigin() {
    return this.getAttribute("crossorigin") || "";
  }
  /**
   * Sets crossOrigin.
   *
   * @param crossOrigin CrossOrigin.
   */
  set crossOrigin(crossOrigin) {
    this.setAttribute("crossorigin", crossOrigin);
  }
  /**
   * Returns href.
   *
   * @returns Href.
   */
  get href() {
    if (!this.hasAttribute("href")) {
      return "";
    }
    try {
      return new URL(this.getAttribute("href"), this[ownerDocument].location.href).href;
    } catch (e2) {
      return this.getAttribute("href");
    }
  }
  /**
   * Sets href.
   *
   * @param href Href.
   */
  set href(href) {
    this.setAttribute("href", href);
  }
  /**
   * Returns hreflang.
   *
   * @returns Hreflang.
   */
  get hreflang() {
    return this.getAttribute("hreflang") || "";
  }
  /**
   * Sets hreflang.
   *
   * @param hreflang Hreflang.
   */
  set hreflang(hreflang) {
    this.setAttribute("hreflang", hreflang);
  }
  /**
   * Returns media.
   *
   * @returns Media.
   */
  get media() {
    return this.getAttribute("media") || "";
  }
  /**
   * Sets media.
   *
   * @param media Media.
   */
  set media(media) {
    this.setAttribute("media", media);
  }
  /**
   * Returns referrerPolicy.
   *
   * @returns ReferrerPolicy.
   */
  get referrerPolicy() {
    return this.getAttribute("referrerPolicy") || "";
  }
  /**
   * Sets referrerPolicy.
   *
   * @param referrerPolicy ReferrerPolicy.
   */
  set referrerPolicy(referrerPolicy) {
    this.setAttribute("referrerPolicy", referrerPolicy);
  }
  /**
   * Returns rel.
   *
   * @returns Rel.
   */
  get rel() {
    return this.getAttribute("rel") || "";
  }
  /**
   * Sets rel.
   *
   * @param rel Rel.
   */
  set rel(rel) {
    this.setAttribute("rel", rel);
  }
  /**
   * Returns type.
   *
   * @returns Type.
   */
  get type() {
    return this.getAttribute("type") || "";
  }
  /**
   * Sets type.
   *
   * @param type Type.
   */
  set type(type) {
    this.setAttribute("type", type);
  }
  /**
   * @override
   */
  [(_HTMLLinkElement_styleSheetLoader = /* @__PURE__ */ new WeakMap(), _a$k = sheet, _b$a = evaluateCSS, _c$6 = relList, connectToNode)](parentNode2 = null) {
    const isConnected$1 = this[isConnected];
    const isParentConnected = parentNode2 ? parentNode2[isConnected] : false;
    super[connectToNode](parentNode2);
    if (isParentConnected && isConnected$1 !== isParentConnected && this[evaluateCSS]) {
      __classPrivateFieldGet$p(this, _HTMLLinkElement_styleSheetLoader, "f").loadStyleSheet(this.getAttribute("href"), this.getAttribute("rel"));
    }
  }
};
var _a$j, _b$9;
class HTMLStyleElement extends HTMLElement$1 {
  constructor() {
    super(...arguments);
    this[_a$j] = null;
    this[_b$9] = this;
  }
  /**
   * Returns CSS style sheet.
   *
   * @returns CSS style sheet.
   */
  get sheet() {
    return this[sheet] ? this[sheet] : null;
  }
  /**
   * Returns media.
   *
   * @returns Media.
   */
  get media() {
    return this.getAttribute("media") || "";
  }
  /**
   * Sets media.
   *
   * @param media Media.
   */
  set media(media) {
    this.setAttribute("media", media);
  }
  /**
   * Returns type.
   *
   * @returns Type.
   */
  get type() {
    return this.getAttribute("type") || "";
  }
  /**
   * Sets type.
   *
   * @param type Type.
   */
  set type(type) {
    this.setAttribute("type", type);
  }
  /**
   * Returns disabled.
   *
   * @returns Disabled.
   */
  get disabled() {
    return this.getAttribute("disabled") !== null;
  }
  /**
   * Sets disabled.
   *
   * @param disabled Disabled.
   */
  set disabled(disabled) {
    if (!disabled) {
      this.removeAttribute("disabled");
    } else {
      this.setAttribute("disabled", "");
    }
  }
  /**
   * @override
   */
  [(_a$j = sheet, _b$9 = styleNode, appendChild)](node2) {
    const returnValue2 = super[appendChild](node2);
    this[updateSheet]();
    return returnValue2;
  }
  /**
   * @override
   */
  [removeChild](node2) {
    const returnValue2 = super[removeChild](node2);
    this[updateSheet]();
    return returnValue2;
  }
  /**
   * @override
   */
  [insertBefore](newNode, referenceNode) {
    const returnValue2 = super[insertBefore](newNode, referenceNode);
    this[updateSheet]();
    return returnValue2;
  }
  /**
   * @override
   */
  [connectToNode](parentNode2 = null) {
    super[connectToNode](parentNode2);
    if (parentNode2) {
      this[sheet] = new CSSStyleSheet();
      this[sheet].replaceSync(this.textContent);
    } else {
      this[sheet] = null;
    }
  }
  /**
   * Updates the CSSStyleSheet with the text content.
   */
  [updateSheet]() {
    if (this[sheet]) {
      this[ownerDocument][cacheID]++;
      this[sheet].replaceSync(this.textContent);
    }
  }
}
class HTMLSlotElement extends HTMLElement$1 {
  constructor() {
    super(...arguments);
    this.onslotchange = null;
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this.getAttribute("name") || "";
  }
  /**
   * Sets name.
   *
   * @param name Name.
   */
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * Sets the slot's manually assigned nodes to an ordered set of slottables.
   *
   * @param _nodes Nodes.
   */
  assign(..._nodes) {
  }
  /**
   * Returns assigned nodes.
   *
   * @param [options] Options.
   * @param [options.flatten] A boolean value indicating whether to return the assigned nodes of any available child <slot> elements (true) or not (false). Defaults to false.
   * @returns Nodes.
   */
  assignedNodes(options2) {
    var _a2;
    const host2 = (_a2 = this.getRootNode()) == null ? void 0 : _a2.host;
    if (host2) {
      const name2 = this.name;
      if (name2) {
        return this.assignedElements(options2);
      }
      return host2[childNodes].slice();
    }
    return [];
  }
  /**
   * Returns assigned elements.
   *
   * @param [_options] Options.
   * @param [_options.flatten] A boolean value indicating whether to return the assigned elements of any available child <slot> elements (true) or not (false). Defaults to false.
   * @returns Nodes.
   */
  assignedElements(_options) {
    var _a2;
    const host2 = (_a2 = this.getRootNode()) == null ? void 0 : _a2.host;
    if (host2) {
      const name2 = this.name;
      if (name2) {
        const assignedElements = [];
        for (const child of host2[children]) {
          if (child.slot === name2) {
            assignedElements.push(child);
          }
        }
        return assignedElements;
      }
      return host2[children].slice();
    }
    return [];
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    return super[cloneNode](deep);
  }
}
class HTMLLabelElement extends HTMLElement$1 {
  /**
   * Returns a string containing the ID of the labeled control. This reflects the "for" attribute.
   *
   * @returns ID of the labeled control.
   */
  get htmlFor() {
    const htmlFor = this.getAttribute("for");
    if (htmlFor !== null) {
      return htmlFor;
    }
    return htmlFor !== null ? htmlFor : "";
  }
  /**
   * Sets a string containing the ID of the labeled control. This reflects the "for" attribute.
   *
   * @param htmlFor ID of the labeled control.
   */
  set htmlFor(htmlFor) {
    this.setAttribute("for", htmlFor);
  }
  /**
   * Returns an HTML element representing the control with which the label is associated.
   *
   * @returns Control element.
   */
  get control() {
    const htmlFor = this.htmlFor;
    if (htmlFor) {
      const control = this[ownerDocument].getElementById(htmlFor);
      return control !== this ? control : null;
    }
    return this.querySelector('button,input:not([type="hidden"]),meter,output,progress,select,textarea');
  }
  /**
   * Returns the parent form element.
   *
   * @returns Form.
   */
  get form() {
    return this[formNode];
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    return super[cloneNode](deep);
  }
  /**
   * @override
   */
  dispatchEvent(event) {
    const returnValue2 = super.dispatchEvent(event);
    if (event.type === "click" && event instanceof MouseEvent && (event.eventPhase === EventPhaseEnum$1.atTarget || event.eventPhase === EventPhaseEnum$1.bubbling)) {
      const control = this.control;
      if (control && event.target !== control) {
        control.dispatchEvent(new MouseEvent("click", { bubbles: true, cancelable: true }));
      }
    }
    return returnValue2;
  }
}
class HTMLMetaElement extends HTMLElement$1 {
  /**
   * Returns content.
   *
   * @returns Content.
   */
  get content() {
    return this.getAttribute("content") || "";
  }
  /**
   * Sets content.
   *
   * @param content Content.
   */
  set content(content2) {
    this.setAttribute("content", content2);
  }
  /**
   * Returns httpEquiv.
   *
   * @returns HttpEquiv.
   */
  get httpEquiv() {
    return this.getAttribute("http-equiv") || "";
  }
  /**
   * Sets httpEquiv.
   *
   * @param httpEquiv HttpEquiv.
   */
  set httpEquiv(httpEquiv) {
    this.setAttribute("http-equiv", httpEquiv);
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this.getAttribute("name") || "";
  }
  /**
   * Sets name.
   *
   * @param name Name.
   */
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * Returns scheme.
   *
   * @returns Name.
   */
  get scheme() {
    return this.getAttribute("scheme") || "";
  }
  /**
   * Sets scheme.
   *
   * @param scheme Scheme.
   */
  set scheme(scheme) {
    this.setAttribute("scheme", scheme);
  }
}
class TimeRange {
  constructor() {
    this.length = 0;
  }
  /**
   * Returns start.
   *
   * @returns Start.
   */
  start() {
    return 0;
  }
  /**
   * Returns end.
   *
   * @returns End.
   */
  end() {
    return 0;
  }
}
var _a$i, _b$8, _c$5, _d$3, _e$3, _f$2, _g$1, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
class HTMLMediaElement extends HTMLElement$1 {
  constructor() {
    super(...arguments);
    this.onabort = null;
    this.oncanplay = null;
    this.oncanplaythrough = null;
    this.ondurationchange = null;
    this.onemptied = null;
    this.onended = null;
    this.onerror = null;
    this.onloadeddata = null;
    this.onloadedmetadata = null;
    this.onloadstart = null;
    this.onpause = null;
    this.onplay = null;
    this.onplaying = null;
    this.onprogress = null;
    this.onratechange = null;
    this.onresize = null;
    this.onseeked = null;
    this.onseeking = null;
    this.onstalled = null;
    this.onsuspend = null;
    this.ontimeupdate = null;
    this.onvolumechange = null;
    this.onwaiting = null;
    this[_a$i] = 1;
    this[_b$8] = true;
    this[_c$5] = 0;
    this[_d$3] = 1;
    this[_e$3] = 1;
    this[_f$2] = false;
    this[_g$1] = false;
    this[_h] = true;
    this[_j] = new TimeRange();
    this[_k] = NaN;
    this[_l] = null;
    this[_m] = false;
    this[_o] = 0;
    this[_p] = 0;
    this[_q] = [];
    this[_r] = [];
    this[_s] = false;
    this[_t] = new TimeRange();
    this[_u] = new TimeRange();
  }
  /**
   * Returns buffered.
   *
   * @returns Buffered.
   */
  get buffered() {
    return this[buffered];
  }
  /**
   * Returns duration.
   *
   * @returns Duration.
   */
  get duration() {
    return this[duration];
  }
  /**
   * Returns error.
   *
   * @returns Error.
   */
  get error() {
    return this[error];
  }
  /**
   * Returns ended.
   *
   * @returns Ended.
   */
  get ended() {
    return this[ended];
  }
  /**
   * Returns networkState.
   *
   * @returns NetworkState.
   */
  get networkState() {
    return this[networkState];
  }
  /**
   * Returns readyState.
   *
   * @returns ReadyState.
   */
  get readyState() {
    return this[readyState];
  }
  /**
   * Returns textTracks.
   *
   * @returns TextTracks.
   */
  get textTracks() {
    return this[textTracks];
  }
  /**
   * Returns videoTracks.
   *
   * @returns VideoTracks.
   */
  get videoTracks() {
    return this[videoTracks];
  }
  /**
   * Returns seeking.
   *
   * @returns Seeking.
   */
  get seeking() {
    return this[seeking];
  }
  /**
   * Returns seekable.
   *
   * @returns Seekable.
   */
  get seekable() {
    return this[seekable];
  }
  /**
   * Returns played.
   *
   * @returns Played.
   */
  get played() {
    return this[played];
  }
  /**
   * Returns autoplay.
   *
   * @returns Autoplay.
   */
  get autoplay() {
    return this.getAttribute("autoplay") !== null;
  }
  /**
   * Sets autoplay.
   *
   * @param autoplay Autoplay.
   */
  set autoplay(autoplay) {
    if (!autoplay) {
      this.removeAttribute("autoplay");
    } else {
      this.setAttribute("autoplay", "");
    }
  }
  /**
   * Returns controls.
   *
   * @returns Controls.
   */
  get controls() {
    return this.getAttribute("controls") !== null;
  }
  /**
   * Sets controls.
   *
   * @param controls Controls.
   */
  set controls(controls) {
    if (!controls) {
      this.removeAttribute("controls");
    } else {
      this.setAttribute("controls", "");
    }
  }
  /**
   * Returns loop.
   *
   * @returns Loop.
   */
  get loop() {
    return this.getAttribute("loop") !== null;
  }
  /**
   * Sets loop.
   *
   * @param loop Loop.
   */
  set loop(loop) {
    if (!loop) {
      this.removeAttribute("loop");
    } else {
      this.setAttribute("loop", "");
    }
  }
  /**
   * Returns muted.
   *
   * @returns Muted.
   */
  get muted() {
    if (this[muted]) {
      return this[muted];
    }
    if (!this[defaultMuted]) {
      return this.getAttribute("muted") !== null;
    }
    return false;
  }
  /**
   * Sets muted.
   *
   * @param muted Muted.
   */
  set muted(muted$1) {
    this[muted] = !!muted$1;
    if (!muted$1 && !this[defaultMuted]) {
      this.removeAttribute("muted");
    } else {
      this.setAttribute("muted", "");
    }
  }
  /**
   * Returns defaultMuted.
   *
   * @returns DefaultMuted.
   */
  get defaultMuted() {
    return this[defaultMuted];
  }
  /**
   * Sets defaultMuted.
   *
   * @param defaultMuted DefaultMuted.
   */
  set defaultMuted(defaultMuted$1) {
    this[defaultMuted] = !!defaultMuted$1;
    if (!this[defaultMuted] && !this[muted]) {
      this.removeAttribute("muted");
    } else {
      this.setAttribute("muted", "");
    }
  }
  /**
   * Returns src.
   *
   * @returns Src.
   */
  get src() {
    return this.getAttribute("src") || "";
  }
  /**
   * Sets src.
   *
   * @param src Src.
   */
  set src(src) {
    this.setAttribute("src", src);
    if (Boolean(src)) {
      this.dispatchEvent(new Event("canplay", { bubbles: false, cancelable: false }));
      this.dispatchEvent(new Event("durationchange", { bubbles: false, cancelable: false }));
    }
  }
  /**
   * Returns currentSrc.
   *
   * @returns CurrentrSrc.
   */
  get currentSrc() {
    return this.src;
  }
  /**
   * Returns volume.
   *
   * @returns Volume.
   */
  get volume() {
    return this[volume];
  }
  /**
   * Sets volume.
   *
   * @param volume Volume.
   */
  set volume(volume$1) {
    const parsedVolume = Number(volume$1);
    if (isNaN(parsedVolume)) {
      throw new TypeError(`Failed to set the 'volume' property on 'HTMLMediaElement': The provided double value is non-finite.`);
    }
    if (parsedVolume < 0 || parsedVolume > 1) {
      throw new DOMException(`Failed to set the 'volume' property on 'HTMLMediaElement': The volume provided (${parsedVolume}) is outside the range [0, 1].`, DOMExceptionNameEnum$1.indexSizeError);
    }
    this[volume] = parsedVolume;
  }
  /**
   * Returns crossOrigin.
   *
   * @returns CrossOrigin.
   */
  get crossOrigin() {
    return this.getAttribute("crossorigin");
  }
  /**
   * Sets crossOrigin.
   *
   * @param crossOrigin CrossOrigin.
   */
  set crossOrigin(crossOrigin) {
    if (crossOrigin === null) {
      return;
    }
    if (["", "use-credentials", "anonymous"].includes(crossOrigin)) {
      this.setAttribute("crossorigin", crossOrigin);
    } else {
      this.setAttribute("crossorigin", "anonymous");
    }
  }
  /**
   * Returns currentTime.
   *
   * @returns CurrentTime.
   */
  get currentTime() {
    return this[currentTime];
  }
  /**
   * Sets currentTime.
   *
   * @param currentTime CurrentTime.
   */
  set currentTime(currentTime$1) {
    const parsedCurrentTime = Number(currentTime$1);
    if (isNaN(parsedCurrentTime)) {
      throw new TypeError(`Failed to set the 'currentTime' property on 'HTMLMediaElement': The provided double value is non-finite.`);
    }
    this[currentTime] = parsedCurrentTime;
  }
  /**
   * Returns playbackRate.
   *
   * @returns PlaybackRate.
   */
  get playbackRate() {
    return this[playbackRate];
  }
  /**
   * Sets playbackRate.
   *
   * @param playbackRate PlaybackRate.
   */
  set playbackRate(playbackRate$1) {
    const parsedPlaybackRate = Number(playbackRate$1);
    if (isNaN(parsedPlaybackRate)) {
      throw new TypeError(`Failed to set the 'playbackRate' property on 'HTMLMediaElement': The provided double value is non-finite.`);
    }
    this[playbackRate] = parsedPlaybackRate;
  }
  /**
   * Returns defaultPlaybackRate.
   *
   * @returns DefaultPlaybackRate.
   */
  get defaultPlaybackRate() {
    return this[defaultPlaybackRate];
  }
  /**
   * Sets defaultPlaybackRate.
   *
   * @param defaultPlaybackRate DefaultPlaybackRate.
   */
  set defaultPlaybackRate(defaultPlaybackRate$1) {
    const parsedDefaultPlaybackRate = Number(defaultPlaybackRate$1);
    if (isNaN(parsedDefaultPlaybackRate)) {
      throw new TypeError(`Failed to set the 'defaultPlaybackRate' property on 'HTMLMediaElement': The provided double value is non-finite.`);
    }
    this[defaultPlaybackRate] = parsedDefaultPlaybackRate;
  }
  /**
   * Returns preservesPitch.
   *
   * @returns PlaybackRate.
   */
  get preservesPitch() {
    return this[preservesPitch];
  }
  /**
   * Sets preservesPitch.
   *
   * @param preservesPitch PreservesPitch.
   */
  set preservesPitch(preservesPitch$1) {
    this[preservesPitch] = Boolean(preservesPitch$1);
  }
  /**
   * Returns preload.
   *
   * @returns preload.
   */
  get preload() {
    return this.getAttribute("preload") || "auto";
  }
  /**
   * Sets preload.
   *
   * @param preload preload.
   */
  set preload(preload) {
    this.setAttribute("preload", preload);
  }
  /**
   * Returns paused.
   *
   * @returns Paused.
   */
  get paused() {
    return this[paused];
  }
  /**
   * Pause played media.
   */
  pause() {
    this[paused] = true;
    this.dispatchEvent(new Event("pause", { bubbles: false, cancelable: false }));
  }
  /**
   * Start playing media.
   */
  async play() {
    this[paused] = false;
    return Promise.resolve();
  }
  /**
   *
   * @param _type
   */
  canPlayType(_type) {
    return "";
  }
  /**
   * Load media.
   */
  load() {
    this.dispatchEvent(new Event("emptied", { bubbles: false, cancelable: false }));
  }
  /**
   *
   */
  captureStream() {
    return {};
  }
  /**
   * @override
   */
  [(_a$i = volume, _b$8 = paused, _c$5 = currentTime, _d$3 = playbackRate, _e$3 = defaultPlaybackRate, _f$2 = muted, _g$1 = defaultMuted, _h = preservesPitch, _j = buffered, _k = duration, _l = error, _m = ended, _o = networkState, _p = readyState, _q = textTracks, _r = videoTracks, _s = seeking, _t = seekable, _u = played, cloneNode)](deep = false) {
    return super[cloneNode](deep);
  }
}
class HTMLAudioElement extends HTMLMediaElement {
}
class HTMLVideoElement extends HTMLMediaElement {
}
class HTMLBaseElement extends HTMLElement$1 {
  /**
   * Returns href.
   *
   * @returns Href.
   */
  get href() {
    const href = this.getAttribute("href");
    if (href !== null) {
      return href;
    }
    return this[ownerDocument].location.href;
  }
  /**
   * Sets href.
   *
   * @param href Href.
   */
  set href(href) {
    this.setAttribute("href", href);
  }
  /**
   * Returns target.
   *
   * @returns Target.
   */
  get target() {
    return this.getAttribute("target") || "";
  }
  /**
   * Sets target.
   *
   * @param target Target.
   */
  set target(target2) {
    this.setAttribute("target", target2);
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    return super[cloneNode](deep);
  }
}
var __classPrivateFieldSet$m = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$o = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HTMLIFrameElementNamedNodeMap_instances, _HTMLIFrameElementNamedNodeMap_pageLoader, _HTMLIFrameElementNamedNodeMap_validateSandboxFlags;
const SANDBOX_FLAGS = [
  "allow-downloads",
  "allow-forms",
  "allow-modals",
  "allow-orientation-lock",
  "allow-pointer-lock",
  "allow-popups",
  "allow-popups-to-escape-sandbox",
  "allow-presentation",
  "allow-same-origin",
  "allow-scripts",
  "allow-top-navigation",
  "allow-top-navigation-by-user-activation",
  "allow-top-navigation-to-custom-protocols"
];
class HTMLIFrameElementNamedNodeMap extends HTMLElementNamedNodeMap {
  /**
   * Constructor.
   *
   * @param ownerElement Owner element.
   * @param pageLoader
   */
  constructor(ownerElement2, pageLoader) {
    super(ownerElement2);
    _HTMLIFrameElementNamedNodeMap_instances.add(this);
    _HTMLIFrameElementNamedNodeMap_pageLoader.set(this, void 0);
    __classPrivateFieldSet$m(this, _HTMLIFrameElementNamedNodeMap_pageLoader, pageLoader, "f");
  }
  /**
   * @override
   */
  setNamedItem(item2) {
    var _a2;
    const replacedAttribute = super.setNamedItem(item2);
    if (item2[name] === "srcdoc") {
      __classPrivateFieldGet$o(this, _HTMLIFrameElementNamedNodeMap_pageLoader, "f").loadPage();
    }
    if (item2[name] === "src" && ((_a2 = this[ownerElement][attributes]["srcdoc"]) == null ? void 0 : _a2.value) === void 0 && item2[value] && item2[value] !== (replacedAttribute == null ? void 0 : replacedAttribute[value])) {
      __classPrivateFieldGet$o(this, _HTMLIFrameElementNamedNodeMap_pageLoader, "f").loadPage();
    }
    if (item2[name] === "sandbox") {
      if (!this[ownerElement][sandbox]) {
        this[ownerElement][sandbox] = new DOMTokenList(this[ownerElement], "sandbox");
      } else {
        this[ownerElement][sandbox][updateIndices]();
      }
      __classPrivateFieldGet$o(this, _HTMLIFrameElementNamedNodeMap_instances, "m", _HTMLIFrameElementNamedNodeMap_validateSandboxFlags).call(this);
    }
    return replacedAttribute || null;
  }
  /**
   * @override
   */
  [(_HTMLIFrameElementNamedNodeMap_pageLoader = /* @__PURE__ */ new WeakMap(), _HTMLIFrameElementNamedNodeMap_instances = /* @__PURE__ */ new WeakSet(), removeNamedItem)](name$1) {
    const removedItem = super[removeNamedItem](name$1);
    if (removedItem && (removedItem[name] === "srcdoc" || removedItem[name] === "src")) {
      __classPrivateFieldGet$o(this, _HTMLIFrameElementNamedNodeMap_pageLoader, "f").loadPage();
    }
    return removedItem;
  }
}
_HTMLIFrameElementNamedNodeMap_validateSandboxFlags = function _HTMLIFrameElementNamedNodeMap_validateSandboxFlags2() {
  const window2 = this[ownerElement][ownerDocument][ownerWindow];
  const values = this[ownerElement][sandbox].values();
  const invalidFlags = [];
  for (const token of values) {
    if (!SANDBOX_FLAGS.includes(token)) {
      invalidFlags.push(token);
    }
  }
  if (invalidFlags.length === 1) {
    window2.console.error(`Error while parsing the 'sandbox' attribute: '${invalidFlags[0]}' is an invalid sandbox flag.`);
  } else if (invalidFlags.length > 1) {
    window2.console.error(`Error while parsing the 'sandbox' attribute: '${invalidFlags.join(`', '`)}' are invalid sandbox flags.`);
  }
};
var __classPrivateFieldSet$l = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$n = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CrossOriginBrowserWindow_targetWindow;
class CrossOriginBrowserWindow extends EventTarget {
  /**
   * Constructor.
   *
   * @param target Target window.
   * @param [parent] Parent window.
   */
  constructor(target2, parent) {
    super();
    this.self = this;
    this.window = this;
    _CrossOriginBrowserWindow_targetWindow.set(this, void 0);
    this.parent = parent ?? this;
    this.top = parent ?? this;
    this.location = new Proxy({}, {
      get: () => {
        throw new DOMException(`Blocked a frame with origin "${this.parent.location.origin}" from accessing a cross-origin frame.`, DOMExceptionNameEnum$1.securityError);
      },
      set: () => {
        throw new DOMException(`Blocked a frame with origin "${this.parent.location.origin}" from accessing a cross-origin frame.`, DOMExceptionNameEnum$1.securityError);
      }
    });
    __classPrivateFieldSet$l(this, _CrossOriginBrowserWindow_targetWindow, target2, "f");
  }
  /**
   * Returns the opener.
   *
   * @returns Opener.
   */
  get opener() {
    return __classPrivateFieldGet$n(this, _CrossOriginBrowserWindow_targetWindow, "f").opener;
  }
  /**
   * Returns the closed state.
   *
   * @returns Closed state.
   */
  get closed() {
    return __classPrivateFieldGet$n(this, _CrossOriginBrowserWindow_targetWindow, "f").closed;
  }
  /**
   * Shifts focus away from the window.
   */
  blur() {
    __classPrivateFieldGet$n(this, _CrossOriginBrowserWindow_targetWindow, "f").blur();
  }
  /**
   * Gives focus to the window.
   */
  focus() {
    __classPrivateFieldGet$n(this, _CrossOriginBrowserWindow_targetWindow, "f").focus();
  }
  /**
   * Closes the window.
   */
  close() {
    __classPrivateFieldGet$n(this, _CrossOriginBrowserWindow_targetWindow, "f").close();
  }
  /**
   * Safely enables cross-origin communication between Window objects; e.g., between a page and a pop-up that it spawned, or between a page and an iframe embedded within it.
   *
   * @param message Message.
   * @param [targetOrigin=*] Target origin.
   * @param transfer Transfer. Not implemented.
   */
  postMessage(message, targetOrigin = "*", transfer) {
    __classPrivateFieldGet$n(this, _CrossOriginBrowserWindow_targetWindow, "f").postMessage(message, targetOrigin, transfer);
  }
}
_CrossOriginBrowserWindow_targetWindow = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet$k = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$m = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HTMLIFrameElementPageLoader_element, _HTMLIFrameElementPageLoader_contentWindowContainer, _HTMLIFrameElementPageLoader_browserParentFrame, _HTMLIFrameElementPageLoader_browserIFrame, _HTMLIFrameElementPageLoader_srcdoc;
class HTMLIFrameElementPageLoader {
  /**
   * Constructor.
   *
   * @param options Options.
   * @param options.element Iframe element.
   * @param options.browserParentFrame Main browser frame.
   * @param options.contentWindowContainer Content window container.
   * @param options.contentWindowContainer.window Content window.
   */
  constructor(options2) {
    _HTMLIFrameElementPageLoader_element.set(this, void 0);
    _HTMLIFrameElementPageLoader_contentWindowContainer.set(this, void 0);
    _HTMLIFrameElementPageLoader_browserParentFrame.set(this, void 0);
    _HTMLIFrameElementPageLoader_browserIFrame.set(this, void 0);
    _HTMLIFrameElementPageLoader_srcdoc.set(this, null);
    __classPrivateFieldSet$k(this, _HTMLIFrameElementPageLoader_element, options2.element, "f");
    __classPrivateFieldSet$k(this, _HTMLIFrameElementPageLoader_contentWindowContainer, options2.contentWindowContainer, "f");
    __classPrivateFieldSet$k(this, _HTMLIFrameElementPageLoader_browserParentFrame, options2.browserParentFrame, "f");
  }
  /**
   * Loads an iframe page.
   */
  loadPage() {
    if (!__classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_element, "f")[isConnected]) {
      this.unloadPage();
      return;
    }
    const srcdoc = __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_element, "f").getAttribute("srcdoc");
    const window2 = __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_element, "f")[ownerDocument][ownerWindow];
    if (srcdoc !== null) {
      if (__classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_srcdoc, "f") === srcdoc) {
        return;
      }
      this.unloadPage();
      __classPrivateFieldSet$k(this, _HTMLIFrameElementPageLoader_browserIFrame, BrowserFrameFactory.createChildFrame(__classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserParentFrame, "f")), "f");
      __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserIFrame, "f").url = "about:srcdoc";
      __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_contentWindowContainer, "f").window = __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserIFrame, "f").window;
      __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserIFrame, "f").window.top = __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserParentFrame, "f").window.top;
      __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserIFrame, "f").window.parent = __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserParentFrame, "f").window;
      __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserIFrame, "f").window.document.open();
      __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserIFrame, "f").window.document.write(srcdoc);
      __classPrivateFieldSet$k(this, _HTMLIFrameElementPageLoader_srcdoc, srcdoc, "f");
      __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_element, "f")[ownerDocument][ownerWindow].requestAnimationFrame(() => __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_element, "f").dispatchEvent(new Event("load")));
      return;
    }
    if (__classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_srcdoc, "f") !== null) {
      this.unloadPage();
    }
    const originURL = __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserParentFrame, "f").window.location;
    const targetURL = BrowserFrameURL.getRelativeURL(__classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserParentFrame, "f"), __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_element, "f").src);
    if (__classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserIFrame, "f") && __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserIFrame, "f").window.location.href === targetURL.href) {
      return;
    }
    if (__classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserParentFrame, "f").page.context.browser.settings.disableIframePageLoading) {
      WindowErrorUtility.dispatchError(__classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_element, "f"), new DOMException(`Failed to load iframe page "${targetURL.href}". Iframe page loading is disabled.`, DOMExceptionNameEnum$1.notSupportedError));
      return;
    }
    const isSameOrigin = originURL.origin === targetURL.origin || targetURL.origin === "null";
    const parentWindow = isSameOrigin ? window2 : new CrossOriginBrowserWindow(window2);
    __classPrivateFieldSet$k(this, _HTMLIFrameElementPageLoader_browserIFrame, __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserIFrame, "f") ?? BrowserFrameFactory.createChildFrame(__classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserParentFrame, "f")), "f");
    __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserIFrame, "f").window.top = parentWindow;
    __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserIFrame, "f").window.parent = parentWindow;
    __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserIFrame, "f").goto(targetURL.href, {
      referrer: originURL.origin,
      referrerPolicy: __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_element, "f").referrerPolicy
    }).then(() => __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_element, "f").dispatchEvent(new Event("load"))).catch((error2) => WindowErrorUtility.dispatchError(__classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_element, "f"), error2));
    __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_contentWindowContainer, "f").window = isSameOrigin ? __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserIFrame, "f").window : new CrossOriginBrowserWindow(__classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserIFrame, "f").window, window2);
  }
  /**
   * Unloads an iframe page.
   */
  unloadPage() {
    if (__classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserIFrame, "f")) {
      BrowserFrameFactory.destroyFrame(__classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_browserIFrame, "f"));
      __classPrivateFieldSet$k(this, _HTMLIFrameElementPageLoader_browserIFrame, null, "f");
    }
    __classPrivateFieldGet$m(this, _HTMLIFrameElementPageLoader_contentWindowContainer, "f").window = null;
    __classPrivateFieldSet$k(this, _HTMLIFrameElementPageLoader_srcdoc, null, "f");
  }
}
_HTMLIFrameElementPageLoader_element = /* @__PURE__ */ new WeakMap(), _HTMLIFrameElementPageLoader_contentWindowContainer = /* @__PURE__ */ new WeakMap(), _HTMLIFrameElementPageLoader_browserParentFrame = /* @__PURE__ */ new WeakMap(), _HTMLIFrameElementPageLoader_browserIFrame = /* @__PURE__ */ new WeakMap(), _HTMLIFrameElementPageLoader_srcdoc = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldGet$l = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$j = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var _HTMLIFrameElement_contentWindowContainer, _HTMLIFrameElement_pageLoader, _a$h;
let HTMLIFrameElement$1 = class HTMLIFrameElement extends HTMLElement$1 {
  /**
   * Constructor.
   *
   * @param browserFrame Browser frame.
   */
  constructor(browserFrame) {
    super();
    this.onload = null;
    this.onerror = null;
    this[_a$h] = null;
    _HTMLIFrameElement_contentWindowContainer.set(this, {
      window: null
    });
    _HTMLIFrameElement_pageLoader.set(this, void 0);
    __classPrivateFieldSet$j(this, _HTMLIFrameElement_pageLoader, new HTMLIFrameElementPageLoader({
      element: this,
      contentWindowContainer: __classPrivateFieldGet$l(this, _HTMLIFrameElement_contentWindowContainer, "f"),
      browserParentFrame: browserFrame
    }), "f");
    this[attributes] = new HTMLIFrameElementNamedNodeMap(this, __classPrivateFieldGet$l(this, _HTMLIFrameElement_pageLoader, "f"));
  }
  /**
   * Returns source.
   *
   * @returns Source.
   */
  get src() {
    return this.getAttribute("src") || "";
  }
  /**
   * Sets source.
   *
   * @param src Source.
   */
  set src(src) {
    this.setAttribute("src", src);
  }
  /**
   * Returns allow.
   *
   * @returns Allow.
   */
  get allow() {
    return this.getAttribute("allow") || "";
  }
  /**
   * Sets allow.
   *
   * @param allow Allow.
   */
  set allow(allow) {
    this.setAttribute("allow", allow);
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    return this.getAttribute("height") || "";
  }
  /**
   * Sets height.
   *
   * @param height Height.
   */
  set height(height2) {
    this.setAttribute("height", height2);
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    return this.getAttribute("width") || "";
  }
  /**
   * Sets width.
   *
   * @param width Width.
   */
  set width(width2) {
    this.setAttribute("width", width2);
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this.getAttribute("name") || "";
  }
  /**
   * Sets name.
   *
   * @param name Name.
   */
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * Returns sandbox.
   *
   * @returns Sandbox.
   */
  get sandbox() {
    if (!this[sandbox]) {
      this[sandbox] = new DOMTokenList(this, "sandbox");
    }
    return this[sandbox];
  }
  /**
   * Sets sandbox.
   */
  set sandbox(sandbox2) {
    this.setAttribute("sandbox", sandbox2);
  }
  /**
   * Returns srcdoc.
   *
   * @returns Srcdoc.
   */
  get srcdoc() {
    return this.getAttribute("srcdoc") || "";
  }
  /**
   * Sets srcdoc.
   *
   * @param srcdoc Srcdoc.
   */
  set srcdoc(srcdoc) {
    this.setAttribute("srcdoc", srcdoc);
  }
  /**
   * Returns referrer policy.
   */
  get referrerPolicy() {
    return this.getAttribute("referrerpolicy") || "";
  }
  /**
   * Sets referrer policy.
   *
   * @param referrerPolicy Referrer policy.
   */
  set referrerPolicy(referrerPolicy) {
    this.setAttribute("referrerpolicy", referrerPolicy);
  }
  /**
   * Returns content document.
   *
   * @returns Content document.
   */
  get contentDocument() {
    var _a2;
    return ((_a2 = __classPrivateFieldGet$l(this, _HTMLIFrameElement_contentWindowContainer, "f").window) == null ? void 0 : _a2.document) ?? null;
  }
  /**
   * Returns content window.
   *
   * @returns Content window.
   */
  get contentWindow() {
    return __classPrivateFieldGet$l(this, _HTMLIFrameElement_contentWindowContainer, "f").window;
  }
  /**
   * @override
   */
  [(_HTMLIFrameElement_contentWindowContainer = /* @__PURE__ */ new WeakMap(), _HTMLIFrameElement_pageLoader = /* @__PURE__ */ new WeakMap(), _a$h = sandbox, connectToNode)](parentNode2 = null) {
    const isConnected$1 = this[isConnected];
    const isParentConnected = parentNode2 ? parentNode2[isConnected] : false;
    super[connectToNode](parentNode2);
    if (isConnected$1 !== isParentConnected) {
      if (isParentConnected) {
        __classPrivateFieldGet$l(this, _HTMLIFrameElement_pageLoader, "f").loadPage();
      } else {
        __classPrivateFieldGet$l(this, _HTMLIFrameElement_pageLoader, "f").unloadPage();
      }
    }
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    return super[cloneNode](deep);
  }
};
var _a$g;
class HTMLDialogElement extends HTMLElement$1 {
  constructor() {
    super(...arguments);
    this[_a$g] = "";
    this.oncancel = null;
    this.onclose = null;
  }
  /**
   * Returns return value.
   *
   * @returns Return value.
   */
  get returnValue() {
    return this[returnValue];
  }
  /**
   * Sets return value.
   *
   * @param value Return value.
   */
  set returnValue(value2) {
    this[returnValue] = value2;
  }
  /**
   * Sets the "open" attribute.
   *
   * @param open Open.
   */
  set open(open) {
    if (open) {
      this.setAttribute("open", "");
    } else {
      this.removeAttribute("open");
    }
  }
  /**
   * Returns open.
   *
   * @returns Open.
   */
  get open() {
    return this.getAttribute("open") !== null;
  }
  /**
   * Closes the dialog.
   *
   * @param [returnValue] ReturnValue.
   */
  close(returnValue2 = "") {
    const wasOpen = this.open;
    this.removeAttribute("open");
    this.returnValue = returnValue2;
    if (wasOpen) {
      this.dispatchEvent(new Event("close"));
    }
  }
  /**
   * Shows the modal.
   */
  showModal() {
    this.setAttribute("open", "");
  }
  /**
   * Shows the dialog.
   */
  show() {
    this.setAttribute("open", "");
  }
}
_a$g = returnValue;
class SVGElementNamedNodeMap extends ElementNamedNodeMap {
  /**
   * @override
   */
  setNamedItem(item2) {
    const replacedItem = super.setNamedItem(item2);
    if (item2[name] === "style" && this[ownerElement][style]) {
      this[ownerElement][style].cssText = item2[value];
    }
    return replacedItem || null;
  }
  /**
   * @override
   */
  [removeNamedItem](name$1) {
    const removedItem = super[removeNamedItem](name$1);
    if (removedItem && removedItem[name] === "style" && this[ownerElement][style]) {
      this[ownerElement][style].cssText = "";
    }
    return removedItem;
  }
}
var __classPrivateFieldGet$k = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$i = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var _SVGElement_dataset, _a$f, _b$7;
class SVGElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.onabort = null;
    this.onerror = null;
    this.onload = null;
    this.onresize = null;
    this.onscroll = null;
    this.onunload = null;
    this[_a$f] = new SVGElementNamedNodeMap(this);
    this[_b$7] = null;
    _SVGElement_dataset.set(this, null);
  }
  /**
   * Returns viewport.
   *
   * @returns SVG rect.
   */
  get viewportElement() {
    return null;
  }
  /**
   * Returns current translate.
   *
   * @returns Element.
   */
  get ownerSVGElement() {
    let parent = this[parentNode];
    while (parent) {
      if (parent[localName] === "svg") {
        return parent;
      }
      parent = parent[parentNode];
    }
    return null;
  }
  /**
   * Returns data set.
   *
   * @returns Data set.
   */
  get dataset() {
    return __classPrivateFieldSet$i(this, _SVGElement_dataset, __classPrivateFieldGet$k(this, _SVGElement_dataset, "f") ?? DatasetFactory.createDataset(this), "f");
  }
  /**
   * Returns style.
   *
   * @returns Style.
   */
  get style() {
    if (!this[style]) {
      this[style] = new CSSStyleDeclaration(this);
    }
    return this[style];
  }
  /**
   * Returns tab index.
   *
   * @returns Tab index.
   */
  get tabIndex() {
    const tabIndex = this.getAttribute("tabindex");
    return tabIndex !== null ? Number(tabIndex) : -1;
  }
  /**
   * Returns tab index.
   *
   * @param tabIndex Tab index.
   */
  set tabIndex(tabIndex) {
    if (tabIndex === -1) {
      this.removeAttribute("tabindex");
    } else {
      this.setAttribute("tabindex", String(tabIndex));
    }
  }
  /**
   * Triggers a blur event.
   */
  blur() {
    HTMLElementUtility.blur(this);
  }
  /**
   * Triggers a focus event.
   */
  focus() {
    HTMLElementUtility.focus(this);
  }
}
_SVGElement_dataset = /* @__PURE__ */ new WeakMap(), _a$f = attributes, _b$7 = style;
class DOMMatrix {
  constructor() {
    this.is2D = false;
    this.isIdentity = false;
  }
}
class SVGGraphicsElement extends SVGElement {
  constructor() {
    super(...arguments);
    this.transform = {};
  }
  /**
   * Returns DOM rect.
   *
   * @returns DOM rect.
   */
  getBBox() {
    return new DOMRect();
  }
  /**
   * Returns CTM.
   *
   * @returns CTM.
   */
  getCTM() {
    return new DOMMatrix();
  }
  /**
   * Returns screen CTM.
   *
   * @returns Screen CTM.
   */
  getScreenCTM() {
    return new DOMMatrix();
  }
}
class SVGRect {
  constructor() {
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
  }
}
class SVGPoint {
  constructor() {
    this.x = 0;
    this.y = 0;
  }
}
class SVGLength {
  constructor() {
    this.unitType = "";
    this.value = 0;
    this.valueInSpecifiedUnits = 0;
    this.valueAsString = "";
  }
  /**
   * New value specific units.
   */
  newValueSpecifiedUnits() {
  }
  /**
   * Convert to specific units.
   */
  convertToSpecifiedUnits() {
  }
}
SVGLength.SVG_LENGTHTYPE_UNKNOWN = 0;
SVGLength.SVG_LENGTHTYPE_NUMBER = 1;
SVGLength.SVG_LENGTHTYPE_PERCENTAGE = 2;
SVGLength.SVG_LENGTHTYPE_EMS = 3;
SVGLength.SVG_LENGTHTYPE_EXS = 4;
SVGLength.SVG_LENGTHTYPE_PX = 5;
SVGLength.SVG_LENGTHTYPE_CM = 6;
SVGLength.SVG_LENGTHTYPE_MM = 7;
SVGLength.SVG_LENGTHTYPE_IN = 8;
SVGLength.SVG_LENGTHTYPE_PT = 9;
SVGLength.SVG_LENGTHTYPE_PC = 10;
class SVGAngle {
  constructor() {
    this.unitType = "";
    this.value = 0;
    this.valueInSpecifiedUnits = 0;
    this.valueAsString = "";
  }
  /**
   * New value specific units.
   */
  newValueSpecifiedUnits() {
  }
  /**
   * Convert to specific units.
   */
  convertToSpecifiedUnits() {
  }
}
SVGAngle.SVG_ANGLETYPE_UNKNOWN = "unknown";
SVGAngle.SVG_ANGLETYPE_UNSPECIFIED = "unspecified";
SVGAngle.SVG_ANGLETYPE_DEG = "0deg";
SVGAngle.SVG_ANGLETYPE_RAD = "0rad";
SVGAngle.SVG_ANGLETYPE_GRAD = "0grad";
class SVGNumber {
  constructor() {
    this.value = 0;
  }
}
class SVGTransform {
  constructor() {
    this.type = 0;
    this.angle = 0;
  }
  /**
   * Set matrix.
   */
  setMatrix() {
  }
  /**
   * Set translate.
   */
  setTranslate() {
  }
  /**
   * Set scale.
   */
  setScale() {
  }
  /**
   * Set rotate.
   */
  setRotate() {
  }
  /**
   * Set skew x.
   */
  setSkewX() {
  }
  /**
   * Set skew y.
   */
  setSkewY() {
  }
}
SVGTransform.SVG_TRANSFORM_UNKNOWN = 0;
SVGTransform.SVG_TRANSFORM_MATRIX = 1;
SVGTransform.SVG_TRANSFORM_TRANSLATE = 2;
SVGTransform.SVG_TRANSFORM_SCALE = 3;
SVGTransform.SVG_TRANSFORM_ROTATE = 4;
SVGTransform.SVG_TRANSFORM_SKEWX = 5;
SVGTransform.SVG_TRANSFORM_SKEWY = 6;
class SVGAnimatedRect {
  constructor() {
    this.baseVal = new SVGRect();
    this.animVal = new SVGRect();
  }
}
class SVGSVGElement extends SVGGraphicsElement {
  constructor() {
    super(...arguments);
    this.onafterprint = null;
    this.onbeforeprint = null;
    this.onbeforeunload = null;
    this.ongamepadconnected = null;
    this.ongamepaddisconnected = null;
    this.onhashchange = null;
    this.onlanguagechange = null;
    this.onmessage = null;
    this.onmessageerror = null;
    this.onoffline = null;
    this.ononline = null;
    this.onpagehide = null;
    this.onpageshow = null;
    this.onpopstate = null;
    this.onrejectionhandled = null;
    this.onstorage = null;
    this.onunhandledrejection = null;
    this.onunload = null;
  }
  /**
   * Returns preserveAspectRatio.
   *
   * @returns PreserveAspectRatio.
   */
  get preserveAspectRatio() {
    return this.getAttributeNS(null, "preserveAspectRatio") || "xMidYMid meet";
  }
  /**
   * Sets preserveAspectRatio.
   *
   * @param preserveAspectRatio PreserveAspectRatio.
   */
  set preserveAspectRatio(preserveAspectRatio) {
    this.setAttributeNS(null, "preserveAspectRatio", preserveAspectRatio);
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    return this.getAttributeNS(null, "width") || "";
  }
  /**
   * Sets width.
   *
   * @param width Width.
   */
  set width(width2) {
    this.setAttributeNS(null, "width", width2);
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    return this.getAttributeNS(null, "height") || "";
  }
  /**
   * Sets height.
   *
   * @param height Height.
   */
  set height(height2) {
    this.setAttributeNS(null, "height", height2);
  }
  /**
   * Returns x.
   *
   * @returns X.
   */
  get x() {
    return this.getAttributeNS(null, "x") || "";
  }
  /**
   * Sets x.
   *
   * @param x X.
   */
  set x(x2) {
    this.setAttributeNS(null, "x", x2);
  }
  /**
   * Returns y.
   *
   * @returns Y.
   */
  get y() {
    return this.getAttributeNS(null, "y") || "";
  }
  /**
   * Sets y.
   *
   * @param y Y.
   */
  set y(y2) {
    this.setAttributeNS(null, "y", y2);
  }
  /**
   * Returns contentScriptType.
   *
   * @returns ContentScriptType.
   */
  get contentScriptType() {
    return this.getAttributeNS(null, "contentScriptType") || "";
  }
  /**
   * Sets contentScriptType.
   *
   * @param contentScriptType ContentScriptType.
   */
  set contentScriptType(contentScriptType) {
    this.setAttributeNS(null, "contentScriptType", contentScriptType);
  }
  /**
   * Returns currentScale.
   *
   * @returns CurrentScale.
   */
  get currentScale() {
    const currentScale = this.getAttributeNS(null, "currentScale");
    if (currentScale !== null) {
      return parseFloat(currentScale);
    }
    return 1;
  }
  /**
   * Sets currentScale.
   *
   * @param currentScale CurrentScale.
   */
  set currentScale(currentScale) {
    this.setAttributeNS(null, "currentScale", String(currentScale));
  }
  /**
   * Returns viewport.
   *
   * @returns SVG rect.
   */
  get viewport() {
    return new SVGRect();
  }
  /**
   * Returns current translate.
   *
   * @returns SVG point.
   */
  get currentTranslate() {
    return new SVGPoint();
  }
  /**
   * Returns view box.
   *
   * @returns Viewbox.
   */
  get viewBox() {
    const rect = new SVGAnimatedRect();
    const viewBox = this.getAttribute("viewBox");
    const list2 = viewBox.split(/\s+/);
    rect.baseVal.x = Number(list2[0]);
    rect.baseVal.y = Number(list2[1]);
    rect.baseVal.width = Number(list2[2]);
    rect.baseVal.height = Number(list2[3]);
    return rect;
  }
  /**
   * Pauses animation.
   */
  pauseAnimations() {
  }
  /**
   * Unpauses animation.
   */
  unpauseAnimations() {
  }
  /**
   * Returns "true" if animation is paused.
   *
   * @returns "true" if animation is paused.
   */
  animationsPaused() {
    return false;
  }
  /**
   * Returns the current time in seconds relative to the start time for the current SVG document fragment.
   *
   * @returns Current time.
   */
  getCurrentTime() {
    return 0;
  }
  /**
   * Sets current time.
   */
  setCurrentTime() {
  }
  /**
   * Returns intersection list.
   *
   * @returns Intersection list.
   */
  getIntersectionList() {
    return [];
  }
  /**
   * Returns enclousure list.
   *
   * @returns Enclousure list.
   */
  getEnclosureList() {
    return [];
  }
  /**
   * Returns true if the rendered content of the given element intersects the supplied rectangle.
   *
   * @returns Intersection state.
   */
  checkIntersection() {
    return false;
  }
  /**
   * Returns true if the rendered content of the given element is entirely contained within the supplied rectangle.
   *
   * @returns Enclousure state.
   */
  checkEnclosure() {
    return false;
  }
  /**
   * Unselects any selected objects, including any selections of text strings and type-in bars.
   */
  deselectAll() {
  }
  /**
   * Returns a number.
   *
   * @returns Number.
   */
  createSVGNumber() {
    return new SVGNumber();
  }
  /**
   * Returns a length.
   *
   * @returns Length.
   */
  createSVGLength() {
    return new SVGLength();
  }
  /**
   * Returns a angle.
   *
   * @returns Angle.
   */
  createSVGAngle() {
    return new SVGAngle();
  }
  /**
   * Returns a point.
   *
   * @returns Point.
   */
  createSVGPoint() {
    return new SVGPoint();
  }
  /**
   * Returns a rect.
   *
   * @returns Rect.
   */
  createSVGRect() {
    return new SVGRect();
  }
  /**
   * Returns a transform.
   *
   * @returns Transform.
   */
  createSVGTransform() {
    return new SVGTransform();
  }
  /**
   * @override
   */
  [cloneNode](deep = false) {
    return super[cloneNode](deep);
  }
}
var __classPrivateFieldSet$h = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$j = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HTMLScriptElementNamedNodeMap_scriptLoader;
class HTMLScriptElementNamedNodeMap extends HTMLElementNamedNodeMap {
  /**
   * Constructor.
   *
   * @param ownerElement Owner element.
   * @param scriptLoader Script loader.
   */
  constructor(ownerElement2, scriptLoader) {
    super(ownerElement2);
    _HTMLScriptElementNamedNodeMap_scriptLoader.set(this, void 0);
    __classPrivateFieldSet$h(this, _HTMLScriptElementNamedNodeMap_scriptLoader, scriptLoader, "f");
  }
  /**
   * @override
   */
  setNamedItem(item2) {
    const replacedItem = super.setNamedItem(item2);
    if (item2[name] === "src" && item2[value] !== null && this[ownerElement][isConnected]) {
      __classPrivateFieldGet$j(this, _HTMLScriptElementNamedNodeMap_scriptLoader, "f").loadScript(item2[value]);
    }
    return replacedItem || null;
  }
}
_HTMLScriptElementNamedNodeMap_scriptLoader = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet$g = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$i = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HTMLScriptElementScriptLoader_element, _HTMLScriptElementScriptLoader_browserFrame, _HTMLScriptElementScriptLoader_loadedScriptURL;
class HTMLScriptElementScriptLoader {
  /**
   * Constructor.
   *
   * @param options Options.
   * @param options.element Element.
   * @param options.browserFrame Browser frame.
   */
  constructor(options2) {
    _HTMLScriptElementScriptLoader_element.set(this, void 0);
    _HTMLScriptElementScriptLoader_browserFrame.set(this, void 0);
    _HTMLScriptElementScriptLoader_loadedScriptURL.set(this, null);
    __classPrivateFieldSet$g(this, _HTMLScriptElementScriptLoader_element, options2.element, "f");
    __classPrivateFieldSet$g(this, _HTMLScriptElementScriptLoader_browserFrame, options2.browserFrame, "f");
  }
  /**
   * Returns a URL relative to the given Location object.
   *
   * @param url URL.
   */
  async loadScript(url) {
    const browserSettings = __classPrivateFieldGet$i(this, _HTMLScriptElementScriptLoader_browserFrame, "f").page.context.browser.settings;
    const element = __classPrivateFieldGet$i(this, _HTMLScriptElementScriptLoader_element, "f");
    const async = element.getAttribute("async") !== null;
    if (!url || !element[isConnected]) {
      return;
    }
    let absoluteURL;
    try {
      absoluteURL = new URL(url, element[ownerDocument][ownerWindow].location.href).href;
    } catch (error3) {
      return;
    }
    if (__classPrivateFieldGet$i(this, _HTMLScriptElementScriptLoader_loadedScriptURL, "f") === absoluteURL) {
      return;
    }
    if (browserSettings.disableJavaScriptFileLoading || browserSettings.disableJavaScriptEvaluation) {
      if (browserSettings.handleDisabledFileLoadingAsSuccess) {
        element.dispatchEvent(new Event("load"));
      } else {
        WindowErrorUtility.dispatchError(element, new DOMException(`Failed to load external script "${absoluteURL}". JavaScript file loading is disabled.`, DOMExceptionNameEnum$1.notSupportedError));
      }
      return;
    }
    const resourceFetch = new NotSupported$a({
      browserFrame: __classPrivateFieldGet$i(this, _HTMLScriptElementScriptLoader_browserFrame, "f"),
      window: element[ownerDocument][ownerWindow]
    });
    let code2 = null;
    let error2 = null;
    __classPrivateFieldSet$g(this, _HTMLScriptElementScriptLoader_loadedScriptURL, absoluteURL, "f");
    if (async) {
      const readyStateManager$1 = element[ownerDocument][ownerWindow][readyStateManager];
      readyStateManager$1.startTask();
      try {
        code2 = await resourceFetch.fetch(absoluteURL);
      } catch (e2) {
        error2 = e2;
      }
      readyStateManager$1.endTask();
    } else {
      try {
        code2 = resourceFetch.fetchSync(absoluteURL);
      } catch (e2) {
        error2 = e2;
      }
    }
    if (error2) {
      WindowErrorUtility.dispatchError(element, error2);
    } else {
      element[ownerDocument][currentScript] = element;
      code2 = "//# sourceURL=" + absoluteURL + "\n" + code2;
      if (browserSettings.disableErrorCapturing || browserSettings.errorCapture !== BrowserErrorCaptureEnum$1.tryAndCatch) {
        element[ownerDocument][ownerWindow].eval(code2);
      } else {
        WindowErrorUtility.captureError(element[ownerDocument][ownerWindow], () => element[ownerDocument][ownerWindow].eval(code2));
      }
      element[ownerDocument][currentScript] = null;
      element.dispatchEvent(new Event("load"));
    }
  }
}
_HTMLScriptElementScriptLoader_element = /* @__PURE__ */ new WeakMap(), _HTMLScriptElementScriptLoader_browserFrame = /* @__PURE__ */ new WeakMap(), _HTMLScriptElementScriptLoader_loadedScriptURL = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet$f = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$h = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HTMLScriptElement_scriptLoader, _a$e;
let HTMLScriptElement$1 = class HTMLScriptElement extends HTMLElement$1 {
  /**
   * Constructor.
   *
   * @param browserFrame Browser frame.
   */
  constructor(browserFrame) {
    super();
    this.onerror = null;
    this.onload = null;
    this[_a$e] = true;
    _HTMLScriptElement_scriptLoader.set(this, void 0);
    __classPrivateFieldSet$f(this, _HTMLScriptElement_scriptLoader, new HTMLScriptElementScriptLoader({
      element: this,
      browserFrame
    }), "f");
    this[attributes] = new HTMLScriptElementNamedNodeMap(this, __classPrivateFieldGet$h(this, _HTMLScriptElement_scriptLoader, "f"));
  }
  /**
   * Returns type.
   *
   * @returns Type.
   */
  get type() {
    return this.getAttribute("type") || "";
  }
  /**
   * Sets type.
   *
   * @param type Type.
   */
  set type(type) {
    this.setAttribute("type", type);
  }
  /**
   * Returns source.
   *
   * @returns Source.
   */
  get src() {
    if (!this.hasAttribute("src")) {
      return "";
    }
    try {
      return new URL(this.getAttribute("src"), this[ownerDocument].location.href).href;
    } catch (e2) {
      return this.getAttribute("src");
    }
  }
  /**
   * Sets source.
   *
   * @param src Source.
   */
  set src(src) {
    this.setAttribute("src", src);
  }
  /**
   * Returns charset.
   *
   * @returns Charset.
   */
  get charset() {
    return this.getAttribute("charset") || "";
  }
  /**
   * Sets charset.
   *
   * @param charset Charset.
   */
  set charset(charset) {
    this.setAttribute("charset", charset);
  }
  /**
   * Returns lang.
   *
   * @returns Lang.
   */
  get lang() {
    return this.getAttribute("lang") || "";
  }
  /**
   * Sets lang.
   *
   * @param lang Lang.
   */
  set lang(lang) {
    this.setAttribute("lang", lang);
  }
  /**
   * Returns async.
   *
   * @returns Async.
   */
  get async() {
    return this.getAttribute("async") !== null;
  }
  /**
   * Sets async.
   *
   * @param async Async.
   */
  set async(async) {
    if (!async) {
      this.removeAttribute("async");
    } else {
      this.setAttribute("async", "");
    }
  }
  /**
   * Returns defer.
   *
   * @returns Defer.
   */
  get defer() {
    return this.getAttribute("defer") !== null;
  }
  /**
   * Sets defer.
   *
   * @param defer Defer.
   */
  set defer(defer) {
    if (!defer) {
      this.removeAttribute("defer");
    } else {
      this.setAttribute("defer", "");
    }
  }
  /**
   * Returns text.
   *
   * @returns Text.
   */
  get text() {
    return this.textContent;
  }
  /**
   * Sets text.
   *
   * @param text Text.
   */
  set text(text2) {
    this.textContent = text2;
  }
  /**
   * @override
   */
  [(_HTMLScriptElement_scriptLoader = /* @__PURE__ */ new WeakMap(), _a$e = evaluateScript, cloneNode)](deep = false) {
    return super[cloneNode](deep);
  }
  /**
   * @override
   */
  [connectToNode](parentNode2 = null) {
    const isConnected$1 = this[isConnected];
    const isParentConnected = parentNode2 ? parentNode2[isConnected] : false;
    const browserSettings = WindowBrowserSettingsReader.getSettings(this[ownerDocument][ownerWindow]);
    super[connectToNode](parentNode2);
    if (isParentConnected && isConnected$1 !== isParentConnected && this[evaluateScript]) {
      const src = this.getAttribute("src");
      if (src !== null) {
        __classPrivateFieldGet$h(this, _HTMLScriptElement_scriptLoader, "f").loadScript(src);
      } else if (!browserSettings.disableJavaScriptEvaluation) {
        const textContent = this.textContent;
        const type = this.getAttribute("type");
        if (textContent && (type === null || type === "application/x-ecmascript" || type === "application/x-javascript" || type.startsWith("text/javascript"))) {
          this[ownerDocument][currentScript] = this;
          const code2 = `//# sourceURL=${this[ownerDocument][ownerWindow].location.href}
` + textContent;
          if (browserSettings.disableErrorCapturing || browserSettings.errorCapture !== BrowserErrorCaptureEnum$1.tryAndCatch) {
            this[ownerDocument][ownerWindow].eval(code2);
          } else {
            WindowErrorUtility.captureError(this[ownerDocument][ownerWindow], () => this[ownerDocument][ownerWindow].eval(code2));
          }
          this[ownerDocument][currentScript] = null;
        }
      }
    }
  }
};
var _a$d, _b$6, _c$4, _d$2, _e$2, _f$1, _g;
class HTMLImageElement extends HTMLElement$1 {
  constructor() {
    super(...arguments);
    this[_a$d] = "IMG";
    this[_b$6] = false;
    this[_c$4] = 0;
    this[_d$2] = 0;
    this[_e$2] = "auto";
    this[_f$1] = 0;
    this[_g] = 0;
  }
  /**
   * Returns complete.
   *
   * @returns Complete.
   */
  get complete() {
    return this[complete];
  }
  /**
   * Returns natural height.
   *
   * @returns Natural height.
   */
  get naturalHeight() {
    return this[naturalHeight];
  }
  /**
   * Returns natural width.
   *
   * @returns Natural width.
   */
  get naturalWidth() {
    return this[naturalWidth];
  }
  /**
   * Returns loading.
   *
   * @returns Loading.
   */
  get loading() {
    const loading2 = this.getAttribute("loading");
    return loading2 === "eager" || loading2 === "lazy" ? loading2 : "auto";
  }
  /**
   * Sets loading.
   *
   * @param loading Loading.
   */
  set loading(loading2) {
    this.setAttribute("loading", loading2);
  }
  /**
   * Returns x.
   */
  get x() {
    return this[x];
  }
  /**
   * Returns y.
   */
  get y() {
    return this[y];
  }
  /**
   * Returns decoding.
   *
   * @returns Decoding.
   */
  get decoding() {
    return this.getAttribute("decoding") || "auto";
  }
  /**
   * Sets decoding.
   *
   * @param decoding Decoding.
   */
  set decoding(decoding) {
    this.setAttribute("decoding", decoding);
  }
  /**
   * Returns cross origin.
   *
   * @returns Cross origin.
   */
  get crossOrigin() {
    return this.getAttribute("crossOrigin");
  }
  /**
   * Sets cross origin.
   *
   * @param crossOrigin Cross origin.
   */
  set crossOrigin(crossOrigin) {
    if (crossOrigin === "anonymous" || crossOrigin === "use-credentials") {
      this.setAttribute("crossOrigin", crossOrigin);
    }
  }
  /**
   * Returns alt.
   *
   * @returns Alt.
   */
  get alt() {
    return this.getAttribute("alt") || "";
  }
  /**
   * Sets alt.
   *
   * @param alt Alt.
   */
  set alt(alt) {
    this.setAttribute("alt", alt);
  }
  /**
   * Returns current src.
   *
   * @returns Current src.
   */
  get currentSrc() {
    return this.src;
  }
  /**
   * Returns width.
   *
   * @returns Width.
   */
  get width() {
    const width2 = this.getAttribute("width");
    return width2 !== null ? Number(width2) : 0;
  }
  /**
   * Sets width.
   *
   * @param width Width.
   */
  set width(width2) {
    this.setAttribute("width", String(width2));
  }
  /**
   * Returns height.
   *
   * @returns Height.
   */
  get height() {
    const height2 = this.getAttribute("height");
    return height2 !== null ? Number(height2) : 0;
  }
  /**
   * Sets height.
   *
   * @param height Height.
   */
  set height(height2) {
    this.setAttribute("height", String(height2));
  }
  /**
   * Returns is map.
   *
   * @returns Is map.
   */
  get isMap() {
    return this.getAttribute("ismap") !== null;
  }
  /**
   * Sets is map.
   *
   * @param ismap Is map.
   */
  set isMap(isMap) {
    if (!isMap) {
      this.removeAttribute("ismap");
    } else {
      this.setAttribute("ismap", "");
    }
  }
  /**
   * Returns referrer policy.
   *
   * @returns Referrer policy.
   */
  get referrerPolicy() {
    return this.getAttribute("referrerpolicy") || "";
  }
  /**
   * Sets referrer policy.
   *
   * @param referrerPolicy Referrer policy.
   */
  set referrerPolicy(referrerPolicy) {
    this.setAttribute("referrerpolicy", referrerPolicy);
  }
  /**
   * Returns sizes.
   *
   * @returns Sizes.
   */
  get sizes() {
    return this.getAttribute("sizes") || "";
  }
  /**
   * Sets sizes.
   *
   * @param sizes Sizes.
   */
  set sizes(sizes) {
    this.setAttribute("sizes", sizes);
  }
  /**
   * Returns source.
   *
   * @returns Source.
   */
  get src() {
    if (!this.hasAttribute("src")) {
      return "";
    }
    try {
      return new URL(this.getAttribute("src"), this[ownerDocument].location.href).href;
    } catch (e2) {
      return this.getAttribute("src");
    }
  }
  /**
   * Sets source.
   *
   * @param src Source.
   */
  set src(src) {
    this.setAttribute("src", src);
  }
  /**
   * Returns srcset.
   *
   * @returns Source.
   */
  get srcset() {
    return this.getAttribute("srcset") || "";
  }
  /**
   * Sets src set.
   *
   * @param srcset Src set.
   */
  set srcset(srcset) {
    this.setAttribute("srcset", srcset);
  }
  /**
   * Returns use map.
   *
   * @returns Use map.
   */
  get useMap() {
    return this.getAttribute("usemap") || "";
  }
  /**
   * Sets is map.
   *
   * @param useMap Is map.
   */
  set useMap(useMap) {
    this.setAttribute("usemap", useMap);
  }
  /**
   * The decode() method of the HTMLImageElement interface returns a Promise that resolves when the image is decoded and it is safe to append the image to the DOM.
   *
   * @returns Promise.
   */
  decode() {
    return Promise.resolve();
  }
  /**
   * @override
   */
  [(_a$d = tagName, _b$6 = complete, _c$4 = naturalHeight, _d$2 = naturalWidth, _e$2 = loading, _f$1 = x, _g = y, cloneNode)](deep = false) {
    return super[cloneNode](deep);
  }
}
class CharacterDataUtility {
  /**
   * Appends the given DOMString to the CharacterData.data string; when this method returns, data contains the concatenated DOMString.
   *
   * @param characterData Character data.
   * @param data Data.
   */
  static appendData(characterData, data2) {
    characterData.data += data2;
  }
  /**
   * Removes the specified amount of characters, starting at the specified offset, from the CharacterData.data string; when this method returns, data contains the shortened DOMString.
   *
   * @param characterData Character data.
   * @param offset Offset.
   * @param count Count.
   */
  static deleteData(characterData, offset2, count) {
    characterData.data = characterData.data.substring(0, offset2) + characterData.data.substring(offset2 + count);
  }
  /**
   * Inserts the specified characters, at the specified offset, in the CharacterData.data string; when this method returns, data contains the modified DOMString.
   *
   * @param characterData Character data.
   * @param offset Offset.
   * @param data Data.
   */
  static insertData(characterData, offset2, data2) {
    characterData.data = characterData.data.substring(0, offset2) + data2 + characterData.data.substring(offset2);
  }
  /**
   * Replaces the specified amount of characters, starting at the specified offset, with the specified DOMString; when this method returns, data contains the modified DOMString.
   *
   * @param characterData Character data.
   * @param offset Offset.
   * @param count Count.
   * @param data Data.
   */
  static replaceData(characterData, offset2, count, data2) {
    characterData.data = characterData.data.substring(0, offset2) + data2 + characterData.data.substring(offset2 + count);
  }
  /**
   * Returns a DOMString containing the part of CharacterData.data of the specified length and starting at the specified offset.
   *
   * @param characterData Character data.
   * @param offset Offset.
   * @param count Count.
   */
  static substringData(characterData, offset2, count) {
    return characterData.data.substring(offset2, offset2 + count);
  }
}
var _a$c;
class CharacterData extends Node2 {
  /**
   * Constructor.
   *
   * @param [data] Data.
   */
  constructor(data$1) {
    super();
    this[_a$c] = "";
    if (data$1) {
      this[data] = data$1;
    }
  }
  /**
   * Returns text content.
   *
   * @returns Text content.
   */
  get length() {
    return this[data].length;
  }
  /**
   * Returns text content.
   *
   * @returns Text content.
   */
  get data() {
    return this[data];
  }
  /**
   * Sets text content.
   *
   * @param textContent Text content.
   */
  set data(data$1) {
    var _a2;
    const oldValue = this[data];
    this[data] = String(data$1);
    if (this[isConnected]) {
      this[ownerDocument][cacheID]++;
    }
    if (this[observers].length > 0) {
      for (const observer of this[observers]) {
        if ((_a2 = observer.options) == null ? void 0 : _a2.characterData) {
          observer.report(new MutationRecord({
            target: this,
            type: MutationTypeEnum$1.characterData,
            oldValue: observer.options.characterDataOldValue ? oldValue : null
          }));
        }
      }
    }
  }
  /**
   * Returns text content.
   *
   * @returns Text content.
   */
  get textContent() {
    return this[data];
  }
  /**
   * Sets text content.
   *
   * @param textContent Text content.
   */
  set textContent(textContent) {
    this.data = textContent;
  }
  /**
   * Returns node value.
   *
   * @returns Node value.
   */
  get nodeValue() {
    return this[data];
  }
  /**
   * Sets node value.
   *
   * @param nodeValue Node value.
   */
  set nodeValue(nodeValue) {
    this.textContent = nodeValue;
  }
  /**
   * Previous element sibling.
   *
   * @returns Element.
   */
  get previousElementSibling() {
    return NonDocumentChildNodeUtility.previousElementSibling(this);
  }
  /**
   * Next element sibling.
   *
   * @returns Element.
   */
  get nextElementSibling() {
    return NonDocumentChildNodeUtility.nextElementSibling(this);
  }
  /**
   * Appends the given DOMString to the CharacterData.data string; when this method returns, data contains the concatenated DOMString.
   *
   * @param data Data.
   */
  appendData(data2) {
    CharacterDataUtility.appendData(this, data2);
  }
  /**
   * Removes the specified amount of characters, starting at the specified offset, from the CharacterData.data string; when this method returns, data contains the shortened DOMString.
   *
   * @param offset Offset.
   * @param count Count.
   */
  deleteData(offset2, count) {
    CharacterDataUtility.deleteData(this, offset2, count);
  }
  /**
   * Inserts the specified characters, at the specified offset, in the CharacterData.data string; when this method returns, data contains the modified DOMString.
   *
   * @param offset Offset.
   * @param data Data.
   */
  insertData(offset2, data2) {
    CharacterDataUtility.insertData(this, offset2, data2);
  }
  /**
   * Replaces the specified amount of characters, starting at the specified offset, with the specified DOMString; when this method returns, data contains the modified DOMString.
   *
   * @param offset Offset.
   * @param count Count.
   * @param data Data.
   */
  replaceData(offset2, count, data2) {
    CharacterDataUtility.replaceData(this, offset2, count, data2);
  }
  /**
   * Returns a DOMString containing the part of CharacterData.data of the specified length and starting at the specified offset.
   *
   * @param offset Offset.
   * @param count Count.
   */
  substringData(offset2, count) {
    return CharacterDataUtility.substringData(this, offset2, count);
  }
  /**
   * Removes the object from its parent children list.
   */
  remove() {
    ChildNodeUtility.remove(this);
  }
  /**
   * The Node.replaceWith() method replaces this Node in the children list of its parent with a set of Node or DOMString objects.
   *
   * @param nodes List of Node or DOMString.
   */
  replaceWith(...nodes) {
    ChildNodeUtility.replaceWith(this, ...nodes);
  }
  /**
   * Inserts a set of Node or DOMString objects in the children list of this ChildNode's parent, just before this ChildNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param nodes List of Node or DOMString.
   */
  before(...nodes) {
    ChildNodeUtility.before(this, ...nodes);
  }
  /**
   * Inserts a set of Node or DOMString objects in the children list of this ChildNode's parent, just after this ChildNode. DOMString objects are inserted as equivalent Text nodes.
   *
   * @param nodes List of Node or DOMString.
   */
  after(...nodes) {
    ChildNodeUtility.after(this, ...nodes);
  }
  /**
   * @override
   */
  [(_a$c = data, cloneNode)](deep = false) {
    const clone2 = super[cloneNode](deep);
    clone2[data] = this[data];
    return clone2;
  }
}
class CustomEvent extends Event {
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type, eventInit = null) {
    super(type, eventInit);
    this.detail = (eventInit == null ? void 0 : eventInit.detail) ?? null;
  }
  /**
   * Init event.
   *
   * @deprecated
   * @param type Type.
   * @param [bubbles=false] "true" if it bubbles.
   * @param [cancelable=false] "true" if it cancelable.
   * @param [detail=null] Custom event detail.
   */
  initCustomEvent(type, bubbles = false, cancelable = false, detail = null) {
    this.type = type;
    this.bubbles = bubbles;
    this.cancelable = cancelable;
    this.detail = detail;
  }
}
class AnimationEvent extends Event {
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type, eventInit = null) {
    super(type, eventInit);
    this.animationName = (eventInit == null ? void 0 : eventInit.animationName) ?? "";
    this.elapsedTime = (eventInit == null ? void 0 : eventInit.elapsedTime) ?? 0;
    this.pseudoElement = (eventInit == null ? void 0 : eventInit.pseudoElement) ?? "";
  }
}
class KeyboardEvent extends UIEvent {
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type, eventInit = null) {
    super(type, eventInit);
    this.altKey = (eventInit == null ? void 0 : eventInit.altKey) ?? false;
    this.code = (eventInit == null ? void 0 : eventInit.code) ?? "";
    this.ctrlKey = (eventInit == null ? void 0 : eventInit.ctrlKey) ?? false;
    this.isComposing = (eventInit == null ? void 0 : eventInit.isComposing) ?? false;
    this.key = (eventInit == null ? void 0 : eventInit.key) ?? "";
    this.location = (eventInit == null ? void 0 : eventInit.location) ?? 0;
    this.metaKey = (eventInit == null ? void 0 : eventInit.metaKey) ?? false;
    this.repeat = (eventInit == null ? void 0 : eventInit.repeat) ?? false;
    this.shiftKey = (eventInit == null ? void 0 : eventInit.shiftKey) ?? false;
    this.keyCode = (eventInit == null ? void 0 : eventInit.keyCode) ?? 0;
  }
}
KeyboardEvent.DOM_KEY_LOCATION_STANDARD = 0;
KeyboardEvent.DOM_KEY_LOCATION_LEFT = 1;
KeyboardEvent.DOM_KEY_LOCATION_RIGHT = 2;
KeyboardEvent.DOM_KEY_LOCATION_NUMPAD = 3;
class MessageEvent extends Event {
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type, eventInit = null) {
    super(type, eventInit);
    this.data = (eventInit == null ? void 0 : eventInit.data) ?? null;
    this.origin = (eventInit == null ? void 0 : eventInit.origin) ?? "";
    this.lastEventId = (eventInit == null ? void 0 : eventInit.lastEventId) ?? "";
    this.source = (eventInit == null ? void 0 : eventInit.source) ?? null;
    this.ports = (eventInit == null ? void 0 : eventInit.ports) ?? [];
  }
}
class ProgressEvent extends Event {
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type, eventInit = null) {
    super(type);
    this.lengthComputable = (eventInit == null ? void 0 : eventInit.lengthComputable) ?? false;
    this.loaded = (eventInit == null ? void 0 : eventInit.loaded) ?? 0;
    this.total = (eventInit == null ? void 0 : eventInit.total) ?? 0;
  }
}
class HashChangeEvent extends Event {
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type, eventInit = null) {
    super(type, eventInit);
    this.newURL = (eventInit == null ? void 0 : eventInit.newURL) ?? "";
    this.oldURL = (eventInit == null ? void 0 : eventInit.oldURL) ?? "";
  }
}
class TouchEvent extends UIEvent {
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type, eventInit = null) {
    super(type, eventInit);
    this.altKey = (eventInit == null ? void 0 : eventInit.altKey) ?? false;
    this.changedTouches = (eventInit == null ? void 0 : eventInit.changedTouches) ?? [];
    this.ctrlKey = (eventInit == null ? void 0 : eventInit.ctrlKey) ?? false;
    this.metaKey = (eventInit == null ? void 0 : eventInit.metaKey) ?? false;
    this.shiftKey = (eventInit == null ? void 0 : eventInit.shiftKey) ?? false;
    this.targetTouches = (eventInit == null ? void 0 : eventInit.targetTouches) ?? [];
    this.touches = (eventInit == null ? void 0 : eventInit.touches) ?? [];
  }
}
class Touch {
  /**
   * Constructor.
   *
   * @param [touchInit] Touch init.
   */
  constructor(touchInit) {
    this.identifier = touchInit.identifier;
    this.target = touchInit.target;
    this.clientX = touchInit.clientX ?? 0;
    this.clientY = touchInit.clientY ?? 0;
    this.screenX = touchInit.screenX ?? 0;
    this.screenY = touchInit.screenY ?? 0;
    this.pageX = touchInit.pageX ?? 0;
    this.pageY = touchInit.pageY ?? 0;
    this.radiusX = touchInit.radiusX ?? 0;
    this.radiusY = touchInit.radiusY ?? 0;
    this.rotationAngle = touchInit.rotationAngle ?? 0;
    this.force = touchInit.force ?? 0;
  }
}
class MessagePort extends EventTarget {
  /**
   * Sends a message from the port, and optionally, transfers ownership of objects to other browsing contexts.
   *
   * @param _message Message.
   * @param _transerList Transfer list.
   */
  postMessage(_message, _transerList) {
  }
  /**
   * Starts the sending of messages queued on the port.
   */
  start() {
  }
  /**
   * Disconnects the port, so it is no longer active. This stops the flow of messages to that port.
   */
  close() {
  }
}
let URL$1 = class URL20 extends URL_1 {
  /**
   * Creates a string containing a URL representing the object given in the parameter.
   *
   * @param object Object.
   * @returns URL.
   */
  static createObjectURL(object) {
    if (object instanceof Blob) {
      const blob = new Blob([object[buffer]], { type: object.type });
      return super.createObjectURL(blob);
    }
    return super.createObjectURL(object);
  }
};
var __classPrivateFieldSet$e = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$g = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Location_browserFrame, _Location_url, _a$b;
class Location {
  /**
   * Constructor.
   *
   * @param browserFrame Browser frame.
   * @param url URL.
   */
  constructor(browserFrame, url) {
    this[_a$b] = "Location";
    _Location_browserFrame.set(this, void 0);
    _Location_url.set(this, void 0);
    __classPrivateFieldSet$e(this, _Location_browserFrame, browserFrame, "f");
    __classPrivateFieldSet$e(this, _Location_url, new URL_1(url), "f");
  }
  /**
   * Returns hash.
   *
   * @returns Hash.
   */
  get hash() {
    return __classPrivateFieldGet$g(this, _Location_url, "f").hash;
  }
  /**
   * Sets hash.
   *
   * @param hash Value.
   */
  set hash(hash2) {
    var _a2;
    const oldURL = __classPrivateFieldGet$g(this, _Location_url, "f").href;
    __classPrivateFieldGet$g(this, _Location_url, "f").hash = hash2;
    const newURL = __classPrivateFieldGet$g(this, _Location_url, "f").href;
    if (newURL !== oldURL) {
      (_a2 = __classPrivateFieldGet$g(this, _Location_browserFrame, "f").window) == null ? void 0 : _a2.dispatchEvent(new HashChangeEvent("hashchange", { oldURL, newURL }));
    }
  }
  /**
   * Returns host.
   *
   * @returns Host.
   */
  get host() {
    return __classPrivateFieldGet$g(this, _Location_url, "f").host;
  }
  /**
   * Sets host.
   *
   * @param host Value.
   */
  set host(host2) {
    const url = new URL_1(__classPrivateFieldGet$g(this, _Location_url, "f").href);
    url.host = host2;
    __classPrivateFieldGet$g(this, _Location_browserFrame, "f").goto(url.href).catch((error2) => __classPrivateFieldGet$g(this, _Location_browserFrame, "f").page.console.error(error2));
  }
  /**
   * Returns hostname.
   *
   * @returns Hostname.
   */
  get hostname() {
    return __classPrivateFieldGet$g(this, _Location_url, "f").hostname;
  }
  /**
   * Sets hostname.
   *
   * @param hostname Value.
   */
  set hostname(hostname) {
    const url = new URL_1(__classPrivateFieldGet$g(this, _Location_url, "f").href);
    url.hostname = hostname;
    __classPrivateFieldGet$g(this, _Location_browserFrame, "f").goto(url.href).catch((error2) => __classPrivateFieldGet$g(this, _Location_browserFrame, "f").page.console.error(error2));
  }
  /**
   * Override set href.
   */
  get href() {
    return __classPrivateFieldGet$g(this, _Location_url, "f").href;
  }
  /**
   * Override set href.
   */
  set href(url) {
    __classPrivateFieldGet$g(this, _Location_browserFrame, "f").goto(url).catch((error2) => __classPrivateFieldGet$g(this, _Location_browserFrame, "f").page.console.error(error2));
  }
  /**
   * Returns origin.
   *
   * @returns Origin.
   */
  get origin() {
    return __classPrivateFieldGet$g(this, _Location_url, "f").origin;
  }
  /**
   * Returns pathname
   *
   * @returns Pathname.
   */
  get pathname() {
    return __classPrivateFieldGet$g(this, _Location_url, "f").pathname;
  }
  /**
   * Sets pathname.
   *
   * @param pathname Value.
   */
  set pathname(pathname) {
    const url = new URL_1(__classPrivateFieldGet$g(this, _Location_url, "f").href);
    url.pathname = pathname;
    __classPrivateFieldGet$g(this, _Location_browserFrame, "f").goto(url.href).catch((error2) => __classPrivateFieldGet$g(this, _Location_browserFrame, "f").page.console.error(error2));
  }
  /**
   * Returns port.
   *
   * @returns Port.
   */
  get port() {
    return __classPrivateFieldGet$g(this, _Location_url, "f").port;
  }
  /**
   * Sets port.
   *
   * @param port Value.
   */
  set port(port) {
    const url = new URL_1(__classPrivateFieldGet$g(this, _Location_url, "f").href);
    url.port = port;
    __classPrivateFieldGet$g(this, _Location_browserFrame, "f").goto(url.href).catch((error2) => __classPrivateFieldGet$g(this, _Location_browserFrame, "f").page.console.error(error2));
  }
  /**
   * Returns protocol.
   *
   * @returns Protocol.
   */
  get protocol() {
    return __classPrivateFieldGet$g(this, _Location_url, "f").protocol;
  }
  /**
   * Sets protocol.
   *
   * @param protocol Value.
   */
  set protocol(protocol) {
    const url = new URL_1(__classPrivateFieldGet$g(this, _Location_url, "f").href);
    url.protocol = protocol;
    __classPrivateFieldGet$g(this, _Location_browserFrame, "f").goto(url.href).catch((error2) => __classPrivateFieldGet$g(this, _Location_browserFrame, "f").page.console.error(error2));
  }
  /**
   * Returns search.
   *
   * @returns Search.
   */
  get search() {
    return __classPrivateFieldGet$g(this, _Location_url, "f").search;
  }
  /**
   * Sets search.
   *
   * @param search Value.
   */
  set search(search) {
    const url = new URL_1(__classPrivateFieldGet$g(this, _Location_url, "f").href);
    url.search = search;
    __classPrivateFieldGet$g(this, _Location_browserFrame, "f").goto(url.href).catch((error2) => __classPrivateFieldGet$g(this, _Location_browserFrame, "f").page.console.error(error2));
  }
  /**
   * Replaces the current resource with the one at the provided URL. The difference from the assign() method is that after using replace() the current page will not be saved in session History, meaning the user won't be able to use the back button to navigate to it.
   *
   * @param url URL.
   */
  replace(url) {
    this.href = url;
  }
  /**
   * Loads the resource at the URL provided in parameter.
   *
   * @param url URL.
   */
  assign(url) {
    this.href = url;
  }
  /**
   * Reloads the resource from the current URL.
   */
  reload() {
    __classPrivateFieldGet$g(this, _Location_browserFrame, "f").goto(this.href).catch((error2) => __classPrivateFieldGet$g(this, _Location_browserFrame, "f").page.console.error(error2));
  }
  /**
   * Replaces the current URL state with the provided one without navigating to the new URL.
   *
   * @param browserFrame Browser frame that must match the current one as validation.
   * @param url URL.
   */
  [(_Location_browserFrame = /* @__PURE__ */ new WeakMap(), _Location_url = /* @__PURE__ */ new WeakMap(), _a$b = Symbol.toStringTag, setURL)](browserFrame, url) {
    if (__classPrivateFieldGet$g(this, _Location_browserFrame, "f") !== browserFrame) {
      throw new Error("Failed to set URL. Browser frame mismatch.");
    }
    __classPrivateFieldGet$g(this, _Location_url, "f").href = url;
  }
  /**
   * Returns the URL as a string.
   *
   * @returns URL as a string.
   */
  toString() {
    return __classPrivateFieldGet$g(this, _Location_url, "f").toString();
  }
}
var __classPrivateFieldSet$d = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$f = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MutationListener_window, _MutationListener_observer, _MutationListener_callback, _MutationListener_records, _MutationListener_immediate;
class MutationListener {
  /**
   * Constructor.
   *
   * @param init Options.
   * @param init.window Window.
   * @param init.options Options.
   * @param init.target Target.
   * @param init.observer Observer.
   * @param init.callback Callback.
   */
  constructor(init) {
    _MutationListener_window.set(this, void 0);
    _MutationListener_observer.set(this, void 0);
    _MutationListener_callback.set(this, void 0);
    _MutationListener_records.set(this, []);
    _MutationListener_immediate.set(this, null);
    this.options = init.options;
    this.target = init.target;
    __classPrivateFieldSet$d(this, _MutationListener_window, init.window, "f");
    __classPrivateFieldSet$d(this, _MutationListener_observer, init.observer, "f");
    __classPrivateFieldSet$d(this, _MutationListener_callback, init.callback, "f");
  }
  /**
   * Reports mutations.
   *
   * @param record Record.
   */
  report(record) {
    if (!__classPrivateFieldGet$f(this, _MutationListener_records, "f")) {
      return;
    }
    __classPrivateFieldGet$f(this, _MutationListener_records, "f").push(record);
    if (__classPrivateFieldGet$f(this, _MutationListener_immediate, "f")) {
      __classPrivateFieldGet$f(this, _MutationListener_window, "f").cancelAnimationFrame(__classPrivateFieldGet$f(this, _MutationListener_immediate, "f"));
    }
    __classPrivateFieldSet$d(this, _MutationListener_immediate, __classPrivateFieldGet$f(this, _MutationListener_window, "f").requestAnimationFrame(() => {
      const records = __classPrivateFieldGet$f(this, _MutationListener_records, "f");
      if ((records == null ? void 0 : records.length) > 0) {
        __classPrivateFieldSet$d(this, _MutationListener_records, [], "f");
        __classPrivateFieldGet$f(this, _MutationListener_callback, "f").call(this, records, __classPrivateFieldGet$f(this, _MutationListener_observer, "f"));
      }
    }), "f");
  }
  /**
   * Destroys the listener.
   */
  takeRecords() {
    if (__classPrivateFieldGet$f(this, _MutationListener_immediate, "f")) {
      __classPrivateFieldGet$f(this, _MutationListener_window, "f").cancelAnimationFrame(__classPrivateFieldGet$f(this, _MutationListener_immediate, "f"));
    }
    const records = __classPrivateFieldGet$f(this, _MutationListener_records, "f");
    __classPrivateFieldSet$d(this, _MutationListener_records, [], "f");
    return records;
  }
  /**
   * Destroys the listener.
   */
  destroy() {
    if (__classPrivateFieldGet$f(this, _MutationListener_immediate, "f")) {
      __classPrivateFieldGet$f(this, _MutationListener_window, "f").cancelAnimationFrame(__classPrivateFieldGet$f(this, _MutationListener_immediate, "f"));
    }
    this.options = null;
    this.target = null;
    __classPrivateFieldSet$d(this, _MutationListener_observer, null, "f");
    __classPrivateFieldSet$d(this, _MutationListener_callback, null, "f");
    __classPrivateFieldSet$d(this, _MutationListener_immediate, null, "f");
    __classPrivateFieldSet$d(this, _MutationListener_records, null, "f");
  }
}
_MutationListener_window = /* @__PURE__ */ new WeakMap(), _MutationListener_observer = /* @__PURE__ */ new WeakMap(), _MutationListener_callback = /* @__PURE__ */ new WeakMap(), _MutationListener_records = /* @__PURE__ */ new WeakMap(), _MutationListener_immediate = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet$c = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$e = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MutationObserver_callback, _MutationObserver_listeners, _MutationObserver_window;
class MutationObserver {
  /**
   * Constructor.
   *
   * @param callback Callback.
   */
  constructor(callback) {
    _MutationObserver_callback.set(this, void 0);
    _MutationObserver_listeners.set(this, []);
    _MutationObserver_window.set(this, null);
    __classPrivateFieldSet$c(this, _MutationObserver_callback, callback, "f");
  }
  /**
   * Starts observing.
   *
   * @param target Target.
   * @param options Options.
   */
  observe(target2, options2) {
    if (!target2) {
      throw new TypeError(`Failed to execute 'observe' on 'MutationObserver': The first parameter "target" should be of type "Node".`);
    }
    if (options2 && (options2.attributeFilter || options2.attributeOldValue)) {
      if (options2.attributes === void 0) {
        options2 = Object.assign({}, options2, {
          attributes: true,
          attributeFilter: options2.attributeFilter,
          attributeOldValue: options2.attributeOldValue
        });
      }
      if (!options2.attributes && options2.attributeOldValue) {
        throw new TypeError(`Failed to execute 'observe' on 'MutationObserver': The options object may only set 'attributeOldValue' to true when 'attributes' is true or not present.`);
      }
      if (!options2.attributes && options2.attributeFilter) {
        throw new TypeError(`Failed to execute 'observe' on 'MutationObserver': The options object may only set 'attributeFilter' when 'attributes' is true or not present.`);
      }
    }
    if (options2 && options2.characterDataOldValue) {
      if (options2.characterData === void 0) {
        options2 = Object.assign({}, options2, {
          characterData: true,
          characterDataOldValue: options2.characterDataOldValue
        });
      }
      if (!options2.characterData && options2.characterDataOldValue) {
        throw new TypeError(`Failed to execute 'observe' on 'MutationObserver': The options object may only set 'characterDataOldValue' to true when 'characterData' is true or not present.`);
      }
    }
    if (!options2 || !options2.childList && !options2.attributes && !options2.characterData) {
      throw new TypeError(`Failed to execute 'observe' on 'MutationObserver': The options object must set at least one of 'attributes', 'characterData', or 'childList' to true.`);
    }
    if (!__classPrivateFieldGet$e(this, _MutationObserver_window, "f")) {
      __classPrivateFieldSet$c(this, _MutationObserver_window, target2[ownerDocument] ? target2[ownerDocument][ownerWindow] : target2[ownerWindow], "f");
    }
    options2 = Object.assign({}, options2, {
      attributeFilter: options2.attributeFilter ? options2.attributeFilter.map((name2) => name2.toLowerCase()) : null
    });
    for (const listener2 of __classPrivateFieldGet$e(this, _MutationObserver_listeners, "f")) {
      if (listener2.target === target2) {
        listener2.options = options2;
        return;
      }
    }
    const listener = new MutationListener({
      window: __classPrivateFieldGet$e(this, _MutationObserver_window, "f"),
      options: options2,
      callback: __classPrivateFieldGet$e(this, _MutationObserver_callback, "f").bind(this),
      observer: this,
      target: target2
    });
    __classPrivateFieldGet$e(this, _MutationObserver_listeners, "f").push(listener);
    __classPrivateFieldGet$e(this, _MutationObserver_window, "f")[mutationObservers].push(this);
    target2[observe](listener);
  }
  /**
   * Disconnects.
   */
  disconnect() {
    if (__classPrivateFieldGet$e(this, _MutationObserver_listeners, "f").length === 0) {
      return;
    }
    const mutationObservers$1 = __classPrivateFieldGet$e(this, _MutationObserver_window, "f")[mutationObservers];
    const index = mutationObservers$1.indexOf(this);
    if (index !== -1) {
      mutationObservers$1.splice(index, 1);
    }
    for (const listener of __classPrivateFieldGet$e(this, _MutationObserver_listeners, "f")) {
      listener.target[unobserve](listener);
      listener.destroy();
    }
    __classPrivateFieldSet$c(this, _MutationObserver_listeners, [], "f");
  }
  /**
   * Returns a list of all matching DOM changes that have been detected but not yet processed by the observer's callback function, leaving the mutation queue empty.
   *
   * @returns Records.
   */
  takeRecords() {
    let records = [];
    for (const listener of __classPrivateFieldGet$e(this, _MutationObserver_listeners, "f")) {
      records = records.concat(listener.takeRecords());
    }
    return records;
  }
}
_MutationObserver_callback = /* @__PURE__ */ new WeakMap(), _MutationObserver_listeners = /* @__PURE__ */ new WeakMap(), _MutationObserver_window = /* @__PURE__ */ new WeakMap();
class ResizeObserver {
  /**
   * Starts observing.
   *
   * Not implemented.
   */
  observe() {
  }
  /**
   * Stops observing.
   *
   * Not implemented.
   */
  unobserve() {
  }
  /**
   * Disconnects.
   *
   * Not implemented.
   */
  disconnect() {
  }
}
var HistoryScrollRestorationEnum;
(function(HistoryScrollRestorationEnum2) {
  HistoryScrollRestorationEnum2["auto"] = "auto";
  HistoryScrollRestorationEnum2["manual"] = "manual";
})(HistoryScrollRestorationEnum || (HistoryScrollRestorationEnum = {}));
const HistoryScrollRestorationEnum$1 = HistoryScrollRestorationEnum;
var __classPrivateFieldGet$d = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$b = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var _History_scrollRestoration;
class History {
  constructor() {
    this.length = 0;
    this.state = null;
    _History_scrollRestoration.set(this, HistoryScrollRestorationEnum$1.auto);
  }
  /**
   * Returns scroll restoration.
   *
   * @returns Sroll restoration.
   */
  get scrollRestoration() {
    return __classPrivateFieldGet$d(this, _History_scrollRestoration, "f");
  }
  /**
   * Sets scroll restoration.
   *
   * @param scrollRestoration Sroll restoration.
   */
  set scrollRestoration(scrollRestoration) {
    __classPrivateFieldSet$b(this, _History_scrollRestoration, HistoryScrollRestorationEnum$1[scrollRestoration] ? scrollRestoration : __classPrivateFieldGet$d(this, _History_scrollRestoration, "f"), "f");
  }
  /**
   * Goes to the previous page in session history.
   */
  back() {
  }
  /**
   * Goes to the next page in session history.
   */
  forward() {
  }
  /**
   * Load a specific page from the session history.
   *
   * @param delta Delta.
   * @param _delta
   */
  go(_delta) {
  }
  /**
   * Pushes the given data onto the session history stack.
   *
   * @param state State.
   * @param title Title.
   * @param [url] URL.
   * @param _state
   * @param _title
   * @param _url
   */
  pushState(_state, _title, _url) {
  }
  /**
   * This method modifies the current history entry, replacing it with a new state.
   *
   * @param state State.
   * @param title Title.
   * @param [url] URL.
   * @param _state
   * @param _title
   * @param _url
   */
  replaceState(_state, _title, _url) {
  }
}
_History_scrollRestoration = /* @__PURE__ */ new WeakMap();
class CSSEscaper {
  /**
   * Escapes CSS.
   *
   * Based on:
   * https://github.com/mathiasbynens/CSS.escape
   *
   * @param cssText CSS.
   * @returns Escaped CSS.
   */
  static escape(cssText2) {
    if (arguments.length == 0) {
      throw new TypeError("`CSS.escape` requires an argument.");
    }
    const returnValue2 = String(cssText2);
    const length2 = returnValue2.length;
    let index = -1;
    let codeUnit;
    let result = "";
    const firstCodeUnit = returnValue2.charCodeAt(0);
    if (
      // If the character is the first character and is a `-` (U+002D), and
      // There is no second character, []
      length2 == 1 && firstCodeUnit == 45
    ) {
      return "\\" + returnValue2;
    }
    while (++index < length2) {
      codeUnit = returnValue2.charCodeAt(index);
      if (codeUnit == 0) {
        result += "";
        continue;
      }
      if (
        // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
        // U+007F, []
        codeUnit >= 1 && codeUnit <= 31 || codeUnit == 127 || // If the character is the first character and is in the range [0-9]
        // (U+0030 to U+0039), []
        index == 0 && codeUnit >= 48 && codeUnit <= 57 || // If the character is the second character and is in the range [0-9]
        // (U+0030 to U+0039) and the first character is a `-` (U+002D), []
        index == 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit == 45
      ) {
        result += "\\" + codeUnit.toString(16) + " ";
        continue;
      }
      if (codeUnit >= 128 || codeUnit == 45 || codeUnit == 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
        result += returnValue2.charAt(index);
        continue;
      }
      result += "\\" + returnValue2.charAt(index);
    }
    return result;
  }
}
const CSSUnits = [
  "Hz",
  "Q",
  "ch",
  "cm",
  "deg",
  "dpcm",
  "dpi",
  "dppx",
  "em",
  "ex",
  "fr",
  "grad",
  "in",
  "kHz",
  "mm",
  "ms",
  "number",
  "pc",
  "percent",
  "pt",
  "px",
  "rad",
  "rem",
  "s",
  "turn",
  "vh",
  "vmax",
  "vmin",
  "vw"
];
class CSSUnitValue {
  /**
   * Constructor.
   *
   * @param value Value.
   * @param unit Unit.
   */
  constructor(value2, unit) {
    this.unit = null;
    this.value = null;
    if (typeof value2 !== "number") {
      throw new TypeError("The provided double value is non-finite");
    }
    if (!CSSUnits.includes(unit)) {
      throw new TypeError("Invalid unit: " + unit);
    }
    this.value = value2;
    this.unit = unit;
  }
}
class CSS {
  /**
   * Constructor.
   */
  constructor() {
    for (const unit of CSSUnits) {
      this[unit] = (value2) => new CSSUnitValue(value2, unit);
    }
  }
  /**
   * Returns a Boolean indicating if the pair property-value, or the condition, given in parameter is supported.
   *
   * TODO: Always returns "true" for now, but it should probably be improved in the future.
   *
   * @param _condition Property name or condition.
   * @param [_value] Value when using property name.
   * @returns "true" if supported.
   */
  supports(_condition, _value) {
    return true;
  }
  /**
   * Escapes a value.
   *
   * @param value Value to escape.
   * @returns Escaped string.
   */
  escape(value2) {
    return CSSEscaper.escape(value2);
  }
}
var __classPrivateFieldGet$c = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$a = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var _CSSFontFaceRule_style, _a$a;
class CSSFontFaceRule extends CSSRule {
  constructor() {
    super(...arguments);
    this.type = CSSRule.FONT_FACE_RULE;
    this[_a$a] = "";
    _CSSFontFaceRule_style.set(this, null);
  }
  /**
   * Returns style.
   *
   * @returns Style.
   */
  get style() {
    if (!__classPrivateFieldGet$c(this, _CSSFontFaceRule_style, "f")) {
      __classPrivateFieldSet$a(this, _CSSFontFaceRule_style, new CSSStyleDeclaration(), "f");
      __classPrivateFieldGet$c(this, _CSSFontFaceRule_style, "f").parentRule = this;
      __classPrivateFieldGet$c(this, _CSSFontFaceRule_style, "f").cssText = this[cssText];
    }
    return __classPrivateFieldGet$c(this, _CSSFontFaceRule_style, "f");
  }
}
_CSSFontFaceRule_style = /* @__PURE__ */ new WeakMap(), _a$a = cssText;
class WheelEvent extends UIEvent {
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type, eventInit = null) {
    super(type, eventInit);
    this.deltaX = (eventInit == null ? void 0 : eventInit.deltaX) ?? 0;
    this.deltaY = (eventInit == null ? void 0 : eventInit.deltaY) ?? 0;
    this.deltaZ = (eventInit == null ? void 0 : eventInit.deltaZ) ?? 0;
    this.deltaMode = (eventInit == null ? void 0 : eventInit.deltaMode) ?? 0;
  }
}
WheelEvent.DOM_DELTA_PIXEL = 0;
WheelEvent.DOM_DELTA_LINE = 1;
WheelEvent.DOM_DELTA_PAGE = 2;
var __classPrivateFieldSet$9 = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$b = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DataTransferItem_item;
class DataTransferItem {
  /**
   * Constructor.
   *
   * @param item Item.
   * @param type Type.
   */
  constructor(item2, type = "") {
    _DataTransferItem_item.set(this, null);
    this.kind = typeof item2 === "string" ? "string" : "file";
    this.type = this.kind === "string" ? type : item2.type;
    __classPrivateFieldSet$9(this, _DataTransferItem_item, item2, "f");
  }
  /**
   * Returns file.
   */
  getAsFile() {
    if (this.kind === "string") {
      return null;
    }
    return __classPrivateFieldGet$b(this, _DataTransferItem_item, "f");
  }
  /**
   * Returns string.
   *
   * @param callback Callback.
   */
  getAsString(callback) {
    if (this.kind === "file") ;
    callback(__classPrivateFieldGet$b(this, _DataTransferItem_item, "f"));
  }
}
_DataTransferItem_item = /* @__PURE__ */ new WeakMap();
class DataTransferItemList extends Array {
  /**
   * Adds an item.
   *
   * @param item Item.
   * @param type Type.
   */
  add(item2, type) {
    if (item2 instanceof File) {
      this.push(new DataTransferItem(item2));
      return;
    }
    if (!type) {
      throw new TypeError(`Failed to execute 'add' on 'DataTransferItemList': parameter 1 is not of type 'File'.`);
    }
    this.push(new DataTransferItem(item2, type));
  }
  /**
   * Removes an item.
   *
   * @param index Index.
   */
  remove(index) {
    this.splice(index, 1);
  }
  /**
   * Clears list.
   */
  clear() {
    while (this.length) {
      this.pop();
    }
  }
}
class DataTransfer {
  constructor() {
    this.dropEffect = "none";
    this.effectAllowed = "none";
    this.items = new DataTransferItemList();
  }
  /**
   * Returns files.
   *
   * @returns Files.
   */
  get files() {
    const files2 = [];
    for (const item2 of this.items) {
      if (item2.kind === "file") {
        files2.push(item2.getAsFile());
      }
    }
    return files2;
  }
  /**
   * Returns types.
   *
   * @returns Types.
   */
  get types() {
    return this.items.map((item2) => item2.type);
  }
  /**
   * Clears the data.
   */
  clearData() {
    this.items.clear();
  }
  /**
   * Sets the data.
   *
   * @param format Format.
   * @param data Data.
   */
  setData(format2, data2) {
    for (let i = 0, max2 = this.items.length; i < max2; i++) {
      if (this.items[i].type === format2) {
        this.items[i] = new DataTransferItem(data2, format2);
        return;
      }
    }
    this.items.add(data2, format2);
  }
  /**
   * Gets the data.
   *
   * @param format Format.
   * @returns Data.
   */
  getData(format2) {
    for (let i = 0, max2 = this.items.length; i < max2; i++) {
      if (this.items[i].type === format2) {
        let data2 = "";
        this.items[i].getAsString((s2) => data2 = s2);
        return data2;
      }
    }
    return "";
  }
  /**
   * Sets drag image.
   *
   * TODO: Implement.
   */
  setDragImage() {
    throw new Error("Not implemented.");
  }
}
class InputEvent extends UIEvent {
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type, eventInit = null) {
    super(type, eventInit);
    this.data = (eventInit == null ? void 0 : eventInit.data) ?? "";
    this.dataTransfer = (eventInit == null ? void 0 : eventInit.dataTransfer) ?? null;
    this.inputType = (eventInit == null ? void 0 : eventInit.inputType) ?? "";
    this.isComposing = (eventInit == null ? void 0 : eventInit.isComposing) ?? false;
  }
}
class StorageEvent extends Event {
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type, eventInit = null) {
    super(type);
    this.key = (eventInit == null ? void 0 : eventInit.key) ?? null;
    this.oldValue = (eventInit == null ? void 0 : eventInit.oldValue) ?? null;
    this.newValue = (eventInit == null ? void 0 : eventInit.newValue) ?? null;
    this.url = (eventInit == null ? void 0 : eventInit.url) ?? "";
    this.storageArea = (eventInit == null ? void 0 : eventInit.storageArea) ?? null;
  }
}
class Screen {
  constructor() {
    this.width = 1024;
    this.height = 768;
    this.availWidth = 1024;
    this.availHeight = 768;
    this.colorDepth = 24;
    this.pixelDepth = 24;
  }
}
var _a$9;
class Storage {
  constructor() {
    this[_a$9] = {};
  }
  /**
   * Returns length.
   *
   * @returns Length.
   */
  get length() {
    return Object.keys(this[data]).length;
  }
  /**
   * Returns name of the nth key.
   *
   * @param index Index.
   * @returns Name.
   */
  key(index) {
    const name2 = Object.keys(this[data])[index];
    return name2 !== void 0 ? name2 : null;
  }
  /**
   * Sets item.
   *
   * @param name Name.
   * @param item Item.
   */
  setItem(name2, item2) {
    this[data][name2] = String(item2);
  }
  /**
   * Returns item.
   *
   * @param name Name.
   * @returns Item.
   */
  getItem(name2) {
    return this[data][name2] !== void 0 ? this[data][name2] : null;
  }
  /**
   * Removes item.
   *
   * @param name Name.
   */
  removeItem(name2) {
    delete this[data][name2];
  }
  /**
   * Clears storage.
   */
  clear() {
    this[data] = {};
  }
}
_a$9 = data;
class StorageFactory {
  /**
   * Creates a new storage.
   */
  static createStorage() {
    return new Proxy(new Storage(), {
      get(storage, key) {
        if (Storage.prototype.hasOwnProperty(key)) {
          const descriptor = Object.getOwnPropertyDescriptor(Storage.prototype, key);
          if (descriptor.value !== void 0) {
            if (typeof descriptor.value === "function") {
              return storage[key].bind(storage);
            }
            return descriptor.value;
          }
          if (descriptor.get) {
            return descriptor.get.call(storage);
          }
          return storage[key];
        }
        return storage[data][key];
      },
      set(storage, key, value2) {
        if (Storage.prototype.hasOwnProperty(key)) {
          return true;
        }
        storage[data][key] = String(value2);
        return true;
      },
      deleteProperty(storage, key) {
        if (Storage.prototype.hasOwnProperty(key)) {
          return true;
        }
        return delete storage[data][key];
      },
      ownKeys(storage) {
        return Object.keys(storage[data]);
      },
      has(storage, key) {
        return storage[data][key] !== void 0;
      },
      defineProperty(storage, key, descriptor) {
        if (Storage.prototype.hasOwnProperty(key)) {
          if (descriptor.get || descriptor.set) {
            Object.defineProperty(storage, key, {
              ...descriptor,
              get: descriptor.get ? descriptor.get.bind(storage) : void 0,
              set: descriptor.set ? descriptor.set.bind(storage) : void 0
            });
          } else {
            Object.defineProperty(storage, key, {
              ...descriptor,
              value: typeof descriptor.value === "function" ? descriptor.value.bind(storage) : descriptor.value
            });
          }
          return true;
        }
        if (descriptor.value === void 0) {
          return false;
        }
        storage[data][key] = String(descriptor.value);
        return true;
      },
      getOwnPropertyDescriptor(storage, key) {
        if (Storage.prototype.hasOwnProperty(key) || storage[data][key] === void 0) {
          return;
        }
        return {
          value: storage[data][key],
          writable: true,
          enumerable: true,
          configurable: true
        };
      }
    });
  }
}
class MimeTypeArray {
  /**
   * Constructor.
   *
   * @param mimeTypes
   */
  constructor(mimeTypes) {
    for (let i = 0, max2 = mimeTypes.length; i < max2; i++) {
      this[i] = mimeTypes[i];
      this[mimeTypes[i].type] = mimeTypes[i];
    }
    this.length = mimeTypes.length;
  }
  /**
   * @param index
   */
  item(index) {
    return this[index] || null;
  }
  /**
   * @param name
   */
  namedItem(name2) {
    return this[name2] || null;
  }
  /**
   * Returns the object as a string.
   *
   * @returns String.
   */
  toString() {
    return "[object MimeTypeArray]";
  }
}
class PluginArray {
  /**
   * Constructor.
   *
   * @param plugins Plugins.
   */
  constructor(plugins) {
    for (let i = 0, max2 = plugins.length; i < max2; i++) {
      this[i] = plugins[i];
      this[plugins[i].name] = plugins[i];
    }
    this.length = plugins.length;
  }
  /**
   * Returns an item.
   *
   * @param index Index.
   * @returns Plugin.
   */
  item(index) {
    return this[index] || null;
  }
  /**
   * Returns an item.
   *
   * @param name Name.
   * @returns Plugin.
   */
  namedItem(name2) {
    return this[name2] || null;
  }
  /**
   * Refreshes the list.
   */
  refresh() {
  }
  /**
   * Returns the object as a string.
   *
   * @returns String.
   */
  toString() {
    return "[object PluginArray]";
  }
}
class PermissionStatus extends EventTarget {
  /**
   * Constructor.
   *
   * @param [state] State.
   */
  constructor(state = "granted") {
    super();
    this.onchange = null;
    this.state = state;
  }
}
var PermissionNameEnum;
(function(PermissionNameEnum2) {
  PermissionNameEnum2["geolocation"] = "geolocation";
  PermissionNameEnum2["notifications"] = "notifications";
  PermissionNameEnum2["push"] = "push";
  PermissionNameEnum2["midi"] = "midi";
  PermissionNameEnum2["camera"] = "camera";
  PermissionNameEnum2["microphone"] = "microphone";
  PermissionNameEnum2["backgroundFetch"] = "background-fetch";
  PermissionNameEnum2["backgroundSync"] = "background-sync";
  PermissionNameEnum2["persistentStorage"] = "persistent-storage";
  PermissionNameEnum2["ambientLightSensor"] = "ambient-light-sensor";
  PermissionNameEnum2["accelerometer"] = "accelerometer";
  PermissionNameEnum2["gyroscope"] = "gyroscope";
  PermissionNameEnum2["magnetometer"] = "magnetometer";
  PermissionNameEnum2["screenWakeLock"] = "screen-wake-lock";
  PermissionNameEnum2["nfc"] = "nfc";
  PermissionNameEnum2["displayCapture"] = "display-capture";
  PermissionNameEnum2["accessibilityEvents"] = "accessibility-events";
  PermissionNameEnum2["clipboardRead"] = "clipboard-read";
  PermissionNameEnum2["clipboardWrite"] = "clipboard-write";
  PermissionNameEnum2["paymentHandler"] = "payment-handler";
  PermissionNameEnum2["idleDetection"] = "idle-detection";
  PermissionNameEnum2["periodicBackgroundSync"] = "periodic-background-sync";
  PermissionNameEnum2["systemWakeLock"] = "system-wake-lock";
  PermissionNameEnum2["storageAccess"] = "storage-access";
  PermissionNameEnum2["windowManagement"] = "window-management";
  PermissionNameEnum2["windowPlacement"] = "window-placement";
  PermissionNameEnum2["localFonts"] = "local-fonts";
  PermissionNameEnum2["topLevelStorageAccess"] = "top-level-storage-access";
})(PermissionNameEnum || (PermissionNameEnum = {}));
const PermissionNameEnum$1 = PermissionNameEnum;
var __classPrivateFieldGet$a = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Permissions_permissionStatus;
class Permissions {
  constructor() {
    _Permissions_permissionStatus.set(this, {});
  }
  /**
   * Returns scroll restoration.
   *
   * @param permissionDescriptor Permission descriptor.
   * @param permissionDescriptor.name Permission name.
   * @param [permissionDescriptor.userVisibleOnly] User visible only.
   * @param [permissionDescriptor.sysex] Sysex.
   * @returns Permission status.
   */
  async query(permissionDescriptor) {
    if (__classPrivateFieldGet$a(this, _Permissions_permissionStatus, "f")[permissionDescriptor.name]) {
      return __classPrivateFieldGet$a(this, _Permissions_permissionStatus, "f")[permissionDescriptor.name];
    }
    if (!Object.values(PermissionNameEnum$1).includes(permissionDescriptor.name)) {
      throw new Error(`Failed to execute 'query' on 'Permissions': Failed to read the 'name' property from 'PermissionDescriptor': The provided value '${permissionDescriptor.name}' is not a valid enum value of type PermissionName.`);
    }
    __classPrivateFieldGet$a(this, _Permissions_permissionStatus, "f")[permissionDescriptor.name] = new PermissionStatus("granted");
    return __classPrivateFieldGet$a(this, _Permissions_permissionStatus, "f")[permissionDescriptor.name];
  }
}
_Permissions_permissionStatus = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet$8 = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$9 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ClipboardItem_data;
class ClipboardItem {
  /**
   * Constructor.
   *
   * @param data Data.
   * @param [options] Options.
   * @param [options.presentationStyle] Presentation style.
   */
  constructor(data2, options2) {
    this.presentationStyle = "unspecified";
    _ClipboardItem_data.set(this, void 0);
    __classPrivateFieldSet$8(this, _ClipboardItem_data, data2, "f");
    if (options2 == null ? void 0 : options2.presentationStyle) {
      this.presentationStyle = options2.presentationStyle;
    }
  }
  /**
   * Returns types.
   *
   * @returns Types.
   */
  get types() {
    return Object.keys(__classPrivateFieldGet$9(this, _ClipboardItem_data, "f"));
  }
  /**
   * Returns data by type.
   *
   * @param type Type.
   * @returns Data.
   */
  async getType(type) {
    if (!__classPrivateFieldGet$9(this, _ClipboardItem_data, "f")[type]) {
      throw new DOMException(`Failed to execute 'getType' on 'ClipboardItem': The type '${type}' was not found`);
    }
    return __classPrivateFieldGet$9(this, _ClipboardItem_data, "f")[type];
  }
}
_ClipboardItem_data = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet$7 = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$8 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Clipboard_ownerWindow, _Clipboard_data;
class Clipboard {
  /**
   * Constructor.
   *
   * @param ownerWindow Owner window.
   */
  constructor(ownerWindow2) {
    _Clipboard_ownerWindow.set(this, void 0);
    _Clipboard_data.set(this, []);
    __classPrivateFieldSet$7(this, _Clipboard_ownerWindow, ownerWindow2, "f");
  }
  /**
   * Returns data.
   *
   * @returns Data.
   */
  async read() {
    const permissionStatus = await __classPrivateFieldGet$8(this, _Clipboard_ownerWindow, "f").navigator.permissions.query({
      name: "clipboard-read"
    });
    if (permissionStatus.state === "denied") {
      throw new DOMException(`Failed to execute 'read' on 'Clipboard': The request is not allowed`);
    }
    return __classPrivateFieldGet$8(this, _Clipboard_data, "f");
  }
  /**
   * Returns text.
   *
   * @returns Text.
   */
  async readText() {
    const permissionStatus = await __classPrivateFieldGet$8(this, _Clipboard_ownerWindow, "f").navigator.permissions.query({
      name: "clipboard-read"
    });
    if (permissionStatus.state === "denied") {
      throw new DOMException(`Failed to execute 'readText' on 'Clipboard': The request is not allowed`);
    }
    let text2 = "";
    for (const item2 of __classPrivateFieldGet$8(this, _Clipboard_data, "f")) {
      if (item2.types.includes("text/plain")) {
        const data2 = await item2.getType("text/plain");
        if (typeof data2 === "string") {
          text2 += data2;
        } else {
          text2 += await data2.text();
        }
      }
    }
    return text2;
  }
  /**
   * Writes data.
   *
   * @param data Data.
   */
  async write(data2) {
    const permissionStatus = await __classPrivateFieldGet$8(this, _Clipboard_ownerWindow, "f").navigator.permissions.query({
      name: "clipboard-write"
    });
    if (permissionStatus.state === "denied") {
      throw new DOMException(`Failed to execute 'write' on 'Clipboard': The request is not allowed`);
    }
    __classPrivateFieldSet$7(this, _Clipboard_data, data2, "f");
  }
  /**
   * Writes text.
   *
   * @param text Text.
   */
  async writeText(text2) {
    const permissionStatus = await __classPrivateFieldGet$8(this, _Clipboard_ownerWindow, "f").navigator.permissions.query({
      name: "clipboard-write"
    });
    if (permissionStatus.state === "denied") {
      throw new DOMException(`Failed to execute 'writeText' on 'Clipboard': The request is not allowed`);
    }
    __classPrivateFieldSet$7(this, _Clipboard_data, [new ClipboardItem({ "text/plain": new Blob([text2], { type: "text/plain" }) })], "f");
  }
}
_Clipboard_ownerWindow = /* @__PURE__ */ new WeakMap(), _Clipboard_data = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet$6 = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$7 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Navigator_ownerWindow, _Navigator_clipboard, _Navigator_permissions;
class Navigator {
  /**
   * Constructor.
   *
   * @param ownerWindow Owner window.
   */
  constructor(ownerWindow2) {
    _Navigator_ownerWindow.set(this, void 0);
    _Navigator_clipboard.set(this, void 0);
    _Navigator_permissions.set(this, void 0);
    __classPrivateFieldSet$6(this, _Navigator_ownerWindow, ownerWindow2, "f");
    __classPrivateFieldSet$6(this, _Navigator_clipboard, new Clipboard(ownerWindow2), "f");
    __classPrivateFieldSet$6(this, _Navigator_permissions, new Permissions(), "f");
  }
  /**
   * False if setting a cookie will be ignored and true otherwise.
   */
  get cookieEnabled() {
    return true;
  }
  /**
   * TODO: Not implemented.
   */
  get credentials() {
    return null;
  }
  /**
   * TODO: Not implemented.
   */
  get geolocation() {
    return null;
  }
  /**
   * String representing the preferred language of the user, usually the language of the browser UI.
   */
  get language() {
    return "en-US";
  }
  /**
   * Array of string representing the user's preferred languages.
   */
  get languages() {
    return ["en-US", "en"];
  }
  /**
   * TODO: Not implemented.
   */
  get locks() {
    return null;
  }
  /**
   * Maximum number of simultaneous touch contact points are supported by the current device.
   */
  get maxTouchPoints() {
    var _a2;
    return ((_a2 = WindowBrowserSettingsReader.getSettings(__classPrivateFieldGet$7(this, _Navigator_ownerWindow, "f"))) == null ? void 0 : _a2.navigator.maxTouchPoints) || 0;
  }
  /**
   * Number of logical processors available to run threads on the user's computer.
   */
  get hardwareConcurrency() {
    return 8;
  }
  /**
   * Browser app code name.
   */
  get appCodeName() {
    return "Mozilla";
  }
  /**
   * Browser app name.
   */
  get appName() {
    return "Netscape";
  }
  /**
   * Browser app version.
   */
  get appVersion() {
    const userAgent = this.userAgent;
    const index = userAgent.indexOf("/");
    return index > -1 ? userAgent.substring(index + 1) : "";
  }
  /**
   * Browser platform.
   */
  get platform() {
    const userAgent = this.userAgent;
    const indexStart = userAgent.indexOf("(");
    const indexEnd = userAgent.indexOf(")");
    return indexStart > -1 && indexEnd > -1 ? userAgent.substring(indexStart + 1, indexEnd) : "";
  }
  /**
   * Browser product.
   */
  get product() {
    return "Gecko";
  }
  /**
   * Browser product sub.
   */
  get productSub() {
    return "20100101";
  }
  /**
   * Browser vendor.
   */
  get vendor() {
    return "";
  }
  /**
   * Browser vendor sub.
   */
  get vendorSub() {
    return "";
  }
  /**
   * Browser user agent.
   *
   * "appCodeName/appVersion number (Platform; Security; OS-or-CPU; Localization; rv: revision-version-number) product/productSub Application-Name Application-Name-version".
   */
  get userAgent() {
    var _a2;
    return ((_a2 = WindowBrowserSettingsReader.getSettings(__classPrivateFieldGet$7(this, _Navigator_ownerWindow, "f"))) == null ? void 0 : _a2.navigator.userAgent) || "";
  }
  /**
   * Boolean value indicating whether the browser is working online.
   */
  get onLine() {
    return true;
  }
  /**
   * Returns a Permissions object that can be used to query and update permission status of APIs covered by the Permissions API.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/permissions
   * @returns Permissions.
   */
  get permissions() {
    return __classPrivateFieldGet$7(this, _Navigator_permissions, "f");
  }
  /**
   * Returns a Clipboard object providing access to the contents of the system clipboard.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/clipboard
   * @returns Clipboard.
   */
  get clipboard() {
    return __classPrivateFieldGet$7(this, _Navigator_clipboard, "f");
  }
  /**
   * Boolean Indicates whether the user agent is controlled by automation.
   */
  get webdriver() {
    return true;
  }
  /**
   * The user's Do Not Track setting, which indicates whether the user is requesting web sites and advertisers to not track them.
   *
   * The value of the property reflects that of the DNT HTTP header, i.e. Values of "1", "0", or "unspecified".
   */
  get doNotTrack() {
    return "unspecified";
  }
  /**
   * Browser mime-types.
   */
  get mimeTypes() {
    return new MimeTypeArray([]);
  }
  /**
   * Browser plugins.
   */
  get plugins() {
    return new PluginArray([]);
  }
  /**
   * Sends an HTTP POST request containing a small amount of data to a web server.
   *
   * @param url URL.
   * @param data Data.
   * @returns "true" if the user agent successfully queued the data for transfer. Otherwise, it returns "false".
   */
  sendBeacon(url, data2) {
    __classPrivateFieldGet$7(this, _Navigator_ownerWindow, "f").fetch(url, {
      method: "POST",
      body: data2
    });
    return true;
  }
  /**
   * Returns the object as a string.
   *
   * @returns String.
   */
  toString() {
    return "[object Navigator]";
  }
}
_Navigator_ownerWindow = /* @__PURE__ */ new WeakMap(), _Navigator_clipboard = /* @__PURE__ */ new WeakMap(), _Navigator_permissions = /* @__PURE__ */ new WeakMap();
class MimeType {
  /**
   * Constructor.
   *
   * @param description
   * @param enabledPlugin
   * @param suffixes
   * @param type
   */
  constructor(description, enabledPlugin, suffixes, type) {
    this.description = description;
    this.enabledPlugin = enabledPlugin;
    this.suffixes = suffixes;
    this.type = type;
  }
  /**
   * Returns the object as a string.
   *
   * @returns String.
   */
  toString() {
    return "[object MimeType]";
  }
}
class Plugin {
  /**
   * Constructor.
   *
   * @param mimeTypes Mime types.
   * @param description Description.
   * @param filename Filename.
   * @param name Name.
   */
  constructor(mimeTypes, description, filename, name2) {
    this.length = 0;
    this.description = description;
    this.filename = filename;
    this.name = name2;
    for (let i = 0, max2 = mimeTypes.length; i < max2; i++) {
      this[i] = mimeTypes[i];
      this[mimeTypes[i].type] = mimeTypes[i];
    }
    this.length = mimeTypes.length;
  }
  /**
   * Item.
   *
   * @param index Number.
   * @returns IMimeType.
   */
  item(index) {
    return this[index] || null;
  }
  /**
   * NamedItem.
   *
   * @param name String.
   * @returns IMimeType.
   */
  namedItem(name2) {
    return this[name2] || null;
  }
  /**
   * Returns the object as a string.
   *
   * @returns String.
   */
  toString() {
    return "[object Plugin]";
  }
}
let NotSupported$9 = class NotSupported4 {
  send() {
    throw Error("Fetch is not supported without Node.js.");
  }
};
const VMGlobalPropertyScript = new Script(`
this.ArrayBuffer = globalThis.ArrayBuffer;
this.Boolean = globalThis.Boolean;
this.DataView = globalThis.DataView;
this.Date = globalThis.Date;
this.Error = globalThis.Error;
this.EvalError = globalThis.EvalError;
this.Float32Array = globalThis.Float32Array;
this.Float64Array = globalThis.Float64Array;
this.GLOBAL = globalThis.GLOBAL;
this.Infinity = globalThis.Infinity;
this.Int16Array = globalThis.Int16Array;
this.Int32Array = globalThis.Int32Array;
this.Int8Array = globalThis.Int8Array;
this.Intl = globalThis.Intl;
this.JSON = globalThis.JSON;
this.Map = globalThis.Map;
this.Math = globalThis.Math;
this.NaN = globalThis.NaN;
this.Number = globalThis.Number;
this.Promise = globalThis.Promise;
this.RangeError = globalThis.RangeError;
this.ReferenceError = globalThis.ReferenceError;
this.RegExp = globalThis.RegExp;
this.Reflect = globalThis.Reflect;
this.Set = globalThis.Set;
this.Symbol = globalThis.Symbol;
this.SyntaxError = globalThis.SyntaxError;
this.String = globalThis.String;
this.TypeError = globalThis.TypeError;
this.URIError = globalThis.URIError;
this.Uint16Array = globalThis.Uint16Array;
this.Uint32Array = globalThis.Uint32Array;
this.Uint8Array = globalThis.Uint8Array;
this.Uint8ClampedArray = globalThis.Uint8ClampedArray;
this.WeakMap = globalThis.WeakMap;
this.WeakSet = globalThis.WeakSet;
this.decodeURI = globalThis.decodeURI;
this.decodeURIComponent = globalThis.decodeURIComponent;
this.encodeURI = globalThis.encodeURI;
this.encodeURIComponent = globalThis.encodeURIComponent;
this.eval = globalThis.eval;
this.escape = globalThis.escape;
this.global = globalThis.global;
this.isFinite = globalThis.isFinite;
this.isNaN = globalThis.isNaN;
this.parseFloat = globalThis.parseFloat;
this.parseInt = globalThis.parseInt;
this.process = null;
this.root = globalThis.root;
this.undefined = globalThis.undefined;
this.unescape = globalThis.unescape;
this.gc = globalThis.gc;
this.v8debug = globalThis.v8debug;
this.AbortController = globalThis.AbortController;
this.AbortSignal = globalThis.AbortSignal;
this.Array = globalThis.Array;
this.Object = globalThis.Object;
this.Function = globalThis.Function;
`);
const webcrypto = globalThis.crypto;
let NotSupported$8 = class NotSupported5 {
};
let NotSupported$7 = class NotSupported6 {
};
const BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
class Base64 {
  /**
   * Creates a Base64-encoded ASCII string from a binary string (i.e., a string in which each character in the string is treated as a byte of binary data).
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/btoa
   * @param data Binay data.
   * @returns Base64-encoded string.
   */
  static btoa(data2) {
    const str = data2.toString();
    if (/[^\u0000-\u00ff]/.test(str)) {
      throw new DOMException("Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range.", DOMExceptionNameEnum$1.invalidCharacterError);
    }
    let t2 = "";
    let p2 = -6;
    let a = 0;
    let i = 0;
    let v2 = 0;
    let c;
    while (i < str.length || p2 > -6) {
      if (p2 < 0) {
        if (i < str.length) {
          c = str.charCodeAt(i++);
          v2 += 8;
        } else {
          c = 0;
        }
        a = (a & 255) << 8 | c & 255;
        p2 += 8;
      }
      t2 += BASE64_CHARS.charAt(v2 > 0 ? a >> p2 & 63 : 64);
      p2 -= 6;
      v2 -= 6;
    }
    return t2;
  }
  /**
   * Decodes a string of data which has been encoded using Base64 encoding.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/atob
   * @see https://infra.spec.whatwg.org/#forgiving-base64-encode.
   * @see Https://html.spec.whatwg.org/multipage/webappapis.html#btoa.
   * @param data Binay string.
   * @returns An ASCII string containing decoded data from encodedData.
   */
  static atob(data2) {
    const str = data2.toString();
    if (/[^\u0000-\u00ff]/.test(str)) {
      throw new DOMException("Failed to execute 'atob' on 'Window': The string to be decoded contains characters outside of the Latin1 range.", DOMExceptionNameEnum$1.invalidCharacterError);
    }
    if (/[^A-Za-z\d+/=]/.test(str) || str.length % 4 == 1) {
      throw new DOMException("Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.", DOMExceptionNameEnum$1.invalidCharacterError);
    }
    let t2 = "";
    let p2 = -8;
    let a = 0;
    let c;
    let d;
    for (let i = 0; i < str.length; i++) {
      if ((c = BASE64_CHARS.indexOf(str.charAt(i))) < 0) {
        continue;
      }
      a = a << 6 | c & 63;
      if ((p2 += 6) >= 0) {
        d = a >> p2 & 255;
        if (c !== 64) {
          t2 += String.fromCharCode(d);
        }
        a &= 63;
        p2 -= 8;
      }
    }
    return t2;
  }
}
var _a$8, _b$5, _c$3, _d$1, _e$1, _f;
class Attr extends Node2 {
  constructor() {
    super(...arguments);
    this[_a$8] = NodeTypeEnum$1.attributeNode;
    this[_b$5] = null;
    this[_c$3] = null;
    this[_d$1] = null;
    this[_e$1] = true;
    this[_f] = null;
  }
  /**
   * Returns specified.
   *
   * @returns Specified.
   */
  get specified() {
    return this[specified];
  }
  /**
   * Returns owner element.
   *
   * @returns Owner element.
   */
  get ownerElement() {
    return this[ownerElement];
  }
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    return this[value];
  }
  /**
   * Sets value.
   *
   * @param value Value.
   */
  set value(value$1) {
    this[value] = value$1;
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this[name];
  }
  /**
   * Returns local name.
   *
   * @returns Local name.
   */
  get localName() {
    return this[name] ? this[name].split(":").reverse()[0] : null;
  }
  /**
   * Returns prefix.
   *
   * @returns Prefix.
   */
  get prefix() {
    return this[name] ? this[name].split(":")[0] : null;
  }
  /**
   * @override
   */
  get textContent() {
    return this[value];
  }
  /**
   * Returns namespace URI.
   *
   * @returns Namespace URI.
   */
  get namespaceURI() {
    return this[namespaceURI];
  }
}
_a$8 = nodeType, _b$5 = namespaceURI, _c$3 = name, _d$1 = value, _e$1 = specified, _f = ownerElement;
var _a$7;
class ProcessingInstruction extends CharacterData {
  constructor() {
    super(...arguments);
    this[_a$7] = NodeTypeEnum$1.processingInstructionNode;
  }
  /**
   * Returns target.
   *
   * @returns Target.
   */
  get target() {
    return this[target];
  }
}
_a$7 = nodeType;
const Readable = globalThis.ReadableStream;
const Writable = globalThis.WritableStream;
const Transform = globalThis.TransformStream;
const Stream = {
  Readable,
  Writable,
  Transform
};
const ReadableStream = globalThis.ReadableStream;
let NotSupported$6 = class NotSupported7 {
};
class ClipboardEvent extends Event {
  /**
   * Constructor.
   *
   * @param type Event type.
   * @param [eventInit] Event init.
   */
  constructor(type, eventInit = null) {
    super(type, eventInit);
    this.clipboardData = (eventInit == null ? void 0 : eventInit.clipboardData) ?? null;
  }
}
let NotSupported$5 = class NotSupported8 {
};
let NotSupported$4 = class NotSupported9 {
};
class DocumentReadyStateManager {
  /**
   * Constructor.
   *
   * @param window
   */
  constructor(window2) {
    this.totalTasks = 0;
    this.readyStateCallbacks = [];
    this.window = null;
    this.immediate = null;
    this.isComplete = false;
    this.window = window2;
  }
  /**
   * Returns a promise that is fulfilled when ready state is complete.
   *
   * @returns Promise.
   */
  waitUntilComplete() {
    return new Promise((resolve3) => {
      if (this.isComplete) {
        resolve3();
      } else {
        this.readyStateCallbacks.push(resolve3);
        if (this.totalTasks === 0 && !this.immediate) {
          this.immediate = this.window.requestAnimationFrame(this.endTask.bind(this));
        }
      }
    });
  }
  /**
   * Starts a task.
   */
  startTask() {
    if (this.isComplete) {
      return;
    }
    if (this.immediate) {
      this.window.cancelAnimationFrame(this.immediate);
      this.immediate = null;
    }
    this.totalTasks++;
  }
  /**
   * Ends a task.
   */
  endTask() {
    if (this.isComplete) {
      return;
    }
    if (this.immediate) {
      this.window.cancelAnimationFrame(this.immediate);
      this.immediate = null;
    }
    this.totalTasks--;
    if (this.totalTasks <= 0) {
      const callbacks2 = this.readyStateCallbacks;
      this.readyStateCallbacks = [];
      this.isComplete = true;
      for (const callback of callbacks2) {
        callback();
      }
    }
  }
}
class HTMLAnchorElementNamedNodeMap extends HTMLElementNamedNodeMap {
  /**
   * @override
   */
  setNamedItem(item2) {
    const replacedItem = super.setNamedItem(item2);
    if (item2[name] === "rel" && this[ownerElement][relList]) {
      this[ownerElement][relList][updateIndices]();
    }
    return replacedItem || null;
  }
  /**
   * @override
   */
  [removeNamedItem](name$1) {
    const removedItem = super[removeNamedItem](name$1);
    if ((removedItem == null ? void 0 : removedItem[name]) === "rel" && this[ownerElement][relList]) {
      this[ownerElement][relList][updateIndices]();
    }
    return removedItem;
  }
}
var _a$6, _b$4;
class HTMLAnchorElement extends HTMLElement$1 {
  constructor() {
    super(...arguments);
    this[_a$6] = new HTMLAnchorElementNamedNodeMap(this);
    this[_b$4] = null;
  }
  /**
   * Returns download.
   *
   * @returns download.
   */
  get download() {
    return this.getAttribute("download") || "";
  }
  /**
   * Sets download.
   *
   * @param download Download.
   */
  set download(download) {
    this.setAttribute("download", download);
  }
  /**
   * Returns hash.
   *
   * @returns Hash.
   */
  get hash() {
    const href = this.getAttribute("href");
    if (href.startsWith("#")) {
      return href;
    }
    let url;
    try {
      url = new URL$1(this.href);
    } catch (e2) {
      return "";
    }
    return url.hash;
  }
  /**
   * Sets hash.
   *
   * @param hash Hash.
   */
  set hash(hash2) {
    let url;
    try {
      url = new URL$1(this.href);
    } catch (e2) {
      return;
    }
    url.hash = hash2;
    this.href = url.href;
  }
  /**
   * Returns href.
   *
   * @returns Href.
   */
  get href() {
    if (!this.hasAttribute("href")) {
      return "";
    }
    try {
      return new URL$1(this.getAttribute("href"), this[ownerDocument].location.href).href;
    } catch (e2) {
      return this.getAttribute("href");
    }
  }
  /**
   * Sets href.
   *
   * @param href Href.
   */
  set href(href) {
    this.setAttribute("href", href);
  }
  /**
   * Returns hreflang.
   *
   * @returns Hreflang.
   */
  get hreflang() {
    return this.getAttribute("hreflang") || "";
  }
  /**
   * Sets hreflang.
   *
   * @param hreflang Hreflang.
   */
  set hreflang(hreflang) {
    this.setAttribute("hreflang", hreflang);
  }
  /**
   * Returns the hyperlink's URL's origin.
   *
   * @returns Origin.
   */
  get origin() {
    try {
      return new URL$1(this.href).origin;
    } catch (e2) {
      return "";
    }
  }
  /**
   * Returns ping.
   *
   * @returns Ping.
   */
  get ping() {
    return this.getAttribute("ping") || "";
  }
  /**
   * Sets ping.
   *
   * @param ping Ping.
   */
  set ping(ping) {
    this.setAttribute("ping", ping);
  }
  /**
   * Returns protocol.
   *
   * @returns Protocol.
   */
  get protocol() {
    try {
      return new URL$1(this.href).protocol;
    } catch (e2) {
      return "";
    }
  }
  /**
   * Sets protocol.
   *
   * @param protocol Protocol.
   */
  set protocol(protocol) {
    let url;
    try {
      url = new URL$1(this.href);
    } catch (e2) {
      return;
    }
    url.protocol = protocol;
    this.href = url.href;
  }
  /**
   * Returns username.
   *
   * @returns Username.
   */
  get username() {
    try {
      return new URL$1(this.href).username;
    } catch (e2) {
      return "";
    }
  }
  /**
   * Sets username.
   *
   * @param username Username.
   */
  set username(username) {
    let url;
    try {
      url = new URL$1(this.href);
    } catch (e2) {
      return;
    }
    url.username = username;
    this.href = url.href;
  }
  /**
   * Returns password.
   *
   * @returns Password.
   */
  get password() {
    try {
      return new URL$1(this.href).password;
    } catch (e2) {
      return "";
    }
  }
  /**
   * Sets password.
   *
   * @param password Password.
   */
  set password(password) {
    let url;
    try {
      url = new URL$1(this.href);
    } catch (e2) {
      return;
    }
    url.password = password;
    this.href = url.href;
  }
  /**
   * Returns pathname.
   *
   * @returns Pathname.
   */
  get pathname() {
    try {
      return new URL$1(this.href).pathname;
    } catch (e2) {
      return "";
    }
  }
  /**
   * Sets pathname.
   *
   * @param pathname Pathname.
   */
  set pathname(pathname) {
    let url;
    try {
      url = new URL$1(this.href);
    } catch (e2) {
      return;
    }
    url.pathname = pathname;
    this.href = url.href;
  }
  /**
   * Returns port.
   *
   * @returns Port.
   */
  get port() {
    try {
      return new URL$1(this.href).port;
    } catch (e2) {
      return "";
    }
  }
  /**
   * Sets port.
   *
   * @param port Port.
   */
  set port(port) {
    let url;
    try {
      url = new URL$1(this.href);
    } catch (e2) {
      return;
    }
    url.port = port;
    this.href = url.href;
  }
  /**
   * Returns host.
   *
   * @returns Host.
   */
  get host() {
    try {
      return new URL$1(this.href).host;
    } catch (e2) {
      return "";
    }
  }
  /**
   * Sets host.
   *
   * @param host Host.
   */
  set host(host2) {
    let url;
    try {
      url = new URL$1(this.href);
    } catch (e2) {
      return;
    }
    url.host = host2;
    this.href = url.href;
  }
  /**
   * Returns hostname.
   *
   * @returns Hostname.
   */
  get hostname() {
    try {
      return new URL$1(this.href).hostname;
    } catch (e2) {
      return "";
    }
  }
  /**
   * Sets hostname.
   *
   * @param hostname Hostname.
   */
  set hostname(hostname) {
    let url;
    try {
      url = new URL$1(this.href);
    } catch (e2) {
      return;
    }
    url.hostname = hostname;
    this.href = url.href;
  }
  /**
   * Returns referrerPolicy.
   *
   * @returns Referrer Policy.
   */
  get referrerPolicy() {
    return this.getAttribute("referrerPolicy") || "";
  }
  /**
   * Sets referrerPolicy.
   *
   * @param referrerPolicy Referrer Policy.
   */
  set referrerPolicy(referrerPolicy) {
    this.setAttribute("referrerPolicy", referrerPolicy);
  }
  /**
   * Returns rel.
   *
   * @returns Rel.
   */
  get rel() {
    return this.getAttribute("rel") || "";
  }
  /**
   * Sets rel.
   *
   * @param rel Rel.
   */
  set rel(rel) {
    this.setAttribute("rel", rel);
  }
  /**
   * Returns rel list.
   *
   * @returns Rel list.
   */
  get relList() {
    if (!this[relList]) {
      this[relList] = new DOMTokenList(this, "rel");
    }
    return this[relList];
  }
  /**
   * Returns search.
   *
   * @returns Search.
   */
  get search() {
    try {
      return new URL$1(this.href).search;
    } catch (e2) {
      return "";
    }
  }
  /**
   * Sets search.
   *
   * @param search Search.
   */
  set search(search) {
    let url;
    try {
      url = new URL$1(this.href);
    } catch (e2) {
      return;
    }
    url.search = search;
    this.href = url.href;
  }
  /**
   * Returns target.
   *
   * @returns target.
   */
  get target() {
    return this.getAttribute("target") || "";
  }
  /**
   * Sets target.
   *
   * @param target Target.
   */
  set target(target2) {
    this.setAttribute("target", target2);
  }
  /**
   * Returns text.
   *
   * @returns text.
   */
  get text() {
    return this.textContent;
  }
  /**
   * Sets text.
   *
   * @param text Text.
   */
  set text(text2) {
    this.textContent = text2;
  }
  /**
   * Returns type.
   *
   * @returns Type.
   */
  get type() {
    return this.getAttribute("type") || "";
  }
  /**
   * Sets type.
   *
   * @param type Type.
   */
  set type(type) {
    this.setAttribute("type", type);
  }
  /**
   * @override
   */
  toString() {
    return this.href;
  }
  /**
   * @override
   */
  dispatchEvent(event) {
    const returnValue2 = super.dispatchEvent(event);
    if (event.type === "click" && event instanceof MouseEvent && event.eventPhase === EventPhaseEnum$1.none && !event.defaultPrevented) {
      const href = this.href;
      if (href) {
        this[ownerDocument][ownerWindow].open(href, this.target || "_self");
        if (this[ownerDocument][ownerWindow].closed) {
          event.stopImmediatePropagation();
        }
      }
    }
    return returnValue2;
  }
}
_a$6 = attributes, _b$4 = relList;
class HTMLButtonElementNamedNodeMap extends HTMLElementNamedNodeMap {
  /**
   * @override
   */
  setNamedItem(item2) {
    const replacedItem = super.setNamedItem(item2);
    if ((item2[name] === "id" || item2[name] === "name") && this[ownerElement][formNode]) {
      if (replacedItem == null ? void 0 : replacedItem[value]) {
        this[ownerElement][formNode][removeFormControlItem](this[ownerElement], replacedItem[value]);
      }
      if (item2[value]) {
        this[ownerElement][formNode][appendFormControlItem](this[ownerElement], item2[value]);
      }
    }
    return replacedItem || null;
  }
  /**
   * @override
   */
  [removeNamedItem](name$1) {
    const removedItem = super[removeNamedItem](name$1);
    if (removedItem && (removedItem[name] === "id" || removedItem[name] === "name") && this[ownerElement][formNode]) {
      this[ownerElement][formNode][removeFormControlItem](this[ownerElement], removedItem[value]);
    }
    return removedItem;
  }
}
var __classPrivateFieldGet$6 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HTMLButtonElement_instances, _HTMLButtonElement_sanitizeType, _a$5, _b$3, _c$2;
const BUTTON_TYPES = ["submit", "reset", "button", "menu"];
class HTMLButtonElement extends HTMLElement$1 {
  constructor() {
    super(...arguments);
    _HTMLButtonElement_instances.add(this);
    this[_a$5] = new HTMLButtonElementNamedNodeMap(this);
    this[_b$3] = "";
    this[_c$2] = new ValidityState(this);
  }
  /**
   * Returns validation message.
   *
   * @returns Validation message.
   */
  get validationMessage() {
    return this[validationMessage];
  }
  /**
   * Returns validity.
   *
   * @returns Validity.
   */
  get validity() {
    return this[validity];
  }
  /**
   * Returns name.
   *
   * @returns Name.
   */
  get name() {
    return this.getAttribute("name") || "";
  }
  /**
   * Sets name.
   *
   * @param name Name.
   */
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    return this.getAttribute("value");
  }
  /**
   * Sets value.
   *
   * @param value Value.
   */
  set value(value2) {
    this.setAttribute("value", value2);
  }
  /**
   * Returns disabled.
   *
   * @returns Disabled.
   */
  get disabled() {
    return this.getAttribute("disabled") !== null;
  }
  /**
   * Sets disabled.
   *
   * @param disabled Disabled.
   */
  set disabled(disabled) {
    if (!disabled) {
      this.removeAttribute("disabled");
    } else {
      this.setAttribute("disabled", "");
    }
  }
  /**
   * Returns type
   *
   * @returns Type
   */
  get type() {
    return __classPrivateFieldGet$6(this, _HTMLButtonElement_instances, "m", _HTMLButtonElement_sanitizeType).call(this, this.getAttribute("type"));
  }
  /**
   * Sets type
   *
   * @param v Type
   */
  set type(v2) {
    this.setAttribute("type", __classPrivateFieldGet$6(this, _HTMLButtonElement_instances, "m", _HTMLButtonElement_sanitizeType).call(this, v2));
  }
  /**
   * Returns form action.
   *
   * @returns Form action.
   */
  get formAction() {
    if (!this.hasAttribute("formaction")) {
      return this[ownerDocument].location.href;
    }
    try {
      return new URL_1(this.getAttribute("formaction"), this[ownerDocument].location.href).href;
    } catch (e2) {
      return "";
    }
  }
  /**
   * Sets form action.
   *
   * @param formAction Form action.
   */
  set formAction(formAction) {
    this.setAttribute("formaction", formAction);
  }
  /**
   * Returns form enctype.
   *
   * @returns Form enctype.
   */
  get formEnctype() {
    return this.getAttribute("formenctype") || "";
  }
  /**
   * Sets form enctype.
   *
   * @param formEnctype Form enctype.
   */
  set formEnctype(formEnctype) {
    this.setAttribute("formenctype", formEnctype);
  }
  /**
   * Returns form method.
   *
   * @returns Form method.
   */
  get formMethod() {
    return this.getAttribute("formmethod") || "";
  }
  /**
   * Sets form method.
   *
   * @param formMethod Form method.
   */
  set formMethod(formMethod) {
    this.setAttribute("formmethod", formMethod);
  }
  /**
   * Returns no validate.
   *
   * @returns No validate.
   */
  get formNoValidate() {
    return this.getAttribute("formnovalidate") !== null;
  }
  /**
   * Sets no validate.
   *
   * @param formNoValidate No validate.
   */
  set formNoValidate(formNoValidate) {
    if (!formNoValidate) {
      this.removeAttribute("formnovalidate");
    } else {
      this.setAttribute("formnovalidate", "");
    }
  }
  /**
   * Returns form target.
   *
   * @returns Form target.
   */
  get formTarget() {
    return this.getAttribute("formtarget") || "";
  }
  /**
   * Sets form target.
   *
   * @param formTarget Form target.
   */
  set formTarget(formTarget) {
    this.setAttribute("formtarget", formTarget);
  }
  /**
   * Returns the parent form element.
   *
   * @returns Form.
   */
  get form() {
    if (this[formNode]) {
      return this[formNode];
    }
    if (!this.isConnected) {
      return null;
    }
    const formID = this.getAttribute("form");
    return formID ? this[ownerDocument].getElementById(formID) : null;
  }
  /**
   * Returns the associated label elements.
   *
   * @returns Label elements.
   */
  get labels() {
    return HTMLLabelElementUtility.getAssociatedLabelElements(this);
  }
  /**
   * Checks validity.
   *
   * @returns "true" if the field is valid.
   */
  checkValidity() {
    const valid = this.disabled || this.type === "reset" || this.type === "button" || this[validity].valid;
    if (!valid) {
      this.dispatchEvent(new Event("invalid", { bubbles: true, cancelable: true }));
    }
    return valid;
  }
  /**
   * Reports validity.
   *
   * @returns Validity.
   */
  reportValidity() {
    return this.checkValidity();
  }
  /**
   * Sets validation message.
   *
   * @param message Message.
   */
  setCustomValidity(message) {
    this[validationMessage] = String(message);
  }
  /**
   * @override
   */
  dispatchEvent(event) {
    if (event.type === "click" && event instanceof MouseEvent && event.eventPhase === EventPhaseEnum$1.none && this.disabled) {
      return false;
    }
    const returnValue2 = super.dispatchEvent(event);
    if (event.type === "click" && event instanceof MouseEvent && (event.eventPhase === EventPhaseEnum$1.atTarget || event.eventPhase === EventPhaseEnum$1.bubbling) && this[isConnected]) {
      const form = this.form;
      if (!form) {
        return returnValue2;
      }
      switch (this.type) {
        case "submit":
          form.requestSubmit(this);
          break;
        case "reset":
          form.reset();
          break;
      }
    }
    return returnValue2;
  }
  /**
   * @override
   */
  [(_HTMLButtonElement_instances = /* @__PURE__ */ new WeakSet(), _a$5 = attributes, _b$3 = validationMessage, _c$2 = validity, connectToNode)](parentNode2 = null) {
    const oldFormNode = this[formNode];
    super[connectToNode](parentNode2);
    if (oldFormNode !== this[formNode]) {
      if (oldFormNode) {
        oldFormNode[removeFormControlItem](this, this.name);
        oldFormNode[removeFormControlItem](this, this.id);
      }
      if (this[formNode]) {
        this[formNode][appendFormControlItem](this, this.name);
        this[formNode][appendFormControlItem](this, this.id);
      }
    }
  }
}
_HTMLButtonElement_sanitizeType = function _HTMLButtonElement_sanitizeType2(type) {
  type = type && type.toLowerCase() || "submit";
  if (!BUTTON_TYPES.includes(type)) {
    type = "submit";
  }
  return type;
};
class HTMLOptionElementNamedNodeMap extends HTMLElementNamedNodeMap {
  /**
   * @override
   */
  setNamedItem(item2) {
    const replacedItem = super.setNamedItem(item2);
    if (!this[ownerElement][dirtyness] && item2[name] === "selected" && (replacedItem == null ? void 0 : replacedItem[value]) !== item2[value]) {
      const selectNode$1 = this[ownerElement][selectNode];
      this[ownerElement][selectedness] = true;
      if (selectNode$1) {
        selectNode$1[updateOptionItems](this[ownerElement]);
      }
    }
    return replacedItem || null;
  }
  /**
   * @override
   */
  [removeNamedItem](name$1) {
    const removedItem = super[removeNamedItem](name$1);
    if (removedItem && !this[ownerElement][dirtyness] && removedItem[name] === "selected") {
      const selectNode$1 = this[ownerElement][selectNode];
      this[ownerElement][selectedness] = false;
      if (selectNode$1) {
        selectNode$1[updateOptionItems]();
      }
    }
    return removedItem;
  }
}
var _a$4, _b$2, _c$1;
class HTMLOptionElement extends HTMLElement$1 {
  constructor() {
    super(...arguments);
    this[_a$4] = new HTMLOptionElementNamedNodeMap(this);
    this[_b$2] = false;
    this[_c$1] = false;
  }
  /**
   * Returns inner text, which is the rendered appearance of text.
   *
   * @returns Inner text.
   */
  get text() {
    return this.innerText;
  }
  /**
   * Sets the inner text, which is the rendered appearance of text.
   *
   * @param innerText Inner text.
   */
  set text(text2) {
    this.innerText = text2;
  }
  /**
   * Returns index.
   *
   * @returns Index.
   */
  get index() {
    return this[selectNode] ? this[selectNode].options.indexOf(this) : 0;
  }
  /**
   * Returns the parent form element.
   *
   * @returns Form.
   */
  get form() {
    return this[formNode];
  }
  /**
   * Returns selected.
   *
   * @returns Selected.
   */
  get selected() {
    return this[selectedness];
  }
  /**
   * Sets selected.
   *
   * @param selected Selected.
   */
  set selected(selected) {
    const selectNode$1 = this[selectNode];
    this[dirtyness] = true;
    this[selectedness] = Boolean(selected);
    if (selectNode$1) {
      selectNode$1[updateOptionItems](this[selectedness] ? this : null);
    }
  }
  /**
   * Returns disabled.
   *
   * @returns Disabled.
   */
  get disabled() {
    return this.getAttribute("disabled") !== null;
  }
  /**
   * Sets disabled.
   *
   * @param disabled Disabled.
   */
  set disabled(disabled) {
    if (!disabled) {
      this.removeAttribute("disabled");
    } else {
      this.setAttribute("disabled", "");
    }
  }
  /**
   * Returns value.
   *
   * @returns Value.
   */
  get value() {
    return this.getAttribute("value") ?? this.textContent;
  }
  /**
   * Sets value.
   *
   * @param value Value.
   */
  set value(value2) {
    this.setAttribute("value", value2);
  }
  /**
   * @override
   */
  [(_a$4 = attributes, _b$2 = selectedness, _c$1 = dirtyness, connectToNode)](parentNode2 = null) {
    const oldSelectNode = this[selectNode];
    super[connectToNode](parentNode2);
    if (oldSelectNode !== this[selectNode]) {
      if (oldSelectNode) {
        oldSelectNode[updateOptionItems]();
      }
      if (this[selectNode]) {
        this[selectNode][updateOptionItems]();
      }
    }
  }
}
class HTMLOptGroupElement extends HTMLElement$1 {
  /**
   * Returns label.
   *
   * @returns Label.
   */
  get label() {
    return this.getAttribute("label") || "";
  }
  /**
   * Sets label.
   *
   * @param label Label.
   */
  set label(label) {
    if (!label) {
      this.removeAttribute("label");
    } else {
      this.setAttribute("label", label);
    }
  }
  /**
   * Returns disabled.
   *
   * @returns Disabled.
   */
  get disabled() {
    return this.getAttribute("disabled") !== null;
  }
  /**
   * Sets disabled.
   *
   * @param disabled Disabled.
   */
  set disabled(disabled) {
    if (!disabled) {
      this.removeAttribute("disabled");
    } else {
      this.setAttribute("disabled", "");
    }
  }
}
class HTMLTimeElement extends HTMLElement$1 {
  /**
   * Returns dateTime.
   *
   * @returns dateTime.
   */
  get dateTime() {
    return this.getAttribute("dateTime") || "";
  }
  /**
   * Sets dateTime.
   *
   * @param dateTime dateTime.
   */
  set dateTime(dateTime) {
    this.setAttribute("dateTime", dateTime);
  }
}
let NotSupported$3 = class NotSupported10 {
};
class WindowPageOpenUtility {
  /**
   * Opens a page.
   *
   * @param browserFrame Browser frame.
   * @param [options] Options.
   * @param [options.url] URL.
   * @param [options.target] Target.
   * @param [options.features] Window features.
   */
  static openPage(browserFrame, options2) {
    const features = this.getWindowFeatures((options2 == null ? void 0 : options2.features) || "");
    const target2 = (options2 == null ? void 0 : options2.target) !== void 0 ? String(options2.target) : null;
    const originURL = new URL_1(browserFrame.window.location.href);
    const targetURL = BrowserFrameURL.getRelativeURL(browserFrame, options2.url);
    const oldWindow = browserFrame.window;
    let targetFrame;
    switch (target2) {
      case "_self":
        targetFrame = browserFrame;
        break;
      case "_top":
        targetFrame = browserFrame.page.mainFrame;
        break;
      case "_parent":
        targetFrame = browserFrame.parentFrame ?? browserFrame;
        break;
      case "_blank":
      default:
        const newPage = browserFrame.page.context.newPage();
        targetFrame = newPage.mainFrame;
        targetFrame[openerFrame] = browserFrame;
        break;
    }
    targetFrame.goto(targetURL.href, {
      referrer: features.noreferrer ? void 0 : browserFrame.window.location.origin,
      referrerPolicy: features.noreferrer ? "no-referrer" : void 0
    }).catch((error2) => targetFrame.page.console.error(error2));
    if (targetURL.protocol === "javascript:") {
      return targetFrame.window;
    }
    if (targetFrame === browserFrame && browserFrame.window === oldWindow) {
      return null;
    }
    if (features.popup && target2 !== "_self" && target2 !== "_top" && target2 !== "_parent") {
      targetFrame[popup] = true;
      if ((features == null ? void 0 : features.width) || (features == null ? void 0 : features.height)) {
        targetFrame.page.setViewport({
          width: features == null ? void 0 : features.width,
          height: features == null ? void 0 : features.height
        });
      }
      if (features == null ? void 0 : features.left) {
        targetFrame.window.screenLeft = features.left;
        targetFrame.window.screenX = features.left;
      }
      if (features == null ? void 0 : features.top) {
        targetFrame.window.screenTop = features.top;
        targetFrame.window.screenY = features.top;
      }
    }
    if (target2 && target2 !== "_self" && target2 !== "_top" && target2 !== "_parent" && target2 !== "_blank") {
      targetFrame.window.name = target2;
    }
    const isCORS = NotSupported$3.isCORS(originURL, targetFrame.url);
    if (!features.noopener && !features.noreferrer && browserFrame.window && targetFrame[openerFrame] && targetFrame.window !== browserFrame.window) {
      targetFrame[openerWindow] = isCORS ? new CrossOriginBrowserWindow(browserFrame.window) : browserFrame.window;
    }
    if (features.noopener || features.noreferrer) {
      return null;
    }
    if (isCORS) {
      return new CrossOriginBrowserWindow(targetFrame.window, browserFrame.window);
    }
    return targetFrame.window;
  }
  /**
   * Returns window features.
   *
   * @param features Window features string.
   * @returns Window features.
   */
  static getWindowFeatures(features) {
    const parts = features.split(",");
    const result = {
      popup: false,
      width: 0,
      height: 0,
      left: 0,
      top: 0,
      noopener: false,
      noreferrer: false
    };
    for (const part of parts) {
      const [key, value2] = part.split("=");
      switch (key) {
        case "popup":
          result.popup = !value2 || value2 === "yes" || value2 === "1" || value2 === "true";
          break;
        case "width":
        case "innerWidth":
          result.width = parseInt(value2, 10);
          break;
        case "height":
        case "innerHeight":
          result.height = parseInt(value2, 10);
          break;
        case "left":
        case "screenX":
          result.left = parseInt(value2, 10);
          break;
        case "top":
        case "screenY":
          result.top = parseInt(value2, 10);
          break;
        case "noopener":
          result.noopener = true;
          break;
        case "noreferrer":
          result.noreferrer = true;
          break;
      }
    }
    return result;
  }
}
let Audio$1 = class Audio extends HTMLAudioElement {
  /**
   * Constructor.
   *
   * @param [url] source URL.
   */
  constructor(url = null) {
    super();
    if (url !== null) {
      this.src = url;
    }
  }
};
let Image$1 = class Image extends HTMLImageElement {
  /**
   * Constructor.
   *
   * @param [width] Width.
   * @param [height] Height.
   */
  constructor(width2 = null, height2 = null) {
    super();
    if (width2 !== null) {
      this.width = width2;
    }
    if (height2 !== null) {
      this.height = height2;
    }
  }
};
var _a$3;
let Text$1 = class Text extends CharacterData {
  constructor() {
    super(...arguments);
    this[_a$3] = NodeTypeEnum$1.textNode;
  }
  /**
   * Node name.
   *
   * @returns Node name.
   */
  get nodeName() {
    return "#text";
  }
  /**
   * @override
   */
  get data() {
    return this[data];
  }
  /**
   * @override
   */
  set data(data2) {
    super.data = data2;
    if (this[textAreaNode]) {
      this[textAreaNode][resetSelection]();
    }
    if (this[styleNode]) {
      this[styleNode][updateSheet]();
    }
  }
  /**
   * Breaks the Text node into two nodes at the specified offset, keeping both nodes in the tree as siblings.
   *
   * @see https://dom.spec.whatwg.org/#dom-text-splittext
   * @param offset Offset.
   * @returns New text node.
   */
  splitText(offset2) {
    const length2 = this[data].length;
    if (offset2 < 0 || offset2 > length2) {
      throw new DOMException("The index is not in the allowed range.", DOMExceptionNameEnum$1.indexSizeError);
    }
    const count = length2 - offset2;
    const newData = this.substringData(offset2, count);
    const newNode = this[ownerDocument].createTextNode(newData);
    if (this[parentNode] !== null) {
      this[parentNode].insertBefore(newNode, this.nextSibling);
    }
    this.replaceData(offset2, count, "");
    return newNode;
  }
  /**
   * Converts to string.
   *
   * @returns String.
   */
  toString() {
    return "[object Text]";
  }
  /**
   * @override
   */
  [(_a$3 = nodeType, cloneNode)](deep = false) {
    return super[cloneNode](deep);
  }
  /**
   * @override
   */
  [connectToNode](parentNode2 = null) {
    const oldTextAreaNode = this[textAreaNode];
    super[connectToNode](parentNode2);
    if (oldTextAreaNode !== this[textAreaNode]) {
      if (oldTextAreaNode) {
        oldTextAreaNode[resetSelection]();
      }
      if (this[textAreaNode]) {
        this[textAreaNode][resetSelection]();
      }
    }
  }
};
var _a$2;
let Comment$1 = class Comment extends CharacterData {
  constructor() {
    super(...arguments);
    this[_a$2] = NodeTypeEnum$1.commentNode;
  }
  /**
   * Node name.
   *
   * @returns Node name.
   */
  get nodeName() {
    return "#comment";
  }
  /**
   * Converts to string.
   *
   * @returns String.
   */
  toString() {
    return "[object Comment]";
  }
  /**
   * @override
   */
  [(_a$2 = nodeType, cloneNode)](deep = false) {
    return super[cloneNode](deep);
  }
};
var __classPrivateFieldSet$5 = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$5 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DOMParser_instances, _DOMParser_window, _DOMParser_createDocument;
let DOMParser$1 = class DOMParser {
  /**
   * Constructor.
   *
   * @param window Window.
   */
  constructor(window2) {
    _DOMParser_instances.add(this);
    _DOMParser_window.set(this, void 0);
    __classPrivateFieldSet$5(this, _DOMParser_window, window2, "f");
  }
  /**
   * Parses HTML and returns a root element.
   *
   * @param string HTML data.
   * @param mimeType Mime type.
   * @returns Root element.
   */
  parseFromString(string, mimeType2) {
    if (!mimeType2) {
      throw new DOMException('Second parameter "mimeType" is mandatory.');
    }
    const newDocument = __classPrivateFieldGet$5(this, _DOMParser_instances, "m", _DOMParser_createDocument).call(this, mimeType2);
    newDocument[childNodes].length = 0;
    newDocument[children].length = 0;
    const root = XMLParser.parse(newDocument, string, { evaluateScripts: true });
    let documentElement = null;
    let documentTypeNode = null;
    for (const node2 of root[childNodes]) {
      if (node2["tagName"] === "HTML") {
        documentElement = node2;
      } else if (node2[nodeType] === NodeTypeEnum$1.documentTypeNode) {
        documentTypeNode = node2;
      }
      if (documentElement && documentTypeNode) {
        break;
      }
    }
    if (documentElement) {
      if (documentTypeNode) {
        newDocument.appendChild(documentTypeNode);
      }
      newDocument.appendChild(documentElement);
      const body = newDocument.body;
      if (body) {
        for (const child of root[childNodes].slice()) {
          body.appendChild(child);
        }
      }
    } else {
      switch (mimeType2) {
        case "image/svg+xml":
          {
            for (const node2 of root[childNodes].slice()) {
              newDocument.appendChild(node2);
            }
          }
          break;
        case "text/html":
        default:
          {
            const documentElement2 = newDocument.createElement("html");
            const bodyElement = newDocument.createElement("body");
            const headElement = newDocument.createElement("head");
            documentElement2.appendChild(headElement);
            documentElement2.appendChild(bodyElement);
            newDocument.appendChild(documentElement2);
            for (const node2 of root[childNodes].slice()) {
              bodyElement.appendChild(node2);
            }
          }
          break;
      }
    }
    return newDocument;
  }
};
_DOMParser_window = /* @__PURE__ */ new WeakMap(), _DOMParser_instances = /* @__PURE__ */ new WeakSet(), _DOMParser_createDocument = function _DOMParser_createDocument2(mimeType2) {
  switch (mimeType2) {
    case "text/html":
      return new (__classPrivateFieldGet$5(this, _DOMParser_window, "f")).HTMLDocument();
    case "image/svg+xml":
      return new (__classPrivateFieldGet$5(this, _DOMParser_window, "f")).SVGDocument();
    case "text/xml":
    case "application/xml":
    case "application/xhtml+xml":
      return new (__classPrivateFieldGet$5(this, _DOMParser_window, "f")).XMLDocument();
    default:
      throw new DOMException(`Unknown mime type "${mimeType2}".`);
  }
};
var utils = {};
utils.removeLeadingAndTrailingHTTPWhitespace = (string) => {
  return string.replace(/^[ \t\n\r]+/u, "").replace(/[ \t\n\r]+$/u, "");
};
utils.removeTrailingHTTPWhitespace = (string) => {
  return string.replace(/[ \t\n\r]+$/u, "");
};
utils.isHTTPWhitespaceChar = (char) => {
  return char === " " || char === "	" || char === "\n" || char === "\r";
};
utils.solelyContainsHTTPTokenCodePoints = (string) => {
  return /^[-!#$%&'*+.^_`|~A-Za-z0-9]*$/u.test(string);
};
utils.soleyContainsHTTPQuotedStringTokenCodePoints = (string) => {
  return /^[\t\u0020-\u007E\u0080-\u00FF]*$/u.test(string);
};
utils.asciiLowercase = (string) => {
  return string.replace(/[A-Z]/ug, (l2) => l2.toLowerCase());
};
utils.collectAnHTTPQuotedString = (input, position) => {
  let value2 = "";
  position++;
  while (true) {
    while (position < input.length && input[position] !== '"' && input[position] !== "\\") {
      value2 += input[position];
      ++position;
    }
    if (position >= input.length) {
      break;
    }
    const quoteOrBackslash = input[position];
    ++position;
    if (quoteOrBackslash === "\\") {
      if (position >= input.length) {
        value2 += "\\";
        break;
      }
      value2 += input[position];
      ++position;
    } else {
      break;
    }
  }
  return [value2, position];
};
const {
  asciiLowercase: asciiLowercase$2,
  solelyContainsHTTPTokenCodePoints: solelyContainsHTTPTokenCodePoints$3,
  soleyContainsHTTPQuotedStringTokenCodePoints: soleyContainsHTTPQuotedStringTokenCodePoints$1
} = utils;
var mimeTypeParameters = class MIMETypeParameters {
  constructor(map2) {
    this._map = map2;
  }
  get size() {
    return this._map.size;
  }
  get(name2) {
    name2 = asciiLowercase$2(String(name2));
    return this._map.get(name2);
  }
  has(name2) {
    name2 = asciiLowercase$2(String(name2));
    return this._map.has(name2);
  }
  set(name2, value2) {
    name2 = asciiLowercase$2(String(name2));
    value2 = String(value2);
    if (!solelyContainsHTTPTokenCodePoints$3(name2)) {
      throw new Error(`Invalid MIME type parameter name "${name2}": only HTTP token code points are valid.`);
    }
    if (!soleyContainsHTTPQuotedStringTokenCodePoints$1(value2)) {
      throw new Error(`Invalid MIME type parameter value "${value2}": only HTTP quoted-string token code points are valid.`);
    }
    return this._map.set(name2, value2);
  }
  clear() {
    this._map.clear();
  }
  delete(name2) {
    name2 = asciiLowercase$2(String(name2));
    return this._map.delete(name2);
  }
  forEach(callbackFn, thisArg) {
    this._map.forEach(callbackFn, thisArg);
  }
  keys() {
    return this._map.keys();
  }
  values() {
    return this._map.values();
  }
  entries() {
    return this._map.entries();
  }
  [Symbol.iterator]() {
    return this._map[Symbol.iterator]();
  }
};
const {
  removeLeadingAndTrailingHTTPWhitespace,
  removeTrailingHTTPWhitespace,
  isHTTPWhitespaceChar,
  solelyContainsHTTPTokenCodePoints: solelyContainsHTTPTokenCodePoints$2,
  soleyContainsHTTPQuotedStringTokenCodePoints,
  asciiLowercase: asciiLowercase$1,
  collectAnHTTPQuotedString
} = utils;
var parser = (input) => {
  input = removeLeadingAndTrailingHTTPWhitespace(input);
  let position = 0;
  let type = "";
  while (position < input.length && input[position] !== "/") {
    type += input[position];
    ++position;
  }
  if (type.length === 0 || !solelyContainsHTTPTokenCodePoints$2(type)) {
    return null;
  }
  if (position >= input.length) {
    return null;
  }
  ++position;
  let subtype = "";
  while (position < input.length && input[position] !== ";") {
    subtype += input[position];
    ++position;
  }
  subtype = removeTrailingHTTPWhitespace(subtype);
  if (subtype.length === 0 || !solelyContainsHTTPTokenCodePoints$2(subtype)) {
    return null;
  }
  const mimeType2 = {
    type: asciiLowercase$1(type),
    subtype: asciiLowercase$1(subtype),
    parameters: /* @__PURE__ */ new Map()
  };
  while (position < input.length) {
    ++position;
    while (isHTTPWhitespaceChar(input[position])) {
      ++position;
    }
    let parameterName = "";
    while (position < input.length && input[position] !== ";" && input[position] !== "=") {
      parameterName += input[position];
      ++position;
    }
    parameterName = asciiLowercase$1(parameterName);
    if (position < input.length) {
      if (input[position] === ";") {
        continue;
      }
      ++position;
    }
    let parameterValue = null;
    if (input[position] === '"') {
      [parameterValue, position] = collectAnHTTPQuotedString(input, position);
      while (position < input.length && input[position] !== ";") {
        ++position;
      }
    } else {
      parameterValue = "";
      while (position < input.length && input[position] !== ";") {
        parameterValue += input[position];
        ++position;
      }
      parameterValue = removeTrailingHTTPWhitespace(parameterValue);
      if (parameterValue === "") {
        continue;
      }
    }
    if (parameterName.length > 0 && solelyContainsHTTPTokenCodePoints$2(parameterName) && soleyContainsHTTPQuotedStringTokenCodePoints(parameterValue) && !mimeType2.parameters.has(parameterName)) {
      mimeType2.parameters.set(parameterName, parameterValue);
    }
  }
  return mimeType2;
};
const { solelyContainsHTTPTokenCodePoints: solelyContainsHTTPTokenCodePoints$1 } = utils;
var serializer = (mimeType2) => {
  let serialization = `${mimeType2.type}/${mimeType2.subtype}`;
  if (mimeType2.parameters.size === 0) {
    return serialization;
  }
  for (let [name2, value2] of mimeType2.parameters) {
    serialization += ";";
    serialization += name2;
    serialization += "=";
    if (!solelyContainsHTTPTokenCodePoints$1(value2) || value2.length === 0) {
      value2 = value2.replace(/(["\\])/ug, "\\$1");
      value2 = `"${value2}"`;
    }
    serialization += value2;
  }
  return serialization;
};
const MIMETypeParameters2 = mimeTypeParameters;
const parse = parser;
const serialize = serializer;
const {
  asciiLowercase,
  solelyContainsHTTPTokenCodePoints
} = utils;
var mimeType = class MIMEType {
  constructor(string) {
    string = String(string);
    const result = parse(string);
    if (result === null) {
      throw new Error(`Could not parse MIME type string "${string}"`);
    }
    this._type = result.type;
    this._subtype = result.subtype;
    this._parameters = new MIMETypeParameters2(result.parameters);
  }
  static parse(string) {
    try {
      return new this(string);
    } catch (e2) {
      return null;
    }
  }
  get essence() {
    return `${this.type}/${this.subtype}`;
  }
  get type() {
    return this._type;
  }
  set type(value2) {
    value2 = asciiLowercase(String(value2));
    if (value2.length === 0) {
      throw new Error("Invalid type: must be a non-empty string");
    }
    if (!solelyContainsHTTPTokenCodePoints(value2)) {
      throw new Error(`Invalid type ${value2}: must contain only HTTP token code points`);
    }
    this._type = value2;
  }
  get subtype() {
    return this._subtype;
  }
  set subtype(value2) {
    value2 = asciiLowercase(String(value2));
    if (value2.length === 0) {
      throw new Error("Invalid subtype: must be a non-empty string");
    }
    if (!solelyContainsHTTPTokenCodePoints(value2)) {
      throw new Error(`Invalid subtype ${value2}: must contain only HTTP token code points`);
    }
    this._subtype = value2;
  }
  get parameters() {
    return this._parameters;
  }
  toString() {
    return serialize(this);
  }
  isJavaScript({ prohibitParameters = false } = {}) {
    switch (this._type) {
      case "text": {
        switch (this._subtype) {
          case "ecmascript":
          case "javascript":
          case "javascript1.0":
          case "javascript1.1":
          case "javascript1.2":
          case "javascript1.3":
          case "javascript1.4":
          case "javascript1.5":
          case "jscript":
          case "livescript":
          case "x-ecmascript":
          case "x-javascript": {
            return !prohibitParameters || this._parameters.size === 0;
          }
          default: {
            return false;
          }
        }
      }
      case "application": {
        switch (this._subtype) {
          case "ecmascript":
          case "javascript":
          case "x-ecmascript":
          case "x-javascript": {
            return !prohibitParameters || this._parameters.size === 0;
          }
          default: {
            return false;
          }
        }
      }
      default: {
        return false;
      }
    }
  }
  isXML() {
    return this._subtype === "xml" && (this._type === "text" || this._type === "application") || this._subtype.endsWith("+xml");
  }
  isHTML() {
    return this._subtype === "html" && this._type === "text";
  }
};
const WhatwgMIMEType = /* @__PURE__ */ getDefaultExportFromCjs(mimeType);
var FileReaderReadyStateEnum;
(function(FileReaderReadyStateEnum2) {
  FileReaderReadyStateEnum2[FileReaderReadyStateEnum2["empty"] = 0] = "empty";
  FileReaderReadyStateEnum2[FileReaderReadyStateEnum2["loading"] = 1] = "loading";
  FileReaderReadyStateEnum2[FileReaderReadyStateEnum2["done"] = 2] = "done";
})(FileReaderReadyStateEnum || (FileReaderReadyStateEnum = {}));
const FileReaderReadyStateEnum$1 = FileReaderReadyStateEnum;
var FileReaderFormatEnum;
(function(FileReaderFormatEnum2) {
  FileReaderFormatEnum2["buffer"] = "buffer";
  FileReaderFormatEnum2["binaryString"] = "binaryString";
  FileReaderFormatEnum2["dataURL"] = "dataURL";
  FileReaderFormatEnum2["text"] = "text";
})(FileReaderFormatEnum || (FileReaderFormatEnum = {}));
const FileReaderFormatEnum$1 = FileReaderFormatEnum;
var FileReaderEventTypeEnum;
(function(FileReaderEventTypeEnum2) {
  FileReaderEventTypeEnum2["abort"] = "abort";
  FileReaderEventTypeEnum2["error"] = "error";
  FileReaderEventTypeEnum2["load"] = "load";
  FileReaderEventTypeEnum2["loadstart"] = "loadstart";
  FileReaderEventTypeEnum2["loadend"] = "loadend";
  FileReaderEventTypeEnum2["progress"] = "progress";
})(FileReaderEventTypeEnum || (FileReaderEventTypeEnum = {}));
const FileReaderEventTypeEnum$1 = FileReaderEventTypeEnum;
var __classPrivateFieldSet$4 = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$4 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FileReader_instances, _FileReader_isTerminated, _FileReader_loadTimeout, _FileReader_parseTimeout, _FileReader_window, _FileReader_readFile;
let FileReader$1 = class FileReader extends EventTarget {
  /**
   * Constructor.
   *
   * @param window Window.
   */
  constructor(window2) {
    super();
    _FileReader_instances.add(this);
    this.error = null;
    this.result = null;
    this.readyState = FileReaderReadyStateEnum$1.empty;
    this.onabort = null;
    this.onerror = null;
    this.onload = null;
    this.onloadstart = null;
    this.onloadend = null;
    this.onprogress = null;
    _FileReader_isTerminated.set(this, false);
    _FileReader_loadTimeout.set(this, null);
    _FileReader_parseTimeout.set(this, null);
    _FileReader_window.set(this, void 0);
    __classPrivateFieldSet$4(this, _FileReader_window, window2, "f");
  }
  /**
   * Reads as ArrayBuffer.
   *
   * @param blob Blob.
   */
  readAsArrayBuffer(blob) {
    __classPrivateFieldGet$4(this, _FileReader_instances, "m", _FileReader_readFile).call(this, blob, FileReaderFormatEnum$1.buffer);
  }
  /**
   * Reads as binary string.
   *
   * @param blob Blob.
   */
  readAsBinaryString(blob) {
    __classPrivateFieldGet$4(this, _FileReader_instances, "m", _FileReader_readFile).call(this, blob, FileReaderFormatEnum$1.binaryString);
  }
  /**
   * Reads as data URL.
   *
   * @param blob Blob.
   */
  readAsDataURL(blob) {
    __classPrivateFieldGet$4(this, _FileReader_instances, "m", _FileReader_readFile).call(this, blob, FileReaderFormatEnum$1.dataURL);
  }
  /**
   * Reads as text.
   *
   * @param blob Blob.
   * @param [encoding] Encoding.
   */
  readAsText(blob, encoding2 = null) {
    __classPrivateFieldGet$4(this, _FileReader_instances, "m", _FileReader_readFile).call(this, blob, FileReaderFormatEnum$1.text, encoding2 || "UTF-8");
  }
  /**
   * Aborts the file reader.
   */
  abort() {
    __classPrivateFieldGet$4(this, _FileReader_window, "f").clearTimeout(__classPrivateFieldGet$4(this, _FileReader_loadTimeout, "f"));
    __classPrivateFieldGet$4(this, _FileReader_window, "f").clearTimeout(__classPrivateFieldGet$4(this, _FileReader_parseTimeout, "f"));
    if (this.readyState === FileReaderReadyStateEnum$1.empty || this.readyState === FileReaderReadyStateEnum$1.done) {
      this.result = null;
      return;
    }
    if (this.readyState === FileReaderReadyStateEnum$1.loading) {
      this.readyState = FileReaderReadyStateEnum$1.done;
      this.result = null;
    }
    __classPrivateFieldSet$4(this, _FileReader_isTerminated, true, "f");
    this.dispatchEvent(new ProgressEvent(FileReaderEventTypeEnum$1.abort));
    this.dispatchEvent(new ProgressEvent(FileReaderEventTypeEnum$1.loadend));
  }
};
_FileReader_isTerminated = /* @__PURE__ */ new WeakMap(), _FileReader_loadTimeout = /* @__PURE__ */ new WeakMap(), _FileReader_parseTimeout = /* @__PURE__ */ new WeakMap(), _FileReader_window = /* @__PURE__ */ new WeakMap(), _FileReader_instances = /* @__PURE__ */ new WeakSet(), _FileReader_readFile = function _FileReader_readFile2(blob, format2, encoding2 = null) {
  if (this.readyState === FileReaderReadyStateEnum$1.loading) {
    throw new DOMException("The object is in an invalid state.", DOMExceptionNameEnum$1.invalidStateError);
  }
  this.readyState = FileReaderReadyStateEnum$1.loading;
  __classPrivateFieldSet$4(this, _FileReader_loadTimeout, __classPrivateFieldGet$4(this, _FileReader_window, "f").setTimeout(() => {
    if (__classPrivateFieldGet$4(this, _FileReader_isTerminated, "f")) {
      __classPrivateFieldSet$4(this, _FileReader_isTerminated, false, "f");
      return;
    }
    this.dispatchEvent(new ProgressEvent(FileReaderEventTypeEnum$1.loadstart));
    let data2 = blob[buffer];
    if (!data2) {
      data2 = Buffer$1.alloc(0);
    }
    this.dispatchEvent(new ProgressEvent(FileReaderEventTypeEnum$1.loadstart, {
      lengthComputable: !isNaN(blob.size),
      total: blob.size,
      loaded: data2.length
    }));
    __classPrivateFieldSet$4(this, _FileReader_parseTimeout, __classPrivateFieldGet$4(this, _FileReader_window, "f").setTimeout(() => {
      if (__classPrivateFieldGet$4(this, _FileReader_isTerminated, "f")) {
        __classPrivateFieldSet$4(this, _FileReader_isTerminated, false, "f");
        return;
      }
      switch (format2) {
        default:
        case FileReaderFormatEnum$1.buffer: {
          this.result = new Uint8Array(data2).buffer;
          break;
        }
        case FileReaderFormatEnum$1.binaryString: {
          this.result = data2.toString("binary");
          break;
        }
        case FileReaderFormatEnum$1.dataURL: {
          const contentType = WhatwgMIMEType.parse(blob.type) || "application/octet-stream";
          this.result = `data:${contentType};base64,${data2.toString("base64")}`;
          break;
        }
        case FileReaderFormatEnum$1.text: {
          this.result = new TextDecoder(encoding2 || "UTF-8").decode(data2);
          break;
        }
      }
      this.readyState = FileReaderReadyStateEnum$1.done;
      this.dispatchEvent(new ProgressEvent(FileReaderEventTypeEnum$1.load));
      this.dispatchEvent(new ProgressEvent(FileReaderEventTypeEnum$1.loadend));
    }), "f");
  }), "f");
};
let NotSupported$2 = class NotSupported11 {
};
let NotSupported$1 = class NotSupported12 {
};
var RangeHowEnum;
(function(RangeHowEnum2) {
  RangeHowEnum2[RangeHowEnum2["endToEnd"] = 2] = "endToEnd";
  RangeHowEnum2[RangeHowEnum2["endToStart"] = 3] = "endToStart";
  RangeHowEnum2[RangeHowEnum2["startToEnd"] = 1] = "startToEnd";
  RangeHowEnum2[RangeHowEnum2["startToStart"] = 0] = "startToStart";
})(RangeHowEnum || (RangeHowEnum = {}));
const RangeHowEnum$1 = RangeHowEnum;
var __classPrivateFieldSet$3 = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$3 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Range_window, _a$1, _b$1;
let Range$1 = class Range {
  /**
   * Constructor.
   *
   * @param window Window.
   */
  constructor(window2) {
    this.END_TO_END = RangeHowEnum$1.endToEnd;
    this.END_TO_START = RangeHowEnum$1.endToStart;
    this.START_TO_END = RangeHowEnum$1.startToEnd;
    this.START_TO_START = RangeHowEnum$1.startToStart;
    this[_a$1] = null;
    this[_b$1] = null;
    _Range_window.set(this, void 0);
    __classPrivateFieldSet$3(this, _Range_window, window2, "f");
    this[ownerDocument] = window2.document;
    this[start] = { node: window2.document, offset: 0 };
    this[end] = { node: window2.document, offset: 0 };
  }
  /**
   * Returns start container.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-startcontainer
   * @returns Start container.
   */
  get startContainer() {
    return this[start].node;
  }
  /**
   * Returns end container.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-endcontainer
   * @returns End container.
   */
  get endContainer() {
    return this[end].node;
  }
  /**
   * Returns start offset.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-startoffset
   * @returns Start offset.
   */
  get startOffset() {
    if (this[start].offset > 0) {
      const length2 = NodeUtility.getNodeLength(this[start].node);
      if (this[start].offset > length2) {
        this[start].offset = length2;
      }
    }
    return this[start].offset;
  }
  /**
   * Returns end offset.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-endoffset
   * @returns End offset.
   */
  get endOffset() {
    if (this[end].offset > 0) {
      const length2 = NodeUtility.getNodeLength(this[end].node);
      if (this[end].offset > length2) {
        this[end].offset = length2;
      }
    }
    return this[end].offset;
  }
  /**
   * Returns a boolean value indicating whether the range's start and end points are at the same position.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-collapsed
   * @returns Collapsed.
   */
  get collapsed() {
    return this[start].node === this[end].node && this.startOffset === this.endOffset;
  }
  /**
   * Returns the deepest Node that contains the startContainer and endContainer nodes.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-commonancestorcontainer
   * @returns Node.
   */
  get commonAncestorContainer() {
    let container = this[start].node;
    while (container) {
      if (NodeUtility.isInclusiveAncestor(container, this[end].node)) {
        return container;
      }
      container = container[parentNode];
    }
    return null;
  }
  /**
   * Returns -1, 0, or 1 depending on whether the referenceNode is before, the same as, or after the Range.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-collapse
   * @param toStart A boolean value: true collapses the Range to its start, false to its end. If omitted, it defaults to false.
   */
  collapse(toStart = false) {
    if (toStart) {
      this[end] = Object.assign({}, this[start]);
    } else {
      this[start] = Object.assign({}, this[end]);
    }
  }
  /**
   * Compares the boundary points of the Range with those of another range.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-compareboundarypoints
   * @param how How.
   * @param sourceRange Range.
   * @returns A number, -1, 0, or 1, indicating whether the corresponding boundary-point of the Range is respectively before, equal to, or after the corresponding boundary-point of sourceRange.
   */
  compareBoundaryPoints(how, sourceRange) {
    if (how !== RangeHowEnum$1.startToStart && how !== RangeHowEnum$1.startToEnd && how !== RangeHowEnum$1.endToEnd && how !== RangeHowEnum$1.endToStart) {
      throw new DOMException(`The comparison method provided must be one of '${RangeHowEnum$1.startToStart}', '${RangeHowEnum$1.startToEnd}', '${RangeHowEnum$1.endToEnd}' or '${RangeHowEnum$1.endToStart}'.`, DOMExceptionNameEnum$1.notSupportedError);
    }
    if (this[ownerDocument] !== sourceRange[ownerDocument]) {
      throw new DOMException(`The two Ranges are not in the same tree.`, DOMExceptionNameEnum$1.wrongDocumentError);
    }
    const thisPoint = {
      node: null,
      offset: 0
    };
    const sourcePoint = {
      node: null,
      offset: 0
    };
    switch (how) {
      case RangeHowEnum$1.startToStart:
        thisPoint.node = this[start].node;
        thisPoint.offset = this.startOffset;
        sourcePoint.node = sourceRange[start].node;
        sourcePoint.offset = sourceRange.startOffset;
        break;
      case RangeHowEnum$1.startToEnd:
        thisPoint.node = this[end].node;
        thisPoint.offset = this.endOffset;
        sourcePoint.node = sourceRange[start].node;
        sourcePoint.offset = sourceRange.startOffset;
        break;
      case RangeHowEnum$1.endToEnd:
        thisPoint.node = this[end].node;
        thisPoint.offset = this.endOffset;
        sourcePoint.node = sourceRange[end].node;
        sourcePoint.offset = sourceRange.endOffset;
        break;
      case RangeHowEnum$1.endToStart:
        thisPoint.node = this[start].node;
        thisPoint.offset = this.startOffset;
        sourcePoint.node = sourceRange[end].node;
        sourcePoint.offset = sourceRange.endOffset;
        break;
    }
    return RangeUtility.compareBoundaryPointsPosition(thisPoint, sourcePoint);
  }
  /**
   * Returns -1, 0, or 1 depending on whether the referenceNode is before, the same as, or after the Range.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-comparepoint
   * @param node Reference node.
   * @param offset Offset.
   * @returns -1,0, or 1.
   */
  comparePoint(node2, offset2) {
    if (node2[ownerDocument] !== this[ownerDocument]) {
      throw new DOMException(`The two Ranges are not in the same tree.`, DOMExceptionNameEnum$1.wrongDocumentError);
    }
    RangeUtility.validateBoundaryPoint({ node: node2, offset: offset2 });
    const boundaryPoint = { node: node2, offset: offset2 };
    if (RangeUtility.compareBoundaryPointsPosition(boundaryPoint, {
      node: this[start].node,
      offset: this.startOffset
    }) === -1) {
      return -1;
    } else if (RangeUtility.compareBoundaryPointsPosition(boundaryPoint, {
      node: this[end].node,
      offset: this.endOffset
    }) === 1) {
      return 1;
    }
    return 0;
  }
  /**
   * Returns a DocumentFragment copying the objects of type Node included in the Range.
   *
   * @see https://dom.spec.whatwg.org/#concept-range-clone
   * @returns Document fragment.
   */
  cloneContents() {
    const fragment = this[ownerDocument].createDocumentFragment();
    const startOffset = this.startOffset;
    const endOffset = this.endOffset;
    if (this.collapsed) {
      return fragment;
    }
    if (this[start].node === this[end].node && (this[start].node[nodeType] === NodeTypeEnum$1.textNode || this[start].node[nodeType] === NodeTypeEnum$1.processingInstructionNode || this[start].node[nodeType] === NodeTypeEnum$1.commentNode)) {
      const clone2 = this[start].node.cloneNode(false);
      clone2[data] = clone2.substringData(startOffset, endOffset - startOffset);
      fragment.appendChild(clone2);
      return fragment;
    }
    let commonAncestor = this[start].node;
    while (!NodeUtility.isInclusiveAncestor(commonAncestor, this[end].node)) {
      commonAncestor = commonAncestor[parentNode];
    }
    let firstPartialContainedChild = null;
    if (!NodeUtility.isInclusiveAncestor(this[start].node, this[end].node)) {
      let candidate = commonAncestor.firstChild;
      while (!firstPartialContainedChild) {
        if (RangeUtility.isPartiallyContained(candidate, this)) {
          firstPartialContainedChild = candidate;
        }
        candidate = candidate.nextSibling;
      }
    }
    let lastPartiallyContainedChild = null;
    if (!NodeUtility.isInclusiveAncestor(this[end].node, this[start].node)) {
      let candidate = commonAncestor.lastChild;
      while (!lastPartiallyContainedChild) {
        if (RangeUtility.isPartiallyContained(candidate, this)) {
          lastPartiallyContainedChild = candidate;
        }
        candidate = candidate.previousSibling;
      }
    }
    const containedChildren = [];
    for (const node2 of commonAncestor[childNodes]) {
      if (RangeUtility.isContained(node2, this)) {
        if (node2[nodeType] === NodeTypeEnum$1.documentTypeNode) {
          throw new DOMException("Invalid document type element.", DOMExceptionNameEnum$1.hierarchyRequestError);
        }
        containedChildren.push(node2);
      }
    }
    if (firstPartialContainedChild !== null && (firstPartialContainedChild[nodeType] === NodeTypeEnum$1.textNode || firstPartialContainedChild[nodeType] === NodeTypeEnum$1.processingInstructionNode || firstPartialContainedChild[nodeType] === NodeTypeEnum$1.commentNode)) {
      const clone2 = this[start].node.cloneNode(false);
      clone2[data] = clone2.substringData(startOffset, NodeUtility.getNodeLength(this[start].node) - startOffset);
      fragment.appendChild(clone2);
    } else if (firstPartialContainedChild !== null) {
      const clone2 = firstPartialContainedChild.cloneNode();
      fragment.appendChild(clone2);
      const subRange = new (__classPrivateFieldGet$3(this, _Range_window, "f")).Range();
      subRange[start].node = this[start].node;
      subRange[start].offset = startOffset;
      subRange[end].node = firstPartialContainedChild;
      subRange[end].offset = NodeUtility.getNodeLength(firstPartialContainedChild);
      const subDocumentFragment = subRange.cloneContents();
      clone2.appendChild(subDocumentFragment);
    }
    for (const containedChild of containedChildren) {
      const clone2 = containedChild.cloneNode(true);
      fragment.appendChild(clone2);
    }
    if (lastPartiallyContainedChild !== null && (lastPartiallyContainedChild[nodeType] === NodeTypeEnum$1.textNode || lastPartiallyContainedChild[nodeType] === NodeTypeEnum$1.processingInstructionNode || lastPartiallyContainedChild[nodeType] === NodeTypeEnum$1.commentNode)) {
      const clone2 = this[end].node.cloneNode(false);
      clone2[data] = clone2.substringData(0, endOffset);
      fragment.appendChild(clone2);
    } else if (lastPartiallyContainedChild !== null) {
      const clone2 = lastPartiallyContainedChild.cloneNode(false);
      fragment.appendChild(clone2);
      const subRange = new (__classPrivateFieldGet$3(this, _Range_window, "f")).Range();
      subRange[start].node = lastPartiallyContainedChild;
      subRange[start].offset = 0;
      subRange[end].node = this[end].node;
      subRange[end].offset = endOffset;
      const subFragment = subRange.cloneContents();
      clone2.appendChild(subFragment);
    }
    return fragment;
  }
  /**
   * Returns a Range object with boundary points identical to the cloned Range.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-clonerange
   * @returns Range.
   */
  cloneRange() {
    const clone2 = new (__classPrivateFieldGet$3(this, _Range_window, "f")).Range();
    clone2[start].node = this[start].node;
    clone2[start].offset = this[start].offset;
    clone2[end].node = this[end].node;
    clone2[end].offset = this[end].offset;
    return clone2;
  }
  /**
   * Returns a DocumentFragment by invoking the HTML fragment parsing algorithm or the XML fragment parsing algorithm with the start of the range (the parent of the selected node) as the context node. The HTML fragment parsing algorithm is used if the range belongs to a Document whose HTMLness bit is set. In the HTML case, if the context node would be html, for historical reasons the fragment parsing algorithm is invoked with body as the context instead.
   *
   * @see https://w3c.github.io/DOM-Parsing/#dfn-fragment-parsing-algorithm
   * @param tagString Tag string.
   * @returns Document fragment.
   */
  createContextualFragment(tagString) {
    return XMLParser.parse(this[ownerDocument], tagString);
  }
  /**
   * Removes the contents of the Range from the Document.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-deletecontents
   */
  deleteContents() {
    const startOffset = this.startOffset;
    const endOffset = this.endOffset;
    if (this.collapsed) {
      return;
    }
    if (this[start].node === this[end].node && (this[start].node[nodeType] === NodeTypeEnum$1.textNode || this[start].node[nodeType] === NodeTypeEnum$1.processingInstructionNode || this[start].node[nodeType] === NodeTypeEnum$1.commentNode)) {
      this[start].node.replaceData(startOffset, endOffset - startOffset, "");
      return;
    }
    const nodesToRemove = [];
    let currentNode = this[start].node;
    const endNode = NodeUtility.nextDescendantNode(this[end].node);
    while (currentNode && currentNode !== endNode) {
      if (RangeUtility.isContained(currentNode, this) && !RangeUtility.isContained(currentNode[parentNode], this)) {
        nodesToRemove.push(currentNode);
      }
      currentNode = NodeUtility.following(currentNode);
    }
    let newNode;
    let newOffset;
    if (NodeUtility.isInclusiveAncestor(this[start].node, this[end].node)) {
      newNode = this[start].node;
      newOffset = startOffset;
    } else {
      let referenceNode = this[start].node;
      while (referenceNode && !NodeUtility.isInclusiveAncestor(referenceNode[parentNode], this[end].node)) {
        referenceNode = referenceNode[parentNode];
      }
      newNode = referenceNode[parentNode];
      newOffset = referenceNode[parentNode][childNodes].indexOf(referenceNode) + 1;
    }
    if (this[start].node[nodeType] === NodeTypeEnum$1.textNode || this[start].node[nodeType] === NodeTypeEnum$1.processingInstructionNode || this[start].node[nodeType] === NodeTypeEnum$1.commentNode) {
      this[start].node.replaceData(this.startOffset, NodeUtility.getNodeLength(this[start].node) - this.startOffset, "");
    }
    for (const node2 of nodesToRemove) {
      const parent = node2[parentNode];
      parent.removeChild(node2);
    }
    if (this[end].node[nodeType] === NodeTypeEnum$1.textNode || this[end].node[nodeType] === NodeTypeEnum$1.processingInstructionNode || this[end].node[nodeType] === NodeTypeEnum$1.commentNode) {
      this[end].node.replaceData(0, endOffset, "");
    }
    this[start].node = newNode;
    this[start].offset = newOffset;
    this[end].node = newNode;
    this[end].offset = newOffset;
  }
  /**
   * Does nothing. It used to disable the Range object and enable the browser to release associated resources. The method has been kept for compatibility.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-detach
   */
  detach() {
  }
  /**
   * Moves contents of the Range from the document tree into a DocumentFragment.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-extractcontents
   * @returns Document fragment.
   */
  extractContents() {
    const fragment = this[ownerDocument].createDocumentFragment();
    const startOffset = this.startOffset;
    const endOffset = this.endOffset;
    if (this.collapsed) {
      return fragment;
    }
    if (this[start].node === this[end].node && (this[start].node[nodeType] === NodeTypeEnum$1.textNode || this[start].node[nodeType] === NodeTypeEnum$1.processingInstructionNode || this[start].node[nodeType] === NodeTypeEnum$1.commentNode)) {
      const clone2 = this[start].node.cloneNode(false);
      clone2[data] = clone2.substringData(startOffset, endOffset - startOffset);
      fragment.appendChild(clone2);
      this[start].node.replaceData(startOffset, endOffset - startOffset, "");
      return fragment;
    }
    let commonAncestor = this[start].node;
    while (!NodeUtility.isInclusiveAncestor(commonAncestor, this[end].node)) {
      commonAncestor = commonAncestor[parentNode];
    }
    let firstPartialContainedChild = null;
    if (!NodeUtility.isInclusiveAncestor(this[start].node, this[end].node)) {
      let candidate = commonAncestor.firstChild;
      while (!firstPartialContainedChild) {
        if (RangeUtility.isPartiallyContained(candidate, this)) {
          firstPartialContainedChild = candidate;
        }
        candidate = candidate.nextSibling;
      }
    }
    let lastPartiallyContainedChild = null;
    if (!NodeUtility.isInclusiveAncestor(this[end].node, this[start].node)) {
      let candidate = commonAncestor.lastChild;
      while (!lastPartiallyContainedChild) {
        if (RangeUtility.isPartiallyContained(candidate, this)) {
          lastPartiallyContainedChild = candidate;
        }
        candidate = candidate.previousSibling;
      }
    }
    const containedChildren = [];
    for (const node2 of commonAncestor[childNodes]) {
      if (RangeUtility.isContained(node2, this)) {
        if (node2[nodeType] === NodeTypeEnum$1.documentTypeNode) {
          throw new DOMException("Invalid document type element.", DOMExceptionNameEnum$1.hierarchyRequestError);
        }
        containedChildren.push(node2);
      }
    }
    let newNode;
    let newOffset;
    if (NodeUtility.isInclusiveAncestor(this[start].node, this[end].node)) {
      newNode = this[start].node;
      newOffset = startOffset;
    } else {
      let referenceNode = this[start].node;
      while (referenceNode && !NodeUtility.isInclusiveAncestor(referenceNode[parentNode], this[end].node)) {
        referenceNode = referenceNode[parentNode];
      }
      newNode = referenceNode[parentNode];
      newOffset = referenceNode[parentNode][childNodes].indexOf(referenceNode) + 1;
    }
    if (firstPartialContainedChild !== null && (firstPartialContainedChild[nodeType] === NodeTypeEnum$1.textNode || firstPartialContainedChild[nodeType] === NodeTypeEnum$1.processingInstructionNode || firstPartialContainedChild[nodeType] === NodeTypeEnum$1.commentNode)) {
      const clone2 = this[start].node.cloneNode(false);
      clone2[data] = clone2.substringData(startOffset, NodeUtility.getNodeLength(this[start].node) - startOffset);
      fragment.appendChild(clone2);
      this[start].node.replaceData(startOffset, NodeUtility.getNodeLength(this[start].node) - startOffset, "");
    } else if (firstPartialContainedChild !== null) {
      const clone2 = firstPartialContainedChild.cloneNode(false);
      fragment.appendChild(clone2);
      const subRange = new (__classPrivateFieldGet$3(this, _Range_window, "f")).Range();
      subRange[start].node = this[start].node;
      subRange[start].offset = startOffset;
      subRange[end].node = firstPartialContainedChild;
      subRange[end].offset = NodeUtility.getNodeLength(firstPartialContainedChild);
      const subFragment = subRange.extractContents();
      clone2.appendChild(subFragment);
    }
    for (const containedChild of containedChildren) {
      fragment.appendChild(containedChild);
    }
    if (lastPartiallyContainedChild !== null && (lastPartiallyContainedChild[nodeType] === NodeTypeEnum$1.textNode || lastPartiallyContainedChild[nodeType] === NodeTypeEnum$1.processingInstructionNode || lastPartiallyContainedChild[nodeType] === NodeTypeEnum$1.commentNode)) {
      const clone2 = this[end].node.cloneNode(false);
      clone2[data] = clone2.substringData(0, endOffset);
      fragment.appendChild(clone2);
      this[end].node.replaceData(0, endOffset, "");
    } else if (lastPartiallyContainedChild !== null) {
      const clone2 = lastPartiallyContainedChild.cloneNode(false);
      fragment.appendChild(clone2);
      const subRange = new (__classPrivateFieldGet$3(this, _Range_window, "f")).Range();
      subRange[start].node = lastPartiallyContainedChild;
      subRange[start].offset = 0;
      subRange[end].node = this[end].node;
      subRange[end].offset = endOffset;
      const subFragment = subRange.extractContents();
      clone2.appendChild(subFragment);
    }
    this[start].node = newNode;
    this[start].offset = newOffset;
    this[end].node = newNode;
    this[end].offset = newOffset;
    return fragment;
  }
  /**
   * Returns a DOMRect object that bounds the contents of the range; this is a rectangle enclosing the union of the bounding rectangles for all the elements in the range.
   *
   * @returns DOMRect object.
   */
  getBoundingClientRect() {
    return new DOMRect();
  }
  /**
   * The Range.getClientRects() method returns a list of DOMRect objects representing the area of the screen occupied by the range. This is created by aggregating the results of calls to Element.getClientRects() for all the elements in the range.
   *
   * @returns DOMRect objects.
   */
  getClientRects() {
    return new DOMRectList();
  }
  /**
   * Returns a boolean indicating whether the given point is in the Range.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-ispointinrange
   * @param node Reference node.
   * @param offset Offset.
   * @returns "true" if in range.
   */
  isPointInRange(node2, offset2 = 0) {
    if (node2[ownerDocument] !== this[ownerDocument]) {
      return false;
    }
    const boundaryPoint = { node: node2, offset: offset2 };
    RangeUtility.validateBoundaryPoint(boundaryPoint);
    if (RangeUtility.compareBoundaryPointsPosition(boundaryPoint, {
      node: this[start].node,
      offset: this.startOffset
    }) === -1 || RangeUtility.compareBoundaryPointsPosition(boundaryPoint, {
      node: this[end].node,
      offset: this.endOffset
    }) === 1) {
      return false;
    }
    return true;
  }
  /**
   * Inserts a node at the start of the Range.
   *
   * @see https://dom.spec.whatwg.org/#concept-range-insert
   * @param newNode New node.
   */
  insertNode(newNode) {
    if (this[start].node[nodeType] === NodeTypeEnum$1.processingInstructionNode || this[start].node[nodeType] === NodeTypeEnum$1.commentNode || this[start].node[nodeType] === NodeTypeEnum$1.textNode && !this[start].node[parentNode] || newNode === this[start].node) {
      throw new DOMException("Invalid start node.", DOMExceptionNameEnum$1.hierarchyRequestError);
    }
    let referenceNode = this[start].node[nodeType] === NodeTypeEnum$1.textNode ? this[start].node : this[start].node[childNodes][this.startOffset] || null;
    const parent = !referenceNode ? this[start].node : referenceNode[parentNode];
    if (this[start].node[nodeType] === NodeTypeEnum$1.textNode) {
      referenceNode = this[start].node.splitText(this.startOffset);
    }
    if (newNode === referenceNode) {
      referenceNode = referenceNode.nextSibling;
    }
    const nodeParent = newNode[parentNode];
    if (nodeParent) {
      nodeParent.removeChild(newNode);
    }
    let newOffset = !referenceNode ? NodeUtility.getNodeLength(parent) : referenceNode[parentNode][childNodes].indexOf(referenceNode);
    newOffset += newNode[nodeType] === NodeTypeEnum$1.documentFragmentNode ? NodeUtility.getNodeLength(newNode) : 1;
    parent.insertBefore(newNode, referenceNode);
    if (this.collapsed) {
      this[end].node = parent;
      this[end].offset = newOffset;
    }
  }
  /**
   * Returns a boolean indicating whether the given Node intersects the Range.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-intersectsnode
   * @param node Reference node.
   * @returns "true" if it intersects.
   */
  intersectsNode(node2) {
    if (node2[ownerDocument] !== this[ownerDocument]) {
      return false;
    }
    const parent = node2[parentNode];
    if (!parent) {
      return true;
    }
    const offset2 = parent[childNodes].indexOf(node2);
    return RangeUtility.compareBoundaryPointsPosition({ node: parent, offset: offset2 }, { node: this[end].node, offset: this.endOffset }) === -1 && RangeUtility.compareBoundaryPointsPosition({ node: parent, offset: offset2 + 1 }, { node: this[start].node, offset: this.startOffset }) === 1;
  }
  /**
   * Sets the Range to contain the Node and its contents.
   *
   * @see https://dom.spec.whatwg.org/#concept-range-select
   * @param node Reference node.
   */
  selectNode(node2) {
    if (!node2[parentNode]) {
      throw new DOMException(`The given Node has no parent.`, DOMExceptionNameEnum$1.invalidNodeTypeError);
    }
    const index = node2[parentNode][childNodes].indexOf(node2);
    this[start].node = node2[parentNode];
    this[start].offset = index;
    this[end].node = node2[parentNode];
    this[end].offset = index + 1;
  }
  /**
   * Sets the Range to contain the contents of a Node.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-selectnodecontents
   * @param node Reference node.
   */
  selectNodeContents(node2) {
    if (node2[nodeType] === NodeTypeEnum$1.documentTypeNode) {
      throw new DOMException("DocumentType Node can't be used as boundary point.", DOMExceptionNameEnum$1.invalidNodeTypeError);
    }
    this[start].node = node2;
    this[start].offset = 0;
    this[end].node = node2;
    this[end].offset = NodeUtility.getNodeLength(node2);
  }
  /**
   * Sets the end position of a Range to be located at the given offset into the specified node x.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-setend
   * @param node End node.
   * @param offset End offset.
   */
  setEnd(node2, offset2 = 0) {
    RangeUtility.validateBoundaryPoint({ node: node2, offset: offset2 });
    const boundaryPoint = { node: node2, offset: offset2 };
    if (node2[ownerDocument] !== this[ownerDocument] || RangeUtility.compareBoundaryPointsPosition(boundaryPoint, {
      node: this[start].node,
      offset: this.startOffset
    }) === -1) {
      this[start].node = node2;
      this[start].offset = offset2;
    }
    this[end].node = node2;
    this[end].offset = offset2;
  }
  /**
   * Sets the start position of a Range.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-setstart
   * @param node Start node.
   * @param offset Start offset.
   */
  setStart(node2, offset2 = 0) {
    RangeUtility.validateBoundaryPoint({ node: node2, offset: offset2 });
    const boundaryPoint = { node: node2, offset: offset2 };
    if (node2[ownerDocument] !== this[ownerDocument] || RangeUtility.compareBoundaryPointsPosition(boundaryPoint, {
      node: this[end].node,
      offset: this.endOffset
    }) === 1) {
      this[end].node = node2;
      this[end].offset = offset2;
    }
    this[start].node = node2;
    this[start].offset = offset2;
  }
  /**
   * Sets the end position of a Range relative to another Node.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-setendafter
   * @param node Reference node.
   */
  setEndAfter(node2) {
    if (!node2[parentNode]) {
      throw new DOMException("The given Node has no parent.", DOMExceptionNameEnum$1.invalidNodeTypeError);
    }
    this.setEnd(node2[parentNode], node2[parentNode][childNodes].indexOf(node2) + 1);
  }
  /**
   * Sets the end position of a Range relative to another Node.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-setendbefore
   * @param node Reference node.
   */
  setEndBefore(node2) {
    if (!node2[parentNode]) {
      throw new DOMException("The given Node has no parent.", DOMExceptionNameEnum$1.invalidNodeTypeError);
    }
    this.setEnd(node2[parentNode], node2[parentNode][childNodes].indexOf(node2));
  }
  /**
   * Sets the start position of a Range relative to a Node.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-setstartafter
   * @param node Reference node.
   */
  setStartAfter(node2) {
    if (!node2[parentNode]) {
      throw new DOMException("The given Node has no parent.", DOMExceptionNameEnum$1.invalidNodeTypeError);
    }
    this.setStart(node2[parentNode], node2[parentNode][childNodes].indexOf(node2) + 1);
  }
  /**
   * Sets the start position of a Range relative to another Node.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-setstartbefore
   * @param node Reference node.
   */
  setStartBefore(node2) {
    if (!node2[parentNode]) {
      throw new DOMException("The given Node has no parent.", DOMExceptionNameEnum$1.invalidNodeTypeError);
    }
    this.setStart(node2[parentNode], node2[parentNode][childNodes].indexOf(node2));
  }
  /**
   * Moves content of the Range into a new node, placing the new node at the start of the specified range.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-surroundcontents
   * @param newParent New parent.
   */
  surroundContents(newParent) {
    let node2 = this.commonAncestorContainer;
    const endNode = NodeUtility.nextDescendantNode(node2);
    while (node2 !== endNode) {
      if (node2[nodeType] !== NodeTypeEnum$1.textNode && RangeUtility.isPartiallyContained(node2, this)) {
        throw new DOMException("The Range has partially contains a non-Text node.", DOMExceptionNameEnum$1.invalidStateError);
      }
      node2 = NodeUtility.following(node2);
    }
    if (newParent[nodeType] === NodeTypeEnum$1.documentNode || newParent[nodeType] === NodeTypeEnum$1.documentTypeNode || newParent[nodeType] === NodeTypeEnum$1.documentFragmentNode) {
      throw new DOMException("Invalid element type.", DOMExceptionNameEnum$1.invalidNodeTypeError);
    }
    const fragment = this.extractContents();
    while (newParent.firstChild) {
      newParent.removeChild(newParent.firstChild);
    }
    this.insertNode(newParent);
    newParent.appendChild(fragment);
    this.selectNode(newParent);
  }
  /**
   * Returns the text of the Range.
   *
   * @see https://dom.spec.whatwg.org/#dom-range-stringifier
   */
  toString() {
    const startOffset = this.startOffset;
    const endOffset = this.endOffset;
    let string = "";
    if (this[start].node === this[end].node && this[start].node[nodeType] === NodeTypeEnum$1.textNode) {
      return this[start].node.data.slice(startOffset, endOffset);
    }
    if (this[start].node[nodeType] === NodeTypeEnum$1.textNode) {
      string += this[start].node.data.slice(startOffset);
    }
    const endNode = NodeUtility.nextDescendantNode(this[end].node);
    let currentNode = this[start].node;
    while (currentNode && currentNode !== endNode) {
      if (currentNode[nodeType] === NodeTypeEnum$1.textNode && RangeUtility.isContained(currentNode, this)) {
        string += currentNode.data;
      }
      currentNode = NodeUtility.following(currentNode);
    }
    if (this[end].node[nodeType] === NodeTypeEnum$1.textNode) {
      string += this[end].node.data.slice(0, endOffset);
    }
    return string;
  }
};
_Range_window = /* @__PURE__ */ new WeakMap(), _a$1 = start, _b$1 = end;
Range$1.END_TO_END = RangeHowEnum$1.endToEnd;
Range$1.END_TO_START = RangeHowEnum$1.endToStart;
Range$1.START_TO_END = RangeHowEnum$1.startToEnd;
Range$1.START_TO_START = RangeHowEnum$1.startToStart;
var __classPrivateFieldSet$2 = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BrowserWindow_instances, _a, _BrowserWindow_browserFrame, _BrowserWindow_innerWidth, _BrowserWindow_innerHeight, _BrowserWindow_outerWidth, _BrowserWindow_outerHeight, _BrowserWindow_devicePixelRatio, _BrowserWindow_zeroTimeouts, _BrowserWindow_bindToThisScope, _b, _c, _d, _e;
const TIMER = {
  setTimeout: globalThis.setTimeout.bind(globalThis),
  clearTimeout: globalThis.clearTimeout.bind(globalThis),
  setInterval: globalThis.setInterval.bind(globalThis),
  clearInterval: globalThis.clearInterval.bind(globalThis),
  queueMicrotask: globalThis.queueMicrotask.bind(globalThis),
  setImmediate: globalThis.setTimeout.bind(globalThis),
  clearImmediate: globalThis.clearTimeout.bind(globalThis)
};
const IS_NODE_JS_TIMEOUT_ENVIRONMENT = setTimeout.toString().includes("new Timeout");
class Timeout {
  /**
   * Constructor.
   * @param callback Callback.
   */
  constructor(callback) {
    this.callback = callback;
  }
}
class BrowserWindow extends EventTarget {
  /**
   * Constructor.
   *
   * @param browserFrame Browser frame.
   * @param [options] Options.
   * @param [options.url] URL.
   */
  constructor(browserFrame, options2) {
    var _f2;
    super();
    _BrowserWindow_instances.add(this);
    this.Node = Node2;
    this.Attr = Attr;
    this.SVGSVGElement = SVGSVGElement;
    this.SVGElement = SVGElement;
    this.SVGGraphicsElement = SVGGraphicsElement;
    this.ShadowRoot = ShadowRoot$1;
    this.ProcessingInstruction = ProcessingInstruction;
    this.Element = Element$1;
    this.CharacterData = CharacterData;
    this.DocumentType = DocumentType;
    this.HTMLAnchorElement = HTMLAnchorElement;
    this.HTMLButtonElement = HTMLButtonElement;
    this.HTMLOptGroupElement = HTMLOptGroupElement;
    this.HTMLOptionElement = HTMLOptionElement;
    this.HTMLElement = HTMLElement$1;
    this.HTMLUnknownElement = HTMLUnknownElement;
    this.HTMLTemplateElement = HTMLTemplateElement;
    this.HTMLInputElement = HTMLInputElement;
    this.HTMLSelectElement = HTMLSelectElement;
    this.HTMLTextAreaElement = HTMLTextAreaElement;
    this.HTMLImageElement = HTMLImageElement;
    this.HTMLStyleElement = HTMLStyleElement;
    this.HTMLLabelElement = HTMLLabelElement;
    this.HTMLSlotElement = HTMLSlotElement;
    this.HTMLMetaElement = HTMLMetaElement;
    this.HTMLMediaElement = HTMLMediaElement;
    this.HTMLAudioElement = HTMLAudioElement;
    this.HTMLVideoElement = HTMLVideoElement;
    this.HTMLBaseElement = HTMLBaseElement;
    this.HTMLDialogElement = HTMLDialogElement;
    this.HTMLTimeElement = HTMLTimeElement;
    this.HTMLHeadElement = HTMLElement$1;
    this.HTMLTitleElement = HTMLElement$1;
    this.HTMLBodyElement = HTMLElement$1;
    this.HTMLHeadingElement = HTMLElement$1;
    this.HTMLParagraphElement = HTMLElement$1;
    this.HTMLHRElement = HTMLElement$1;
    this.HTMLPreElement = HTMLElement$1;
    this.HTMLUListElement = HTMLElement$1;
    this.HTMLOListElement = HTMLElement$1;
    this.HTMLLElement = HTMLElement$1;
    this.HTMLMenuElement = HTMLElement$1;
    this.HTMLDListElement = HTMLElement$1;
    this.HTMLDivElement = HTMLElement$1;
    this.HTMLAreaElement = HTMLElement$1;
    this.HTMLBRElement = HTMLElement$1;
    this.HTMLCanvasElement = HTMLElement$1;
    this.HTMLDataElement = HTMLElement$1;
    this.HTMLDataListElement = HTMLElement$1;
    this.HTMLDetailsElement = HTMLElement$1;
    this.HTMLDirectoryElement = HTMLElement$1;
    this.HTMLFieldSetElement = HTMLElement$1;
    this.HTMLFontElement = HTMLElement$1;
    this.HTMLHtmlElement = HTMLElement$1;
    this.HTMLLegendElement = HTMLElement$1;
    this.HTMLMapElement = HTMLElement$1;
    this.HTMLMarqueeElement = HTMLElement$1;
    this.HTMLMeterElement = HTMLElement$1;
    this.HTMLModElement = HTMLElement$1;
    this.HTMLOutputElement = HTMLElement$1;
    this.HTMLPictureElement = HTMLElement$1;
    this.HTMLProgressElement = HTMLElement$1;
    this.HTMLQuoteElement = HTMLElement$1;
    this.HTMLSourceElement = HTMLElement$1;
    this.HTMLSpanElement = HTMLElement$1;
    this.HTMLTableCaptionElement = HTMLElement$1;
    this.HTMLTableCellElement = HTMLElement$1;
    this.HTMLTableColElement = HTMLElement$1;
    this.HTMLTableElement = HTMLElement$1;
    this.HTMLTableRowElement = HTMLElement$1;
    this.HTMLTableSectionElement = HTMLElement$1;
    this.HTMLFrameElement = HTMLElement$1;
    this.HTMLFrameSetElement = HTMLElement$1;
    this.HTMLEmbedElement = HTMLElement$1;
    this.HTMLObjectElement = HTMLElement$1;
    this.HTMLParamElement = HTMLElement$1;
    this.HTMLTrackElement = HTMLElement$1;
    this.Event = Event;
    this.UIEvent = UIEvent;
    this.CustomEvent = CustomEvent;
    this.AnimationEvent = AnimationEvent;
    this.KeyboardEvent = KeyboardEvent;
    this.MessageEvent = MessageEvent;
    this.MouseEvent = MouseEvent;
    this.PointerEvent = PointerEvent;
    this.FocusEvent = FocusEvent;
    this.WheelEvent = WheelEvent;
    this.InputEvent = InputEvent;
    this.ErrorEvent = ErrorEvent;
    this.StorageEvent = StorageEvent;
    this.SubmitEvent = SubmitEvent;
    this.ProgressEvent = ProgressEvent;
    this.MediaQueryListEvent = MediaQueryListEvent;
    this.HashChangeEvent = HashChangeEvent;
    this.ClipboardEvent = ClipboardEvent;
    this.TouchEvent = TouchEvent;
    this.Touch = Touch;
    this.AudioProcessingEvent = Event;
    this.BeforeInputEvent = Event;
    this.BeforeUnloadEvent = Event;
    this.BlobEvent = Event;
    this.CloseEvent = Event;
    this.CompositionEvent = Event;
    this.CSSFontFaceLoadEvent = Event;
    this.DeviceLightEvent = Event;
    this.DeviceMotionEvent = Event;
    this.DeviceOrientationEvent = Event;
    this.DeviceProximityEvent = Event;
    this.DOMTransactionEvent = Event;
    this.DragEvent = Event;
    this.EditingBeforeInputEvent = Event;
    this.FetchEvent = Event;
    this.GamepadEvent = Event;
    this.IDBVersionChangeEvent = Event;
    this.MediaStreamEvent = Event;
    this.MutationEvent = Event;
    this.OfflineAudioCompletionEvent = Event;
    this.OverconstrainedError = Event;
    this.PageTransitionEvent = Event;
    this.PaymentRequestUpdateEvent = Event;
    this.PopStateEvent = Event;
    this.RelatedEvent = Event;
    this.RTCDataChannelEvent = Event;
    this.RTCIdentityErrorEvent = Event;
    this.RTCIdentityEvent = Event;
    this.RTCPeerConnectionIceEvent = Event;
    this.SensorEvent = Event;
    this.SVGEvent = Event;
    this.SVGZoomEvent = Event;
    this.TimeEvent = Event;
    this.TrackEvent = Event;
    this.TransitionEvent = Event;
    this.UserProximityEvent = Event;
    this.WebGLContextEvent = Event;
    this.TextEvent = Event;
    this.NamedNodeMap = NamedNodeMap;
    this.NodeFilter = NodeFilter;
    this.NodeIterator = NodeIterator;
    this.TreeWalker = TreeWalker;
    this.MutationObserver = MutationObserver;
    this.MutationRecord = MutationRecord;
    this.CSSStyleDeclaration = CSSStyleDeclaration;
    this.EventTarget = EventTarget;
    this.MessagePort = MessagePort;
    this.DataTransfer = DataTransfer;
    this.DataTransferItem = DataTransferItem;
    this.DataTransferItemList = DataTransferItemList;
    this.URL = URL$1;
    this.Location = Location;
    this.CustomElementRegistry = CustomElementRegistry;
    this.Window = this.constructor;
    this.XMLSerializer = XMLSerializer;
    this.ResizeObserver = ResizeObserver;
    this.CSSStyleSheet = CSSStyleSheet;
    this.Blob = Blob;
    this.File = File;
    this.DOMException = DOMException;
    this.History = History;
    this.Screen = Screen;
    this.Storage = Storage;
    this.URLSearchParams = URLSearchParams_1;
    this.HTMLCollection = HTMLCollection;
    this.HTMLFormControlsCollection = HTMLFormControlsCollection;
    this.NodeList = NodeList;
    this.CSSUnitValue = CSSUnitValue;
    this.CSSRule = CSSRule;
    this.CSSContainerRule = CSSContainerRule;
    this.CSSFontFaceRule = CSSFontFaceRule;
    this.CSSKeyframeRule = CSSKeyframeRule;
    this.CSSKeyframesRule = CSSKeyframesRule;
    this.CSSMediaRule = CSSMediaRule;
    this.CSSStyleRule = CSSStyleRule;
    this.CSSSupportsRule = CSSSupportsRule;
    this.Selection = Selection;
    this.Navigator = Navigator;
    this.MimeType = MimeType;
    this.MimeTypeArray = MimeTypeArray;
    this.Plugin = Plugin;
    this.PluginArray = PluginArray;
    this.FileList = FileList;
    this.DOMRect = DOMRect;
    this.DOMRectReadOnly = DOMRectReadOnly;
    this.RadioNodeList = RadioNodeList;
    this.ValidityState = ValidityState;
    this.Headers = NotSupported$5;
    this.XMLHttpRequestUpload = NotSupported$8;
    this.XMLHttpRequestEventTarget = NotSupported$7;
    this.ReadableStream = ReadableStream;
    this.WritableStream = Stream.Writable;
    this.TransformStream = Stream.Transform;
    this.AbortController = NotSupported$b;
    this.AbortSignal = NotSupported$6;
    this.FormData = FormData;
    this.Permissions = Permissions;
    this.PermissionStatus = PermissionStatus;
    this.Clipboard = Clipboard;
    this.ClipboardItem = ClipboardItem;
    this.onload = null;
    this.onerror = null;
    this.self = this;
    this.top = this;
    this.parent = this;
    this.window = this;
    this.globalThis = this;
    this.performance = performance;
    this.screenLeft = 0;
    this.screenTop = 0;
    this.screenX = 0;
    this.screenY = 0;
    this.crypto = webcrypto;
    this.closed = false;
    this.name = "";
    this.Buffer = Buffer$1;
    this[_b] = {};
    this[_c] = [];
    this[_d] = new DocumentReadyStateManager(this);
    this[_e] = null;
    _BrowserWindow_browserFrame.set(this, void 0);
    _BrowserWindow_innerWidth.set(this, null);
    _BrowserWindow_innerHeight.set(this, null);
    _BrowserWindow_outerWidth.set(this, null);
    _BrowserWindow_outerHeight.set(this, null);
    _BrowserWindow_devicePixelRatio.set(this, null);
    _BrowserWindow_zeroTimeouts.set(this, null);
    const asyncTaskManager$1 = browserFrame[asyncTaskManager];
    __classPrivateFieldSet$2(this, _BrowserWindow_browserFrame, browserFrame, "f");
    this.customElements = new CustomElementRegistry(this);
    this[navigator$1] = new Navigator(this);
    this[history] = new History();
    this[screen] = new Screen();
    this[sessionStorage] = StorageFactory.createStorage();
    this[localStorage] = StorageFactory.createStorage();
    this[location] = new Location(__classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f"), (options2 == null ? void 0 : options2.url) ?? "about:blank");
    this[asyncTaskManager] = asyncTaskManager$1;
    this.console = browserFrame.page.console;
    WindowBrowserSettingsReader.setSettings(this, __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").page.context.browser.settings);
    const window2 = this;
    this[setupVMContext]();
    class Request extends NotSupported$2 {
      constructor(input, init) {
        super({ window: window2, asyncTaskManager: asyncTaskManager$1 }, input, init);
      }
    }
    class Response extends NotSupported$1 {
      constructor(body, init) {
        super({ window: window2, browserFrame }, body, init);
      }
    }
    _f2 = window$1;
    Response[_f2] = window2;
    class XMLHttpRequest extends NotSupported$4 {
      constructor() {
        super({ window: window2, browserFrame });
      }
    }
    class FileReader2 extends FileReader$1 {
      constructor() {
        super(window2);
      }
    }
    class DOMParser2 extends DOMParser$1 {
      constructor() {
        super(window2);
      }
    }
    class Range2 extends Range$1 {
      constructor() {
        super(window2);
      }
    }
    class HTMLScriptElement2 extends HTMLScriptElement$1 {
      constructor() {
        super(browserFrame);
      }
    }
    class HTMLLinkElement2 extends HTMLLinkElement$1 {
      constructor() {
        super(browserFrame);
      }
    }
    class HTMLIFrameElement2 extends HTMLIFrameElement$1 {
      constructor() {
        super(browserFrame);
      }
    }
    class HTMLFormElement2 extends HTMLFormElement$1 {
      constructor() {
        super(browserFrame);
      }
    }
    class Document2 extends Document$1 {
      constructor() {
        super({ window: window2, browserFrame });
      }
    }
    class HTMLDocument2 extends HTMLDocument$1 {
      constructor() {
        super({ window: window2, browserFrame });
      }
    }
    class XMLDocument2 extends XMLDocument$1 {
      constructor() {
        super({ window: window2, browserFrame });
      }
    }
    class SVGDocument2 extends SVGDocument$1 {
      constructor() {
        super({ window: window2, browserFrame });
      }
    }
    class Audio2 extends Audio$1 {
    }
    class Image2 extends Image$1 {
    }
    class DocumentFragment2 extends DocumentFragment$1 {
    }
    class Text2 extends Text$1 {
    }
    class Comment2 extends Comment$1 {
    }
    this.Response = Response;
    this.Request = Request;
    this.Image = Image2;
    this.Text = Text2;
    this.Comment = Comment2;
    this.DocumentFragment = DocumentFragment2;
    this.FileReader = FileReader2;
    this.DOMParser = DOMParser2;
    this.XMLHttpRequest = XMLHttpRequest;
    this.Range = Range2;
    this.Audio = Audio2;
    this.HTMLScriptElement = HTMLScriptElement2;
    this.HTMLLinkElement = HTMLLinkElement2;
    this.HTMLIFrameElement = HTMLIFrameElement2;
    this.HTMLFormElement = HTMLFormElement2;
    this.Document = Document2;
    this.HTMLDocument = HTMLDocument2;
    this.XMLDocument = XMLDocument2;
    this.SVGDocument = SVGDocument2;
    this.Document[ownerDocument] = null;
    this.HTMLDocument[ownerDocument] = null;
    this.XMLDocument[ownerDocument] = null;
    this.SVGDocument[ownerDocument] = null;
    this.document = new HTMLDocument2();
    this.document[defaultView] = this;
    this.Audio[ownerDocument] = this.document;
    this.Image[ownerDocument] = this.document;
    this.DocumentFragment[ownerDocument] = this.document;
    this.Text[ownerDocument] = this.document;
    this.Comment[ownerDocument] = this.document;
    this[readyStateManager].waitUntilComplete().then(() => {
      this.document[readyState] = DocumentReadyStateEnum$1.complete;
      this.document.dispatchEvent(new Event("readystatechange"));
      this.document.dispatchEvent(new Event("load", { bubbles: true }));
    });
    __classPrivateFieldGet$2(this, _BrowserWindow_instances, "m", _BrowserWindow_bindToThisScope).call(this);
  }
  /**
   * Returns location.
   */
  get location() {
    return this[location];
  }
  /**
   * Returns location.
   *
   * @param href Href.
   */
  set location(href) {
    this[location].href = href;
  }
  /**
   * Returns history.
   */
  get history() {
    return this[history];
  }
  /**
   * Returns navigator.
   */
  get navigator() {
    return this[navigator$1];
  }
  /**
   * Returns screen.
   */
  get screen() {
    return this[screen];
  }
  /**
   * Returns session storage.
   */
  get sessionStorage() {
    return this[sessionStorage];
  }
  /**
   * Returns local storage.
   */
  get localStorage() {
    return this[localStorage];
  }
  /**
   * Returns opener.
   *
   * @returns Opener.
   */
  get opener() {
    return __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f")[openerWindow];
  }
  /**
   * The number of pixels that the document is currently scrolled horizontally.
   *
   * @returns Scroll X.
   */
  get scrollX() {
    var _a2, _b2;
    return ((_b2 = (_a2 = this.document) == null ? void 0 : _a2.documentElement) == null ? void 0 : _b2.scrollLeft) ?? 0;
  }
  /**
   * The read-only Window property pageXOffset is an alias for scrollX.
   *
   * @returns Scroll X.
   */
  get pageXOffset() {
    return this.scrollX;
  }
  /**
   * The number of pixels that the document is currently scrolled vertically.
   *
   * @returns Scroll Y.
   */
  get scrollY() {
    var _a2, _b2;
    return ((_b2 = (_a2 = this.document) == null ? void 0 : _a2.documentElement) == null ? void 0 : _b2.scrollTop) ?? 0;
  }
  /**
   * The read-only Window property pageYOffset is an alias for scrollY.
   *
   * @returns Scroll Y.
   */
  get pageYOffset() {
    return this.scrollY;
  }
  /**
   * The CSS interface holds useful CSS-related methods.
   *
   * @returns CSS interface.
   */
  get CSS() {
    return new CSS();
  }
  /**
   * Returns inner width.
   *
   * @returns Inner width.
   */
  get innerWidth() {
    if (__classPrivateFieldGet$2(this, _BrowserWindow_innerWidth, "f") === null) {
      return __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").page.viewport.width;
    }
    return __classPrivateFieldGet$2(this, _BrowserWindow_innerWidth, "f");
  }
  /**
   * Sets inner width.
   *
   * @param value Inner width.
   */
  set innerWidth(value2) {
    __classPrivateFieldSet$2(this, _BrowserWindow_innerWidth, value2, "f");
  }
  /**
   * Returns inner height.
   *
   * @returns Inner height.
   */
  get innerHeight() {
    if (__classPrivateFieldGet$2(this, _BrowserWindow_innerHeight, "f") === null) {
      return __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").page.viewport.height;
    }
    return __classPrivateFieldGet$2(this, _BrowserWindow_innerHeight, "f");
  }
  /**
   * Sets inner height.
   *
   * @param value Inner height.
   */
  set innerHeight(value2) {
    __classPrivateFieldSet$2(this, _BrowserWindow_innerHeight, value2, "f");
  }
  /**
   * Returns outer width.
   *
   * @returns Outer width.
   */
  get outerWidth() {
    if (__classPrivateFieldGet$2(this, _BrowserWindow_outerWidth, "f") === null) {
      return __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").page.viewport.width;
    }
    return __classPrivateFieldGet$2(this, _BrowserWindow_outerWidth, "f");
  }
  /**
   * Sets outer width.
   *
   * @param value Outer width.
   */
  set outerWidth(value2) {
    __classPrivateFieldSet$2(this, _BrowserWindow_outerWidth, value2, "f");
  }
  /**
   * Returns outer height.
   *
   * @returns Outer height.
   */
  get outerHeight() {
    if (__classPrivateFieldGet$2(this, _BrowserWindow_outerHeight, "f") === null) {
      return __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").page.viewport.height;
    }
    return __classPrivateFieldGet$2(this, _BrowserWindow_outerHeight, "f");
  }
  /**
   * Sets outer height.
   *
   * @param value Outer height.
   */
  set outerHeight(value2) {
    __classPrivateFieldSet$2(this, _BrowserWindow_outerHeight, value2, "f");
  }
  /**
   * Returns device pixel ratio.
   *
   * @returns Device pixel ratio.
   */
  get devicePixelRatio() {
    if (__classPrivateFieldGet$2(this, _BrowserWindow_devicePixelRatio, "f") === null) {
      return __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").page.viewport.devicePixelRatio;
    }
    return __classPrivateFieldGet$2(this, _BrowserWindow_devicePixelRatio, "f");
  }
  /**
   * Sets device pixel ratio.
   *
   * @param value Device pixel ratio.
   */
  set devicePixelRatio(value2) {
    __classPrivateFieldSet$2(this, _BrowserWindow_devicePixelRatio, value2, "f");
  }
  /**
   * Returns an object containing the values of all CSS properties of an element.
   *
   * @param element Element.
   * @returns CSS style declaration.
   */
  getComputedStyle(element) {
    element[computedStyle] = element[computedStyle] || new CSSStyleDeclaration(element, true);
    return element[computedStyle];
  }
  /**
   * Returns selection.
   *
   * @returns Selection.
   */
  getSelection() {
    return this.document.getSelection();
  }
  /**
   * Scrolls to a particular set of coordinates.
   *
   * @param x X position or options object.
   * @param y Y position.
   */
  scroll(x2, y2) {
    if (typeof x2 === "object") {
      if (x2.behavior === "smooth") {
        this.setTimeout(() => {
          if (x2.top !== void 0) {
            this.document.documentElement.scrollTop = x2.top;
          }
          if (x2.left !== void 0) {
            this.document.documentElement.scrollLeft = x2.left;
          }
        });
      } else {
        if (x2.top !== void 0) {
          this.document.documentElement.scrollTop = x2.top;
        }
        if (x2.left !== void 0) {
          this.document.documentElement.scrollLeft = x2.left;
        }
      }
    } else if (x2 !== void 0 && y2 !== void 0) {
      this.document.documentElement.scrollLeft = x2;
      this.document.documentElement.scrollTop = y2;
    }
  }
  /**
   * Scrolls to a particular set of coordinates.
   *
   * @param x X position or options object.
   * @param y Y position.
   */
  scrollTo(x2, y2) {
    this.scroll(x2, y2);
  }
  /**
   * Shifts focus away from the window.
   */
  blur() {
  }
  /**
   * Gives focus to the window.
   */
  focus() {
  }
  /**
   * Loads a specified resource into a new or existing browsing context (that is, a tab, a window, or an iframe) under a specified name.
   *
   * @param [url] URL.
   * @param [target] Target.
   * @param [features] Window features.
   * @returns Window.
   */
  open(url, target2, features) {
    return WindowPageOpenUtility.openPage(__classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f"), {
      url,
      target: target2,
      features
    });
  }
  /**
   * Closes the window.
   */
  close() {
    var _a2;
    if (((_a2 = __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").page) == null ? void 0 : _a2.mainFrame) === __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f")) {
      this[destroy]();
      __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").page.close();
    }
  }
  /**
   * Returns a new MediaQueryList object that can then be used to determine if the document matches the media query string.
   *
   * @param mediaQueryString A string specifying the media query to parse into a MediaQueryList.
   * @returns A new MediaQueryList.
   */
  matchMedia(mediaQueryString) {
    return new MediaQueryList({ ownerWindow: this, media: mediaQueryString });
  }
  /**
   * Sets a timer which executes a function once the timer expires.
   *
   * @param callback Function to be executed.
   * @param [delay=0] Delay in ms.
   * @param args Arguments passed to the callback function.
   * @returns Timeout ID.
   */
  setTimeout(callback, delay = 0, ...args) {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    if (!delay) {
      if (!__classPrivateFieldGet$2(this, _BrowserWindow_zeroTimeouts, "f")) {
        const settings2 = (_c2 = (_b2 = (_a2 = __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").page) == null ? void 0 : _a2.context) == null ? void 0 : _b2.browser) == null ? void 0 : _c2.settings;
        const useTryCatch2 = !settings2 || !settings2.disableErrorCapturing || settings2.errorCapture === BrowserErrorCaptureEnum$1.tryAndCatch;
        const id2 = TIMER.setTimeout(() => {
          const zeroTimeouts = __classPrivateFieldGet$2(this, _BrowserWindow_zeroTimeouts, "f");
          __classPrivateFieldSet$2(this, _BrowserWindow_zeroTimeouts, null, "f");
          for (const zeroTimeout2 of zeroTimeouts) {
            if (useTryCatch2) {
              WindowErrorUtility.captureError(this, () => zeroTimeout2.callback());
            } else {
              zeroTimeout2.callback();
            }
          }
          __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f")[asyncTaskManager].endTimer(id2);
        });
        __classPrivateFieldSet$2(this, _BrowserWindow_zeroTimeouts, [], "f");
        __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f")[asyncTaskManager].startTimer(id2);
      }
      const zeroTimeout = new Timeout(() => callback(...args));
      __classPrivateFieldGet$2(this, _BrowserWindow_zeroTimeouts, "f").push(zeroTimeout);
      return zeroTimeout;
    }
    const settings = (_f2 = (_e2 = (_d2 = __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").page) == null ? void 0 : _d2.context) == null ? void 0 : _e2.browser) == null ? void 0 : _f2.settings;
    const useTryCatch = !settings || !settings.disableErrorCapturing || settings.errorCapture === BrowserErrorCaptureEnum$1.tryAndCatch;
    const id = TIMER.setTimeout(() => {
      if (useTryCatch) {
        WindowErrorUtility.captureError(this, () => callback(...args));
      } else {
        callback(...args);
      }
      __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f")[asyncTaskManager].endTimer(id);
    }, (settings == null ? void 0 : settings.timer.maxTimeout) !== -1 && delay && delay > (settings == null ? void 0 : settings.timer.maxTimeout) ? settings == null ? void 0 : settings.timer.maxTimeout : delay);
    __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f")[asyncTaskManager].startTimer(id);
    return id;
  }
  /**
   * Cancels a timeout previously established by calling setTimeout().
   *
   * @param id ID of the timeout.
   */
  clearTimeout(id) {
    if (id && id instanceof Timeout) {
      const zeroTimeouts = __classPrivateFieldGet$2(this, _BrowserWindow_zeroTimeouts, "f") || [];
      const index = zeroTimeouts.indexOf(id);
      if (index !== -1) {
        zeroTimeouts.splice(index, 1);
      }
      return;
    }
    if (IS_NODE_JS_TIMEOUT_ENVIRONMENT && (!id || id.constructor.name !== "Timeout")) {
      return;
    }
    TIMER.clearTimeout(id);
    __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f")[asyncTaskManager].endTimer(id);
  }
  /**
   * Calls a function with a fixed time delay between each call.
   *
   * @param callback Function to be executed.
   * @param [delay=0] Delay in ms.
   * @param args Arguments passed to the callback function.
   * @returns Interval ID.
   */
  setInterval(callback, delay = 0, ...args) {
    var _a2, _b2, _c2;
    const settings = (_c2 = (_b2 = (_a2 = __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").page) == null ? void 0 : _a2.context) == null ? void 0 : _b2.browser) == null ? void 0 : _c2.settings;
    const useTryCatch = !settings || !settings.disableErrorCapturing || settings.errorCapture === BrowserErrorCaptureEnum$1.tryAndCatch;
    let iterations = 0;
    const id = TIMER.setInterval(() => {
      if (useTryCatch) {
        WindowErrorUtility.captureError(this, () => callback(...args), () => this.clearInterval(id));
      } else {
        callback(...args);
      }
      if ((settings == null ? void 0 : settings.timer.maxIntervalIterations) !== -1) {
        if (iterations >= (settings == null ? void 0 : settings.timer.maxIntervalIterations)) {
          this.clearInterval(id);
        }
        iterations++;
      }
    }, (settings == null ? void 0 : settings.timer.maxIntervalTime) !== -1 && delay && delay > (settings == null ? void 0 : settings.timer.maxIntervalTime) ? settings == null ? void 0 : settings.timer.maxIntervalTime : delay);
    __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f")[asyncTaskManager].startTimer(id);
    return id;
  }
  /**
   * Cancels a timed repeating action which was previously established by a call to setInterval().
   *
   * @param id ID of the interval.
   */
  clearInterval(id) {
    if (IS_NODE_JS_TIMEOUT_ENVIRONMENT && (!id || id.constructor.name !== "Timeout")) {
      return;
    }
    TIMER.clearInterval(id);
    __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f")[asyncTaskManager].endTimer(id);
  }
  /**
   * Mock animation frames with timeouts.
   *
   * @param callback Callback.
   * @returns ID.
   */
  requestAnimationFrame(callback) {
    var _a2, _b2, _c2;
    const settings = (_c2 = (_b2 = (_a2 = __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").page) == null ? void 0 : _a2.context) == null ? void 0 : _b2.browser) == null ? void 0 : _c2.settings;
    const useTryCatch = !settings || !settings.disableErrorCapturing || settings.errorCapture === BrowserErrorCaptureEnum$1.tryAndCatch;
    const id = TIMER.setImmediate(() => {
      if (useTryCatch) {
        WindowErrorUtility.captureError(this, () => callback(this.performance.now()));
      } else {
        callback(this.performance.now());
      }
      __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f")[asyncTaskManager].endImmediate(id);
    });
    __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f")[asyncTaskManager].startImmediate(id);
    return id;
  }
  /**
   * Mock animation frames with timeouts.
   *
   * @param id ID.
   */
  cancelAnimationFrame(id) {
    if (IS_NODE_JS_TIMEOUT_ENVIRONMENT && (!id || id.constructor.name !== "Immediate")) {
      return;
    }
    TIMER.clearImmediate(id);
    __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f")[asyncTaskManager].endImmediate(id);
  }
  /**
   * Queues a microtask to be executed at a safe time prior to control returning to the browser's event loop.
   *
   * @param callback Function to be executed.
   */
  queueMicrotask(callback) {
    var _a2, _b2, _c2;
    let isAborted = false;
    const taskId = __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f")[asyncTaskManager].startTask(() => isAborted = true);
    const settings = (_c2 = (_b2 = (_a2 = __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").page) == null ? void 0 : _a2.context) == null ? void 0 : _b2.browser) == null ? void 0 : _c2.settings;
    const useTryCatch = !settings || !settings.disableErrorCapturing || settings.errorCapture === BrowserErrorCaptureEnum$1.tryAndCatch;
    TIMER.queueMicrotask(() => {
      if (!isAborted) {
        if (useTryCatch) {
          WindowErrorUtility.captureError(this, callback);
        } else {
          callback();
        }
        __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f")[asyncTaskManager].endTask(taskId);
      }
    });
  }
  /**
   * This method provides an easy, logical way to fetch resources asynchronously across the network.
   *
   * @param url URL.
   * @param [init] Init.
   * @returns Promise.
   */
  async fetch(url, init) {
    return await new NotSupported$9({
      browserFrame: __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f"),
      window: this,
      url,
      init
    }).send();
  }
  /**
   * Creates a Base64-encoded ASCII string from a binary string (i.e., a string in which each character in the string is treated as a byte of binary data).
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/btoa
   * @param data Binay data.
   * @returns Base64-encoded string.
   */
  btoa(data2) {
    return Base64.btoa(data2);
  }
  /**
   * Decodes a string of data which has been encoded using Base64 encoding.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/atob
   * @see https://infra.spec.whatwg.org/#forgiving-base64-encode.
   * @see Https://html.spec.whatwg.org/multipage/webappapis.html#btoa.
   * @param data Binay string.
   * @returns An ASCII string containing decoded data from encodedData.
   */
  atob(data2) {
    return Base64.atob(data2);
  }
  /**
   * Safely enables cross-origin communication between Window objects; e.g., between a page and a pop-up that it spawned, or between a page and an iframe embedded within it.
   *
   * @param message Message.
   * @param [targetOrigin=*] Target origin.
   * @param _transfer Transfer. Not implemented.
   */
  postMessage(message, targetOrigin = "*", _transfer) {
    if (targetOrigin && targetOrigin !== "*" && this.location.origin !== targetOrigin) {
      throw new DOMException(`Failed to execute 'postMessage' on 'Window': The target origin provided ('${targetOrigin}') does not match the recipient window's origin ('${this.location.origin}').`, DOMExceptionNameEnum$1.securityError);
    }
    try {
      JSON.stringify(message);
    } catch (error2) {
      throw new DOMException(`Failed to execute 'postMessage' on 'Window': The provided message cannot be serialized.`, DOMExceptionNameEnum$1.invalidStateError);
    }
    this.setTimeout(() => this.dispatchEvent(new MessageEvent("message", {
      data: message,
      origin: __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").parentFrame ? __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").parentFrame.window.location.origin : __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").window.location.origin,
      source: __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").parentFrame ? __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").parentFrame.window : __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").window,
      lastEventId: ""
    })));
  }
  /**
   * Resizes the window.
   *
   * @param width Width.
   * @param height Height.
   */
  resizeTo(width2, height2) {
    if (!width2 || !height2) {
      throw new DOMException(`Failed to execute 'resizeTo' on 'Window': 2 arguments required, but only ${arguments.length} present.`);
    }
    if (__classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f")[popup]) {
      __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").page.setViewport({ width: width2, height: height2 });
    }
  }
  /**
   * Resizes the current window by a specified amount.
   *
   * @param width Width.
   * @param height Height.
   */
  resizeBy(width2, height2) {
    if (!width2 || !height2) {
      throw new DOMException(`Failed to execute 'resizeBy' on 'Window': 2 arguments required, but only ${arguments.length} present.`);
    }
    if (__classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f")[popup]) {
      const viewport2 = __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").page.viewport;
      __classPrivateFieldGet$2(this, _BrowserWindow_browserFrame, "f").page.setViewport({
        width: viewport2.width + width2,
        height: viewport2.height + height2
      });
    }
  }
  /**
   * Setup of VM context.
   */
  [(_BrowserWindow_browserFrame = /* @__PURE__ */ new WeakMap(), _BrowserWindow_innerWidth = /* @__PURE__ */ new WeakMap(), _BrowserWindow_innerHeight = /* @__PURE__ */ new WeakMap(), _BrowserWindow_outerWidth = /* @__PURE__ */ new WeakMap(), _BrowserWindow_outerHeight = /* @__PURE__ */ new WeakMap(), _BrowserWindow_devicePixelRatio = /* @__PURE__ */ new WeakMap(), _BrowserWindow_zeroTimeouts = /* @__PURE__ */ new WeakMap(), _BrowserWindow_instances = /* @__PURE__ */ new WeakSet(), _b = captureEventListenerCount, _c = mutationObservers, _d = readyStateManager, _e = asyncTaskManager, setupVMContext)]() {
    if (!VM.isContext(this)) {
      VM.createContext(this);
      VMGlobalPropertyScript.runInContext(this);
    }
  }
  /**
   * Destroys the window.
   */
  [destroy]() {
    if (!this.Audio[ownerDocument]) {
      return;
    }
    this.closed = true;
    this[asyncTaskManager] = null;
    this.Audio[ownerDocument] = null;
    this.Image[ownerDocument] = null;
    this.DocumentFragment[ownerDocument] = null;
    this.Text[ownerDocument] = null;
    this.Comment[ownerDocument] = null;
    const mutationObservers$1 = this[mutationObservers];
    for (const mutationObserver of mutationObservers$1) {
      mutationObserver.disconnect();
    }
    this[mutationObservers] = [];
    for (const node2 of this.document[childNodes].slice()) {
      if (node2.disconnectedCallback) {
        delete node2.disconnectedCallback;
      }
      this.document.removeChild(node2);
    }
    if (this.customElements[destroy]) {
      this.customElements[destroy]();
    }
    this.document[activeElement] = null;
    this.document[nextActiveElement] = null;
    this.document[currentScript] = null;
    this.document[selection] = null;
    WindowBrowserSettingsReader.removeSettings(this);
  }
}
_a = BrowserWindow, _BrowserWindow_bindToThisScope = function _BrowserWindow_bindToThisScope2() {
  var _a2, _b2;
  const propertyDescriptors = Object.assign(Object.getOwnPropertyDescriptors(EventTarget.prototype), Object.getOwnPropertyDescriptors(_a.prototype));
  for (const key of Object.keys(propertyDescriptors)) {
    const descriptor = propertyDescriptors[key];
    if (descriptor.get || descriptor.set) {
      Object.defineProperty(this, key, {
        configurable: true,
        enumerable: true,
        get: (_a2 = descriptor.get) == null ? void 0 : _a2.bind(this),
        set: (_b2 = descriptor.set) == null ? void 0 : _b2.bind(this)
      });
    } else if (key !== "constructor" && key[0] !== "_" && key[0] === key[0].toLowerCase() && typeof this[key] === "function" && !this[key].toString().startsWith("class ")) {
      this[key] = this[key].bind(this);
    }
  }
};
var __classPrivateFieldSet$1 = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet$1 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _VirtualConsole_printer, _VirtualConsole_count, _VirtualConsole_time, _VirtualConsole_groupID, _VirtualConsole_groups;
class VirtualConsole {
  /**
   * Constructor.
   *
   * @param printer Console printer.
   */
  constructor(printer) {
    _VirtualConsole_printer.set(this, void 0);
    _VirtualConsole_count.set(this, {});
    _VirtualConsole_time.set(this, {});
    _VirtualConsole_groupID.set(this, 0);
    _VirtualConsole_groups.set(this, []);
    __classPrivateFieldSet$1(this, _VirtualConsole_printer, printer, "f");
  }
  /**
   * Writes an error message to the console if the assertion is false. If the assertion is true, nothing happens.
   *
   * @param assertion Assertion.
   * @param args Arguments.
   */
  assert(assertion, ...args) {
    if (!assertion) {
      __classPrivateFieldGet$1(this, _VirtualConsole_printer, "f").print({
        type: VirtualConsoleLogTypeEnum$1.assert,
        level: VirtualConsoleLogLevelEnum$1.error,
        message: ["Assertion failed:", ...args],
        group: __classPrivateFieldGet$1(this, _VirtualConsole_groups, "f")[__classPrivateFieldGet$1(this, _VirtualConsole_groups, "f").length - 1] || null
      });
    }
  }
  /**
   * Clears the console.
   */
  clear() {
    __classPrivateFieldGet$1(this, _VirtualConsole_printer, "f").clear();
  }
  /**
   * Logs the number of times that this particular call to count() has been called.
   *
   * @param [label='default'] Label.
   */
  count(label = "default") {
    if (!__classPrivateFieldGet$1(this, _VirtualConsole_count, "f")[label]) {
      __classPrivateFieldGet$1(this, _VirtualConsole_count, "f")[label] = 0;
    }
    __classPrivateFieldGet$1(this, _VirtualConsole_count, "f")[label]++;
    __classPrivateFieldGet$1(this, _VirtualConsole_printer, "f").print({
      type: VirtualConsoleLogTypeEnum$1.count,
      level: VirtualConsoleLogLevelEnum$1.info,
      message: [`${label}: ${__classPrivateFieldGet$1(this, _VirtualConsole_count, "f")[label]}`],
      group: __classPrivateFieldGet$1(this, _VirtualConsole_groups, "f")[__classPrivateFieldGet$1(this, _VirtualConsole_groups, "f").length - 1] || null
    });
  }
  /**
   * Resets the counter.
   *
   * @param [label='default'] Label.
   */
  countReset(label = "default") {
    delete __classPrivateFieldGet$1(this, _VirtualConsole_count, "f")[label];
    __classPrivateFieldGet$1(this, _VirtualConsole_printer, "f").print({
      type: VirtualConsoleLogTypeEnum$1.countReset,
      level: VirtualConsoleLogLevelEnum$1.warn,
      message: [`${label}: 0`],
      group: __classPrivateFieldGet$1(this, _VirtualConsole_groups, "f")[__classPrivateFieldGet$1(this, _VirtualConsole_groups, "f").length - 1] || null
    });
  }
  /**
   * Outputs a message to the web console at the "debug" log level.
   *
   * @param args Arguments.
   */
  debug(...args) {
    __classPrivateFieldGet$1(this, _VirtualConsole_printer, "f").print({
      type: VirtualConsoleLogTypeEnum$1.debug,
      level: VirtualConsoleLogLevelEnum$1.log,
      message: args,
      group: __classPrivateFieldGet$1(this, _VirtualConsole_groups, "f")[__classPrivateFieldGet$1(this, _VirtualConsole_groups, "f").length - 1] || null
    });
  }
  /**
   * Displays an interactive list of the properties of the specified JavaScript object.
   *
   * @param data Data.
   */
  dir(data2) {
    __classPrivateFieldGet$1(this, _VirtualConsole_printer, "f").print({
      type: VirtualConsoleLogTypeEnum$1.dir,
      level: VirtualConsoleLogLevelEnum$1.log,
      message: [data2],
      group: __classPrivateFieldGet$1(this, _VirtualConsole_groups, "f")[__classPrivateFieldGet$1(this, _VirtualConsole_groups, "f").length - 1] || null
    });
  }
  /**
   * Displays an interactive tree of the descendant elements of the specified XML/HTML element.
   *
   * @param data Data.
   */
  dirxml(data2) {
    __classPrivateFieldGet$1(this, _VirtualConsole_printer, "f").print({
      type: VirtualConsoleLogTypeEnum$1.dirxml,
      level: VirtualConsoleLogLevelEnum$1.log,
      message: [data2],
      group: __classPrivateFieldGet$1(this, _VirtualConsole_groups, "f")[__classPrivateFieldGet$1(this, _VirtualConsole_groups, "f").length - 1] || null
    });
  }
  /**
   * Outputs an error message to the console.
   *
   * @param args Arguments.
   */
  error(...args) {
    __classPrivateFieldGet$1(this, _VirtualConsole_printer, "f").print({
      type: VirtualConsoleLogTypeEnum$1.error,
      level: VirtualConsoleLogLevelEnum$1.error,
      message: args,
      group: __classPrivateFieldGet$1(this, _VirtualConsole_groups, "f")[__classPrivateFieldGet$1(this, _VirtualConsole_groups, "f").length - 1] || null
    });
  }
  /**
   * Alias for error().
   *
   * @deprecated
   * @alias error()
   * @param args Arguments.
   */
  exception(...args) {
    this.error(...args);
  }
  /**
   * Creates a new inline group in the console, causing any subsequent console messages to be indented by an additional level, until console.groupEnd() is called.
   *
   * @param [label] Label.
   */
  group(label) {
    var _a2;
    __classPrivateFieldSet$1(this, _VirtualConsole_groupID, (_a2 = __classPrivateFieldGet$1(this, _VirtualConsole_groupID, "f"), _a2++, _a2), "f");
    const group = {
      id: __classPrivateFieldGet$1(this, _VirtualConsole_groupID, "f"),
      label: label || "default",
      collapsed: false,
      parent: __classPrivateFieldGet$1(this, _VirtualConsole_groups, "f")[__classPrivateFieldGet$1(this, _VirtualConsole_groups, "f").length - 1] || null
    };
    __classPrivateFieldGet$1(this, _VirtualConsole_groups, "f").push(group);
    __classPrivateFieldGet$1(this, _VirtualConsole_printer, "f").print({
      type: VirtualConsoleLogTypeEnum$1.group,
      level: VirtualConsoleLogLevelEnum$1.log,
      message: [label || "default"],
      group
    });
  }
  /**
   * Creates a new inline group in the console, but prints it as collapsed, requiring the use of a disclosure button to expand it.
   *
   * @param [label] Label.
   */
  groupCollapsed(label) {
    var _a2;
    __classPrivateFieldSet$1(this, _VirtualConsole_groupID, (_a2 = __classPrivateFieldGet$1(this, _VirtualConsole_groupID, "f"), _a2++, _a2), "f");
    const group = {
      id: __classPrivateFieldGet$1(this, _VirtualConsole_groupID, "f"),
      label: label || "default",
      collapsed: true,
      parent: __classPrivateFieldGet$1(this, _VirtualConsole_groups, "f")[__classPrivateFieldGet$1(this, _VirtualConsole_groups, "f").length - 1] || null
    };
    __classPrivateFieldGet$1(this, _VirtualConsole_groups, "f").push(group);
    __classPrivateFieldGet$1(this, _VirtualConsole_printer, "f").print({
      type: VirtualConsoleLogTypeEnum$1.groupCollapsed,
      level: VirtualConsoleLogLevelEnum$1.log,
      message: [label || "default"],
      group
    });
  }
  /**
   * Exits the current inline group in the console.
   */
  groupEnd() {
    if (__classPrivateFieldGet$1(this, _VirtualConsole_groups, "f").length === 0) {
      return;
    }
    __classPrivateFieldGet$1(this, _VirtualConsole_groups, "f").pop();
  }
  /**
   *
   * @param args
   */
  info(...args) {
    __classPrivateFieldGet$1(this, _VirtualConsole_printer, "f").print({
      type: VirtualConsoleLogTypeEnum$1.info,
      level: VirtualConsoleLogLevelEnum$1.info,
      message: args,
      group: __classPrivateFieldGet$1(this, _VirtualConsole_groups, "f")[__classPrivateFieldGet$1(this, _VirtualConsole_groups, "f").length - 1] || null
    });
  }
  /**
   * Outputs a message to the console.
   *
   * @param args Arguments.
   */
  log(...args) {
    __classPrivateFieldGet$1(this, _VirtualConsole_printer, "f").print({
      type: VirtualConsoleLogTypeEnum$1.log,
      level: VirtualConsoleLogLevelEnum$1.log,
      message: args,
      group: __classPrivateFieldGet$1(this, _VirtualConsole_groups, "f")[__classPrivateFieldGet$1(this, _VirtualConsole_groups, "f").length - 1] || null
    });
  }
  /**
   * Starts recording a performance profile.
   *
   * TODO: Implement this.
   */
  profile() {
    throw new Error("Method not implemented.");
  }
  /**
   * Stops recording a performance profile.
   *
   * TODO: Implement this.
   */
  profileEnd() {
    throw new Error("Method not implemented.");
  }
  /**
   * Displays tabular data as a table.
   *
   * @param data Data.
   */
  table(data2) {
    __classPrivateFieldGet$1(this, _VirtualConsole_printer, "f").print({
      type: VirtualConsoleLogTypeEnum$1.table,
      level: VirtualConsoleLogLevelEnum$1.log,
      message: [data2],
      group: __classPrivateFieldGet$1(this, _VirtualConsole_groups, "f")[__classPrivateFieldGet$1(this, _VirtualConsole_groups, "f").length - 1] || null
    });
  }
  /**
   * Starts a timer you can use to track how long an operation takes.
   *
   * @param [label=default] Label.
   */
  time(label = "default") {
    __classPrivateFieldGet$1(this, _VirtualConsole_time, "f")[label] = performance.now();
  }
  /**
   * Stops a timer that was previously started by calling console.time().
   * The method logs the elapsed time in milliseconds.
   *
   * @param [label=default] Label.
   */
  timeEnd(label = "default") {
    const time = __classPrivateFieldGet$1(this, _VirtualConsole_time, "f")[label];
    if (time) {
      const duration2 = performance.now() - time;
      __classPrivateFieldGet$1(this, _VirtualConsole_printer, "f").print({
        type: VirtualConsoleLogTypeEnum$1.timeEnd,
        level: VirtualConsoleLogLevelEnum$1.info,
        message: [`${label}: ${duration2}ms - timer ended`],
        group: __classPrivateFieldGet$1(this, _VirtualConsole_groups, "f")[__classPrivateFieldGet$1(this, _VirtualConsole_groups, "f").length - 1] || null
      });
    }
  }
  /**
   * Logs the current value of a timer that was previously started by calling console.time().
   * The method logs the elapsed time in milliseconds.
   *
   * @param [label=default] Label.
   * @param [args] Arguments.
   */
  timeLog(label = "default", ...args) {
    const time = __classPrivateFieldGet$1(this, _VirtualConsole_time, "f")[label];
    if (time) {
      const duration2 = performance.now() - time;
      __classPrivateFieldGet$1(this, _VirtualConsole_printer, "f").print({
        type: VirtualConsoleLogTypeEnum$1.timeLog,
        level: VirtualConsoleLogLevelEnum$1.info,
        message: [`${label}: ${duration2}ms`, ...args],
        group: __classPrivateFieldGet$1(this, _VirtualConsole_groups, "f")[__classPrivateFieldGet$1(this, _VirtualConsole_groups, "f").length - 1] || null
      });
    }
  }
  /**
   * Adds a single marker to the browser's Performance tool.
   *
   * TODO: Implement this.
   */
  timeStamp() {
    throw new Error("Method not implemented.");
  }
  /**
   * Outputs a stack trace to the console.
   *
   * @param args Arguments.
   */
  trace(...args) {
    __classPrivateFieldGet$1(this, _VirtualConsole_printer, "f").print({
      type: VirtualConsoleLogTypeEnum$1.trace,
      level: VirtualConsoleLogLevelEnum$1.log,
      message: [...args, new Error("stack").stack.replace("Error: stack", "")],
      group: __classPrivateFieldGet$1(this, _VirtualConsole_groups, "f")[__classPrivateFieldGet$1(this, _VirtualConsole_groups, "f").length - 1] || null
    });
  }
  /**
   * Outputs a warning message to the console.
   *
   * @param args Arguments.
   */
  warn(...args) {
    __classPrivateFieldGet$1(this, _VirtualConsole_printer, "f").print({
      type: VirtualConsoleLogTypeEnum$1.warn,
      level: VirtualConsoleLogLevelEnum$1.warn,
      message: args,
      group: __classPrivateFieldGet$1(this, _VirtualConsole_groups, "f")[__classPrivateFieldGet$1(this, _VirtualConsole_groups, "f").length - 1] || null
    });
  }
}
_VirtualConsole_printer = /* @__PURE__ */ new WeakMap(), _VirtualConsole_count = /* @__PURE__ */ new WeakMap(), _VirtualConsole_time = /* @__PURE__ */ new WeakMap(), _VirtualConsole_groupID = /* @__PURE__ */ new WeakMap(), _VirtualConsole_groups = /* @__PURE__ */ new WeakMap();
class BrowserPageUtility {
  /**
   * Returns frames for a page.
   *
   * @param page Page.
   * @returns Frames.
   */
  static getFrames(page) {
    return this.findFrames(page.mainFrame);
  }
  /**
   * Aborts all ongoing operations and destroys the page.
   *
   * @param page Page.
   */
  static closePage(page) {
    return new Promise((resolve3, reject) => {
      if (!page.mainFrame) {
        resolve3();
        return;
      }
      const index = page.context.pages.indexOf(page);
      if (index !== -1) {
        page.context.pages.splice(index, 1);
      }
      BrowserFrameFactory.destroyFrame(page.mainFrame).then(() => {
        page.virtualConsolePrinter = null;
        page.mainFrame = null;
        page.context = null;
        resolve3();
      }).catch((error2) => reject(error2));
    });
  }
  /**
   * Returns all frames.
   *
   * @param parentFrame Parent frame.
   * @returns Frames, including the parent.
   */
  static findFrames(parentFrame) {
    let frames = [parentFrame];
    for (const frame of parentFrame.childFrames) {
      frames = frames.concat(this.findFrames(frame));
    }
    return frames;
  }
}
const DefaultBrowserPageViewport = {
  width: 1024,
  height: 768,
  devicePixelRatio: 1
};
class NotSupported13 {
}
const PackageVersion = { version: "0.0.0" };
const DefaultBrowserSettings = {
  disableJavaScriptEvaluation: false,
  disableJavaScriptFileLoading: false,
  disableCSSFileLoading: false,
  disableIframePageLoading: false,
  disableComputedStyleRendering: false,
  disableErrorCapturing: false,
  errorCapture: BrowserErrorCaptureEnum$1.tryAndCatch,
  enableFileSystemHttpRequests: false,
  timer: {
    maxTimeout: -1,
    maxIntervalTime: -1,
    maxIntervalIterations: -1
  },
  navigation: {
    disableMainFrameNavigation: false,
    disableChildFrameNavigation: false,
    disableChildPageNavigation: false,
    disableFallbackToSetURL: false,
    crossOriginPolicy: BrowserNavigationCrossOriginPolicyEnum$1.anyOrigin
  },
  navigator: {
    userAgent: `Mozilla/5.0 (X11; ${"Unknown".charAt(0).toUpperCase() + "Unknown".slice(1) + " Unknown"}) AppleWebKit/537.36 (KHTML, like Gecko) HappyDOM/${PackageVersion.version}`,
    maxTouchPoints: 0
  },
  device: {
    prefersColorScheme: "light",
    mediaType: "screen"
  }
};
class BrowserSettingsFactory {
  /**
   * Returns browser settings.
   *
   * @param [settings] Browser settings.
   * @param [freezeObject] "true" to freeze the object.
   * @returns Settings.
   */
  static createSettings(settings) {
    return {
      ...DefaultBrowserSettings,
      ...settings,
      navigation: {
        ...DefaultBrowserSettings.navigation,
        ...settings == null ? void 0 : settings.navigation
      },
      navigator: {
        ...DefaultBrowserSettings.navigator,
        ...settings == null ? void 0 : settings.navigator
      },
      timer: {
        ...DefaultBrowserSettings.timer,
        ...settings == null ? void 0 : settings.timer
      },
      device: {
        ...DefaultBrowserSettings.device,
        ...settings == null ? void 0 : settings.device
      }
    };
  }
}
class DetachedBrowserPage {
  /**
   * Constructor.
   *
   * @param context Browser context.
   */
  constructor(context) {
    this.virtualConsolePrinter = new VirtualConsolePrinter();
    this.viewport = Object.assign({}, DefaultBrowserPageViewport);
    this.context = context;
    this.console = context.browser.console ?? new VirtualConsole(this.virtualConsolePrinter);
    this.mainFrame = new DetachedBrowserFrame(this);
  }
  /**
   * Returns frames.
   */
  get frames() {
    return BrowserPageUtility.getFrames(this);
  }
  /**
   * Returns the viewport.
   */
  get content() {
    return this.mainFrame.content;
  }
  /**
   * Sets the content.
   *
   * @param content Content.
   */
  set content(content2) {
    this.mainFrame.content = content2;
  }
  /**
   * Returns the URL.
   *
   * @returns URL.
   */
  get url() {
    return this.mainFrame.url;
  }
  /**
   * Sets the content.
   *
   * @param url URL.
   */
  set url(url) {
    this.mainFrame.url = url;
  }
  /**
   * Aborts all ongoing operations and destroys the page.
   */
  close() {
    return new Promise((resolve3, reject) => {
      const context = this.context;
      BrowserPageUtility.closePage(this).then(() => {
        if (context.pages[0] === this) {
          context.close().then(resolve3).catch(reject);
        } else {
          resolve3();
        }
      }).catch(reject);
    });
  }
  /**
   * Returns a promise that is resolved when all resources has been loaded, fetch has completed, and all async tasks such as timers are complete.
   */
  waitUntilComplete() {
    return this.mainFrame.waitUntilComplete();
  }
  /**
   * Returns a promise that is resolved when the page has navigated and the response HTML has been written to the document.
   */
  waitForNavigation() {
    return this.mainFrame.waitForNavigation();
  }
  /**
   * Aborts all ongoing operations.
   */
  abort() {
    return this.mainFrame.abort();
  }
  /**
   * Evaluates code or a VM Script in the page's context.
   *
   * @param script Script.
   * @returns Result.
   */
  evaluate(script) {
    return this.mainFrame.evaluate(script);
  }
  /**
   * Sets the viewport.
   *
   * @param viewport Viewport.
   */
  setViewport(viewport2) {
    const previousViewport = Object.assign({}, this.viewport);
    Object.assign(this.viewport, viewport2);
    if (previousViewport.width !== this.viewport.width || previousViewport.height !== this.viewport.height || previousViewport.devicePixelRatio !== this.viewport.devicePixelRatio) {
      this.mainFrame.window.dispatchEvent(new Event("resize"));
    }
  }
  /**
   * Go to a page.
   *
   * @param url URL.
   * @param [options] Options.
   * @returns Response.
   */
  goto(url, options2) {
    return this.mainFrame.goto(url, options2);
  }
  /**
   * Reloads the current page.
   *
   * @param [options] Options.
   * @returns Response.
   */
  reload(options2) {
    return this.mainFrame.reload(options2);
  }
}
class DetachedBrowserContext {
  /**
   * Constructor.
   *
   * @param browser Browser.
   */
  constructor(browser) {
    this.cookieContainer = new CookieContainer();
    this.responseCache = new NotSupported$c();
    this.preflightResponseCache = new NotSupported13();
    this.browser = browser;
    this.pages = [];
    this.pages.push(new DetachedBrowserPage(this));
  }
  /**
   * Aborts all ongoing operations and destroys the context.
   */
  async close() {
    if (!this.browser) {
      return;
    }
    await Promise.all(this.pages.slice().map((page) => page.close()));
    const browser = this.browser;
    const index = browser.contexts.indexOf(this);
    if (index !== -1) {
      browser.contexts.splice(index, 1);
    }
    this.pages = [];
    this.browser = null;
    this.cookieContainer = null;
    this.responseCache.clear();
    this.preflightResponseCache.clear();
    this.responseCache = null;
    this.preflightResponseCache = null;
    if (browser.contexts.length === 0) {
      browser.close();
    }
  }
  /**
   * Returns a promise that is resolved when all resources has been loaded, fetch has completed, and all async tasks such as timers are complete.
   *
   * @returns Promise.
   */
  async waitUntilComplete() {
    await Promise.all(this.pages.map((page) => page.waitUntilComplete()));
  }
  /**
   * Aborts all ongoing operations.
   */
  abort() {
    return new Promise((resolve3, reject) => {
      if (!this.pages.length) {
        resolve3();
        return;
      }
      Promise.all(this.pages.slice().map((page) => page.abort())).then(() => resolve3()).catch((error2) => reject(error2));
    });
  }
  /**
   * Creates a new page.
   *
   * @param [opener] Opener.
   * @returns Page.
   */
  newPage() {
    const page = new DetachedBrowserPage(this);
    this.pages.push(page);
    return page;
  }
}
class DetachedBrowser {
  /**
   * Constructor.
   *
   * @param windowClass Window class.
   * @param [options] Options.
   * @param [options.settings] Browser settings.
   * @param [options.console] Console.
   */
  constructor(windowClass, options2) {
    this.windowClass = windowClass;
    this.console = (options2 == null ? void 0 : options2.console) || null;
    this.settings = BrowserSettingsFactory.createSettings(options2 == null ? void 0 : options2.settings);
    this.contexts = [];
    this.contexts.push(new DetachedBrowserContext(this));
  }
  /**
   * Returns the default context.
   *
   * @returns Default context.
   */
  get defaultContext() {
    if (this.contexts.length === 0) {
      throw new Error("No default context. The browser has been closed.");
    }
    return this.contexts[0];
  }
  /**
   * Aborts all ongoing operations and destroys the browser.
   */
  async close() {
    await Promise.all(this.contexts.slice().map((context) => context.close()));
    this.contexts = [];
    this.console = null;
    this.windowClass = null;
  }
  /**
   * Returns a promise that is resolved when all resources has been loaded, fetch has completed, and all async tasks such as timers are complete.
   *
   * @returns Promise.
   */
  async waitUntilComplete() {
    await Promise.all(this.contexts.map((page) => page.waitUntilComplete()));
  }
  /**
   * Aborts all ongoing operations.
   */
  abort() {
    return new Promise((resolve3, reject) => {
      if (!this.contexts.length) {
        resolve3();
        return;
      }
      Promise.all(this.contexts.slice().map((context) => context.abort())).then(() => resolve3()).catch((error2) => reject(error2));
    });
  }
  /**
   * Creates a new incognito context.
   */
  newIncognitoContext() {
    throw new Error("Not possible to create a new context on a detached browser.");
  }
  /**
   * Creates a new page.
   *
   * @returns Page.
   */
  newPage() {
    if (this.contexts.length === 0) {
      throw new Error("No default context. The browser has been closed.");
    }
    return this.contexts[0].newPage();
  }
}
var __classPrivateFieldSet = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DetachedWindowAPI_browserFrame;
class DetachedWindowAPI {
  /**
   * Constructor.
   *
   * @param browserFrame Browser frame.
   */
  constructor(browserFrame) {
    _DetachedWindowAPI_browserFrame.set(this, void 0);
    __classPrivateFieldSet(this, _DetachedWindowAPI_browserFrame, browserFrame, "f");
  }
  /**
   * Returns settings.
   *
   * @returns Settings.
   */
  get settings() {
    return __classPrivateFieldGet(this, _DetachedWindowAPI_browserFrame, "f").page.context.browser.settings;
  }
  /**
   * Returns virtual console printer.
   *
   * @returns Virtual console printer.
   */
  get virtualConsolePrinter() {
    return __classPrivateFieldGet(this, _DetachedWindowAPI_browserFrame, "f").page.virtualConsolePrinter;
  }
  /**
   * Waits for all async tasks to complete.
   *
   * @returns Promise.
   */
  waitUntilComplete() {
    return __classPrivateFieldGet(this, _DetachedWindowAPI_browserFrame, "f").waitUntilComplete();
  }
  /**
   * Waits for all async tasks to complete.
   *
   * @deprecated Use waitUntilComplete() instead.
   * @returns Promise.
   */
  whenAsyncComplete() {
    return this.waitUntilComplete();
  }
  /**
   * Aborts all async tasks.
   */
  abort() {
    return __classPrivateFieldGet(this, _DetachedWindowAPI_browserFrame, "f").abort();
  }
  /**
   * Aborts all async tasks.
   *
   * @deprecated Use abort() instead.
   */
  cancelAsync() {
    return this.abort();
  }
  /**
   * Aborts all async tasks and closes the window.
   */
  close() {
    return __classPrivateFieldGet(this, _DetachedWindowAPI_browserFrame, "f").page.close();
  }
  /**
   * Sets the URL without navigating the browser.
   *
   * @param url URL.
   */
  setURL(url) {
    __classPrivateFieldGet(this, _DetachedWindowAPI_browserFrame, "f").url = url;
  }
  /**
   * Sets the viewport.
   *
   * @param viewport Viewport.
   */
  setViewport(viewport2) {
    __classPrivateFieldGet(this, _DetachedWindowAPI_browserFrame, "f").page.setViewport(viewport2);
  }
  /**
   * Sets the window size.
   *
   * @deprecated Use setViewport() instead.
   * @param options Options.
   * @param options.width Width.
   * @param options.height Height.
   */
  setWindowSize(options2) {
    this.setViewport({
      width: options2 == null ? void 0 : options2.width,
      height: options2 == null ? void 0 : options2.height
    });
  }
  /**
   * Sets the window width.
   *
   * @deprecated Use setViewport() instead.
   * @param width Width.
   */
  setInnerWidth(width2) {
    this.setViewport({ width: width2 });
  }
  /**
   * Sets the window height.
   *
   * @deprecated Use setViewport() instead.
   * @param height Height.
   */
  setInnerHeight(height2) {
    this.setViewport({ height: height2 });
  }
}
_DetachedWindowAPI_browserFrame = /* @__PURE__ */ new WeakMap();
class Window extends BrowserWindow {
  /**
   * Constructor.
   *
   * @param [options] Options.
   * @param [options.width] Window width. Defaults to "1024".
   * @param [options.height] Window height. Defaults to "768".
   * @param [options.innerWidth] Inner width. Deprecated. Defaults to "1024".
   * @param [options.innerHeight] Inner height. Deprecated. Defaults to "768".
   * @param [options.url] URL.
   * @param [options.console] Console.
   * @param [options.settings] Settings.
   */
  constructor(options2) {
    const browser = new DetachedBrowser(BrowserWindow, {
      console: options2 == null ? void 0 : options2.console,
      settings: options2 == null ? void 0 : options2.settings
    });
    const browserPage = browser.defaultContext.pages[0];
    const browserFrame = browserPage.mainFrame;
    if (options2 && (options2.width || options2.height || options2.innerWidth || options2.innerHeight)) {
      Object.assign(browserPage.viewport, {
        width: options2.width || options2.innerWidth || browserPage.viewport.width,
        height: options2.height || options2.innerHeight || browserPage.viewport.height
      });
    }
    super(browserFrame, {
      url: options2 == null ? void 0 : options2.url
    });
    browserFrame.window = this;
    this.happyDOM = new DetachedWindowAPI(browserFrame);
  }
}
function createConstant(kind) {
  return {
    _type: "Constant",
    kind
  };
}
const Never = createConstant("never");
function isString(value2) {
  return typeof value2 === "string";
}
function isFunction(value2) {
  return typeof value2 === "function" ? true : false;
}
function callsites() {
  const _prepareStackTrace = Error.prepareStackTrace;
  try {
    let result = [];
    Error.prepareStackTrace = (_, callSites) => {
      const callSitesWithoutCurrent = callSites.slice(1);
      result = callSitesWithoutCurrent;
      return callSitesWithoutCurrent;
    };
    new Error().stack;
    return result;
  } finally {
    Error.prepareStackTrace = _prepareStackTrace;
  }
}
function isHappyWrapperError(err) {
  return typeof err === "object" && err.kind === "HappyWrapper";
}
var isInspectionTuple = (thing) => {
  return Array.isArray(thing) && thing.length === 2 && typeof thing[0] === "string" && !Array.isArray(thing[1]);
};
function isDocument(dom) {
  return typeof dom === "object" && dom !== null && !isElement(dom) && "body" in dom;
}
function isFragment(dom) {
  return typeof dom === "object" && dom !== null && !isElement(dom) && !isTextNode(dom) && !("body" in dom);
}
function isElement(el) {
  return typeof el === "object" && el !== null && "outerHTML" in el && el.nodeType === 1;
}
var isElementLike = (container) => {
  if (isDocument(container)) {
    return container.body.childNodes.length === 1 && container.body.firstChild === container.body.firstElementChild;
  }
  return isFragment(container) && container.childNodes.length === 1 && container.firstChild === container.firstElementChild;
};
function isTextNodeLike(node2) {
  var _a2;
  return (isDocument(node2) || isFragment(node2)) && ((_a2 = node2 == null ? void 0 : node2.childNodes) == null ? void 0 : _a2.length) === 1 && isTextNode(node2.firstChild);
}
var isUpdateSignature = (args) => {
  return Array.isArray(args) && args.length === 3 && // && (typeof args[0] === 'string' || typeof args[0] === 'object')
  typeof args[1] === "number" && typeof args[2] === "number";
};
function isTextNode(node2) {
  if (typeof node2 === "string") {
    const test = createFragment(node2);
    return isTextNodeLike(test);
  } else {
    return typeof node2 === "object" && node2 !== null && !("firstElementChild" in node2);
  }
}
var isContainer = (thing) => {
  return isDocument(thing) || isFragment(thing) || isElement(thing) || isTextNode(thing);
};
var nodeTypeLookup = (type) => {
  switch (type) {
    case 1: {
      return "element";
    }
    case 3: {
      return "text";
    }
    case 8: {
      return "comment";
    }
    case 11: {
      return "fragment";
    }
  }
};
var getNodeType = (node2) => {
  if (typeof node2 === "string") {
    return "html";
  }
  const byType = nodeTypeLookup(node2.nodeType);
  if (byType) {
    return byType;
  }
  return isTextNode(node2) ? "text" : isElement(node2) ? "element" : isDocument(node2) ? "document" : isFragment(node2) ? "fragment" : "node";
};
var solveForNodeType = (_ = void 0) => {
  const solver = () => ({
    solver: (s2) => (node2, parent) => {
      if (node2 === null) {
        throw new Error("Value passed into solver was NULL!");
      }
      if (node2 === void 0) {
        throw new Error("Value passed into solver was UNDEFINED!");
      }
      const type = getNodeType(node2);
      if (type in s2) {
        const fn2 = s2[type];
        return fn2(node2, parent);
      } else {
        if (type === "node" && "element" in s2 && isElement(node2)) {
          const fn2 = s2.element;
          return fn2(node2, parent);
        } else if (type === "node" && "text" in s2 && isTextNode(node2)) {
          const fn2 = s2.text;
          return fn2(node2);
        }
        throw new HappyMishap(`Problem finding "${type}" in solver.`, {
          name: `solveForNodeType(${type})`
        });
      }
    }
  });
  return {
    outputType: () => solver(),
    mirror: () => solver()
  };
};
function toHtml(node2) {
  if (node2 === null) {
    return "";
  }
  const n2 = Array.isArray(node2) ? node2 : [node2];
  try {
    const results = n2.map((i) => {
      const convert = solveForNodeType().outputType().solver({
        html: (h) => h,
        text: (t2) => t2.textContent,
        comment: (h) => `<!-- ${h.textContent} -->`,
        element: (e2) => e2.outerHTML,
        node: (ne) => {
          if (isElement(ne)) {
            convert(ne);
          }
          if (isTextNode(ne)) {
            convert(ne);
          }
          throw new Error(
            `Unknown node type detected while converting to HTML: [ name: ${ne.nodeName}, type: ${ne.nodeType}, value: ${ne.nodeValue} ]`
          );
        },
        document: (d) => `<html>${d.head.hasChildNodes() ? d.head.outerHTML : ""}${d.body.outerHTML}</html>`,
        fragment: (f) => {
          return isElementLike(f) ? f.firstElementChild.outerHTML : f.childNodes.map((c) => convert(c, f)).join("");
        }
      });
      return convert(i);
    });
    return results.join("");
  } catch (error_) {
    const error2 = Array.isArray(node2) ? new HappyMishap(
      `Problem converting an array of ${n2.length} nodes [${n2.map((i) => getNodeType(i)).join(", ")}] to HTML`,
      {
        name: "toHTML([...])",
        inspect: ["first node", node2[0]],
        error: error_
      }
    ) : new HappyMishap(`Problem converting "${getNodeType(node2)}" to HTML!`, {
      name: "toHTML(getNodeType(node))",
      inspect: node2,
      error: error_
    });
    throw error2;
  }
}
function clone(container) {
  const clone2 = solveForNodeType().mirror().solver({
    html: (h) => `${h}`,
    fragment: _function.flow(toHtml, createFragment),
    document: (d) => {
      return createDocument(d.body.innerHTML, d.head.innerHTML);
    },
    element: (e2) => _function.pipe(e2, toHtml, createElement),
    node: (n2) => {
      throw new HappyMishap("Can't clone an unknown node!", { inspect: n2 });
    },
    text: _function.flow(toHtml, createTextNode),
    comment: _function.flow(toHtml, createCommentNode)
  });
  return clone2(container);
}
var getChildren = (el) => {
  if (!el.hasChildNodes()) {
    return [];
  }
  const output = [];
  let child = el.firstChild;
  for (let idx = 0; idx < el.childNodes.length; idx++) {
    if (isElement(child) || isTextNode(child)) {
      output.push(child);
    } else if (isFragment(child) || isDocument(child)) {
      for (const fragChild of getChildren(child)) {
        output.push(fragChild);
      }
    } else {
      throw new HappyMishap(
        `unknown node type [${getNodeType(
          child
        )}] found while trying to convert children to an array`,
        { name: "getChildrenAsArray", inspect: child }
      );
    }
    child = child.nextSibling;
  }
  return output;
};
function descClass(n2) {
  const list2 = getClassList(n2);
  return list2.length > 0 ? `{ ${list2.join(" ")} }` : "";
}
function descFrag(n2) {
  const children2 = getChildren(n2).map((i) => describeNode(i));
  return isElementLike(n2) ? `[el: ${n2.firstElementChild.tagName.toLowerCase()}]${descClass}` : isTextNodeLike(n2) ? `[text: ${n2.textContent.slice(0, 4).replace(/\n+/g, "")}...]` : `[children: ${children2.length > 0 ? `${children2.join(", ")}` : "none"}]`;
}
var describeNode = (node2) => {
  if (!node2) {
    return node2 === null ? "[null]" : "undefined";
  } else if (isUpdateSignature(node2)) {
    return `UpdateSignature(${describeNode(node2[0])})`;
  } else if (Array.isArray(node2)) {
    return node2.map((i) => describeNode(i)).join("\n");
  }
  return solveForNodeType().outputType().solver({
    html: (h) => _function.pipe(h, createFragment, describeNode),
    node: (n2) => `node${descClass(n2)}`,
    text: (t2) => `text[${t2.textContent.slice(0, 5).replace("\n", "")}...]`,
    comment: (t2) => `comment[${t2.textContent.slice(0, 5).replace("\n", "")}...]`,
    element: (e2) => `element[${e2.tagName.toLowerCase()}]${descClass(e2)}`,
    fragment: (f) => `fragment${descFrag(f)}`,
    document: (d) => `doc[head: ${!!d.head}, body: ${!!d.body}]: ${describeNode(
      createFragment(d.body)
    )}`
  })(node2);
};
var inspect = (item2, toJSON = false) => {
  const solver = Array.isArray(item2) ? () => item2.map((i) => describeNode(i)) : solveForNodeType().outputType().solver({
    html: (h) => _function.pipe(h, createFragment, (f) => inspect(f)),
    fragment: (x2) => ({
      kind: "Fragment",
      children: `${x2.children.length} / ${x2.childNodes.length}`,
      ...x2.childNodes.length > 1 ? {
        leadsWith: isElement(x2.firstChild) ? "element" : isTextNode(x2.firstChild) ? "text" : "other",
        endsWith: isElement(x2.lastChild) ? "element" : isTextNode(x2.lastChild) ? "text" : "other"
      } : {
        childNode: inspect(x2.firstChild)
      },
      content: x2.textContent.length > 128 ? `${x2.textContent.slice(0, 128)} ...` : x2.textContent,
      childDetails: x2.childNodes.map((i) => {
        try {
          return {
            html: toHtml(i),
            nodeType: getNodeType(i),
            hasParentElement: !!i.parentElement,
            hasParentNode: i.parentNode ? `${getNodeType(i.parentNode)} [type:${i.parentNode.nodeType}]` : false,
            childNodes: i.childNodes.length
          };
        } catch {
          return "N/A";
        }
      }),
      html: toHtml(x2)
    }),
    document: (x2) => {
      var _a2, _b2, _c2, _d2;
      return {
        kind: "Document",
        headerChildren: (_a2 = x2.head.childNodes) == null ? void 0 : _a2.length,
        bodyChildren: (_b2 = x2.body.childNodes) == null ? void 0 : _b2.length,
        body: toHtml(x2.body),
        children: `${(_c2 = x2.body.children) == null ? void 0 : _c2.length} / ${(_d2 = x2.body.childNodes) == null ? void 0 : _d2.length}`,
        childTextContent: x2.body.childNodes.map((i) => i.textContent),
        childDetails: x2.childNodes.map((i) => {
          try {
            return {
              html: toHtml(i),
              nodeType: getNodeType(i),
              hasParentElement: !!i.parentElement,
              hasParentNode: i.parentNode ? `${getNodeType(i.parentNode)} [type:${i.parentNode.nodeType}]` : false,
              childNodes: i.childNodes.length
            };
          } catch {
            return "N/A";
          }
        })
      };
    },
    text: (x2) => {
      var _a2, _b2;
      return {
        kind: "IText node",
        textContent: x2.textContent.length > 128 ? `${x2.textContent.slice(0, 128)} ...` : x2.textContent,
        children: (_a2 = x2.childNodes) == null ? void 0 : _a2.length,
        childContent: ((_b2 = x2 == null ? void 0 : x2.childNodes) == null ? void 0 : _b2.map((i) => i.textContent)) || []
      };
    },
    comment: (c) => {
      var _a2, _b2;
      return {
        kind: "IComment node",
        textContent: c.textContent.length > 128 ? `${c.textContent.slice(0, 128)} ...` : c.textContent,
        children: (_a2 = c.childNodes) == null ? void 0 : _a2.length,
        childContent: ((_b2 = c == null ? void 0 : c.childNodes) == null ? void 0 : _b2.map((i) => i.textContent)) || []
      };
    },
    element: (x2) => {
      var _a2, _b2;
      return {
        kind: "IElement node",
        tagName: x2.tagName,
        classes: getClassList(x2),
        /**
         * in functions like wrap and pretty print, a "parent element" is provided
         * as a synthetic parent but if this flag indicates whether the flag has
         * a connected parent in a DOM tree.
         */
        hasNaturalParent: !!x2.parentElement,
        ...x2.parentElement ? { parent: describeNode(x2.parentElement) } : {},
        textContent: x2.textContent,
        children: `${x2.children.length} / ${x2.childNodes.length}`,
        childContent: ((_a2 = x2.childNodes) == null ? void 0 : _a2.map((i) => i.textContent)) || [],
        childDetails: ((_b2 = x2 == null ? void 0 : x2.childNodes) == null ? void 0 : _b2.map((i) => {
          try {
            return {
              html: toHtml(i),
              nodeType: getNodeType(i),
              hasParentElement: !!i.parentElement,
              hasParentNode: i.parentNode ? `${getNodeType(i.parentNode)} [type:${i.parentNode.nodeType}]` : false,
              childNodes: i.childNodes.length
            };
          } catch {
            return "N/A";
          }
        })) || [],
        html: truncate(512)(toHtml(x2))
      };
    },
    node: (n2) => {
      var _a2, _b2;
      return {
        kind: "INode (generic)",
        looksLike: isElement(n2) ? "element" : isTextNode(n2) ? "text" : "unknown",
        children: `${(_a2 = n2.childNodes) == null ? void 0 : _a2.length}`,
        childContent: ((_b2 = n2 == null ? void 0 : n2.childNodes) == null ? void 0 : _b2.map((i) => truncate(128)(i.textContent))) || [],
        html: truncate(512)(n2.toString())
      };
    }
  });
  const result = isContainer(item2) || typeof item2 === "string" ? solver(item2) : {
    result: "not found",
    type: typeof item2,
    ...typeof item2 === "object" && item2 !== null ? { keys: Object.keys(item2) } : { value: JSON.stringify(item2) }
  };
  return toJSON ? JSON.stringify(result, null, 2) : result;
};
var truncate = (maxLength) => (input) => input.slice(0, maxLength);
var HappyMishap = class extends Error {
  constructor(message, options2 = {}) {
    var _a2;
    super();
    __publicField(this, "name", "HappyWrapper");
    __publicField(this, "kind", "HappyWrapper");
    __publicField(this, "trace", []);
    __publicField(this, "line");
    __publicField(this, "fn");
    __publicField(this, "file");
    __publicField(this, "structuredStack");
    this.message = `
${message}`;
    if (options2.name) {
      this.name = `HappyWrapper::${options2.name || "unknown"}`;
    }
    try {
      const sites = callsites();
      this.structuredStack = (sites || []).slice(1).map((i) => {
        var _a3;
        return {
          fn: i.getFunctionName() || i.getMethodName() || ((_a3 = i.getFunction()) == null ? void 0 : _a3.name) || void 0,
          line: i.getLineNumber() || void 0,
          file: i.getFileName() ? i.getFileName() : null
        };
      }) || [];
    } catch {
      this.structuredStack = [];
    }
    this.fn = this.structuredStack[0].fn || "";
    this.file = this.structuredStack[0].file || "";
    this.line = this.structuredStack[0].line || null;
    if (isHappyWrapperError(options2.error)) {
      this.name = `[file: ${this.file}, line: ${this.line}] HappyWrapper::${options2.name || options2.error.name}`;
    }
    if (options2.error) {
      const name2 = options2.error instanceof Error ? options2.error.name.replace("HappyWrapper::", "") : "unknown";
      const underlying = `

The underlying error message [${name2}] was:
${options2.error instanceof Error ? options2.error.message : String(options2.error)}`;
      this.message = `${this.message}${underlying}`;
      this.trace = [...this.trace, name2];
    } else {
      if (options2.inspect) {
        const inspections = isInspectionTuple(options2.inspect) ? [options2.inspect] : Array.isArray(options2.inspect) ? options2.inspect : [options2.inspect];
        for (const [idx, i] of inspections.entries()) {
          const intro = isInspectionTuple(i) ? `${i[0]}
` : `${[idx]}:
`;
          const container = isInspectionTuple(i) ? i[1] : i;
          this.message = `${this.message}

${intro}${JSON.stringify(
            inspect(container),
            null,
            2
          )}`;
        }
      }
      if (this.trace.length > 1) {
        this.message = `${this.message}

Trace:${this.trace.map(
          (i, idx) => `${idx}. ${i}`
        )}`;
      }
    }
    this.message = `${this.message}
`;
    for (const l2 of this.structuredStack) {
      this.message = ((_a2 = l2.file) == null ? void 0 : _a2.includes(".pnpm")) ? this.message : `${this.message}
  - ${l2.fn ? `${l2.fn}() ` : ""}${l2.file}:${l2.line}`;
    }
    this.structuredStack = [];
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message
    };
  }
  toString() {
    return {
      name: this.name,
      message: this.message
    };
  }
};
function createDocument(body, head) {
  const window2 = new Window();
  const document2 = window2.document;
  document2.body.innerHTML = body;
  if (head) {
    document2.head.innerHTML = head;
  }
  return document2;
}
function createFragment(content2) {
  const window2 = new Window();
  const document2 = window2.document;
  const fragment = document2.createDocumentFragment();
  if (content2) {
    fragment.append(clone(content2));
  }
  return fragment;
}
function createTextNode(text2) {
  if (!text2) {
    return new Text$1("");
  }
  const frag = createFragment(text2);
  if (isTextNodeLike(frag)) {
    return frag.firstChild;
  } else {
    throw new HappyMishap(
      `The HTML passed in cannot be converted to a single text node: "${text2}".`,
      { name: "createFragment(text)", inspect: frag }
    );
  }
}
function createCommentNode(comment2) {
  return new Comment$1(comment2);
}
var createElement = (el, parent) => solveForNodeType().outputType().solver({
  node: (n2) => {
    if (isElement(n2)) {
      return createElement(n2);
    } else {
      throw new HappyMishap(
        "can't create an IElement from an INode node because it doesn't have a tagName property",
        { inspect: n2 }
      );
    }
  },
  html: (h) => {
    const frag = createFragment(h);
    if (isElementLike(frag)) {
      if (parent) {
        parent.append(frag.firstElementChild);
        return parent == null ? void 0 : parent.lastElementChild.cloneNode();
      }
      return frag.firstElementChild;
    } else {
      throw new HappyMishap(
        "The HTML passed into createElement() is not convertible to a IElement node!",
        { name: "createElement(html)", inspect: frag }
      );
    }
  },
  element: _function.identity,
  text: (t2) => {
    throw new HappyMishap(
      "An IElement can not be created from a IText node because element's require a wrapping tag name!",
      { name: "createElement(text)", inspect: t2 }
    );
  },
  comment: (t2) => {
    throw new HappyMishap(
      "An IElement can not be created from a IComment node because element's require a wrapping tag name!",
      { name: "createElement(comment)", inspect: t2 }
    );
  },
  fragment: (f) => {
    if (isElement(f.firstElementChild)) {
      return f.firstElementChild;
    } else {
      throw new HappyMishap(
        `Unable to create a IElement node from: 

${toHtml(f)}`,
        { name: "createElement()" }
      );
    }
  },
  document: (d) => {
    if (isElementLike(d)) {
      if (parent) {
        throw new HappyMishap(
          "A Document and a parent IElement were passed into createElement. This is not a valid combination!"
        );
      }
      return d.firstElementChild;
    } else {
      throw new HappyMishap(
        "Can not create an Element from passed in Document",
        { name: "createElement(document)", inspect: d }
      );
    }
  }
})(el);
var getAttribute = (attr) => {
  return solveForNodeType("text").outputType().solver({
    html: (h) => _function.pipe(h, createFragment, getAttribute(attr)),
    fragment: (f) => f.firstElementChild.getAttribute(attr),
    document: (doc) => doc.body.firstElementChild.getAttribute(attr),
    element: (el) => el.getAttribute(attr)
  });
};
var getClass = getAttribute("class");
var getClassList = (container) => {
  if (!container) {
    return [];
  }
  return solveForNodeType().outputType().solver({
    html: (h) => _function.pipe(h, createFragment, getClassList),
    document: (d) => {
      var _a2;
      return ((_a2 = getClass(d.body.firstElementChild)) == null ? void 0 : _a2.split(/\s+/)) || [];
    },
    fragment: (f) => {
      var _a2;
      return ((_a2 = getClass(f.firstElementChild)) == null ? void 0 : _a2.split(/\s+/)) || [];
    },
    element: (e2) => {
      var _a2;
      return ((_a2 = getClass(e2)) == null ? void 0 : _a2.split(/\s+/)) || [];
    },
    text: (n2) => {
      throw new HappyMishap("Passed in a text node to getClassList!", {
        name: "getClassList",
        inspect: n2
      });
    },
    comment: (n2) => {
      throw new HappyMishap("Passed in a comment node to getClassList!", {
        name: "getClassList",
        inspect: n2
      });
    },
    node: (n2) => {
      throw new HappyMishap(
        "Passed in an unknown node type to getClassList!",
        { name: "getClassList", inspect: n2 }
      );
    }
  })(container).filter(Boolean);
};
var hasSelector = (source, sel) => {
  let container;
  if (typeof source === "string") {
    if (source.includes("<html>")) {
      container = createDocument(source);
    } else {
      container = createFragment(source);
    }
  } else if (isDocument(source)) {
    container = source.body;
  } else if (isElement(source)) {
    container = source;
  } else {
    container = source;
  }
  const result = container.querySelector(sel);
  return result ? true : false;
};
var containerName = (node2) => {
  return isElement(node2) ? "IElement" : isDocument(node2) ? "HappyDoc" : isString(node2) ? node2.includes("<html>") ? "HappyDoc" : "IFragment" : "IElement";
};
var query = (node2, sel, handling = "empty") => {
  let container;
  if (typeof node2 === "string") {
    if (node2.includes("<html>")) {
      container = createDocument(node2);
    } else {
      container = createFragment(node2);
    }
  } else if (isDocument(node2)) {
    container = node2.body;
  } else if (isElement(node2)) {
    container = node2;
  } else {
    container = node2;
  }
  const result = container.querySelector(sel);
  if (handling === "throw" && !result) {
    const err = new Error(`Failed to find an HTML element for the selector "${sel}"`);
    err.name = "DomError";
    err.container = containerName(node2);
    err.selector = sel;
    throw err;
  }
  return result !== void 0 ? result : handling === "empty" ? {} : handling === "undefined" ? void 0 : isFunction(handling) ? handling() : Never;
};
var queryAll = (dom, sel) => {
  let container;
  if (typeof dom === "string") {
    if (dom.includes("<html>")) {
      container = createDocument(dom);
    } else {
      container = createFragment(dom);
    }
  } else if (isDocument(dom)) {
    container = dom.body;
  } else if (isElement(dom)) {
    container = dom;
  } else {
    container = dom;
  }
  let result = [];
  container.querySelectorAll(sel).forEach((i) => {
    if (isElement(i)) {
      result.push(i);
    }
  });
  return result;
};
var findWhere = (source, selector, handling, ...text2) => {
  const results = Array.from(
    queryAll(source, selector)
  ).filter(
    (i) => isElement(i)
  );
  const [criteria, comparator] = text2;
  let found = results.find((r) => {
    const txt = r.textContent;
    switch (criteria) {
      case "callback":
        return comparator(r);
      case "contains":
        return txt.includes(comparator);
      case "endsWith":
        return txt.endsWith(comparator);
      case "startsWith":
        return txt.startsWith(comparator);
      case "doesNotContain":
        return !txt.includes(comparator);
      case "regex":
        return comparator.test(txt);
    }
  });
  if (!found && handling === "throw") {
    const err = new Error(
      `Failed to find any elements which met the selector "${selector}" as well as the "${criteria}" criteria of "${String(comparator)}"`
    );
    err.name = "DomError";
    err.container = containerName(source);
    err.selector = selector;
    err.criteria = criteria;
    err.comparator = comparator;
    throw err;
  }
  return found ? found : void 0;
};
const requestUrl = async (req) => {
  let resp = await globalThis.requestUrl(req);
  resp.url = req.url;
  return resp;
};
const WORLD_CAT_URL = `https://search.worldcat.org/search`;
const worldCatBookPage = async (p2, book) => {
  const qp = [];
  if (book.isbn13) {
    qp.push(`bn:${book.isbn13}`);
  } else if (book.isbn10) {
    qp.push(`bn:${book.isbn10}`);
  } else if ("isbn" in book && [10, 13].includes(String(book.isbn).length)) {
    qp.push(`bn:${book.isbn}`);
  }
  if (book.title) {
    qp.push(`ti:${book.title}`);
  }
  if (book.authors.length > 0) {
    qp.push(`au:${book.authors[0]}`);
  }
  const encode2 = (s2) => s2.map((i) => i.replaceAll(" ", "+")).join("+AND+");
  const url = `${WORLD_CAT_URL}?q=${encode2(qp)}`;
  p2.debug(`World Catalog: ${url}`);
  const resp = await requestUrl({
    url,
    method: "GET",
    headers: {
      Accept: "*/*",
      "Accept-Encoding": "gzip, deflate, br",
      "Cache-Control": "no-cache",
      "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
      Connection: "keep-alive"
    }
  });
  if (resp.status === 200) {
    let html = resp.text;
    p2.debug({ resp, html });
  }
  return url;
};
const AmazonBook = async (p2, book) => {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i, _j2, _k2, _l2, _m2, _n, _o2;
  const url = `https://www.amazon.com/dp/${book.asin}`;
  p2.debug(`Scraping ${url}`, book);
  let html;
  try {
    let req = await requestUrl({
      url,
      method: "GET",
      headers: {
        Accept: "*/*",
        "Accept-Encoding": "gzip, deflate, br",
        "Content-Type": "text/html",
        "Cache-Control": "no-cache",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
        Connection: "keep-alive"
      }
    });
    html = req.text;
    p2.debug("Returned from Amazon API call", html);
  } catch (e2) {
    p2.error(`Problems loading book information from Amazon (${url})`, e2 == null ? void 0 : e2.msg);
    return book;
  }
  let page = createDocument(html);
  p2.debug("page created");
  let amazonRating = page && ((_a2 = query(page, "span .a-icon-alt")) == null ? void 0 : _a2.textContent) ? Number(stripAfter(((_b2 = query(page, "span .a-icon-alt")) == null ? void 0 : _b2.textContent) || "", " ")) : void 0;
  let reviewsAmazon = hasSelector(page, "span .arcCustomerReviewText") ? Number(stripAfter((_c2 = query(page, "span .arcCustomerReviewText", "throw")) == null ? void 0 : _c2.textContent, " ")) : void 0;
  query(page, "#histogramTable", "undefined");
  let isKindleBook = query(page, "#rpi-attribute-book_details-ebook_pages", "undefined") ? true : false;
  let description = (_d2 = query(page, "div[data-a-expander-name=book_description_expander] p span")) == null ? void 0 : _d2.textContent;
  let isbn10 = (_f2 = (_e2 = findWhere(page, "span.a-text-bold", "undefined", "contains", "ISBN-10")) == null ? void 0 : _e2.nextElementSibling) == null ? void 0 : _f2.textContent;
  let isbn13 = (_h2 = (_g2 = findWhere(page, "span.a-text-bold", "undefined", "contains", "ISBN-13")) == null ? void 0 : _g2.nextElementSibling) == null ? void 0 : _h2.textContent;
  let [publisher, publicationDate] = ((_j2 = (_i = findWhere(
    page,
    "span.a-text-bold",
    "undefined",
    "contains",
    "Item Weight"
  )) == null ? void 0 : _i.nextElementSibling) == null ? void 0 : _j2.textContent.split("(")) || [void 0, void 0];
  let weight = (_l2 = (_k2 = findWhere(
    page,
    "span.a-text-bold",
    "undefined",
    "contains",
    "Item Weight"
  )) == null ? void 0 : _k2.nextElementSibling) == null ? void 0 : _l2.textContent;
  let kindleVariantAvailable = isKindleBook === true ? true : query(page, "#tmm-grid-swatch-KINDLE", void 0) === void 0 ? false : true;
  let numOfRatings = stripAfter(((_m2 = query(page, "#acrCustomerReviewText")) == null ? void 0 : _m2.textContent) || "", " ratings");
  let pages = isKindleBook ? stripAfter(
    ((_n = query(page, "#rpi-attribute-book_details-ebook_pages .a-declarative")) == null ? void 0 : _n.textContent) || "",
    " "
  ) : retainWhile(
    stripUntil(
      ((_o2 = query(page, "#rpi-attribute-book_details-fiona_pages")) == null ? void 0 : _o2.textContent) || "",
      ...NUMERIC_CHAR
    ),
    ...NUMERIC_CHAR
  );
  p2.debug("Amazon", {
    url,
    isKindleBook,
    kindleVariantAvailable,
    pages,
    numOfRatings,
    weight,
    publisher,
    publicationDate,
    isbn10,
    isbn13,
    description,
    rating: amazonRating,
    reviewsAmazon
  });
  return {
    ...book,
    ratingsAmazon: amazonRating,
    totalPages: book.totalPages ? book.totalPages : pages,
    description: book.description ? book.description : description,
    isKindleBook,
    kindleVariantAvailable,
    reviewsAmazon,
    isbn10: book.isbn10 ? book.isbn10 : isbn10,
    isbn13: book.isbn13 ? book.isbn13 : isbn13,
    weight: book.weight ? book.weight : weight,
    publisher: book.publisher ? book.publisher : publisher == null ? void 0 : publisher.trim(),
    publishDate: book.publishDate ? book.publishDate : publicationDate ? DateTime$1.fromFormat(stripTrailing(publicationDate, ")"), "DATE_MED").toFormat("yyyy-mm-dd") : void 0
  };
};
const Book = createHandler("Book").scalar().options().handler(async (evt) => {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
  const { plugin: p2, page } = evt;
  const fmt = p2.api.format;
  const current = page.current;
  let book = {
    title: current.title || ((_a2 = current["kindle-sync"]) == null ? void 0 : _a2.title) || "unknown",
    subtitle: current.subtitle,
    authors: current.authors ? current.authors.split(",").map((i) => i.trim()) : current.author ? current.author.split(",").map((i) => i.trim()) : ((_b2 = current["kindle-sync"]) == null ? void 0 : _b2.author) ? (_c2 = current["kindle-sync"]) == null ? void 0 : _c2.author.split(",").map((i) => i.trim()) : [],
    bookCategory: current.category,
    publisher: current.publisher,
    publishDate: current.publishDate,
    totalPages: current.totalPage,
    description: current.description,
    isbn13: current.isbn13,
    isbn10: current.isbn10,
    asin: ((_d2 = current["kindle-sync"]) == null ? void 0 : _d2.asin) ? current["kindle-sync"].asin : typeof (current == null ? void 0 : current.asin) === "string" ? String(current == null ? void 0 : current.asin) : void 0,
    coverImages: [
      ...current.coverUrl ? [current.coverUrl] : [],
      ...((_e2 = current["kindle-sync"]) == null ? void 0 : _e2.bookImageUrl) ? [
        (_f2 = current["kindle-sync"]) == null ? void 0 : _f2.bookImageUrl
      ] : []
    ],
    worldCatSubjects: [],
    googleBookLink: current.link,
    /**
     * provides a link to the WorldCat service with the featured
     * book highlighted.
     */
    worldCatBookLink: void 0,
    /**
     * provides a list of books by the same author
     */
    otherBooks: current.otherBooks,
    /**
     * the _number_ of highlights found from a kindle device
     */
    kindleHighlightCount: (_g2 = current["kindle-sync"]) == null ? void 0 : _g2.highlightsCount
  };
  if (!book.title && (!book.isbn10 || !book.isbn13 || !book.asin)) {
    p2.error(`Book() query requested on a page without necessary metadata! Page must have at least a title and some book identifier (e.g., ISBN10, ISBN13, or ASIN).`);
    page.callout("warning", "No Book metadata found!", { content: `A kind-model query for a book summary was made but we rely on at least a "title" and some book identifier (isbn10, isbn13, or asin are all ok)` });
  } else {
    book.worldCatBookLink = await worldCatBookPage(p2, book);
    book = await AmazonBook(p2, book);
    p2.debug("Book after Amazon Scrape", { book });
    const cover = [
      `<div class="book-cover" style="padding-bottom: 8px;">`,
      book.coverImages.length > 0 ? `<img src="${book.coverImages[0]}" style="">` : ``,
      `</div>`
    ];
    const publisher = book.publisher ? [
      fmt.medium("Publisher:"),
      fmt.ul([book.publisher], { indentation: "default", my: "tight" })
    ] : [];
    const publicationDate = book.publishDate ? [
      fmt.medium("Publication Date:"),
      isDateTime(book.publishDate) ? fmt.ul([(_h2 = book == null ? void 0 : book.publishDate) == null ? void 0 : _h2.toFormat("LLL yyyy")], { indentation: "default", my: "tight" }) : "unknown format"
    ] : [];
    const pages = book.totalPages ? [
      fmt.medium("Length:&nbsp;"),
      fmt.ul([`${fmt.normal(book.totalPages)} ${fmt.light("pages", { ts: "sm" })}`], { indentation: "default", my: "tight" })
    ] : [];
    const author = book.authors.length > 0 ? [
      fmt.medium("Written By:"),
      fmt.ul(book.authors, { indentation: "default", my: "tight" })
    ] : [];
    const book_ids = [
      `<div class="book-ids">`,
      fmt.medium("Book Identifiers:"),
      fmt.ul([
        book.isbn10 ? `${fmt.light(book.isbn10, { ts: "sm" })}&nbsp;${fmt.medium("&nbsp;isbn10", { ts: "xs" })}` : void 0,
        book.isbn13 ? `${fmt.light(book.isbn13, { ts: "sm" })}&nbsp;${fmt.medium("&nbsp;isbn13", { ts: "xs" })}` : void 0,
        book.asin ? `${fmt.light(book.asin, { ts: "sm" })}&nbsp;${fmt.medium("&nbsp;asin", { ts: "xs" })}` : void 0
      ], { indentation: "default", my: "tight" }),
      `</div>`
    ];
    const summary = fmt.blockquote("example", "Summary", {
      content: fmt.wrap([
        ...cover,
        ...author,
        ...publisher,
        ...publicationDate,
        ...pages,
        ...book_ids
      ], { my: "4px", px: "8px" }),
      style: {
        mr: "8px",
        ml: "8px"
      }
    });
    const description = fmt.blockquote("info", "Book Description", {
      fold: "+",
      content: book.description || "no description found"
    });
    const otherBooks = book.otherBooks ? [
      fmt.blockquote("info", `Books by ${book.authors[0]}`, {
        content: book.otherBooks.map((b) => {
          return fmt.link(
            b.title,
            b.titleLink,
            { iconUrl: b.imageLink }
          );
        }).join("\n") || "&nbsp;",
        icon: BOOK_ICON,
        fold: "-"
      })
    ] : [];
    const actions = fmt.blockquote("info", "Actions / Links", {
      content: fmt.wrap([
        book.asin ? fmt.link(
          "Open in Kindle",
          `kindle://book?action=open&asin=${book.asin}`,
          { svgInline: KINDLE_ICON }
        ) : void 0,
        book.asin ? fmt.link(
          "Amazon",
          `https://www.amazon.com/dp/${book.asin}`,
          { svgInline: AMAZON }
        ) : void 0,
        book.googleBookLink ? fmt.link(
          "Google",
          book.googleBookLink,
          { svgInline: BOOK_ICON }
        ) : void 0,
        book.worldCatBookLink ? fmt.link(
          "WorldCat",
          book.worldCatBookLink,
          { svgInline: BOOK_CATALOG }
        ) : void 0,
        fmt.link(
          "Search",
          `https://google.com/search?q=${book.title} by ${book.authors.join(", ")}`,
          { svgInline: SEARCH_BOOK }
        )
        // fmt.link(
        // 	"Update Metadata", 
        // 	`https://google.com/?q=${book.title} by ${book.authors.join(", ")}`,
        // 	{ svgInline: META_DATA}
        // ),
      ], { flex: true, direction: "row", ts: "sm", gap: "12px" }),
      fold: "+"
    });
    const reviews = fmt.blockquote("info", "Reviews", {
      content: "not available currently",
      fold: "-",
      icon: TIP_ICON
    });
    const details = fmt.wrap([
      description,
      reviews,
      ...otherBooks,
      actions,
      fmt.empty_callout({ flex: true, grow: 1 })
    ], { flex: true, direction: "column" });
    const html = [
      `<div class="book-summary">`,
      ...book.subtitle ? [
        `<div class="book-subtitle" style="display:block; width: 100%">`,
        fmt.blockquote("quote", book.subtitle, { style: { mb: "8px" } }),
        `</div>`
      ] : [],
      // column container
      `<div class="book-cols" style="display:flex; flex-direction: cols; width: 100%;">`,
      // LEFT / SUMMARY
      `<div class="summary-col" style="display:flex; flex-grow:0; max-width: 30%;">${summary}</div>`,
      // RIGHT / DETAILS
      details,
      `</div`
    ];
    await page.render(html.join("\n"));
  }
});
const IconPage = createHandler("IconPage").scalar().options().handler(async (evt) => {
  var _a2;
  const { plugin: p2, page } = evt;
  const icon = (i) => `<span class="icon" style="display: flex; max-width: 32px; max-height: 32px;">${page.current[i]}</span>`;
  const meta = getMetadata(p2)(page);
  p2.info("Icon Props", { meta });
  page.render(`## **${page.current.file.name}** is an Icon Page`);
  page.render(`> _To define one of the icons here to be used as "icon" for another page you'll prefix the name with #icon/link._`);
  page.table(
    ["name", "icon"],
    (_a2 = meta["svg_inline"]) == null ? void 0 : _a2.map((i) => [
      i,
      icon(i)
    ])
  );
});
const Kind = createHandler("Kind").scalar(
  "kind AS opt(string)",
  "category AS opt(string)",
  "subcategory AS opt(string)"
).options({
  show: "array(string)",
  hide: "array(string)"
}).handler(async (evt) => {
  const p2 = evt.plugin;
  const page = evt.page;
  if (page) {
    const {
      table: table3
    } = page;
    const fmt = p2.api.format;
    const {
      showCategories: showCategories2,
      showSubcategories: showSubcategories2,
      showDesc: showDesc2,
      showLinks: showLinks2,
      createFileLink: createFileLink2
    } = p2.api;
    let { kind, category, subcategory } = evt.scalar;
    kind = kind ? kind : page.kindTags[0];
    const pages = subcategory ? page.pages(`#${kind}/${category}/${subcategory}`) : category ? page.pages(`#${kind}/${category}`) : page.pages(`#${kind}`);
    if (pages.length > 0) {
      table3(
        [
          "Page",
          !page.isCategoryPage ? "Category" : void 0,
          "Subcategory",
          "Desc",
          "Links"
        ].filter((i) => i),
        pages.sort((p22) => p22.file.mday).map((p22) => {
          const pg = isDvPage(p22) ? p22 : page.page(p22);
          return [
            createFileLink2(pg),
            !page.isCategoryPage ? showCategories2(pg, { currentPage: page }) : void 0,
            showSubcategories2(pg),
            showDesc2(pg),
            showLinks2(pg)
          ].filter((i) => i);
        })
      );
    } else {
      const msg2 = subcategory ? fmt.as_tag(`${kind}/${category}/${subcategory}`) : category ? fmt.as_tag(`${kind}/${category}`) : `${fmt.as_tag(kind)}`;
      page.callout("note", `none found currently<span style="font-weight: 150; position: absolute; right: 8px;">${msg2}</span>`);
    }
  }
});
const Journal = createHandler("Journal").scalar().options({
  thisYearFormat: "string",
  otherYearFormat: "string",
  fileFormat: "string"
}).handler(async (evt) => {
  const p2 = evt.plugin;
  const page = evt.page;
  if (page) {
    let when = getWhenDate(p2)(page);
    if (when) {
      const format2 = evt.options.fileFormat || "journal/YYYY/YYYY-MM-DD";
      const prev = htmlLink(p2)(
        journalFile(format2, priorDay(when)),
        {
          createPageWhereMissing: true,
          display: describeDate(when, -1)
        }
      );
      const next = htmlLink(p2)(
        journalFile(format2, nextDay(when)),
        {
          createPageWhereMissing: true,
          display: describeDate(when, 1)
        }
      );
      const holidays = p2.dv.pages(
        `#holiday/${getMonth(when)}-${getDate(when)} OR #day/${getMonth(when)}-${getDate(when)}`
      ).where((p22) => p22.file.tags.includes("#holiday"));
      const holiday = holidays.values.map(
        (h) => h.file.name
      ).join(" / ");
      p2.info("journal", holidays.length, holidays);
      p2.info("journal", holidays.length, holidays, holiday);
      let events = Array.from(p2.dv.pages(
        [
          `#event/${getMonth(when)}-${getDate(when)} `,
          `#event/${getYear(when)}-${getMonth(when)}-${getDate(when)}`,
          `#day/${getYear(when)}-${getMonth(when)}-${getDate(when)}`,
          `#day/${getMonth(when)}-${getDate(when)}`
        ].join(" OR ")
      ).where((p22) => p22.file.tags.includes("#event")).map(
        (e2) => {
          return `<li>${htmlLink(p2)(e2.file.path)}</li>`;
        }
      )).join("\n");
      let meetings = Array.from(p2.dv.pages(
        [
          `#meeting/${getMonth(when)}-${getDate(when)} `,
          `#meeting/${getYear(when)}-${getMonth(when)}-${getDate(when)}`,
          `#day/${getYear(when)}-${getMonth(when)}-${getDate(when)}`,
          `#day/${getMonth(when)}-${getDate(when)}`
        ].join(" OR ")
      ).where((p22) => p22.file.tags.includes("#meeting")).map(
        (e2) => {
          return `<li>${htmlLink(p2)(e2.file.path)}</li>`;
        }
      )).join("\n");
      const heading2 = [
        `<div id="journal-heading" style="width:100%">`,
        `<h1 id="day-and-date" style="margin-bottom: 4px">`,
        CALENDAR_DATE,
        isThisYear(when) ? moment(when).format("ddd, MMMM Do") : moment(when).format("ddd, MMM Do, YYYY"),
        `</h1>`,
        `<div class="secondary-bar" style="display: flex; width: 100%; padding-bottom: 1rem;">`,
        `<span class="relative-date" style="flex-grow: 1">${holiday ? `${holiday},` : ""}`,
        isToday(when) || isYesterday(when) || isTomorrow(when) ? badge(
          retainUntil(
            moment(when).calendar(),
            ...WHITESPACE_CHARS
          ),
          isToday(when) ? "green" : isYesterday(when) ? "gray" : "blue"
        ) : light(italic(moment(when).fromNow())),
        `</span>`,
        `<span id="date-nav" style="display: flex; ">`,
        `<span class="spacer" style="display: flex; flex-grow: 1"> </span>`,
        `<span class="nav-buttons" style="display:flex; flex-grow: 0">`,
        prev,
        "&nbsp;&nbsp;",
        next,
        `</span>`,
        `</span>`,
        `</div>`,
        events.length > 0 ? [
          `<h3 id="journal-events">Events</h3>`,
          `<ul>`,
          events,
          `</ul>`
        ].join("\n") : `<!-- no events -->`,
        meetings.length > 0 ? [
          `<h3 id="journal-meetings">Meetings</h3>`,
          `<ul>`,
          meetings,
          `</ul>`
        ].join("\n") : `<!-- no events -->`
      ].join("\n");
      page.render(heading2);
    } else {
      page.render(
        blockquote("error", "Invalid Date", {
          content: `The ${bold("Journal")} kind query expects the "when" or "date" frontmatter property to be set with a valid ISO 8601 date string; or as a fallback that the title/name of the page lead with an ISO 8601 date.`
        })
      );
    }
  }
});
const PageEntry = createHandler("PageEntry").scalar().options({ verbose: "opt(bool)" }).handler(async (evt) => {
  const { plugin: p2, page } = evt;
  const fmt = p2.api.format;
  const api2 = p2.api;
  const current = page.current;
  const banner_img = isUrl(page.current["_banner"]) ? page.current["_banner"] : void 0;
  const banner_aspect = isCssAspectRatio(page.current["_banner_aspect"]) ? page.current["_banner_aspect"] : "32/12";
  const hasBanner = isUrl(banner_img);
  let [_p1, icon] = api2.getProp(page.current, "icon", "_icon", "svgIcon", "_svgIcon");
  const hasIcon = isInlineSvg(icon);
  let [_p2, desc] = api2.getProp(page.current, "desc", "description", "about", "tagline", "summary");
  const hasDesc = isString$1(desc);
  const type = current.type ? fmt.internalLink(page.page(current.type)) : void 0;
  const kind = current.kind ? fmt.internalLink(page.page(current.kind)) : void 0;
  const category = current.category ? fmt.internalLink(page.page(current.category)) : void 0;
  const categories = current.categories ? current.categories.map((c) => fmt.internalLink(page.page(c))).join(fmt.light(" | ", { opacity: 0.5 })) : void 0;
  const subcategory = current.subcategory ? fmt.internalLink(page.page(current.subcategory)) : void 0;
  const wiki = isWikipediaUrl(current.wiki) ? fmt.link("Wikipedia", current.wiki) : isWikipediaUrl(current.wikipedia) ? fmt.link("Wikipedia", current.wikipedia) : void 0;
  const siblings = page.get_internal_links(page.current, "about", "related", "competitors", "partners").map((i) => fmt.internalLink(i));
  const parents = page.get_internal_links(page.current, "parent", "parents", "father", "mother", "belongs_to", "member_of", "child_of").map((i) => fmt.internalLink(i));
  const children2 = page.get_internal_links(page.current, "child", "children", "son", "daughter").map((i) => fmt.internalLink(i));
  const siblingsNoOthers = siblings.length > 0 && parents.length === 0 && children2.length === 0;
  const repo = find_in(isRepoUrl)(current.repo, current.github, current.git, current.homepage, current.url, current.home);
  const repo_lnk = repo ? fmt.link("Repo", repo) : void 0;
  const shouldDisplay = hasIcon || hasDesc || type || kind || category || categories;
  if (shouldDisplay) {
    const breadcrumbs = [type, kind, category, categories, subcategory].filter((i) => i).join(
      fmt.light("&nbsp;>&nbsp;", { opacity: 0.5 })
    );
    const ext_links = [wiki, repo_lnk].filter((i) => i).join(", ");
    const title = isString$1(desc) ? desc.length < 120 ? desc : ext_links : ext_links;
    const body = isString$1(desc) && desc.length >= 120 ? ensureTrailing(desc, ".") : void 0;
    const right2 = breadcrumbs.length > 0 ? siblingsNoOthers ? `${breadcrumbs} [ ${siblings} ]` : breadcrumbs : fmt.light("<i>no classification</i>");
    await page.callout("example", title, {
      style: {
        mt: "0.55rem",
        mb: "1rem"
      },
      icon: hasIcon ? icon : MARKDOWN_PAGE_ICON,
      content: body,
      toRight: right2,
      fold: "+"
    });
  }
  if (hasBanner) {
    page.renderValue(`<img src="${banner_img}" style="width:100%;aspect-ratio:${banner_aspect}; object-fit: cover"> `);
  }
});
function traverse(tree, cb) {
  if (isObject(tree) && "children" in tree && isArray(tree.children)) {
    for (let child of tree.children) {
      if (isObject(child) && child) {
        let node2 = { ...child, parent: tree };
        traverse(node2, cb);
      }
    }
  }
  cb(tree);
}
const find_links = (links, fm_links, page) => (t2) => {
  var _a2, _b2;
  if (isObject(t2) && isUrl((_a2 = t2 == null ? void 0 : t2.attributes) == null ? void 0 : _a2.src)) [
    links.push({
      url: t2.attributes.src,
      title: ((_b2 = t2.attributes) == null ? void 0 : _b2.alt) || page.file.name,
      in_content: true,
      in_frontmatter: fm_links.map((i) => i.url).includes(t2.attributes.src),
      tagName: t2.name,
      domain: isYouTubeCreatorUrl(t2.attributes.src) ? "youtube-creator" : isYouTubeVideoUrl(t2.attributes.src) ? "youtube-video" : isGithubRepoUrl(t2.attributes.src) ? "github-repo" : void 0
    })
  ];
  return links;
};
function linksInFrontmatter(fm) {
  let links = [];
  Object.keys(fm).forEach((k) => {
    const prop = fm[k];
    if (isArray(prop)) {
      prop.forEach((p2) => {
        if (isUrl(p2)) {
          links.push({ url: p2, property: k });
        }
      });
    } else {
      if (isUrl(prop)) {
        links.push({ url: prop, property: k });
      }
    }
  });
  return links;
}
const pageContent = (p2) => async (ref) => {
  const path = isFileLink(ref) ? ref.path : isTFile(ref) ? ref.path : isString$1(ref) ? ref : isDvPage(ref) ? ref.file.path : void 0;
  if (!path) {
    p2.error("invalid path reference sent into pageContent()", ref);
    return void 0;
  }
  const content2 = await p2.dv.io.load(path);
  if (!content2) {
    p2.error(`the path passed to pageContent(${path}) was not a valid file in the vault`);
    return void 0;
  }
  p2.debug({ [`content [${typeof content2}]`]: content2 });
  const { yaml, body, blocks, h1, preH1, postH1 } = splitContent(content2);
  const ast = Markdoc.parse(content2);
  const renderableTree = () => {
    const result = Markdoc.transform(ast);
    return isString$1(result) ? JSON.parse(result) : result;
  };
  const page = isDvPage(ref) ? ref : p2.dv.page(path);
  return {
    filepath: path,
    content: content2,
    yaml,
    body,
    h1,
    preH1,
    postH1,
    blocks,
    ast,
    page,
    renderableTree,
    externalLinks: () => {
      let links = [];
      let tree = renderableTree();
      let fm_links = linksInFrontmatter(page.file.frontmatter);
      traverse(tree, find_links(links, fm_links, page));
      return [links, fm_links];
    },
    internalLinks: () => {
      return isDvPage(ref) ? Array.from(ref.file.outlinks) : Array.from(p2.dv.page(path).file.outlinks);
    }
  };
};
const VideoGallery = createHandler("VideoGallery").scalar().options({ size: "opt(enum(S,M,L))" }).handler(async (evt) => {
  var _a2, _b2, _c2;
  const { plugin: p2, page } = evt;
  let videos = [];
  let backLinks = page.as_array(((_b2 = (_a2 = page.current) == null ? void 0 : _a2.file) == null ? void 0 : _b2.inlinks) || []);
  let backPages = await Promise.all(
    backLinks.map((i) => pageContent(p2)(i))
  ).then((pgs) => pgs.filter((i) => i));
  backPages.forEach((pg) => {
    let [links] = pg.externalLinks();
    videos = [
      ...videos,
      ...links.filter((i) => i.domain === "youtube-video").map((i) => ({
        ...i,
        title: i.title.toLowerCase() === "video" ? pg.page.file.name : i.title,
        filepath: pg.filepath
      }))
    ];
  });
  let size = ((_c2 = evt == null ? void 0 : evt.options) == null ? void 0 : _c2.size) || "M";
  const grid_cols = size == "L" ? 2 : size == "M" ? 3 : size == "S" ? 4 : 5;
  const dom = [
    `<div class="video-gallery" style="display: grid; grid-template-columns: repeat(${grid_cols}, minmax(0, 1fr)); gap: 8px;">`,
    ...videos.map((v2) => {
      const src = youtubeEmbed(v2.url);
      const node2 = [
        `<div class="video-stack" style="display: flex; flex-direction: column; aspect-ratio: 1.75 auto">`,
        `<iframe class="video-ref" content-editable="false" aria-multiline="true" allow="fullscreen" frameborder="0" sandbox="allow-same-origin allow-modals allow-popups allow-presentation allow-forms" src="${src}"></iframe>`,
        `<a data-tooltip-position="top" aria-label="${v2.filepath}" data-href="${v2.filepath}" class="internal-link data-link-icon data-link-text" _target="_blank" rel="noopener" data-link-path="${v2.filepath}" style="">${v2.title}</a>`,
        `</div>`
      ].join("\n");
      return node2;
    }),
    "</div>"
  ].join("\n");
  page.render(dom);
});
const Page = createHandler("Page").scalar().options().handler(async (evt) => {
  var _a2, _b2, _c2, _d2;
  const p2 = evt.plugin;
  const page = evt.page;
  const fmt = p2.api.format;
  p2.info(`Page Details`, page);
  page.render(fmt.bold("Page Information<br/>"));
  const kindOfPage = [fmt.bold("Kind of Page"), page.type];
  const types = ((_a2 = page.typeTags) == null ? void 0 : _a2.length) > 0 ? [fmt.bold("Types(s)"), page.kindTags.join(", ")] : void 0;
  const kinds = ((_b2 = page.kindTags) == null ? void 0 : _b2.length) > 0 ? [fmt.bold("Kind(s)"), page.kindTags.join(", ")] : void 0;
  const cats = ((_c2 = page.categories) == null ? void 0 : _c2.length) > 0 ? [
    fmt.bold("Category(s)"),
    page.categories.map((i) => i.category).join(", ")
  ] : void 0;
  const subCats = ((_d2 = page.subcategories) == null ? void 0 : _d2.length) > 0 ? [
    fmt.bold("Subcategories(s)"),
    page.subcategories.map((i) => i.subcategory).join(", ")
  ] : void 0;
  const metadata = Object.keys(page.metadata).length > 0 ? [
    fmt.bold("Frontmatter"),
    Object.keys(page.metadata).filter((k) => !isFunction$2(page.metadata[k])).map(
      (k) => `${k}(${page.metadata[k].join(", ")})`
    ).join("<br/>")
  ] : void 0;
  const report = [
    kindOfPage,
    types,
    kinds,
    cats,
    subCats,
    metadata
  ].filter((i) => i);
  page.render(fmt.twoColumnTable(
    "",
    "Value",
    ...report
  ));
});
const Subcategories = createHandler("Subcategories").scalar(
  "category AS opt(string)"
).options().handler(async (evt) => {
  const { plugin: p2, page, scalar } = evt;
  const kind = page.kindTags[0];
  const categories = scalar.category && scalar.category.includes("/") ? [
    [
      ensureLeading(scalar.category.split("/")[0], "#"),
      "subcategory",
      scalar.category.split("/")[1]
    ].join("/")
  ] : scalar.category && kind ? [`${ensureLeading(kind, "#")}/subcategory/${stripLeading(scalar.category, "#")}`] : page.categories.map((i) => {
    const [k, c] = i.kindedTag.split("/");
    return `${ensureLeading(k, "#")}/subcategory/${c}`;
  });
  if (categories.length === 0) {
    showQueryError()("Subcategories", page, `no subcategories`);
  } else {
    for (const cat of categories) {
      const pages = p2.dv.pages(cat).sort((i) => i.file.name);
      if (pages.length > 0) {
        page.table(
          ["Subcategory", "Desc", "Links"],
          pages.map((i) => [
            createFileLink(p2)(i),
            showDesc(p2)(i),
            showLinks(p2)(i)
          ])
        );
      } else {
        page.renderValue(`- _no subcategories for ${ensureLeading(cat.split("/")[2], "#")} category_`);
      }
    }
  }
});
const queryHandlers = (p2) => (ctx) => [
  IconPage(p2)(ctx),
  BackLinks(p2)(ctx),
  Book(p2)(ctx),
  Kind(p2)(ctx),
  PageEntry(p2)(ctx),
  Page(p2)(ctx),
  Journal(p2)(ctx),
  VideoGallery(p2)(ctx),
  Subcategories(p2)(ctx)
];
const api = (plugin4) => ({
  /**
   * The **Query Handler** API surface.
   * 
   * - `BackLinks`
   * - `VideoGallery`
   * - etc.
   */
  queryHandlers: queryHandlers(plugin4),
  ...buildingBlocks(plugin4),
  ...showApi(plugin4),
  ...iconApi(plugin4),
  fm: fmApi(plugin4),
  obsidian: obsidianApi(plugin4),
  /**
   * **render**`(el, filePath) -> API`
   * 
   * You can gain access to the **Render API** if you provide an HTMLElement and filePath.
   */
  render: renderApi(plugin4),
  /**
   * **Formatting API**, designed to help you build useful HTML blocks that work
   * well with Obsidian.
   */
  format: formattingApi(plugin4),
  /**
   * Returns a `DvPage` when given a valid path to a file in the vault.
   * 
   * - also ensures that `DvPage` is added to the cache
   */
  getPage: getPage(plugin4),
  /**
   * Returns the _file path_ to a page when any `PageReference` is passed in.
   */
  getPath,
  /** 
   * Converts a `MarkdownView` to a `PageView`.
   * 
   * A `PageView` is a `PageInfo` on steroids. It provides
   * things like _content_, _content structure_, and several 
   * DOM entry points.
   * 
   * Note: from a caching standpoint, the `PageInfo` is cached
   * but the remaining props which separate a `PageView` from
   * `PageInfo` are all derived from the view that was passed in
   * (and therefore are not cached).
   */
  createPageView: createPageView(plugin4),
  /**
   * Creates a `PageInfoBlock` type which builds on the `PageInfo` type but with the benefit of having the following core types of 
   * information:
   * 
   * - the source of the code block
   * - the code block's HTML container element
   * - Obsidian's `Component` (which we're probably not taking full advantage of yet)
   */
  getPageInfoBlock: getPageInfoBlock(plugin4),
  /**
   * Converts a `PageReference` into a `PageInfo` which has
   * tons of extra meta properties and functions along with 
   * a `page` property which represents the `DvPage` API surface
   * for this page.
   */
  getPageInfo: getPageInfo(plugin4)
});
const csv = (plugin4) => {
  plugin4.registerMarkdownCodeBlockProcessor("csv", (source, el, ctx) => {
    const rows = source.split("\n").filter((row) => row.length > 0);
    const table3 = el.createEl("table");
    const body = table3.createEl("tbody");
    for (let i = 0; i < rows.length; i++) {
      const cols = rows[i].split(",");
      const row = body.createEl("tr");
      for (let j = 0; j < cols.length; j++) {
        row.createEl("td", { text: cols[j] });
      }
    }
  });
};
const on_editor_change = (plugin4) => {
  plugin4.registerEvent(
    plugin4.app.workspace.on(
      "editor-change",
      (editor, _info) => {
        let content2 = editor.getValue();
        const attributed = /\n::\s*quote\s*\(\s*"(.+?)"\s{0,1},\s{0,1}"(.+?)"\s*\)/sg;
        const quote = /\n::\s{0,1}quote\s{0,1}\("(.+?)"\s*\)/sg;
        const warn2 = /\n::\s{0,1}warn\s{0,1}\("(.+?)"\s*\)/sg;
        const warnWithCode = /\n::\s*warn\s*\(\s*"(.+?)"\s{0,1},\s{0,1}(.+?)\s*\)/sg;
        const err = /\n::\s{0,1}err(or){0,1}\s{0,1}\("(.+?)"\s*\)/sg;
        const errWithCode = /\n::\s*err(or){0,1}\s*\(\s*"(.+?)"\s{0,1},\s{0,1}(.+?)\s*\)/sg;
        const cur = editor.getCursor();
        if (attributed.test(content2)) {
          const text2 = content2.replaceAll(attributed, `
> [!quote] ${"$1".trim()}
> - $2

`);
          editor.setValue(text2);
          editor.setCursor({ ch: 0, line: cur.line + 2 });
          content2 = editor.getValue();
        }
        if (quote.test(content2)) {
          const text2 = content2.replaceAll(quote, `
> [!quote] ${"$1".trim()}
`);
          editor.setValue(text2);
          editor.setCursor(cur);
          editor.setCursor({ ch: 0, line: cur.line + 1 });
          content2 = editor.getValue();
        }
        if (warnWithCode.test(content2)) {
          const text2 = content2.replaceAll(warnWithCode, `
> [!warning] Warning [ ${"$3".trim()} ]
> - $1

`);
          editor.setValue(text2);
          editor.setCursor({ ch: 0, line: cur.line + 2 });
          content2 = editor.getValue();
        }
        if (warn2.test(content2)) {
          const text2 = content2.replaceAll(warn2, `
> [!warning] ${"$1".trim()}
`);
          editor.setValue(text2);
          editor.setCursor({ ch: 0, line: cur.line + 1 });
          content2 = editor.getValue();
        }
        if (errWithCode.test(content2)) {
          const text2 = content2.replaceAll(errWithCode, `
> [!error] Error [ ${"$3".trim()} ]
> <li style="color: #F38BA8">$2</li>

`);
          editor.setValue(text2);
          editor.setCursor({ ch: 0, line: cur.line + 2 });
          content2 = editor.getValue();
        }
        if (err.test(content2)) {
          const text2 = content2.replaceAll(err, `
> [!error] ${"$2".trim()}
`);
          editor.setValue(text2);
          editor.setCursor({ ch: 0, line: cur.line + 1 });
          content2 = editor.getValue();
        }
        const emoji_lookup = {
          "thumbs-up": "",
          "thumbs-down": "",
          "sunglasses": "",
          "smile": "",
          "rocket": ""
        };
        const emoji_pattern = /\(\(\s*(smile|thumbs-up|sunglasses){1}\s*\)\)/s;
        if (emoji_pattern.test(content2)) {
          plugin4.warn("emoji detected", emoji_pattern.test(content2));
          while (emoji_pattern.test(content2)) {
            const match2 = content2.match(emoji_pattern);
            plugin4.warn("match:", match2);
            if (match2) {
              const [all, first, next] = match2;
              plugin4.debug("emoji pattern", { all, first, next, match: match2 });
              const replacement = `<span class="emoji">${emoji_lookup[first]}</span>`;
              content2 = content2.replace(emoji_pattern, replacement);
            }
          }
          editor.setValue(content2);
          editor.setCursor({ ch: 0, line: cur.line + 1 });
        }
      }
    )
  );
};
const add_commands = (plugin4) => {
  plugin4.addCommand({
    id: "create-new-kinded-page",
    name: "create a new (kinded) page",
    editorCallback: create_new_kinded_page(plugin4)
  });
  plugin4.addCommand({
    id: "create-new-classification-page",
    name: "add a classification for a (kinded) page",
    editorCallback: (editor, view) => {
      const content2 = view.getViewData();
      plugin4.info("create-new-classification-page", { content: content2 });
    }
  });
  plugin4.addCommand({
    id: "add-url-props-for-kinded-page",
    name: "add links to (kinded) page",
    editorCallback: (editor, view) => {
      const content2 = view.getViewData();
      plugin4.info("add-url-props-for-kinded-page", { content: content2 });
    }
  });
  plugin4.addCommand({
    id: "update-kinded-page",
    name: "update this page",
    editorCallback: update_kinded_page(plugin4),
    icon: "refresh"
  });
};
const EventHandler = (plugin4) => ({
  /** a new active tab has been selected */
  onTabChange(cb) {
    plugin4.registerEvent(
      plugin4.app.workspace.on("active-leaf-change", (leaf) => {
        var _a2, _b2, _c2, _d2;
        if (leaf) {
          let pageName = leaf.view.getDisplayText();
          let icon = leaf.view.getIcon();
          let state = leaf.view.getState();
          let ephemeral = leaf.getEphemeralState().cursor;
          cb({
            pageName,
            filePath: state.file,
            icon,
            cursor: ephemeral,
            hasSelectedText: !(((_a2 = ephemeral == null ? void 0 : ephemeral.from) == null ? void 0 : _a2.ch) === ((_b2 = ephemeral == null ? void 0 : ephemeral.to) == null ? void 0 : _b2.ch) && ((_c2 = ephemeral == null ? void 0 : ephemeral.from) == null ? void 0 : _c2.line) === ((_d2 = ephemeral == null ? void 0 : ephemeral.to) == null ? void 0 : _d2.line)),
            leaf
          });
        }
      })
    );
  },
  /**
   * Provide a callback to whenever a _layout change_ is detected.
   */
  onLayoutChange: (cb) => {
    plugin4.app.workspace.on("layout-change", () => {
      cb();
    });
  },
  /**
   * Provide a callback to whenever a _resize_ is detected.
   */
  onResize: (cb) => {
    plugin4.app.workspace.on("resize", () => {
      cb();
    });
  },
  /**
   * Provide a callback to whenever a _window open_ event is detected.
   */
  onWindowOpen: (cb) => {
    plugin4.app.workspace.on("window-open", () => {
      cb();
    });
  },
  /**
   * Provide a callback to whenever a _window close_ event is detected.
   */
  onWindowClose: (cb) => {
    plugin4.app.workspace.on("window-close", () => {
      cb();
    });
  },
  /**
   * Provide a callback whenever a **quick preview** event is fired.
   */
  onQuickPreview: (cb) => {
    plugin4.app.workspace.on("quick-preview", (f, d) => {
      return cb(f, d);
    });
  },
  /**
   * Provide a callback whenever a **quick preview** event is fired.
   */
  onQuit: (cb) => {
    plugin4.app.workspace.on("quit", (tasks) => {
      return cb(tasks);
    });
  },
  /**
   * Provide a callback to handle each time a new file is **modified**.
   */
  onFileModified(cb) {
    plugin4.registerEvent(
      plugin4.app.vault.on("modify", (file) => {
        cb({ ...file });
      })
    );
    plugin4.info("registered event", cb);
  },
  /**
   * Provide a callback to handle each time a new file is **created**.
   */
  onFileCreated(cb) {
    plugin4.app.vault.on("create", (file) => {
      cb({ ...file });
    });
  },
  /**
   * Provide a callback to handle each time a file is **deleted**.
   */
  onFileDeleted(cb) {
    plugin4.app.vault.on("delete", (file) => {
      cb({ ...file });
    });
  }
});
class TextInputModal extends Modal {
  constructor(app2, title, defaultValue, resolve3) {
    super(app2);
    __publicField(this, "title");
    __publicField(this, "defaultValue");
    __publicField(this, "resolve");
    this.title = title;
    this.defaultValue = defaultValue;
    this.resolve = resolve3;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.title });
    const inputEl = contentEl.createEl("input", {
      type: "text",
      value: this.defaultValue
    });
    inputEl.addClass("text-input-modal-input");
    inputEl.focus();
    inputEl.onkeydown = (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        this.submit(inputEl.value);
      }
    };
    contentEl.createEl("br");
    const buttonContainer = contentEl.createDiv({ cls: "text-input-modal-buttons" });
    const submitBtn = buttonContainer.createEl("button", { text: "Submit" });
    submitBtn.addClass("mod-cta");
    submitBtn.onClickEvent(() => {
      this.submit(inputEl.value);
    });
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onClickEvent(() => {
      this.close();
      this.resolve(null);
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  submit(value2) {
    this.close();
    this.resolve(value2);
  }
}
const create_new_kinded_page = (p2) => async (editor, view) => {
  let value2;
  const modal = new TextInputModal(p2.app, "Filename", "", (v2) => {
    value2 = v2;
  });
  const fileName = await modal.open();
  console.log("value", value2, fileName);
};
const update_kinded_page = (p2) => async (editor, view) => {
  var _a2;
  const page = p2.api.createPageView(view);
  if (page.type !== "none") {
    p2.info("update-kinded-page", page);
    let changes = false;
    if (page.hasKindTag && page.kindTags.length === 1 && !page.hasKindProp) {
      changes = true;
      await page.setFmKey(
        "kind",
        createVaultLink(p2)((_a2 = page.classifications[0]) == null ? void 0 : _a2.kind)
      );
      new Notice("Set 'kind' property", 5e3);
      if (page.hasKindsProp) {
        page.removeFmKey("kinds");
        new Notice("Removed 'kinds' property'", 5e3);
      }
    }
    if (page.hasKindTag && page.kindTags.length > 1 && !page.hasKindsProp) {
      changes = true;
      await page.setFmKey(
        "kinds",
        page.classifications.map(
          (c) => createVaultLink(p2)(c.kind)
        )
      );
      new Notice("Set 'kinds' property", 5e3);
      if (page.hasKindProp) {
        page.removeFmKey("kind");
        new Notice("Removed 'kind' property'", 5e3);
      }
    }
    if (page.hasCategoryTag && !page.isCategoryPage && page.categories.length === 1 && !page.hasCategoryProp) {
      new Notice("'category' property added", 5e3);
      await page.setFmKey(
        "category",
        createVaultLink(p2)(page.categories[0].page)
      );
      if (page.hasCategoriesProp) {
        new Notice("'categories' property removed", 5e3);
        page.removeFmKey("categories");
      }
      changes = true;
    }
    if (page.hasCategoryProp && page.categories.length > 1 && !page.hasCategoriesProp) {
      await page.setFmKey(
        "categories",
        page.categories.map((i) => createVaultLink(p2)(i.page)).filter((i) => i)
      );
      if (page.hasCategoryProp) {
        new Notice("'category' property removed");
        page.removeFmKey("category");
      }
    }
    if (page.hasSubcategoryTag && !page.hasSubcategoryProp) {
      changes = true;
      await page.setFmKey(
        "subcategories",
        page.subcategories.map((i) => createVaultLink(p2)(i.page)).filter((i) => i)
      );
    }
    if (!changes) {
      new Notice("No changes necessary for Update command", 4e3);
    } else {
      new Notice("Updates completed");
    }
  }
};
const t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 48, 8, 96, 3, 127, 127, 127, 1, 127, 96, 3, 127, 127, 127, 0, 96, 2, 127, 127, 0, 96, 1, 127, 1, 127, 96, 3, 127, 127, 126, 1, 126, 96, 3, 126, 127, 127, 1, 126, 96, 2, 127, 126, 0, 96, 1, 127, 1, 126, 3, 11, 10, 0, 0, 2, 1, 3, 4, 5, 6, 1, 7, 5, 3, 1, 0, 1, 7, 85, 9, 3, 109, 101, 109, 2, 0, 5, 120, 120, 104, 51, 50, 0, 0, 6, 105, 110, 105, 116, 51, 50, 0, 2, 8, 117, 112, 100, 97, 116, 101, 51, 50, 0, 3, 8, 100, 105, 103, 101, 115, 116, 51, 50, 0, 4, 5, 120, 120, 104, 54, 52, 0, 5, 6, 105, 110, 105, 116, 54, 52, 0, 7, 8, 117, 112, 100, 97, 116, 101, 54, 52, 0, 8, 8, 100, 105, 103, 101, 115, 116, 54, 52, 0, 9, 10, 251, 22, 10, 242, 1, 1, 4, 127, 32, 0, 32, 1, 106, 33, 3, 32, 1, 65, 16, 79, 4, 127, 32, 3, 65, 16, 107, 33, 6, 32, 2, 65, 168, 136, 141, 161, 2, 106, 33, 3, 32, 2, 65, 137, 235, 208, 208, 7, 107, 33, 4, 32, 2, 65, 207, 140, 162, 142, 6, 106, 33, 5, 3, 64, 32, 3, 32, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 3, 32, 4, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 4, 32, 2, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 2, 32, 5, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 5, 32, 6, 32, 0, 65, 4, 106, 34, 0, 79, 13, 0, 11, 32, 2, 65, 12, 119, 32, 5, 65, 18, 119, 106, 32, 4, 65, 7, 119, 106, 32, 3, 65, 1, 119, 106, 5, 32, 2, 65, 177, 207, 217, 178, 1, 106, 11, 32, 1, 106, 32, 0, 32, 1, 65, 15, 113, 16, 1, 11, 146, 1, 0, 32, 1, 32, 2, 106, 33, 2, 3, 64, 32, 1, 65, 4, 106, 32, 2, 75, 69, 4, 64, 32, 0, 32, 1, 40, 2, 0, 65, 189, 220, 202, 149, 124, 108, 106, 65, 17, 119, 65, 175, 214, 211, 190, 2, 108, 33, 0, 32, 1, 65, 4, 106, 33, 1, 12, 1, 11, 11, 3, 64, 32, 1, 32, 2, 79, 69, 4, 64, 32, 0, 32, 1, 45, 0, 0, 65, 177, 207, 217, 178, 1, 108, 106, 65, 11, 119, 65, 177, 243, 221, 241, 121, 108, 33, 0, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 32, 0, 65, 15, 118, 115, 65, 247, 148, 175, 175, 120, 108, 34, 0, 65, 13, 118, 32, 0, 115, 65, 189, 220, 202, 149, 124, 108, 34, 0, 65, 16, 118, 32, 0, 115, 11, 63, 0, 32, 0, 65, 8, 106, 32, 1, 65, 168, 136, 141, 161, 2, 106, 54, 2, 0, 32, 0, 65, 12, 106, 32, 1, 65, 137, 235, 208, 208, 7, 107, 54, 2, 0, 32, 0, 65, 16, 106, 32, 1, 54, 2, 0, 32, 0, 65, 20, 106, 32, 1, 65, 207, 140, 162, 142, 6, 106, 54, 2, 0, 11, 195, 4, 1, 6, 127, 32, 1, 32, 2, 106, 33, 6, 32, 0, 65, 24, 106, 33, 4, 32, 0, 65, 40, 106, 40, 2, 0, 33, 3, 32, 0, 32, 0, 40, 2, 0, 32, 2, 106, 54, 2, 0, 32, 0, 65, 4, 106, 34, 5, 32, 5, 40, 2, 0, 32, 2, 65, 16, 79, 32, 0, 40, 2, 0, 65, 16, 79, 114, 114, 54, 2, 0, 32, 2, 32, 3, 106, 65, 16, 73, 4, 64, 32, 3, 32, 4, 106, 32, 1, 32, 2, 252, 10, 0, 0, 32, 0, 65, 40, 106, 32, 2, 32, 3, 106, 54, 2, 0, 15, 11, 32, 3, 4, 64, 32, 3, 32, 4, 106, 32, 1, 65, 16, 32, 3, 107, 34, 2, 252, 10, 0, 0, 32, 0, 65, 8, 106, 34, 3, 32, 3, 40, 2, 0, 32, 4, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 54, 2, 0, 32, 0, 65, 12, 106, 34, 3, 32, 3, 40, 2, 0, 32, 4, 65, 4, 106, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 54, 2, 0, 32, 0, 65, 16, 106, 34, 3, 32, 3, 40, 2, 0, 32, 4, 65, 8, 106, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 54, 2, 0, 32, 0, 65, 20, 106, 34, 3, 32, 3, 40, 2, 0, 32, 4, 65, 12, 106, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 54, 2, 0, 32, 0, 65, 40, 106, 65, 0, 54, 2, 0, 32, 1, 32, 2, 106, 33, 1, 11, 32, 1, 32, 6, 65, 16, 107, 77, 4, 64, 32, 6, 65, 16, 107, 33, 8, 32, 0, 65, 8, 106, 40, 2, 0, 33, 2, 32, 0, 65, 12, 106, 40, 2, 0, 33, 3, 32, 0, 65, 16, 106, 40, 2, 0, 33, 5, 32, 0, 65, 20, 106, 40, 2, 0, 33, 7, 3, 64, 32, 2, 32, 1, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 2, 32, 3, 32, 1, 65, 4, 106, 34, 1, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 3, 32, 5, 32, 1, 65, 4, 106, 34, 1, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 5, 32, 7, 32, 1, 65, 4, 106, 34, 1, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 7, 32, 8, 32, 1, 65, 4, 106, 34, 1, 79, 13, 0, 11, 32, 0, 65, 8, 106, 32, 2, 54, 2, 0, 32, 0, 65, 12, 106, 32, 3, 54, 2, 0, 32, 0, 65, 16, 106, 32, 5, 54, 2, 0, 32, 0, 65, 20, 106, 32, 7, 54, 2, 0, 11, 32, 1, 32, 6, 73, 4, 64, 32, 4, 32, 1, 32, 6, 32, 1, 107, 34, 1, 252, 10, 0, 0, 32, 0, 65, 40, 106, 32, 1, 54, 2, 0, 11, 11, 97, 1, 1, 127, 32, 0, 65, 16, 106, 40, 2, 0, 33, 1, 32, 0, 65, 4, 106, 40, 2, 0, 4, 127, 32, 1, 65, 12, 119, 32, 0, 65, 20, 106, 40, 2, 0, 65, 18, 119, 106, 32, 0, 65, 12, 106, 40, 2, 0, 65, 7, 119, 106, 32, 0, 65, 8, 106, 40, 2, 0, 65, 1, 119, 106, 5, 32, 1, 65, 177, 207, 217, 178, 1, 106, 11, 32, 0, 40, 2, 0, 106, 32, 0, 65, 24, 106, 32, 0, 65, 40, 106, 40, 2, 0, 16, 1, 11, 255, 3, 2, 3, 126, 1, 127, 32, 0, 32, 1, 106, 33, 6, 32, 1, 65, 32, 79, 4, 126, 32, 6, 65, 32, 107, 33, 6, 32, 2, 66, 214, 235, 130, 238, 234, 253, 137, 245, 224, 0, 124, 33, 3, 32, 2, 66, 177, 169, 172, 193, 173, 184, 212, 166, 61, 125, 33, 4, 32, 2, 66, 249, 234, 208, 208, 231, 201, 161, 228, 225, 0, 124, 33, 5, 3, 64, 32, 3, 32, 0, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 3, 32, 4, 32, 0, 65, 8, 106, 34, 0, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 4, 32, 2, 32, 0, 65, 8, 106, 34, 0, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 2, 32, 5, 32, 0, 65, 8, 106, 34, 0, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 5, 32, 6, 32, 0, 65, 8, 106, 34, 0, 79, 13, 0, 11, 32, 2, 66, 12, 137, 32, 5, 66, 18, 137, 124, 32, 4, 66, 7, 137, 124, 32, 3, 66, 1, 137, 124, 32, 3, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 4, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 2, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 5, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 5, 32, 2, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 124, 11, 32, 1, 173, 124, 32, 0, 32, 1, 65, 31, 113, 16, 6, 11, 134, 2, 0, 32, 1, 32, 2, 106, 33, 2, 3, 64, 32, 2, 32, 1, 65, 8, 106, 79, 4, 64, 32, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 32, 0, 133, 66, 27, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 33, 0, 32, 1, 65, 8, 106, 33, 1, 12, 1, 11, 11, 32, 1, 65, 4, 106, 32, 2, 77, 4, 64, 32, 0, 32, 1, 53, 2, 0, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 23, 137, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 249, 243, 221, 241, 153, 246, 153, 171, 22, 124, 33, 0, 32, 1, 65, 4, 106, 33, 1, 11, 3, 64, 32, 1, 32, 2, 73, 4, 64, 32, 0, 32, 1, 49, 0, 0, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 126, 133, 66, 11, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 0, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 32, 0, 66, 33, 136, 133, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 34, 0, 32, 0, 66, 29, 136, 133, 66, 249, 243, 221, 241, 153, 246, 153, 171, 22, 126, 34, 0, 32, 0, 66, 32, 136, 133, 11, 77, 0, 32, 0, 65, 8, 106, 32, 1, 66, 214, 235, 130, 238, 234, 253, 137, 245, 224, 0, 124, 55, 3, 0, 32, 0, 65, 16, 106, 32, 1, 66, 177, 169, 172, 193, 173, 184, 212, 166, 61, 125, 55, 3, 0, 32, 0, 65, 24, 106, 32, 1, 55, 3, 0, 32, 0, 65, 32, 106, 32, 1, 66, 249, 234, 208, 208, 231, 201, 161, 228, 225, 0, 124, 55, 3, 0, 11, 244, 4, 2, 3, 127, 4, 126, 32, 1, 32, 2, 106, 33, 5, 32, 0, 65, 40, 106, 33, 4, 32, 0, 65, 200, 0, 106, 40, 2, 0, 33, 3, 32, 0, 32, 0, 41, 3, 0, 32, 2, 173, 124, 55, 3, 0, 32, 2, 32, 3, 106, 65, 32, 73, 4, 64, 32, 3, 32, 4, 106, 32, 1, 32, 2, 252, 10, 0, 0, 32, 0, 65, 200, 0, 106, 32, 2, 32, 3, 106, 54, 2, 0, 15, 11, 32, 3, 4, 64, 32, 3, 32, 4, 106, 32, 1, 65, 32, 32, 3, 107, 34, 2, 252, 10, 0, 0, 32, 0, 65, 8, 106, 34, 3, 32, 3, 41, 3, 0, 32, 4, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 55, 3, 0, 32, 0, 65, 16, 106, 34, 3, 32, 3, 41, 3, 0, 32, 4, 65, 8, 106, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 55, 3, 0, 32, 0, 65, 24, 106, 34, 3, 32, 3, 41, 3, 0, 32, 4, 65, 16, 106, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 55, 3, 0, 32, 0, 65, 32, 106, 34, 3, 32, 3, 41, 3, 0, 32, 4, 65, 24, 106, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 55, 3, 0, 32, 0, 65, 200, 0, 106, 65, 0, 54, 2, 0, 32, 1, 32, 2, 106, 33, 1, 11, 32, 1, 65, 32, 106, 32, 5, 77, 4, 64, 32, 5, 65, 32, 107, 33, 2, 32, 0, 65, 8, 106, 41, 3, 0, 33, 6, 32, 0, 65, 16, 106, 41, 3, 0, 33, 7, 32, 0, 65, 24, 106, 41, 3, 0, 33, 8, 32, 0, 65, 32, 106, 41, 3, 0, 33, 9, 3, 64, 32, 6, 32, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 6, 32, 7, 32, 1, 65, 8, 106, 34, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 7, 32, 8, 32, 1, 65, 8, 106, 34, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 8, 32, 9, 32, 1, 65, 8, 106, 34, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 9, 32, 2, 32, 1, 65, 8, 106, 34, 1, 79, 13, 0, 11, 32, 0, 65, 8, 106, 32, 6, 55, 3, 0, 32, 0, 65, 16, 106, 32, 7, 55, 3, 0, 32, 0, 65, 24, 106, 32, 8, 55, 3, 0, 32, 0, 65, 32, 106, 32, 9, 55, 3, 0, 11, 32, 1, 32, 5, 73, 4, 64, 32, 4, 32, 1, 32, 5, 32, 1, 107, 34, 1, 252, 10, 0, 0, 32, 0, 65, 200, 0, 106, 32, 1, 54, 2, 0, 11, 11, 188, 2, 1, 5, 126, 32, 0, 65, 24, 106, 41, 3, 0, 33, 1, 32, 0, 41, 3, 0, 34, 2, 66, 32, 90, 4, 126, 32, 0, 65, 8, 106, 41, 3, 0, 34, 3, 66, 1, 137, 32, 0, 65, 16, 106, 41, 3, 0, 34, 4, 66, 7, 137, 124, 32, 1, 66, 12, 137, 32, 0, 65, 32, 106, 41, 3, 0, 34, 5, 66, 18, 137, 124, 124, 32, 3, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 4, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 1, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 5, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 5, 32, 1, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 124, 11, 32, 2, 124, 32, 0, 65, 40, 106, 32, 2, 66, 31, 131, 167, 16, 6, 11]);
async function e() {
  return function(t2) {
    const { exports: { mem: e2, xxh32: n2, xxh64: r, init32: i, update32: a, digest32: o, init64: s2, update64: u, digest64: c } } = t2;
    let h = new Uint8Array(e2.buffer);
    function g(t3, n3) {
      if (e2.buffer.byteLength < t3 + n3) {
        const r2 = Math.ceil((t3 + n3 - e2.buffer.byteLength) / 65536);
        e2.grow(r2), h = new Uint8Array(e2.buffer);
      }
    }
    function f(t3, e3, n3, r2, i2, a2) {
      g(t3);
      const o2 = new Uint8Array(t3);
      return h.set(o2), n3(0, e3), o2.set(h.subarray(0, t3)), { update(e4) {
        let n4;
        return h.set(o2), "string" == typeof e4 ? (g(3 * e4.length, t3), n4 = w.encodeInto(e4, h.subarray(t3)).written) : (g(e4.byteLength, t3), h.set(e4, t3), n4 = e4.byteLength), r2(0, t3, n4), o2.set(h.subarray(0, t3)), this;
      }, digest: () => (h.set(o2), a2(i2(0))) };
    }
    function y2(t3) {
      return t3 >>> 0;
    }
    const b = 2n ** 64n - 1n;
    function d(t3) {
      return t3 & b;
    }
    const w = new TextEncoder(), l2 = 0, p2 = 0n;
    function x2(t3, e3 = l2) {
      return g(3 * t3.length, 0), y2(n2(0, w.encodeInto(t3, h).written, e3));
    }
    function L(t3, e3 = p2) {
      return g(3 * t3.length, 0), d(r(0, w.encodeInto(t3, h).written, e3));
    }
    return { h32: x2, h32ToString: (t3, e3 = l2) => x2(t3, e3).toString(16).padStart(8, "0"), h32Raw: (t3, e3 = l2) => (g(t3.byteLength, 0), h.set(t3), y2(n2(0, t3.byteLength, e3))), create32: (t3 = l2) => f(48, t3, i, a, o, y2), h64: L, h64ToString: (t3, e3 = p2) => L(t3, e3).toString(16).padStart(16, "0"), h64Raw: (t3, e3 = p2) => (g(t3.byteLength, 0), h.set(t3), d(r(0, t3.byteLength, e3))), create64: (t3 = p2) => f(88, t3, s2, u, c, d) };
  }((await WebAssembly.instantiate(t)).instance);
}
const codeblockParser = (p2) => {
  let callback = async (source, el, ctx) => {
    el.style.overflowX = "auto";
    const event = { source, el, ctx };
    getPageInfoBlock(p2)(event);
    const handlers = p2.api.queryHandlers(event);
    p2.api.format;
    const outcomes = await Promise.all(handlers.map((i) => i()));
    p2.info(`code block processed`, outcomes);
    if (!outcomes.some((i) => i)) {
      handlers.map((i) => i.handlerName);
      handlers.find((i) => isError(i));
    }
  };
  let registration = p2.registerMarkdownCodeBlockProcessor(
    "km",
    callback
  );
  registration.sortOrder = -100;
};
const on_file_created = (plugin4) => {
  plugin4.registerEvent(plugin4.app.vault.on("create", (evt) => {
    const kind_folder = plugin4.settings.kind_folder;
    const find = new RegExp(`^${kind_folder}$`);
    if (find.test(evt.path)) {
      new Notice("Kind file added");
    }
  }));
};
const on_file_deleted = (plugin4) => {
  EventHandler(plugin4).onFileDeleted((evt) => {
    const kind_folder = plugin4.settings.kind_folder;
    const find = new RegExp(`^${kind_folder}$`);
    if (find.test(evt == null ? void 0 : evt.path)) {
      new Notice("Kind file deleted");
    } else {
      plugin4.info(`file ${evt == null ? void 0 : evt.path} was deleted but has no effect on Kind Model (and it's caching)`);
    }
  });
};
const on_file_modified = (plugin4) => {
  EventHandler(plugin4).onFileModified((evt) => {
    if (isString$1((evt == null ? void 0 : evt.path) || null) && isKindedPage(plugin4)(evt == null ? void 0 : evt.path)) {
      const kind_folder = plugin4.settings.kind_folder;
      const find = new RegExp(`^${kind_folder}`);
      if (find.test(evt.path)) {
        new Notice("Kind file modified");
      }
    }
  });
};
const on_layout_change = (plugin4) => {
  EventHandler(plugin4).onLayoutChange(() => {
    plugin4.info("layout change detected");
  });
};
const on_tab_change = (p2) => {
  EventHandler(p2).onTabChange((evt) => {
    p2.info(
      evt.pageName,
      "navigation event",
      {
        file: evt.filePath,
        icon: evt.icon,
        hasSelectedText: evt.hasSelectedText
      }
    );
  });
};
const electron = window.require("electron");
const { clipboard } = electron;
const commands = [
  "PageEntry()",
  "Page()",
  "BackLinks()",
  'Kind("kind","opt:category","opt:subcategory")'
];
class KindSuggest extends EditorSuggest {
  constructor(app2, plugin4) {
    super(app2);
    __publicField(this, "plugin");
    this.plugin = plugin4;
    plugin4.debug("KindSuggest instantiated");
  }
  onTrigger(cursor, editor) {
    const currentLine = editor.getLine(cursor.line);
    const priorLine = editor.getLine(Math.max(cursor.line - 1, 0));
    const beforeCursor = currentLine.substring(0, cursor.ch);
    const words = currentLine.split(/\s+/);
    const lastWord = words.pop() || "";
    const lastWordLoc = currentLine.indexOf(lastWord);
    this.plugin.info(`lastWord: ${lastWord}`, isValidURL(lastWord));
    ["https://", "http://"].some((i) => lastWord.startsWith(i));
    if (isValidURL(lastWord)) {
      return {
        start: {
          line: cursor.line,
          ch: lastWordLoc
        },
        end: cursor,
        query: currentLine
      };
    }
    const completeKindQuery = priorLine.includes("km") && currentLine.length > 0 && commands.some((c) => c.startsWith(currentLine));
    if (completeKindQuery) {
      return {
        start: {
          line: cursor.line,
          ch: 0
        },
        end: cursor,
        query: currentLine
      };
    }
    const match2 = beforeCursor.match(/\/([^\s]*)$/);
    if (match2) {
      return {
        start: {
          line: cursor.line,
          ch: cursor.ch - match2[1].length - 1
        },
        end: cursor,
        query: match2[1]
      };
    }
    return null;
  }
  getSuggestions(ctx) {
    var _a2;
    let suggestions = [];
    this.plugin.info("getting suggestions", { query: ctx.query, isUrl: isValidURL(ctx.query.trim()) });
    if (ctx.query.length > 0 && commands.some((i) => i.startsWith(ctx.query))) {
      const suggestions2 = commands.filter((c) => c.startsWith(ctx.query));
      return suggestions2;
    }
    if (isValidURL(ctx.query.trim())) {
      this.plugin.info("is URL");
      const suggestions2 = [
        `Add the URL "${ctx.query.trim()}" as frontmatter property `,
        `Convert to a markdown link `,
        `Leave raw URL "as is"`
      ];
      return suggestions2;
    } else {
      this.plugin.info("not URL", ctx.query.trim());
    }
    const file = (_a2 = this.context) == null ? void 0 : _a2.file;
    if (file) {
      const page = getPageInfo(this.plugin)(file);
      let isReallyImportant = false;
      const clipboardText = clipboard.readText();
      const hasURLInClipboard = ["https://", "http://"].some((i) => clipboardText.startsWith(i));
      const allCommands = [
        ...page.isKindedPage || page.isCategoryPage || page.isSubcategoryPage || page.isKindDefnPage ? ["Update Kind Page "] : []
      ];
      const query2 = ctx.query.toLowerCase();
      if (file) {
        const metadata = this.app.metadataCache.getFileCache(file);
        if (metadata && metadata.frontmatter) {
          isReallyImportant = metadata.frontmatter.isReallyImportant === true;
        }
      }
      suggestions = [
        ...allCommands.filter(
          (cmd) => cmd.toLowerCase().includes(query2)
        ),
        ...hasURLInClipboard ? [`Paste the URL "${clipboardText}" as `] : []
      ];
      if (isReallyImportant) {
        const insertDateIndex = suggestions.findIndex(
          (cmd) => cmd === "Insert Date"
        );
        if (insertDateIndex > -1) {
          const [insertDateCmd] = suggestions.splice(insertDateIndex, 1);
          suggestions.unshift(insertDateCmd);
        }
      }
    }
    return suggestions;
  }
  renderSuggestion(suggestion, el) {
    el.createEl("div", { text: suggestion });
  }
  selectSuggestion(suggestion, evt) {
    if (this.context) {
      const { editor, start: start2, end: end2, file, query: query2 } = this.context;
      const selectedText = editor.getSelection();
      const view = this.app.workspace.getActiveViewOfType(MarkdownView);
      const page = getPageInfo(this.plugin)(file);
      if (page && view) {
        ({
          isKindedPage: isKindedPage(this.plugin)(page),
          isCategoryPage: isCategoryPage(this.plugin)(page),
          isSubcategoryPage: isSubcategoryPage(this.plugin)(page)
        });
        this.plugin.info("Suggestion", suggestion);
        switch (suggestion) {
          case "Update":
            editor.exec("update-kinded-model");
            break;
          case "Bold":
            if (selectedText) {
              editor.replaceSelection(`**${selectedText}**`);
            } else {
              editor.replaceRange("****", start2, end2);
              editor.setCursor({ line: start2.line, ch: start2.ch + 2 });
            }
            break;
          case "Italic":
            v;
            if (selectedText) {
              editor.replaceSelection(`*${selectedText}*`);
            } else {
              editor.replaceRange("**", start2, end2);
              editor.setCursor({ line: start2.line, ch: start2.ch + 1 });
            }
            break;
          case "Underline":
            if (selectedText) {
              editor.replaceSelection(`<u>${selectedText}</u>`);
            } else {
              editor.replaceRange("<u></u>", start2, end2);
              editor.setCursor({ line: start2.line, ch: start2.ch + 3 });
            }
            break;
          case "Insert Date":
            editor.replaceRange(
              (/* @__PURE__ */ new Date()).toLocaleDateString(),
              start2,
              end2
            );
            break;
          case "Link":
            if (selectedText) {
              const url = prompt("Enter URL:");
              if (url) {
                editor.replaceSelection(`[${selectedText}](${url})`);
              }
            } else {
              const text2 = prompt("Enter Link Text:") || "";
              const url = prompt("Enter URL:") || "";
              editor.replaceRange(`[${text2}](${url})`, start2, end2);
            }
            break;
          case "Convert to a markdown link ":
            editor.replaceRange(`[${query2}](${query2})`, start2, end2);
            break;
          default:
            if (commands.includes(selectedText.trim())) ;
            else {
              editor.replaceRange(suggestion, start2, end2);
            }
            break;
        }
      } else {
        this.plugin.debug(`The selectSuggestion() method was triggered but couldn't create a PageInfo structure (or possibly a view for page)!`, file, view, page);
      }
    } else {
      this.plugin.debug(`The selectSuggestion() method was triggered but no context was provided on instantiated class!`, this);
    }
  }
}
let hasher = null;
class KindModelPlugin extends Plugin$1 {
  constructor() {
    super(...arguments);
    __publicField(this, "settings");
    /** the Dataview API surface */
    __publicField(this, "dv", globalThis["DataviewAPI"]);
    __publicField(this, "api");
    __publicField(this, "log");
    __publicField(this, "debug");
    __publicField(this, "info");
    __publicField(this, "warn");
    __publicField(this, "error");
    __publicField(this, "cache", {
      kindDefinitionsByPath: /* @__PURE__ */ new Map(),
      kindDefinitionsByTag: /* @__PURE__ */ new Map(),
      typeDefinitionsByPath: /* @__PURE__ */ new Map(),
      typeDefinitionsByTag: /* @__PURE__ */ new Map(),
      kindTagDuplicates: /* @__PURE__ */ new Map(),
      typeTagDuplicates: /* @__PURE__ */ new Map()
    });
    __publicField(this, "hasher");
    __publicField(this, "cache_ready", false);
  }
  /**
   * provides a boolean flag which indicates whether this plugin's 
   * cache is complete and therefore other operations which depend
   * on this can proceed.
   */
  get ready() {
    return this.cache_ready;
  }
  set ready(state) {
    this.cache_ready = state;
  }
  /**
   * Setup this plugin on the "onload" event from Obsidian
   */
  async onload() {
    await this.loadSettings();
    const log = logger(this.settings.log_level);
    log.info("starting plugin");
    const { debug: debug2, info: info2, warn: warn2, error: error2 } = log;
    this.log = log;
    this.debug = debug2;
    this.info = info2;
    this.warn = warn2;
    this.error = error2;
    this.hasher = hasher ? hasher : (await e()).h32;
    hasher = this.hasher;
    this.registerEditorSuggest(new KindSuggest(this.app, this));
    this.ready = false;
    const caching = initializeKindCaches(this);
    caching.then(() => {
      this.ready = true;
      this.info("Caching lookups complete");
      this.saveSettings();
    });
    this.dv = getAPI_1(this.app);
    this.api = api(this);
    csv(this);
    on_editor_change(this);
    add_commands(this);
    on_file_deleted(this);
    on_file_created(this);
    on_file_modified(this);
    on_layout_change(this);
    on_tab_change(this);
    codeblockParser(this);
    const statusBarItemEl = this.addStatusBarItem();
    statusBarItemEl.setText("Kind Models");
    statusBarItemEl.addClass("clickable");
    this.addSettingTab(new SettingsTab(this.app, this));
    log.info(`ready`);
    this.mount();
  }
  mount() {
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    const { info: info2, error: error2 } = logger(this.settings.log_level);
    if (typeof this.saveData !== "function") {
      error2("the 'this' context appear to have been lost when trying to call saveSettings()", this);
      return;
    }
    await this.saveData(this.settings);
    info2("saved user settings", this.settings);
  }
}
export {
  KindModelPlugin as default
};
//# sourceMappingURL=main.mjs.map
