# `km` Schema Upgrade

## Context

This plugin provides `km` code blocks which contain a set of commands such as `BackLinks()`, `Kind()`, `VideoGallery()`, etc. Each of these commands takes parameters to refine what the command should do.

> As an example if I were to add `BackLinks({ dedupe: false })` then the deduping feature that **BackLinks** by default uses would be disabled.

## Requirements

Currently the problem is that's impractical for users to remember the parameters for each command so we need -- at a minimum -- a way to translate a schema/type definition into a runtime ruleset and use that to give very clear error messages when the user makes mistakes. Ideally we'd want to have a CodeMirror component which could provide type support for each of the commands without needing to define the schema twice. This CodeMirror component would provide autocomplete and error reporting support to guide the user to a correct signature.

## Knowledge Base

- you should use the `obsidian` skill in planning and execution
- consider using a library like `zod` or `ArkType` which can synchronize/share type information between the runtime and type systems of Typescript 
  - I generally prefer the syntax of `ArkType` and I believe it's actually much more performant from a type inference standpoint too.
- it is worth noting the Obsidian -- out-of-the-box -- provides code highlighting for a code block marked as `js`. Since our commands follow the syntactic rules of `js` we might be able to use this as a starting point and just add the further constraints and autocomplete parts based on the types of the parameters.

## Solution

- Find a way to provide a world-class experience to the user of the plugin by providing auto-complete and visual indicators of errors while they're inputting the command inside the `km` code block.
- If a user exits the `km` block in an error state, provide a useful error in the space designated for the `km` block indicating the error in enough detail that gives clarity to the user what has happened.
- Meanwhile, we need an ergonomic DX solution too:
  - We ideally only define a type definition once for the expected signature of each command
  - From that one type definition we can both use it as Typescript _type_ when handling the user's inputs but also provide it to the CodeMirror component so that it can provide the LSP-like experience.

We are done when we have both a working solution -- with corresponding unit tests -- and a well thought out and complete document which describes the expectations for both the user of the plugin and developer writing a `km` command. Save this document to `docs/km-type-guardrails.md`

