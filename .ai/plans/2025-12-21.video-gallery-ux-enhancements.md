# VideoGallery UX Enhancements Plan

**Created:** 2025-12-21
**Status:** ‚úÖ IMPLEMENTED
**Implemented:** 2025-12-21 (14:04 - 14:10)
**Project:** Obsidian Kind Model Plugin
**Component:** VideoGallery Handler

---

## Review Summary

**Reviews Completed:** 2025-12-21 (Parallel Expert Reviews)

**Reviewers:**
- ‚úÖ Browser/CSS/Animation Expert: **Approve with Changes**
- ‚úÖ Obsidian Plugin Integration Expert: **Approve with Changes**
- ‚úÖ TypeScript/Accessibility/UX Expert: **Approve with Changes**

**Overall Assessment:** **APPROVED WITH CRITICAL CHANGES REQUIRED**

This plan has excellent foundations and demonstrates strong architectural thinking. However, three critical issues must be addressed before implementation:

### Critical Issues (BLOCKERS)

| Issue | Severity | Identified By | Status |
|-------|----------|---------------|--------|
| **1. Missing Cleanup/Lifecycle Management** | üî¥ CRITICAL | All 3 reviewers | ‚ö†Ô∏è MUST FIX |
| **2. Transform-Origin CSS Mismatch** | üî¥ CRITICAL | Browser Expert | ‚ö†Ô∏è MUST FIX |
| **3. Race Condition Protection Missing** | üî¥ CRITICAL | TypeScript Expert | ‚ö†Ô∏è MUST FIX |
| **4. WCAG 2.1 Accessibility Violations** | üî¥ CRITICAL | TypeScript Expert | ‚ö†Ô∏è MUST FIX |
| **5. YouTube IFrame API Security** | üü° HIGH | Obsidian + TypeScript Experts | ‚ö†Ô∏è MUST FIX |
| **6. State Management (WeakMap Required)** | üü° HIGH | TypeScript + Obsidian Experts | ‚ö†Ô∏è MUST FIX |

### Key Changes from Review

1. **Cleanup System Added** - New MutationObserver-based cleanup for event listeners (addresses memory leaks)
2. **Transform-Origin Fixed** - Changed from `top left` to `center center` to match transform calculations
3. **Race Condition Guards** - Added `isAnimating` flag and click debouncing
4. **WCAG Compliance** - Added ARIA live regions, focus management, focus trap, screen reader announcements
5. **YouTube API Security** - Changed postMessage origin from `'*'` to `'https://www.youtube.com'`
6. **WeakMap State** - Changed from global state to WeakMap-based per-gallery state

### Updated Implementation Requirements

Before starting Phase 1:
- [x] Add cleanup infrastructure (MutationObserver, cleanup registry)
- [x] Implement WeakMap-based state management
- [x] Add runtime element validation
- [x] Update CSS with correct transform-origin

See **"Required Changes Before Implementation"** section below for complete details.

---

## Executive Summary

Transform the VideoGallery km-block handler from a static grid of YouTube embeds into a polished, interactive gallery experience with smooth animations, hover effects, and an immersive full-width viewing mode. This enhancement focuses purely on UI/UX improvements without changing the underlying data model or handler API.

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Phase |
|----|-------------|----------|-------|
| FR-1 | Hover effect: subtle growth animation with center-point anchor | High | 1 |
| FR-2 | Hover effect: elevated appearance with shadow/blur border | High | 1 |
| FR-3 | Click behavior: intercept first click to expand video | High | 2 |
| FR-4 | Expanded mode: full page width with backdrop blur | High | 2 |
| FR-5 | Expanded mode: auto-play video on expansion | High | 2 |
| FR-6 | Expanded mode: ESC key returns to grid | High | 2 |
| FR-7 | Expanded mode: click outside video returns to grid | High | 2 |
| FR-8 | Expanded mode: normal play/pause on subsequent clicks | Medium | 2 |
| FR-9 | All transitions smoothly animated | High | 1, 2 |

### Non-Functional Requirements

| ID | Requirement | Target | Phase |
|----|-------------|--------|-------|
| NFR-1 | Hover animation duration | 250-300ms | 1 |
| NFR-2 | Expansion animation duration | 400-500ms | 2 |
| NFR-3 | No layout shift during hover | Grid maintains position | 1 |
| NFR-4 | Accessibility: keyboard navigation support | ESC key handling | 2 |
| NFR-5 | Performance: GPU-accelerated transforms | Use `transform`, `opacity` only | 1, 2 |
| NFR-6 | Responsive: works across all size options (S, M, L) | Tested on all grid sizes | 1, 2 |
| NFR-7 | Obsidian theme compatibility | Uses CSS variables | 1, 2 |

## Architecture Overview

### Current Architecture

```
VideoGallery Handler
‚îú‚îÄ‚îÄ Collects YouTube URLs from backlinks
‚îú‚îÄ‚îÄ Generates HTML grid with iframes
‚îî‚îÄ‚îÄ Renders via Dataview's renderValue()

Current DOM Structure:
<div class="video-gallery">
  <div class="video-stack">
    <iframe class="video-ref" src="..."></iframe>
    <a class="internal-link">Title</a>
  </div>
  ...
</div>
```

### Enhanced Architecture

```
VideoGallery Handler
‚îú‚îÄ‚îÄ Collects YouTube URLs from backlinks
‚îú‚îÄ‚îÄ Generates HTML grid with enhanced structure
‚îú‚îÄ‚îÄ Renders via Dataview's renderValue()
‚îî‚îÄ‚îÄ Attaches event listeners post-render (NEW)
    ‚îú‚îÄ‚îÄ Hover handlers (mouseenter/mouseleave)
    ‚îú‚îÄ‚îÄ Click handlers (click interception)
    ‚îî‚îÄ‚îÄ Global handlers (ESC key, outside click)

Enhanced DOM Structure:
<div class="video-gallery" data-km-gallery-id="unique-id">
  <div class="video-gallery-grid">
    <div class="video-item" data-video-index="0">
      <div class="video-stack">
        <div class="video-container">
          <iframe class="video-ref" src="..."></iframe>
        </div>
        <a class="internal-link">Title</a>
      </div>
    </div>
    ...
  </div>
  <div class="video-backdrop" style="display: none;"></div>
</div>

CSS Modules:
‚îú‚îÄ‚îÄ .video-gallery { position: relative; }
‚îú‚îÄ‚îÄ .video-item { position: relative; transition: transform 250ms; }
‚îú‚îÄ‚îÄ .video-item:hover { transform: scale(1.05); z-index: 10; }
‚îú‚îÄ‚îÄ .video-item.expanded { position: fixed; width: 80vw; ... }
‚îî‚îÄ‚îÄ .video-backdrop { position: fixed; backdrop-filter: blur(8px); }
```

### Component Interaction Flow

#### Hover Flow
```
User hovers ‚Üí mouseenter event
  ‚Üí Add .hovering class to .video-item
  ‚Üí CSS transforms: scale(1.05), add shadow/border
  ‚Üí Change z-index to elevate above grid
  ‚Üí CSS transition animates (250ms)

User unhovers ‚Üí mouseleave event
  ‚Üí Remove .hovering class
  ‚Üí CSS transforms: scale(1.0), remove shadow/border
  ‚Üí Reset z-index
  ‚Üí CSS transition animates (250ms)
```

#### Click-to-Expand Flow
```
User clicks video ‚Üí click event on .video-item
  ‚Üí Check state: if NOT expanded
    ‚Üí preventDefault() to stop YouTube's play/pause
    ‚Üí Record original position (getBoundingClientRect)
    ‚Üí Add .expanding class
    ‚Üí Calculate target position (center of viewport, 80vw width)
    ‚Üí Apply transform: translate + scale
    ‚Üí Show backdrop with fade-in
    ‚Üí After transition (400ms):
      ‚Üí Add .expanded class
      ‚Üí Remove .expanding class
      ‚Üí Send YouTube API command to play video
      ‚Üí Attach ESC and outside-click listeners
      ‚Üí Remove hover listeners temporarily
  ‚Üí Check state: if ALREADY expanded
    ‚Üí Allow default YouTube behavior (play/pause)
```

#### Return-to-Grid Flow
```
Trigger: ESC key OR click outside video

‚Üí Add .collapsing class
‚Üí Remove .expanded class
‚Üí Send YouTube API command to pause video
‚Üí Apply reverse transform (back to grid position)
‚Üí Fade out backdrop
‚Üí After transition (400ms):
  ‚Üí Remove .collapsing class
  ‚Üí Clear inline transforms
  ‚Üí Re-attach hover listeners
  ‚Üí Remove ESC and outside-click listeners
```

## Phases

### Phase 1: Hover Effects & CSS Foundation

**Goal:** Implement smooth hover effects with center-anchored growth and elevated appearance

**Dependencies:** None

**Blast Radius:** `pnpm test` (full test suite)

**Files to Create:**
- None (all changes to existing files)

**Files to Modify:**
- `src/handlers/VideoGallery.ts` - Update DOM structure, add container divs, attach hover listeners
- `styles.css` - Add CSS for hover effects, transitions, shadows

**Deliverables:**
- Enhanced DOM structure with wrapper elements for positioning
- CSS classes for hover states (`.video-item`, `.video-item:hover`, `.hovering`)
- JavaScript hover event handlers attached post-render
- Smooth transform animations (250-300ms)
- Elevated appearance with box-shadow and optional border

**Technical Details:**

1. **DOM Structure Changes:**
   ```typescript
   // Before:
   <div class="video-stack">
     <iframe class="video-ref" src="..."></iframe>
     <a>Title</a>
   </div>

   // After:
   <div class="video-item" data-video-index="${index}">
     <div class="video-stack">
       <div class="video-container">
         <iframe class="video-ref" src="..."></iframe>
       </div>
       <a>Title</a>
     </div>
   </div>
   ```

2. **CSS Strategy:**
   - Use `transform: scale(1.05)` for growth (GPU-accelerated)
   - Use `transform-origin: center center` for center-point anchor
   - Use `transition: transform 250ms ease-out, box-shadow 250ms ease-out`
   - Elevate with `z-index: 10` on hover
   - Add `box-shadow: 0 8px 24px rgba(0,0,0,0.3)` for depth
   - Optional: `border: 2px solid var(--interactive-accent)` with subtle glow

3. **JavaScript Event Handling:**
   ```typescript
   // After render.render(dom), attach listeners:
   const galleryEl = el.querySelector('.video-gallery');
   const videoItems = galleryEl.querySelectorAll('.video-item');

   videoItems.forEach(item => {
     item.addEventListener('mouseenter', () => {
       item.classList.add('hovering');
     });

     item.addEventListener('mouseleave', () => {
       item.classList.remove('hovering');
     });
   });
   ```

4. **Preventing Grid Disruption:**
   - Use `position: relative` on `.video-item`
   - Apply `transform` instead of changing width/height
   - Ensure grid container has `position: relative` or `static` (default)
   - Elevated item uses `z-index` to appear above siblings without affecting layout

**Acceptance Criteria:**
- [ ] File `src/handlers/VideoGallery.ts` modified with new DOM structure (grep for `video-item`)
- [ ] File `styles.css` contains `.video-item`, `.video-item.hovering`, `.video-container` styles
- [ ] Hovering over video shows subtle scale animation (visually verified)
- [ ] Hover animation completes in 250-300ms
- [ ] Video remains centered during hover growth
- [ ] Grid layout does not shift when hovering
- [ ] Box shadow appears during hover
- [ ] All size options (S, M, L) display correctly
- [ ] No console errors during hover interactions
- [ ] Existing tests pass: `pnpm test`

---

### Phase 2: Click-to-Expand & Immersive Viewing Mode

**Goal:** Implement full-width expansion, backdrop blur, auto-play, and return-to-grid behaviors

**Dependencies:** Phase 1 (hover effects foundation)

**Blast Radius:** `pnpm test` (full test suite)

**Files to Modify:**
- `src/handlers/VideoGallery.ts` - Add click handlers, expansion logic, YouTube IFrame API integration
- `styles.css` - Add CSS for expanded state, backdrop, animations

**Deliverables:**
- Click interception logic (first click = expand, not play/pause)
- Smooth animation from grid position to full-width centered
- Backdrop element with blur effect
- Auto-play when expanded
- ESC key handler to collapse and pause
- Outside-click handler to collapse and pause
- Return animation back to original grid position
- Normal YouTube play/pause on subsequent clicks when expanded

**Technical Details:**

1. **State Management:**
   ```typescript
   // Track expansion state per gallery instance
   interface VideoGalleryState {
     expandedVideoIndex: number | null;
     originalRect: DOMRect | null;
     escHandler: ((e: KeyboardEvent) => void) | null;
     outsideClickHandler: ((e: MouseEvent) => void) | null;
   }
   ```

2. **Click Interception:**
   ```typescript
   videoItem.addEventListener('click', (e) => {
     const isExpanded = videoItem.classList.contains('expanded');

     if (!isExpanded) {
       e.preventDefault(); // Stop YouTube default behavior
       e.stopPropagation();
       expandVideo(videoItem, index);
     }
     // If already expanded, allow YouTube's default play/pause
   });
   ```

3. **Expansion Animation:**
   ```typescript
   function expandVideo(videoItem: HTMLElement, index: number) {
     // 1. Record original position
     const originalRect = videoItem.getBoundingClientRect();

     // 2. Add expanding state
     videoItem.classList.add('expanding');

     // 3. Show backdrop
     const backdrop = el.querySelector('.video-backdrop');
     backdrop.style.display = 'block';
     backdrop.classList.add('visible');

     // 4. Calculate target position (center viewport, 80vw width)
     const viewportWidth = window.innerWidth;
     const viewportHeight = window.innerHeight;
     const targetWidth = viewportWidth * 0.8;
     const targetHeight = targetWidth * (9/16); // 16:9 aspect ratio

     const targetX = (viewportWidth - targetWidth) / 2;
     const targetY = (viewportHeight - targetHeight) / 2;

     // 5. Apply transform
     const translateX = targetX - originalRect.left;
     const translateY = targetY - originalRect.top;
     const scaleX = targetWidth / originalRect.width;
     const scaleY = targetHeight / originalRect.height;

     videoItem.style.transform =
       `translate(${translateX}px, ${translateY}px) scale(${scaleX}, ${scaleY})`;

     // 6. After transition, finalize state
     setTimeout(() => {
       videoItem.classList.remove('expanding');
       videoItem.classList.add('expanded');

       // Auto-play video
       const iframe = videoItem.querySelector('iframe');
       sendYouTubeCommand(iframe, 'playVideo');

       // Attach global listeners
       attachEscListener(videoItem, originalRect);
       attachOutsideClickListener(videoItem, originalRect);
     }, 500); // Match CSS transition duration
   }
   ```

4. **YouTube IFrame API Integration:**
   ```typescript
   // Send commands to YouTube player via postMessage
   function sendYouTubeCommand(iframe: HTMLIFrameElement, command: string) {
     const message = JSON.stringify({
       event: 'command',
       func: command,
       args: []
     });
     iframe.contentWindow?.postMessage(message, '*');
   }

   // Enable YouTube IFrame API by adding ?enablejsapi=1 to src
   // Modify youtubeEmbed() helper to include this parameter
   ```

5. **Return to Grid:**
   ```typescript
   function collapseVideo(videoItem: HTMLElement, originalRect: DOMRect) {
     // 1. Add collapsing state
     videoItem.classList.add('collapsing');
     videoItem.classList.remove('expanded');

     // 2. Pause video
     const iframe = videoItem.querySelector('iframe');
     sendYouTubeCommand(iframe, 'pauseVideo');

     // 3. Hide backdrop
     const backdrop = el.querySelector('.video-backdrop');
     backdrop.classList.remove('visible');

     // 4. Reverse transform to original position
     videoItem.style.transform = 'translate(0, 0) scale(1)';

     // 5. After transition, cleanup
     setTimeout(() => {
       videoItem.classList.remove('collapsing');
       videoItem.style.transform = '';
       backdrop.style.display = 'none';

       // Remove global listeners
       if (escHandler) {
         document.removeEventListener('keydown', escHandler);
       }
       if (outsideClickHandler) {
         document.removeEventListener('click', outsideClickHandler);
       }
     }, 500);
   }
   ```

6. **CSS for Expanded State:**
   ```css
   .video-item.expanding,
   .video-item.expanded {
     position: fixed !important;
     z-index: 1000;
     transition: transform 500ms cubic-bezier(0.4, 0.0, 0.2, 1);
   }

   .video-item.collapsing {
     position: fixed !important;
     z-index: 1000;
     transition: transform 500ms cubic-bezier(0.4, 0.0, 0.2, 1);
   }

   .video-backdrop {
     position: fixed;
     top: 0;
     left: 0;
     width: 100vw;
     height: 100vh;
     background: rgba(0, 0, 0, 0.6);
     backdrop-filter: blur(12px);
     z-index: 999;
     opacity: 0;
     transition: opacity 500ms ease;
     pointer-events: none;
   }

   .video-backdrop.visible {
     opacity: 1;
     pointer-events: auto;
   }
   ```

7. **YouTube Embed URL Modification:**
   - Update `src/helpers/youtube.ts` `youtubeEmbed()` to add `?enablejsapi=1` parameter
   - This enables postMessage API for play/pause control

**Acceptance Criteria:**
- [ ] File `src/handlers/VideoGallery.ts` contains click handler logic (grep for `expandVideo`)
- [ ] File `src/helpers/youtube.ts` modified to include `enablejsapi=1` parameter
- [ ] File `styles.css` contains `.video-item.expanded`, `.video-backdrop`, `.collapsing` styles
- [ ] Clicking video expands it to ~80vw width
- [ ] Expansion animation completes in 400-500ms
- [ ] Backdrop appears with blur effect during expansion
- [ ] Video auto-plays after expansion completes
- [ ] Pressing ESC while expanded collapses video and pauses playback
- [ ] Clicking outside video while expanded collapses video and pauses playback
- [ ] Clicking video while expanded toggles play/pause (YouTube default behavior)
- [ ] Collapse animation returns video to exact grid position
- [ ] No console errors during expansion/collapse
- [ ] Works across all size options (S, M, L)
- [ ] Existing tests pass: `pnpm test`

---

### Phase 3: Polish & Refinement

**Goal:** Final polish, accessibility improvements, and edge case handling

**Dependencies:** Phase 1 & 2

**Blast Radius:** `pnpm test` (full test suite)

**Files to Modify:**
- `src/handlers/VideoGallery.ts` - Add loading states, error handling, accessibility attributes
- `styles.css` - Refinements to animations, responsive tweaks

**Deliverables:**
- Loading state during expansion
- Error handling for missing elements
- ARIA attributes for accessibility
- Responsive adjustments for narrow viewports
- Focus management (trap focus in expanded video)
- Prevent body scroll when video expanded
- Cleanup on gallery unmount/re-render

**Technical Details:**

1. **Accessibility Enhancements:**
   ```typescript
   // Add ARIA attributes
   videoItem.setAttribute('role', 'button');
   videoItem.setAttribute('aria-label', `Expand video: ${title}`);
   videoItem.setAttribute('tabindex', '0');

   // Keyboard support for Enter/Space to expand
   videoItem.addEventListener('keydown', (e) => {
     if (e.key === 'Enter' || e.key === ' ') {
       e.preventDefault();
       expandVideo(videoItem, index);
     }
   });

   // Focus trap in expanded state
   function trapFocus(videoItem: HTMLElement) {
     const focusableElements = videoItem.querySelectorAll(
       'a, button, iframe, [tabindex]:not([tabindex="-1"])'
     );
     // Implement focus trap logic
   }
   ```

2. **Prevent Body Scroll:**
   ```typescript
   function expandVideo(...) {
     // ...existing code...

     // Prevent body scroll
     document.body.style.overflow = 'hidden';
   }

   function collapseVideo(...) {
     // ...existing code...

     // Restore body scroll
     document.body.style.overflow = '';
   }
   ```

3. **Loading State:**
   ```css
   .video-item.expanding .video-container::after {
     content: '';
     position: absolute;
     top: 50%;
     left: 50%;
     transform: translate(-50%, -50%);
     width: 48px;
     height: 48px;
     border: 3px solid rgba(255,255,255,0.3);
     border-top-color: white;
     border-radius: 50%;
     animation: spin 1s linear infinite;
   }

   @keyframes spin {
     to { transform: translate(-50%, -50%) rotate(360deg); }
   }
   ```

4. **Responsive Handling:**
   ```css
   @media (max-width: 768px) {
     .video-item.expanded {
       width: 95vw !important;
     }
   }

   @media (max-width: 480px) {
     .video-gallery-grid {
       grid-template-columns: 1fr !important; /* Force single column */
     }
   }
   ```

5. **Cleanup on Re-render:**
   ```typescript
   // Store cleanup functions
   const cleanupHandlers: (() => void)[] = [];

   // Register cleanup
   cleanupHandlers.push(() => {
     document.removeEventListener('keydown', escHandler);
     document.removeEventListener('click', outsideClickHandler);
     document.body.style.overflow = '';
   });

   // Obsidian will call this when the block is destroyed
   // (Check if createHandler provides a cleanup hook)
   ```

6. **Error Handling:**
   ```typescript
   function expandVideo(videoItem: HTMLElement, index: number) {
     try {
       const iframe = videoItem.querySelector('iframe');
       if (!iframe) {
         console.error('[VideoGallery] iframe not found');
         return;
       }

       // ...rest of expansion logic...
     } catch (error) {
       console.error('[VideoGallery] Expansion failed:', error);
       // Cleanup partial state
       collapseVideo(videoItem, originalRect);
     }
   }
   ```

**Acceptance Criteria:**
- [ ] File `src/handlers/VideoGallery.ts` contains accessibility attributes (grep for `aria-label`)
- [ ] Keyboard navigation works (Tab, Enter, Space, ESC)
- [ ] Focus is trapped within expanded video
- [ ] Body scroll is prevented when video expanded
- [ ] Body scroll is restored when video collapsed
- [ ] Loading indicator appears during expansion transition (visually verified)
- [ ] Error handling prevents crashes if iframe missing
- [ ] Responsive behavior tested on narrow viewports (<768px)
- [ ] Cleanup handlers remove event listeners on component unmount
- [ ] No memory leaks (event listeners properly removed)
- [ ] No console warnings or errors
- [ ] Existing tests pass: `pnpm test`

---

## Cross-Cutting Concerns

### Performance Considerations

1. **GPU Acceleration:**
   - Use only `transform` and `opacity` for animations (GPU-accelerated)
   - Avoid animating `width`, `height`, `top`, `left` (triggers layout/paint)
   - Use `will-change: transform` sparingly (only during transitions)

2. **Event Delegation:**
   - Attach listeners to individual items (manageable scale, typically <50 videos)
   - If performance issues arise, consider event delegation on parent container

3. **Debouncing/Throttling:**
   - Resize events should be throttled if viewport resize affects expanded video
   - Scroll events not needed (expansion locks viewport)

### Browser Compatibility

- **Transforms:** Fully supported (no prefixes needed)
- **Backdrop Filter:** Supported in modern browsers (Obsidian uses Chromium)
- **PostMessage API:** Fully supported
- **Grid Layout:** Fully supported (already used in current implementation)

### Obsidian Integration

1. **Theme Compatibility:**
   - Use CSS variables for colors: `var(--interactive-accent)`, `var(--background-primary)`
   - Test with light and dark themes
   - Backdrop blur should work with all themes

2. **Plugin Lifecycle:**
   - Event listeners must be cleaned up when view changes
   - Check if `render` API provides cleanup hooks
   - Consider storing state in plugin instance if needed

3. **Mobile App:**
   - Obsidian mobile uses touch events (hover effects won't apply)
   - Expansion should work identically on mobile
   - Test on iOS/Android if possible

### Security Considerations

1. **YouTube IFrame API:**
   - Only send whitelisted commands (`playVideo`, `pauseVideo`)
   - Validate iframe origin before postMessage
   - Use structured clone for message data

2. **XSS Prevention:**
   - Already handled by current implementation (YouTube URLs validated)
   - No new user input vectors introduced

### Accessibility (WCAG 2.1)

- **Keyboard Navigation:** Full keyboard support (Enter, Space, ESC, Tab)
- **Screen Readers:** ARIA labels describe video expansion state
- **Focus Management:** Focus trapped in expanded state, returned to trigger on collapse
- **Motion:** Consider `prefers-reduced-motion` media query to disable animations

```css
@media (prefers-reduced-motion: reduce) {
  .video-item,
  .video-backdrop {
    transition-duration: 0.01ms !important;
  }
}
```

---

## Parallelization Opportunities

Due to the sequential nature of UI implementation, phases must be executed in order:

| Phase Group | Phases | Can Start After | Reason |
|-------------|--------|-----------------|--------|
| Group A | Phase 1 | Plan approval | Foundation for all interactions |
| Group B | Phase 2 | Phase 1 complete | Depends on hover structure/CSS |
| Group C | Phase 3 | Phase 2 complete | Polish and refinement |

**No parallel execution possible** - each phase builds directly on the previous.

However, within each phase, CSS and JS can be developed in parallel by different developers.

---

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| YouTube IFrame API changes | High | Low | Use standard postMessage API; fallback to manual controls |
| Animation jank on low-end devices | Medium | Medium | Use GPU-accelerated properties only; test on mobile |
| Obsidian API changes breaking render hook | High | Low | Isolated to VideoGallery handler; easy to revert |
| Expanded video breaks with Obsidian updates | Medium | Low | Use standard web APIs; minimal Obsidian-specific code |
| Hover effects conflict with touch devices | Low | High | Accept limitation; expansion still works on tap |
| Backdrop blur not supported | Low | Very Low | Chromium supports backdrop-filter; graceful degradation |

---

## Testing Strategy

### Manual Testing Checklist

**Phase 1 - Hover Effects:**
- [ ] Hover over video in S size grid
- [ ] Hover over video in M size grid (default)
- [ ] Hover over video in L size grid
- [ ] Verify animation duration (~250ms)
- [ ] Verify center-point anchor (video grows evenly)
- [ ] Verify grid doesn't shift
- [ ] Verify shadow/border appears
- [ ] Test in light theme
- [ ] Test in dark theme

**Phase 2 - Expansion:**
- [ ] Click video to expand
- [ ] Verify smooth animation to center
- [ ] Verify backdrop blur appears
- [ ] Verify video auto-plays
- [ ] Click video again (should play/pause)
- [ ] Press ESC (should collapse and pause)
- [ ] Expand again, click outside (should collapse and pause)
- [ ] Verify collapse animation returns to exact position
- [ ] Test with multiple videos (expand different ones)
- [ ] Test in S/M/L size grids

**Phase 3 - Polish:**
- [ ] Tab to video item, press Enter (should expand)
- [ ] While expanded, Tab through focusable elements
- [ ] Verify body scroll locked when expanded
- [ ] Verify body scroll restored when collapsed
- [ ] Test on narrow viewport (<768px)
- [ ] Verify loading indicator during expansion
- [ ] Test error handling (manually break iframe)
- [ ] Check browser console for errors/warnings
- [ ] Test with prefers-reduced-motion enabled

### Automated Testing

**Unit Tests:**
- Not applicable (primarily visual/DOM manipulation)

**Integration Tests:**
- Handler still renders correct HTML structure
- No regressions in video URL collection
- Grid layout calculations correct for S/M/L sizes

**Visual Regression Tests:**
- Consider screenshot testing if available in test infrastructure
- Compare hover state, expanded state visually

---

## Implementation Notes

### Code Organization

All changes localized to:
1. `src/handlers/VideoGallery.ts` - Handler logic, DOM generation, event listeners
2. `src/helpers/youtube.ts` - Add `enablejsapi=1` parameter
3. `styles.css` - All visual styling, animations, transitions

### ArkType Schema

No changes needed to schema - this is purely UI enhancement:
```typescript
const VideoGalleryOptionsSchema = type({
  "+": "reject",
  "size?": "'S' | 'M' | 'L'",
});
// Schema remains unchanged
```

### YouTube IFrame API Documentation

- [IFrame Player API](https://developers.google.com/youtube/iframe_api_reference)
- [Player Parameters](https://developers.google.com/youtube/player_parameters)
- Key parameter: `enablejsapi=1` enables postMessage control
- Commands: `playVideo`, `pauseVideo`, `stopVideo`

### CSS Variables to Use

- `--interactive-accent` - Border color on hover
- `--background-primary` - Backdrop fallback color
- `--text-normal` - Text color for loading indicator
- `--radius-m` - Border radius (optional)

---

## Open Questions

- [ ] **Q1:** Should expansion be full viewport width (100vw) or constrained (80vw)?
  - **Recommendation:** 80vw for better framing and less overwhelming

- [ ] **Q2:** Should we support expansion on mobile/tablet differently (e.g., full screen)?
  - **Recommendation:** Keep consistent behavior across devices

- [ ] **Q3:** Should hover effects be disabled on touch devices to avoid stuck hover states?
  - **Recommendation:** Yes, use `@media (hover: hover)` query

- [ ] **Q4:** Should we add a close button (X) in the top-right of expanded video?
  - **Recommendation:** Nice-to-have for Phase 3; ESC and outside-click sufficient for MVP

- [ ] **Q5:** Should the title link remain clickable when expanded?
  - **Recommendation:** Keep clickable for navigation to source page

---

## Success Metrics

### User Experience Metrics

- **Visual Appeal:** Gallery should feel modern, polished, professional
- **Interaction Smoothness:** All animations 60fps (no jank)
- **Discoverability:** Users naturally understand hover = preview, click = expand
- **Accessibility:** Fully keyboard navigable, screen reader friendly

### Technical Metrics

- **Animation Performance:** All transitions use GPU-accelerated properties
- **Code Quality:** No console errors, proper cleanup, no memory leaks
- **Maintainability:** Changes localized, easy to extend or revert
- **Compatibility:** Works in all Obsidian themes, light/dark modes

---

## Future Enhancements (Out of Scope)

These ideas are noted for future consideration but not part of this plan:

1. **Video Preview on Hover:** Show animated preview/thumbnail
2. **Playlist Mode:** Next/previous navigation between videos
3. **Picture-in-Picture:** Keep video playing while browsing notes
4. **Custom Thumbnails:** Override YouTube thumbnail with custom image
5. **Video Timeline Scrubbing:** Interactive timeline in hover state
6. **Lazy Loading:** Only load iframes when scrolled into view
7. **Infinite Scroll:** Load more videos as user scrolls
8. **Grid Layout Options:** Masonry, carousel, filmstrip layouts

---

## Required Changes Before Implementation

This section consolidates all critical feedback from the parallel expert reviews (Browser/CSS, Obsidian Integration, TypeScript/Accessibility). **These changes are MANDATORY before starting implementation.**

### 1. Cleanup & Lifecycle Management ‚ö†Ô∏è BLOCKER

**Identified by:** All three reviewers
**Severity:** CRITICAL
**Impact:** Memory leaks, ghost event listeners, broken state on KM block re-render

**Problem:**
- The render API (`renderApi.ts`) does not provide cleanup hooks
- KM blocks re-render on file saves (auto-refresh system)
- Event listeners accumulate on each re-render
- Global listeners (ESC, outside-click) persist after block unmounts
- Body overflow may remain locked

**Required Fix:**
Add MutationObserver-based cleanup system before Phase 1:

```typescript
// Cleanup registry interface
interface CleanupRegistry {
  listeners: Array<{
    element: EventTarget;
    event: string;
    handler: EventListenerOrEventListenerObject;
  }>;
  timers: Array<ReturnType<typeof setTimeout>>;
  observers: MutationObserver[];
}

// Store cleanup per gallery (WeakMap)
const galleryCleanup = new WeakMap<HTMLElement, CleanupRegistry>();

function initializeCleanup(galleryEl: HTMLElement): void {
  galleryCleanup.set(galleryEl, {
    listeners: [],
    timers: [],
    observers: [],
  });

  // Watch for DOM removal
  const observer = new MutationObserver((mutations) => {
    mutations.forEach(mutation => {
      mutation.removedNodes.forEach(node => {
        if (node === galleryEl || (node as HTMLElement).contains?.(galleryEl)) {
          cleanupGallery(galleryEl);
          observer.disconnect();
        }
      });
    });
  });

  observer.observe(galleryEl.parentElement!, { childList: true, subtree: true });

  const cleanup = galleryCleanup.get(galleryEl)!;
  cleanup.observers.push(observer);
}

function cleanupGallery(galleryEl: HTMLElement): void {
  const cleanup = galleryCleanup.get(galleryEl);
  if (!cleanup) return;

  // Remove all listeners
  cleanup.listeners.forEach(({ element, event, handler }) => {
    element.removeEventListener(event, handler);
  });

  // Clear all timers
  cleanup.timers.forEach(timer => clearTimeout(timer));

  // Disconnect all observers
  cleanup.observers.forEach(observer => observer.disconnect());

  // Restore body scroll
  document.body.style.overflow = '';

  // Clear registry
  galleryCleanup.delete(galleryEl);
}

function registerListener(
  galleryEl: HTMLElement,
  target: EventTarget,
  event: string,
  handler: EventListenerOrEventListenerObject
): void {
  target.addEventListener(event, handler);

  const cleanup = galleryCleanup.get(galleryEl);
  if (cleanup) {
    cleanup.listeners.push({ element: target, event, handler });
  }
}

function registerTimer(galleryEl: HTMLElement, timer: ReturnType<typeof setTimeout>): void {
  const cleanup = galleryCleanup.get(galleryEl);
  if (cleanup) {
    cleanup.timers.push(timer);
  }
}
```

**Integration Point:** Call `initializeCleanup(galleryEl)` immediately after render, use `registerListener()` and `registerTimer()` for all event listeners and timeouts.

---

### 2. Transform-Origin CSS Bug ‚ö†Ô∏è BLOCKER

**Identified by:** Browser/CSS Expert
**Severity:** CRITICAL
**Impact:** Expansion animation will "jump" or skew instead of smooth center-to-center transition

**Problem:**
Phase 2 CSS (line 908) sets `transform-origin: top left`, but expansion JavaScript calculates center-to-center transforms. This mismatch causes visual glitches.

**Required Fix:**
Change CSS to match transform calculations:

```css
/* WRONG (from original plan): */
.video-item.expanding,
.video-item.collapsing,
.video-item.expanded {
  position: fixed !important;
  z-index: 1000;
  transform-origin: top left; /* ‚ùå WRONG */
  transition: transform 500ms cubic-bezier(0.4, 0.0, 0.2, 1);
}

/* CORRECT: */
.video-item.expanding,
.video-item.collapsing,
.video-item.expanded {
  position: fixed !important;
  z-index: 1000;
  top: 0;
  left: 0;
  transform-origin: center center; /* ‚úÖ CORRECT */
  transition: transform 500ms cubic-bezier(0.4, 0.0, 0.2, 1);
  will-change: transform;
}

.video-item.expanded {
  will-change: auto; /* Release compositor resources after transition */
}
```

**Also update JavaScript calculation:**

```typescript
// Calculate center-to-center transform
const originalCenterX = originalRect.left + (originalRect.width / 2);
const originalCenterY = originalRect.top + (originalRect.height / 2);
const targetCenterX = targetX + (targetWidth / 2);
const targetCenterY = targetY + (targetHeight / 2);

const translateX = targetCenterX - originalCenterX;
const translateY = targetCenterY - originalCenterY;
const scale = targetWidth / originalRect.width; // Uniform scale

videoItem.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
```

---

### 3. Race Condition Protection ‚ö†Ô∏è BLOCKER

**Identified by:** TypeScript/Accessibility Expert
**Severity:** CRITICAL
**Impact:** State corruption on rapid clicks, multiple expanded videos, YouTube commands sent to unready iframes

**Problem:**
- User can click expand multiple times during animation
- User can click different videos before animation completes
- ESC during expansion causes inconsistent state

**Required Fix:**
Add animation lock to state management:

```typescript
interface VideoGalleryState {
  expandedVideoIndex: number | null;
  isAnimating: boolean; // NEW: Lock during transitions
  animationTimer: ReturnType<typeof setTimeout> | null;
  originalRect: DOMRect | null;
  escHandler: ((e: KeyboardEvent) => void) | null;
  outsideClickHandler: ((e: MouseEvent) => void) | null;
}

function expandVideo(galleryEl: HTMLElement, videoItem: HTMLElement, index: number) {
  const state = getState(galleryEl);

  // Ignore clicks during animation
  if (state.isAnimating) {
    return;
  }

  // If another video is expanded, collapse it first
  if (state.expandedVideoIndex !== null && state.expandedVideoIndex !== index) {
    const currentExpanded = galleryEl.querySelector(`[data-video-index="${state.expandedVideoIndex}"]`);
    if (currentExpanded) {
      collapseVideo(galleryEl, currentExpanded as HTMLElement, state.originalRect!);
      // Wait for collapse before expanding new video
      setTimeout(() => expandVideo(galleryEl, videoItem, index), 500);
      return;
    }
  }

  state.isAnimating = true;

  try {
    // ... expansion logic ...

    const timer = setTimeout(() => {
      state.isAnimating = false;
      state.expandedVideoIndex = index;
      // ... rest of finalization
    }, 500);

    registerTimer(galleryEl, timer);
    state.animationTimer = timer;

  } catch (error) {
    // Rollback on error
    state.isAnimating = false;
    videoItem.classList.remove('expanding', 'expanded');
    videoItem.style.transform = '';
    document.body.style.overflow = '';
    throw error;
  }
}
```

---

### 4. WCAG 2.1 Accessibility Compliance ‚ö†Ô∏è BLOCKER

**Identified by:** TypeScript/Accessibility Expert
**Severity:** CRITICAL
**Impact:** Screen reader users cannot use feature, keyboard navigation broken, legal compliance issues

**Required Additions:**

#### 4.1 ARIA Live Region for State Announcements
```typescript
// Add to gallery HTML structure:
<div class="video-gallery" role="region" aria-label="Video Gallery">
  <div
    class="sr-only"
    role="status"
    aria-live="polite"
    aria-atomic="true"
  ></div>
  <div class="video-gallery-grid">
    <!-- videos -->
  </div>
  <div class="video-backdrop" role="dialog" aria-modal="true" aria-label="Expanded video viewer"></div>
</div>

// Helper function:
function announceToScreenReader(galleryEl: HTMLElement, message: string) {
  const status = galleryEl.querySelector('[role="status"]');
  if (status) {
    status.textContent = message;
    setTimeout(() => { status.textContent = ''; }, 1000);
  }
}

// Usage:
expandVideo() {
  announceToScreenReader(galleryEl, `Expanding video: ${videoTitle}`);
}
```

#### 4.2 Focus Management
```typescript
let previouslyFocusedElement: HTMLElement | null = null;

function expandVideo(...) {
  // Store current focus
  previouslyFocusedElement = document.activeElement as HTMLElement;

  // ... expansion logic ...

  // After expansion, focus iframe
  videoItem.querySelector('iframe')?.focus();
}

function collapseVideo(...) {
  // ... collapse logic ...

  setTimeout(() => {
    // Return focus to trigger element
    if (previouslyFocusedElement?.focus) {
      previouslyFocusedElement.focus();
    }
    previouslyFocusedElement = null;
  }, 500);
}
```

#### 4.3 Focus Trap in Expanded State
```typescript
function trapFocus(container: HTMLElement): () => void {
  const focusableElements = container.querySelectorAll<HTMLElement>(
    'a[href], button:not([disabled]), iframe, [tabindex]:not([tabindex="-1"])'
  );

  if (focusableElements.length === 0) return () => {};

  const firstFocusable = focusableElements[0];
  const lastFocusable = focusableElements[focusableElements.length - 1];

  function handleTabKey(e: KeyboardEvent) {
    if (e.key !== 'Tab') return;

    if (e.shiftKey) {
      if (document.activeElement === firstFocusable) {
        lastFocusable.focus();
        e.preventDefault();
      }
    } else {
      if (document.activeElement === lastFocusable) {
        firstFocusable.focus();
        e.preventDefault();
      }
    }
  }

  container.addEventListener('keydown', handleTabKey);
  firstFocusable.focus();

  return () => container.removeEventListener('keydown', handleTabKey);
}

// In expandVideo:
const cleanupFocusTrap = trapFocus(videoItem);
// Store cleanup function in state for later removal
```

#### 4.4 ARIA Attributes on Video Items
```typescript
videoItem.setAttribute('role', 'button');
videoItem.setAttribute('aria-label', `Expand video: ${title}`);
videoItem.setAttribute('tabindex', '0');
videoItem.setAttribute('aria-expanded', 'false');

// When expanded:
videoItem.setAttribute('aria-expanded', 'true');

// Keyboard support:
registerListener(galleryEl, videoItem, 'keydown', (e: KeyboardEvent) => {
  if (e.key === 'Enter' || e.key === ' ') {
    e.preventDefault();
    expandVideo(galleryEl, videoItem, index);
  }
});
```

#### 4.5 Screen-Reader-Only CSS Class
```css
/* Add to styles.css */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}
```

---

### 5. YouTube IFrame API Security ‚ö†Ô∏è HIGH PRIORITY

**Identified by:** Obsidian + TypeScript Experts
**Severity:** HIGH
**Impact:** Security vulnerability (postMessage to wildcard origin), potential XSS vector

**Problem:**
Plan uses `iframe.contentWindow?.postMessage(message, '*')` which sends to any origin.

**Required Fix:**

```typescript
type SafeYouTubeCommand = 'playVideo' | 'pauseVideo' | 'stopVideo';

function sendYouTubeCommand(iframe: HTMLIFrameElement | null, command: SafeYouTubeCommand) {
  if (!iframe || !iframe.contentWindow) {
    console.warn('[VideoGallery] Cannot send command: iframe not ready');
    return;
  }

  // Validate iframe src is YouTube
  if (!iframe.src.startsWith('https://www.youtube.com/')) {
    console.error('[VideoGallery] Attempted to send command to non-YouTube iframe');
    return;
  }

  const YOUTUBE_ORIGIN = 'https://www.youtube.com';

  const message = JSON.stringify({
    event: 'command',
    func: command,
    args: []
  });

  iframe.contentWindow.postMessage(message, YOUTUBE_ORIGIN); // Specific origin only
}
```

**Also update `youtubeEmbed()` helper:**

```typescript
// In src/helpers/youtube.ts:
export function youtubeEmbedWithApi(url: YouTubeVideoUrl): YouTubeEmbedUrl {
  const baseUrl = youtubeEmbed(url); // Existing function
  const separator = baseUrl.includes('?') ? '&' : '?';

  return `${baseUrl}${separator}enablejsapi=1&origin=${encodeURIComponent(window.location.origin)}` as YouTubeEmbedUrl;
}
```

**YouTube Player Ready Detection:**

```typescript
function waitForPlayerReady(iframe: HTMLIFrameElement): Promise<void> {
  return new Promise((resolve) => {
    const timeout = setTimeout(() => resolve(), 2000); // 2s fallback

    function onMessage(event: MessageEvent) {
      if (event.origin !== 'https://www.youtube.com') return;

      try {
        const data = JSON.parse(event.data);
        if (data.event === 'onReady') {
          clearTimeout(timeout);
          window.removeEventListener('message', onMessage);
          resolve();
        }
      } catch (e) {
        // Ignore parse errors
      }
    }

    window.addEventListener('message', onMessage);
  });
}

// Usage in expandVideo:
const iframe = videoItem.querySelector('iframe') as HTMLIFrameElement;
await waitForPlayerReady(iframe);
sendYouTubeCommand(iframe, 'playVideo');
```

---

### 6. WeakMap-Based State Management ‚ö†Ô∏è HIGH PRIORITY

**Identified by:** TypeScript + Obsidian Experts
**Severity:** HIGH
**Impact:** State corruption when multiple VideoGallery blocks exist on same page

**Problem:**
Original plan uses global state object. Multiple galleries on same page will share state and corrupt each other.

**Required Fix:**

```typescript
// Use WeakMap for per-gallery-instance state
const galleryStates = new WeakMap<HTMLElement, VideoGalleryState>();

function initializeState(galleryEl: HTMLElement): void {
  galleryStates.set(galleryEl, {
    expandedVideoIndex: null,
    isAnimating: false,
    animationTimer: null,
    originalRect: null,
    escHandler: null,
    outsideClickHandler: null,
  });
}

function getState(galleryEl: HTMLElement): VideoGalleryState {
  if (!galleryStates.has(galleryEl)) {
    initializeState(galleryEl);
  }
  return galleryStates.get(galleryEl)!;
}

// Usage:
const state = getState(galleryEl); // Never use global state
```

---

## Implementation Checklist

Before starting Phase 1, ensure these are implemented:

- [ ] **Cleanup System** - MutationObserver + cleanup registry (Section 1)
- [ ] **Transform-Origin Fix** - CSS updated to `center center` (Section 2)
- [ ] **Race Condition Guards** - `isAnimating` flag added (Section 3)
- [ ] **ARIA Live Regions** - Screen reader announcements (Section 4.1)
- [ ] **Focus Management** - Store/restore focus (Section 4.2)
- [ ] **Focus Trap** - Keyboard navigation contained (Section 4.3)
- [ ] **ARIA Attributes** - All interactive elements labeled (Section 4.4)
- [ ] **YouTube API Security** - Origin validation, no wildcard (Section 5)
- [ ] **WeakMap State** - Per-gallery state isolation (Section 6)
- [ ] **Helper Functions** - `youtubeEmbedWithApi()`, `waitForPlayerReady()` (Section 5)
- [ ] **Screen Reader CSS** - `.sr-only` class added (Section 4.5)

**All checkboxes must be checked before implementation begins.**

---

## Updated Phase Descriptions

### Phase 0: Foundation (NEW - MUST COMPLETE FIRST)

**Duration:** 1-2 hours
**Goal:** Implement all required infrastructure from reviews

**Deliverables:**
- Cleanup system (MutationObserver, cleanup registry)
- WeakMap-based state management
- Helper functions (`announceToScreenReader`, `waitForPlayerReady`, etc.)
- Updated `youtubeEmbedWithApi()` in `src/helpers/youtube.ts`
- `.sr-only` CSS class
- TypeScript interfaces updated

**Files to Modify:**
- `src/handlers/VideoGallery.ts` - Add infrastructure code
- `src/helpers/youtube.ts` - Add `youtubeEmbedWithApi()`
- `styles.css` - Add `.sr-only` class

**Acceptance Criteria:**
- [ ] All helper functions compile without errors
- [ ] WeakMap state getters/setters work correctly
- [ ] Cleanup registry can register and remove listeners
- [ ] MutationObserver detects gallery removal
- [ ] `youtubeEmbedWithApi()` adds correct query params
- [ ] `.sr-only` class visually hides content

**After Phase 0 completion, proceed with Phase 1 as originally planned (with modifications from reviews).**

---

## Appendix: CSS Complete Reference

### Complete CSS for All Phases

```css
/* ============================================
   VideoGallery - Phase 1: Hover Effects
   ============================================ */

.video-gallery {
  position: relative;
  width: 100%;
}

.video-gallery-grid {
  display: grid;
  gap: 8px;
  position: relative;
}

.video-item {
  position: relative;
  cursor: pointer;
  transform-origin: center center;
  transition:
    transform 250ms cubic-bezier(0.4, 0.0, 0.2, 1),
    box-shadow 250ms cubic-bezier(0.4, 0.0, 0.2, 1),
    z-index 0s;
}

/* Only apply hover effects on devices that support hover */
@media (hover: hover) {
  .video-item:hover,
  .video-item.hovering {
    transform: scale(1.05);
    z-index: 10;
    box-shadow:
      0 8px 24px rgba(0, 0, 0, 0.3),
      0 0 0 2px var(--interactive-accent);
  }
}

.video-stack {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.video-container {
  position: relative;
  aspect-ratio: 16 / 9;
  width: 100%;
  overflow: hidden;
  border-radius: 4px;
}

.video-container iframe {
  width: 100%;
  height: 100%;
  border: none;
}

/* ============================================
   VideoGallery - Phase 2: Expansion
   ============================================ */

.video-item.expanding,
.video-item.collapsing,
.video-item.expanded {
  position: fixed !important;
  z-index: 1000;
  transition: transform 500ms cubic-bezier(0.4, 0.0, 0.2, 1);
  transform-origin: top left;
}

.video-item.expanded {
  cursor: default;
}

/* Backdrop blur effect */
.video-backdrop {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  z-index: 999;
  opacity: 0;
  transition: opacity 500ms ease;
  pointer-events: none;
  display: none;
}

.video-backdrop.visible {
  opacity: 1;
  pointer-events: auto;
}

/* Loading indicator */
.video-item.expanding .video-container::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 48px;
  height: 48px;
  border: 3px solid rgba(255, 255, 255, 0.3);
  border-top-color: white;
  border-radius: 50%;
  animation: km-video-spin 1s linear infinite;
  z-index: 10;
}

@keyframes km-video-spin {
  to { transform: translate(-50%, -50%) rotate(360deg); }
}

/* ============================================
   VideoGallery - Phase 3: Polish
   ============================================ */

/* Keyboard focus indicators */
.video-item:focus-visible {
  outline: 2px solid var(--interactive-accent);
  outline-offset: 4px;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .video-item.expanding,
  .video-item.expanded {
    /* Use 95vw instead of 80vw on tablets */
  }
}

@media (max-width: 480px) {
  .video-gallery-grid {
    grid-template-columns: 1fr !important;
  }
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
  .video-item,
  .video-backdrop,
  .video-item.expanding,
  .video-item.collapsing {
    transition-duration: 0.01ms !important;
  }

  .video-item.expanding .video-container::after {
    animation: none !important;
  }
}
```

---

## Appendix: TypeScript Type Definitions

```typescript
/**
 * State management for VideoGallery expansion
 */
interface VideoGalleryState {
  /** Currently expanded video index, or null if none expanded */
  expandedVideoIndex: number | null;

  /** Original bounding rect of expanded video (for collapse animation) */
  originalRect: DOMRect | null;

  /** ESC key handler reference (for cleanup) */
  escHandler: ((e: KeyboardEvent) => void) | null;

  /** Outside click handler reference (for cleanup) */
  outsideClickHandler: ((e: MouseEvent) => void) | null;

  /** Cleanup functions to call on unmount */
  cleanupHandlers: Array<() => void>;
}

/**
 * YouTube IFrame API command types
 */
type YouTubeCommand =
  | 'playVideo'
  | 'pauseVideo'
  | 'stopVideo'
  | 'mute'
  | 'unMute';

/**
 * Enhanced video metadata
 */
interface VideoGalleryVideo {
  url: YouTubeVideoUrl;
  filepath: PagePath;
  title: string;
  index: number; // Added for tracking
}
```

---

## Sign-Off

**Plan Created By:** Claude (AI Assistant)
**Review Status:** Awaiting User Approval
**Next Steps:** User reviews plan, provides feedback, approves for implementation

Once approved, implementation can begin with Phase 1.
