# Known Issues Fixes Implementation Plan

**Created:** 2025-12-14
**Status:** Reviewed - Ready for Implementation

## Executive Summary

This plan addresses six known issues in the Obsidian Kind Model plugin: stale renders on tab restore, broken Google video previews, silent errors, future page automation, classification column formatting, and multi-classification vertical spacing.

## Review Summary

**Reviews Completed:** 2025-12-14

**Reviewers:**

- Backend TypeScript Developer: Approve with Changes
- Frontend Developer: Approve with Changes
- Feature Tester: Approve with Changes

**Key Changes from Review:**

1. Phase 1: Revised re-render approach - `previewMode.rerender(true)` API doesn't exist; use `workspace.trigger('layout-change')` instead
2. Phase 3: Focus on enhancing existing error handling rather than re-implementing
3. Phase 4: Multi-layered timing strategy using `metadataCache.on('resolved')` in addition to debounce
4. Phase 5: Combine km block insertion with initial content write (single atomic operation)
5. Phase 6: Fix existing CSS typo (`whitespace` → `white-space`) and add fallback for `:has()` selector
6. All phases: Comprehensive test specifications added

**Resolved Concerns:**

- Re-render API → Use workspace events instead of direct previewMode call
- CSS browser support → Add fallback selectors for older engines
- Timing issues → Multi-layered approach with metadata cache ready + debounce + retry
- Error handling duplication → Enhance existing rather than re-implement

---

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | `km` blocks must render when tabs are restored on Obsidian startup | High | Backend TS Developer |
| FR-2 | YouTube video URLs must render properly in VideoGallery | Medium | Backend TS Developer |
| FR-3 | Errors must be visible to users (not silent failures) | High | Backend TS Developer |
| FR-4 | Future page creation must auto-run `update` command | Medium | Backend TS Developer |
| FR-5 | Future pages must auto-insert appropriate `km` query blocks | Medium | Backend TS Developer |
| FR-6 | Classification columns must use non-breaking spaces | Medium | Frontend Developer |
| FR-7 | Multi-classification entries must be single-spaced | Low | Frontend Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Re-render mechanism must not impact normal editing performance | <50ms overhead | Backend TS Developer |
| NFR-2 | Error display must be user-friendly and non-blocking | Clear UI callouts | Frontend Developer |
| NFR-3 | Automation must handle timing issues gracefully | Retry/debounce patterns | Backend TS Developer |

## Architecture Overview

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                         Plugin Lifecycle                            │
│                                                                     │
│  ┌──────────────┐    ┌─────────────────────┐    ┌────────────────┐ │
│  │   onload()   │───>│ deferUntilDataview  │───>│ Event Handlers │ │
│  │              │    │      Ready()        │    │                │ │
│  └──────────────┘    └─────────────────────┘    └────────────────┘ │
│         │                                              │           │
│         v                                              v           │
│  ┌──────────────┐                           ┌────────────────────┐ │
│  │  Codeblock   │                           │ on_tab_change      │ │
│  │   Parser     │<─── triggers re-render ───│ on_layout_change   │ │
│  └──────────────┘                           └────────────────────┘ │
└─────────────────────────────────────────────────────────────────────┘
```

### Data Flow

1. **Stale Renders:** Tab restore → layout-ready → workspace event trigger → re-render of km blocks
2. **Video Previews:** URL extraction → pattern matching → embed URL transformation
3. **Future Pages:** File creation → name pattern detection → metadata ready → auto-update → km block insertion
4. **Classification:** Data collection → HTML rendering with `&nbsp;` and CSS fixes

---

## Phases

### Phase 1: Fix Stale Renders on Tab Restore

**Principal Owner:** Backend TypeScript Developer

**Goal:** Ensure `km` codeblocks render properly when Obsidian restores tabs on startup

**Dependencies:** None

**Deliverables:**

- Modified `on_layout_change.ts` to detect initial layout ready state
- Workspace event trigger to force markdown re-processing
- Integration with deferred initialization completion

**Technical Details:**

**Files to modify:**

- `src/events/on_layout_change.ts` - Add re-render trigger logic
- `src/main.ts` - Track initialization state for re-render decision

**Key Implementation (REVISED):**

> **Review Note:** The original plan suggested `view.previewMode.rerender(true)` which doesn't exist in Obsidian's API. Use workspace events instead.

1. Add a flag `initialRenderComplete` to plugin instance
2. In `deferUntilDataviewReady` callback, after initialization:

   ```typescript
   this.deferUntilDataviewReady(async () => {
     // Initialization tasks
     await initializeKindLookups(this);

     // Flag that we're ready
     this.initialRenderComplete = true;

     // Trigger workspace to re-process markdown codeblocks
     this.app.workspace.trigger('layout-change');
   });
   ```

3. Alternative approach: Re-register the codeblock processor after initialization:

   ```typescript
   // Unregister and re-register to force re-processing
   this.registerMarkdownCodeBlockProcessor('km', callback);
   ```

**Acceptance Criteria:**

- [ ] Opening Obsidian with existing tabs shows km blocks rendered
- [ ] No duplicate renders on normal navigation
- [ ] No performance degradation during normal editing

**Test Specifications:**

```typescript
// test/events/on_layout_change.test.ts
describe("on_layout_change re-render behavior", () => {
  it("should not re-render before initialRenderComplete flag is set")
  it("should trigger layout-change event when initialization completes")
  it("should handle empty workspace gracefully")
  it("should debounce multiple layout change events")
})
```

---

### Phase 2: Fix YouTube Video Preview URLs

**Principal Owner:** Backend TypeScript Developer

**Goal:** Investigate and fix broken YouTube video previews in VideoGallery handler

**Dependencies:** None (can run in parallel with Phase 1)

**Deliverables:**

- Diagnosis of why YouTube video previews are broken
- Fix for `youtubeEmbed()` usage or URL pattern matching
- Verification that embed URLs and preview images work correctly

**Technical Details:**

**Files to investigate/modify:**

- `src/handlers/VideoGallery.ts` - Main handler using `youtubeEmbed()` from inferred-types
- `src/helpers/pageContent.ts` - URL detection via `isYouTubeVideoUrl()` (lines 137-162)
- `inferred-types` package - External dependency providing `youtubeEmbed()` and `isYouTubeVideoUrl()`

**Key Implementation:**

1. **Diagnose the issue:**
   - Check if `isYouTubeVideoUrl()` from inferred-types matches current YouTube URL formats
   - Check if `youtubeEmbed()` produces valid embed URLs
   - Test with actual YouTube video URLs to see where the breakdown occurs

2. **Common YouTube URL formats to support:**

   ```
   https://www.youtube.com/watch?v={videoId}
   https://youtu.be/{videoId}
   https://www.youtube.com/embed/{videoId}
   https://youtube.com/shorts/{videoId}
   ```

3. **Expected embed URL format:**

   ```
   https://www.youtube.com/embed/{videoId}
   ```

4. **If inferred-types is outdated:**
   - Option A: Update inferred-types package if fix is available
   - Option B: Create local wrapper functions that handle current YouTube formats
   - Option C: Submit PR to inferred-types with fix

5. **Preview image URL (thumbnail):**

   ```
   https://img.youtube.com/vi/{videoId}/maxresdefault.jpg
   https://img.youtube.com/vi/{videoId}/hqdefault.jpg
   ```

**Acceptance Criteria:**

- [ ] YouTube video URLs are detected correctly
- [ ] VideoGallery renders YouTube videos in working iframe
- [ ] Preview thumbnails display correctly
- [ ] Unit tests for URL detection and transformation

**Test Specifications:**

```typescript
// test/helpers/youtubeUrl.test.ts
describe("YouTube URL handling", () => {
  it("should detect youtube.com/watch?v= URLs")
  it("should detect youtu.be/ short URLs")
  it("should detect youtube.com/embed/ URLs")
  it("should detect youtube.com/shorts/ URLs")
  it("should extract video ID correctly from all formats")
  it("should generate correct embed URL")
  it("should generate correct thumbnail URL")
  it("should reject malformed URLs")
})
```

---

### Phase 3: Enhance User-Visible Error Handling

**Principal Owner:** Backend TypeScript Developer

**Goal:** Enhance existing error handling to ensure no silent failures

**Dependencies:** None (can run in parallel with Phases 1-2)

**Deliverables:**

- Enhanced error context in existing error handling
- Optional debug mode for detailed error information
- Use of Obsidian's Notice API for critical errors

**Technical Details:**

> **Review Note:** Error handling already exists in `codeblockParser.ts` (lines 53-85) and `createHandler.ts` (lines 115-117). Focus on ENHANCING, not re-implementing.

**Files to modify:**

- `src/events/codeblockParser.ts` - Enhance error display with more context
- `src/utils/logging.ts` - Add optional Notice API integration

**Key Implementation:**

1. Enhance error messages in codeblockParser:

   ```typescript
   render.callout(
     "error",
     `Error in ${handlerName} handler`,
     {
       content: [
         `<b>Query:</b> ${format.inline_codeblock(source)}`,
         `<b>Error:</b> ${err?.message || String(err)}`,
         settings.debugMode && `<details><summary>Stack</summary><pre>${err?.stack}</pre></details>`,
       ].filter(Boolean),
       icon: ERROR_ICON,
     },
   );
   ```

2. Add Notice for critical initialization errors:

   ```typescript
   // In main.ts or logging.ts
   new Notice(`Kind Model: ${errorMessage}`, 5000);
   ```

3. Use KindError's `asBrowserMessages()` more consistently (already used on line 61)

**Acceptance Criteria:**

- [ ] All handler errors show handler name and query context
- [ ] Error messages are user-friendly
- [ ] Debug mode shows stack traces
- [ ] No silent failures - every error is visible

**Test Specifications:**

```typescript
// test/events/codeblockParser.test.ts
describe("Error display in codeblock parser", () => {
  it("should render error callout with handler name")
  it("should include query source in error display")
  it("should show stack trace when debug mode enabled")
  it("should show user-friendly message when debug mode disabled")
  it("should handle errors with missing message property")
})
```

---

### Phase 4: Automate Future Page Update Command

**Principal Owner:** Backend TypeScript Developer

**Goal:** Auto-run `update` command when a future page is created from a link

**Dependencies:** Phase 3 (error handling for timing issues)

**Deliverables:**

- Detection mechanism for "future page materialization"
- Multi-layered timing strategy (debounce + metadata cache + retry)
- Handling for Obsidian timing issues

**Technical Details:**

**Files to modify:**

- `src/events/on_file_created.ts` - Detect future page creation
- `src/commands/update_kinded_page.ts` - Export for programmatic use
- `src/utils/` - New `debounce.ts` utility if not exists

**Key Implementation (REVISED):**

> **Review Note:** Simple debounce is insufficient. Use multi-layered approach: metadata cache ready + debounce + retry pattern.

1. Detect if newly created file matches a "future page" pattern:
   - File path matches pattern generated by `createFuturePageLink()`
   - Check if file is empty/minimal (just created)

2. Multi-layered timing strategy:

   ```typescript
   // In on_file_created.ts
   this.deferUntilDataviewReady(async () => {
     // Wait for metadata cache to resolve
     await new Promise(resolve => {
       this.app.metadataCache.on('resolved', resolve);
     });

     // Additional debounce for safety
     await wait(300);

     // Attempt update with retry
     await retryWithBackoff(
       () => update_kinded_page(plugin, file),
       { maxAttempts: 3, initialDelay: 200 }
     );
   });
   ```

3. Retry pattern implementation:

   ```typescript
   async function retryWithBackoff<T>(
     fn: () => Promise<T>,
     options: { maxAttempts: number; initialDelay: number }
   ): Promise<T> {
     for (let attempt = 1; attempt <= options.maxAttempts; attempt++) {
       try {
         return await fn();
       } catch (error) {
         if (attempt === options.maxAttempts) throw error;
         await wait(options.initialDelay * attempt);
       }
     }
   }
   ```

**Acceptance Criteria:**

- [ ] Clicking a future page link creates page with correct frontmatter
- [ ] No race conditions or timing failures
- [ ] Manual `update` command still works
- [ ] Works for both category and subcategory pages

**Test Specifications:**

```typescript
// test/events/on_file_created.test.ts
describe("Future page auto-update", () => {
  it("should detect future page pattern from filename/path")
  it("should wait for metadata cache to resolve before updating")
  it("should retry on timing failures with backoff")
  it("should exhaust retries and log error gracefully")
  it("should not auto-update files with existing content")
  it("should handle missing MarkdownView gracefully")
})

// test/utils/retryWithBackoff.test.ts
describe("retryWithBackoff utility", () => {
  it("should return result on first successful attempt")
  it("should retry on failure with increasing delay")
  it("should throw after max attempts")
})
```

---

### Phase 5: Auto-Insert km Query Blocks for Category/Subcategory Pages

**Principal Owner:** Backend TypeScript Developer

**Goal:** Auto-insert appropriate `km` query blocks when category/subcategory pages are created

**Dependencies:** Phase 4 (builds on auto-update functionality)

**Deliverables:**

- Template generation for category pages: `Kind("{{kind}}", "{{category}}")`
- Template generation for subcategory pages: `Kind("{{kind}}", "{{category}}", "{{subcategory}}")`
- Combined content insertion with initial write (single atomic operation)

**Technical Details:**

**Files to modify:**

- `src/events/on_file_created.ts` - Add km block to initial content
- `src/helpers/futurePage.ts` - Add template generation utility

**Key Implementation (REVISED):**

> **Review Note:** Combine km block insertion with initial content write to avoid multiple file modifications and undo stack pollution.

1. Modify the initial content string (line 52 in on_file_created.ts) to include km block:

   ```typescript
   // Current (line 52):
   const content = `${tag}\n# [[${kind.file?.path || name}|${displayName}]]\n\`\`\`km\nPageEntry()\n\`\`\``;

   // New: Include Kind() block based on page type
   const kindBlock = isCategoryPage
     ? `Kind("${kindName}", "${categoryName}")`
     : `Kind("${kindName}", "${categoryName}", "${subcategoryName}")`;

   const content = `${tag}\n# [[${kind.file?.path || name}|${displayName}]]\n\`\`\`km\n${kindBlock}\n\`\`\``;
   ```

2. Template generation helper:

   ```typescript
   // In src/helpers/futurePage.ts
   export function generateKindBlock(
     kind: string,
     category: string,
     subcategory?: string
   ): string {
     if (subcategory) {
       return `Kind("${kind}", "${category}", "${subcategory}")`;
     }
     return `Kind("${kind}", "${category}")`;
   }
   ```

3. Avoid duplicate km blocks by checking existing content before insertion

**Acceptance Criteria:**

- [ ] Category pages get `Kind("kind", "category")` block
- [ ] Subcategory pages get `Kind("kind", "cat", "subcat")` block
- [ ] Block is properly formatted and renders correctly
- [ ] Existing category/subcategory creation still works

**Test Specifications:**

```typescript
// test/helpers/futurePage.test.ts
describe("generateKindBlock()", () => {
  it("should generate category template with 2 parameters")
  it("should generate subcategory template with 3 parameters")
  it("should escape special characters in parameter values")
})

// test/events/on_file_created.test.ts
describe("km block insertion", () => {
  it("should include Kind() block in initial category page content")
  it("should include Kind() block in initial subcategory page content")
  it("should not duplicate km blocks if page already has them")
})
```

---

### Phase 6: Fix Classification Column Formatting

**Principal Owner:** Frontend Developer

**Goal:** Use non-breaking spaces and improve column width calculation for classification display

**Dependencies:** None (can run in parallel with Phases 1-5)

**Deliverables:**

- Fix existing CSS typo (`whitespace` → `white-space`)
- Non-breaking spaces in classification separator
- CSS for minimum column width on classification column
- Updated `showClassifications()` function

**Technical Details:**

**Files to modify:**

- `src/api/showApi.ts` - Fix typo and update separator/element rendering (lines 762, 780-788)
- `styles.css` - Add CSS for classification column

**Key Implementation (REVISED):**

> **Review Note:** Fix existing CSS typo first. Use CSS variables for theming compatibility. Only latest Obsidian supported, so `:has()` selector is fine.

1. **CRITICAL:** Fix existing CSS typo in showApi.ts (lines 780, 781, 788):

   ```typescript
   // Current (WRONG):
   style="whitespace: nowrap"
   // Correct:
   style="white-space: nowrap"
   ```

2. Update the separator (line 762 in showApi.ts):

   ```typescript
   // Current:
   const sep = ` <span style="opacity: 0.8"> &gt; </span>`;
   // New:
   const sep = `&nbsp;<span class="km-sep" style="opacity: 0.8">&gt;</span>&nbsp;`;
   ```

3. Add wrapper class to classification output:

   ```typescript
   const wrapper = `<span class="km-classification">${content}</span>`;
   ```

4. Add CSS in styles.css:

   ```css
   /* Classification display */
   .km-classification {
     white-space: nowrap;
   }

   .km-sep {
     opacity: 0.8;
   }

   /* Table column support */
   .dataview.table-view-table td:has(.km-classification) {
     min-width: max-content;
     white-space: nowrap;
   }
   ```

**Acceptance Criteria:**

- [ ] CSS typo is fixed (`white-space` not `whitespace`)
- [ ] Classification text doesn't wrap mid-phrase
- [ ] Column has reasonable minimum width
- [ ] All spaces are non-breaking within classification
- [ ] Works with Obsidian's dark and light themes

**Test Specifications:**

```typescript
// test/api/showApi.test.ts
describe("showClassifications() formatting", () => {
  it("should use white-space: nowrap (not whitespace)")
  it("should replace spaces with &nbsp; in classification elements")
  it("should use &nbsp; in separator elements")
  it("should apply km-classification wrapper class")
})
```

**Manual Testing Checklist:**

- [ ] Test in narrow table columns
- [ ] Test with dark theme
- [ ] Test with light theme

---

### Phase 7: Fix Multi-Classification Vertical Spacing

**Principal Owner:** Frontend Developer

**Goal:** Reduce vertical whitespace when pages have multiple classifications

**Dependencies:** Phase 6 (builds on classification CSS work)

**Deliverables:**

- CSS to single-space multi-classification entries using CSS variables
- Updated HTML structure for multi-classification rendering

**Technical Details:**

**Files to modify:**

- `src/api/showApi.ts` - Update multi-classification rendering (lines 741-822)
- `styles.css` - Add CSS for vertical spacing control

**Key Implementation (REVISED):**

> **Review Note:** Use Obsidian CSS variables for theming compatibility. Use logical gap values from Obsidian's 4px grid system.

1. Update HTML structure in showClassifications():

   ```typescript
   const classifications = items.map(item =>
     `<div class="km-classification-item">${item}</div>`
   ).join('');
   return `<div class="km-classification-list">${classifications}</div>`;
   ```

2. Add CSS using Obsidian variables with fallbacks:

   ```css
   /* Multi-classification support */
   .km-classification-list {
     display: flex;
     flex-direction: column;
     gap: var(--size-4-1, 4px); /* 4px - aligns with Obsidian's spacing system */
   }

   .km-classification-item {
     margin: 0;
     padding: 0;
     line-height: var(--line-height-normal, 1.5);
     white-space: nowrap;
   }

   /* Allow user customization */
   .km-classification-list {
     gap: var(--km-classification-gap, var(--size-4-1, 4px));
   }
   ```

3. Test with various classification counts (1, 2, 3+ classifications)

**Acceptance Criteria:**

- [ ] Multiple classifications are single-spaced
- [ ] No excessive vertical whitespace
- [ ] Readable and visually clean
- [ ] Works in both table and other contexts
- [ ] User can customize gap via CSS snippet

**Test Specifications:**

```typescript
// test/api/showApi.test.ts
describe("showClassifications() multi-item spacing", () => {
  it("should render single classification without list wrapper")
  it("should render multiple classifications with km-classification-list wrapper")
  it("should apply km-classification-item class to each item")
})
```

**Manual Testing Checklist:**

- [ ] Test with 1, 2, 3, 5+ classifications
- [ ] Test with various Obsidian themes (Default, Minimal, etc.)
- [ ] Test user CSS snippet override

---

## Cross-Cutting Concerns

### Testing Strategy (EXPANDED)

**Test Organization:**

```
test/
├── events/
│   ├── on_layout_change.test.ts    (Phase 1)
│   ├── on_file_created.test.ts     (Phases 4-5)
│   └── codeblockParser.test.ts     (Phase 3)
├── helpers/
│   ├── pageContent.test.ts         (Phase 2)
│   └── futurePage.test.ts          (Phase 5)
├── api/
│   └── showApi.test.ts             (Phases 6-7)
├── utils/
│   └── retryWithBackoff.test.ts    (Phase 4)
├── mocks/
│   ├── obsidian.ts                 (Obsidian API mocks)
│   └── dataview.ts                 (Dataview API mocks)
└── data/
    └── plugin.ts                   (Existing mock plugin)
```

**Mocking Strategy:**

```typescript
// test/mocks/obsidian.ts
export const mockWorkspace = {
  getLeavesOfType: vi.fn((type: string) => []),
  trigger: vi.fn(),
  on: vi.fn(),
  onLayoutReady: vi.fn(callback => callback()),
};

export const mockVault = {
  modify: vi.fn(async (file, content) => {}),
  rename: vi.fn(async (file, newPath) => {}),
  on: vi.fn(),
};

export const mockMetadataCache = {
  on: vi.fn((event, callback) => {
    if (event === 'resolved') callback();
  }),
};

export const mockApp = {
  workspace: mockWorkspace,
  vault: mockVault,
  metadataCache: mockMetadataCache,
};
```

**Unit tests:**

- URL detection/transformation functions (Phase 2)
- Template generation for km blocks (Phase 5)
- Non-breaking space insertion (Phase 6)
- Retry with backoff utility (Phase 4)

**Integration tests:**

- Handler error propagation (Phase 3)
- File creation → update → km insertion flow (Phases 4-5)

**Manual testing required:**

- Stale render fix requires Obsidian restart testing
- Visual verification of classification formatting

**Manual Testing Checklist:**

- [ ] Restart Obsidian with open tabs containing km blocks
- [ ] Verify km blocks render without clicking into them
- [ ] Test with various vault sizes (small, medium, large)
- [ ] Test YouTube videos in VideoGallery render correctly
- [ ] Create future category/subcategory pages via links
- [ ] Verify auto-update runs and km blocks inserted
- [ ] Check classification rendering in narrow/wide tables
- [ ] Verify dark/light theme rendering
- [ ] Test error displays are visible and helpful

### Security Considerations

- URL validation before embedding (Phase 2)
- Sanitize any user-provided content in error messages (Phase 3)
- Validate YouTube video IDs to prevent injection

### Performance Considerations

- Debounce re-render calls to prevent flooding (Phase 1)
- Cache URL pattern matching results (Phase 2)
- Avoid re-rendering unchanged content (Phase 1)
- Single atomic file write instead of multiple modifications (Phase 5)
- Add performance logging for NFR-1 verification

## Parallelization Opportunities

### Revised Implementation Parallelization Strategy

> **Review Note:** Phase 1 should complete before Phase 4 to avoid competing workspace events.

| Parallel Group | Phases | Reason |
|----------------|--------|--------|
| Group A1 | Phase 2, Phase 3, Phase 6 | No dependencies, truly parallel |
| Group A2 | Phase 1 | Needs testing before automation phases |
| Group B | Phase 4 | Depends on Phase 3 for error handling, Phase 1 for workspace stability |
| Group C | Phase 5, Phase 7 | Phase 5 depends on Phase 4; Phase 7 depends on Phase 6 |

```text
Timeline:
───────────────────────────────────────────────────────────────────────►

Group A1: ██████████████████████ (Phases 2, 3, 6 - true parallel)
                              │
Group A2:         ████████████ (Phase 1 - needs testing)
                              │
Group B:                      └──████████ (Phase 4)
                                        │
Group C:                                └──████████ (Phases 5, 7)
```

### Synchronization Points

1. **After Group A1:** Error handling patterns established, CSS foundation ready
2. **After Group A2:** Workspace event behavior verified, no re-render issues
3. **After Group B:** File creation automation tested and stable
4. **Final:** Integration testing across all fixes

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| Obsidian API changes for re-render | High | Use workspace.trigger() which is stable |
| YouTube URL format changes | Medium | Abstract URL patterns for easy updates; use inferred-types package |
| inferred-types package outdated | Medium | Create local wrapper if needed; submit PR to package |
| Timing issues in auto-update | High | Multi-layered approach: metadata cache + debounce + retry |
| CSS specificity conflicts | Low | Use specific class names with km- prefix |
| Undo stack pollution | Low | Single atomic file writes |

## Open Questions

- [x] ~~Should re-render be debounced on repeated tab switches?~~ → Only on initial load after initialization
- [x] ~~Should errors show as notices (popups) or only inline callouts?~~ → Both: Notice for critical, inline for handler errors
- [x] ~~Is there a preferred minimum width for the classification column?~~ → Use `max-content` with CSS variables for user customization
- [x] ~~What minimum Obsidian version do we support?~~ → Latest only, `:has()` selector is supported
- [ ] What specific YouTube URL format changes broke the video previews? (Need to diagnose with actual URLs)
