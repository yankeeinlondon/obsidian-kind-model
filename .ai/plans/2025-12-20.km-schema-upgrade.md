# KM Schema Upgrade - Implementation Plan

**Created:** 2025-12-20
**Status:** Reviewed - Ready for Implementation
**Feature Reference:** `.ai/features/2025-12. km-schema-upgrade.md`

## Review Summary

**Reviews Completed:** 2025-12-20

**Reviewers:**

- Schema Architect: Approve with Changes
- Frontend Developer: Approve with Changes
- Backend TypeScript Developer: Approve with Changes
- Feature Tester (TypeScript): Approve with Changes

**Key Changes from Review:**

1. Added Phase 0 (Spike) to validate ArkType integration before full commitment
2. Added comprehensive TypeToken→ArkType translation reference
3. Added "Tests to Write" sections to each phase
4. Specified CodeMirror extension registration via Obsidian's API
5. Added shared parsing utilities (`km-parser.ts`) for Phase 3/4 reuse
6. Clarified handler registry lifecycle and access patterns
7. Resolved open questions (autocomplete triggers automatically)

**Resolved Concerns:**

- ArkType vs alternatives → Spike will validate, but ArkType chosen for unified type inference
- Migration rollback plan → Spike validates approach; handlers migrated in batches
- CodeMirror registration → Use `this.registerEditorExtension()` in plugin `onload()`
- Autocomplete trigger → Automatic triggering (modern IDE behavior)

---

## Executive Summary

Upgrade the `km` codeblock system to provide world-class developer and user experience through:

1. Replacing the custom TypeToken validation with ArkType for unified runtime/type validation
2. Implementing a CodeMirror 6 extension for inline autocomplete and error reporting
3. Creating comprehensive documentation for both plugin users and handler developers

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Define handler schemas once, use for both TypeScript types AND runtime validation | High | Schema Architect |
| FR-2 | Provide autocomplete for handler names in `km` codeblocks | High | Frontend Developer |
| FR-3 | Provide autocomplete for handler parameters/options | High | Frontend Developer |
| FR-4 | Show inline validation errors while editing `km` blocks | High | Frontend Developer |
| FR-5 | Display clear, actionable errors in the rendered block area when user exits with errors | High | Backend TypeScript Developer |
| FR-6 | Support all existing TypeToken types: `string`, `number`, `bool`, `array(T)`, `opt(T)`, `enum(a,b,c)`, unions | High | Schema Architect |
| FR-7 | Migrate all existing handlers to new schema system | Medium | Backend TypeScript Developer |
| FR-8 | Create comprehensive documentation for users and developers | Medium | Backend TypeScript Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | No noticeable lag when typing in `km` blocks | <50ms response | Frontend Developer |
| NFR-2 | Handler schema definition should be maintainable (single source of truth) | Co-located types | Schema Architect |
| NFR-3 | Type inference from ArkType schemas should work without explicit type annotations | Full inference | Schema Architect |
| NFR-4 | Error messages should clearly explain what's wrong and how to fix it | Actionable messages | Backend TypeScript Developer |
| NFR-5 | Autocomplete should work immediately on `km` block creation | Instant activation | Frontend Developer |
| NFR-6 | Build size increase from ArkType should be minimal | <50KB gzipped | Schema Architect |

## Architecture Overview

### Current Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                        Obsidian Editor                          │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  km codeblock                                            │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │ BackLinks({dedupe: false})                      │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ codeblockParser.ts                                              │
│ - Registers `km` language with Obsidian                         │
│ - Routes to handlers via regex matching                         │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ createHandler.ts                                                │
│ - Fluent API: .scalar().options().handler()                     │
│ - TypeToken strings define schema (e.g., "opt(bool)")           │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ parseParams.ts                                                  │
│ - JS→JSON conversion (regex-based)                              │
│ - Option key validation                                         │
│ - Type validation (validateOptionType)                          │
│ - LIMITATIONS: shallow array validation, nested paren edge cases│
└─────────────────────────────────────────────────────────────────┘
```

### Proposed Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                        Obsidian Editor                          │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  km codeblock (with CodeMirror 6 extension)              │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │ BackLinks({dedupe: false})  ◄── autocomplete    │    │   │
│  │  │                             ◄── inline linting  │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ km-codemirror-extension.ts (NEW)                                │
│ - Registered via this.registerEditorExtension() in onload()    │
│ - ViewPlugin with proper destroy() cleanup                      │
│ - Autocomplete source using handler registry                    │
│ - Linter with 300ms debounce                                    │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ km-parser.ts (NEW - SHARED)                                     │
│ - Parsing utilities for context detection                       │
│ - Used by both autocomplete and linter                          │
│ - Handles edge cases: multiline, nested, incomplete syntax      │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ handler-registry.ts (NEW)                                       │
│ - Central registry of all handlers + their ArkType schemas      │
│ - Handlers self-register at module load time                    │
│ - Provides schema metadata for autocomplete                     │
│ - Singleton accessed via plugin instance                        │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ createHandler.ts (MODIFIED)                                     │
│ - Accept ArkType schemas instead of TypeToken strings           │
│ - Schema provides BOTH runtime validation AND TypeScript types  │
│ - Register handler with registry on creation                    │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ ArkType (NEW DEPENDENCY)                                        │
│ - Declarative schema definition                                 │
│ - Runtime validation with detailed errors                       │
│ - TypeScript type inference from schemas                        │
│ - ~14KB gzipped                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Error Display Architecture

```
┌─────────────────────────────────────────┐
│ CodeMirror Editor (while typing)        │
│  ├─ Red squiggle underline (inline)     │
│  ├─ Hover tooltip (error details)       │
│  └─ Quick fix actions (when available)  │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ Rendered Block (after exiting editor)   │
│  ├─ Error callout (detailed message)    │
│  ├─ Expected vs actual type             │
│  ├─ "Did you mean?" suggestions         │
│  └─ Link to handler documentation       │
└─────────────────────────────────────────┘
```

### Data Flow

1. **Schema Definition**: Handler defines schema with ArkType
2. **Registration**: Handler self-registers at module load time with central registry
3. **Editing**: CodeMirror extension queries registry for autocomplete/validation
4. **Rendering**: codeblockParser uses ArkType schema for robust validation
5. **Error Display**: Rich error messages from ArkType shown in block output

---

## Phases

### Phase 0: Validation Spike

**Principal Owner:** Schema Architect

**Goal:** Validate ArkType integration before committing to full migration

**Dependencies:** None

**Blast Radius:** None (spike code discarded)

**Deliverables:**

- Install ArkType
- Migrate ONE handler (BackLinks) as proof of concept
- Prove type inference works with curried `createHandler` pattern
- Measure actual bundle size impact
- Compare error message quality vs current TypeToken
- Document findings and go/no-go recommendation

**Technical Details:**

1. Install ArkType: `pnpm add arktype`
2. Create temporary spike file: `src/handlers/_spike-backlinks.ts`
3. Define BackLinks schema with ArkType
4. Verify type inference works with no explicit annotations
5. Validate all current BackLinks options work correctly
6. Measure bundle size: `pnpm build && ls -la dist/main.mjs`

**Acceptance Criteria:**

- [ ] ArkType installed and builds successfully
- [ ] BackLinks handler works with ArkType schema
- [ ] Type inference works (demonstrated in spike file)
- [ ] Bundle size increase documented
- [ ] Error message quality evaluated
- [ ] Go/no-go decision made

---

### Phase 1: ArkType Integration and Schema Layer

**Principal Owner:** Schema Architect

**Goal:** Establish ArkType as the schema foundation, replacing TypeToken strings

**Dependencies:** Phase 0 (spike validates approach)

**Blast Radius:** `test/parseParams.test.ts`

**Deliverables:**

- New schema helper functions that map to current TypeToken semantics
- Updated `createHandler` fluent API to accept ArkType schemas
- Type inference working without explicit annotations
- Complete TypeToken→ArkType translation reference

**Technical Details:**

Files to create:

- `src/handlers/schema.ts` - ArkType schema utilities and type exports

Files to modify:

- `src/handlers/createHandler.ts` - Accept ArkType schemas
- `src/helpers/parseParams.ts` - Use ArkType for validation (keep jsObjectToJson)
- `package.json` - Add arktype dependency

**TypeToken to ArkType Translation Reference:**

| TypeToken | ArkType | Example |
|-----------|---------|---------|
| `"string"` | `"string"` | `name: "string"` |
| `"number"` | `"number"` | `count: "number"` |
| `"bool"` | `"boolean"` | `enabled: "boolean"` |
| `"opt(bool)"` | `"boolean?"` or key with `?` | `"enabled?": "boolean"` |
| `"array(string)"` | `"string[]"` | `tags: "string[]"` |
| `"opt(string)"` | `"string?"` | `"name?": "string"` |
| `"enum(a,b,c)"` | `"'a' \| 'b' \| 'c'"` | `mode: "'fast' \| 'slow'"` |
| `"string\|array(string)"` | `"string \| string[]"` | `exclude: "string \| string[]"` |
| `"opt(string\|array(string))"` | `"(string \| string[])?"` | `"exclude?": "string \| string[]"` |

**Schema Definition Pattern:**

```typescript
import { type } from "arktype";

// Options schema
const BackLinksOptions = type({
  "ignoreTags?": "string[]",
  "dedupe?": "boolean",
  "exclude?": "string | string[]",
  "excludeCompletedTasks?": "boolean",
});

// Type is automatically inferred:
type BackLinksOptions = typeof BackLinksOptions.infer;

// Scalar schema (for handlers with positional params)
const KindScalar = type({
  kind: "string",
  "category?": "string",
  "subcategory?": "string",
});
type KindScalar = typeof KindScalar.infer;
```

**Tests to Write:**

Happy Path:

- [ ] ArkType schema definitions parse correctly
- [ ] Schema helper functions produce valid ArkType schemas
- [ ] Type inference works without explicit annotations (type test)
- [ ] Basic validation passes for valid inputs

Edge Cases:

- [ ] Optional fields handle undefined/null correctly
- [ ] Union types validate correctly (`string | string[]`)
- [ ] Array types validate element types (deep validation)
- [ ] Enum types reject invalid values

Error Handling:

- [ ] Invalid types produce clear error messages
- [ ] Missing required fields are caught
- [ ] Type mismatches are reported with expected vs actual

Type Tests:

- [ ] Inferred types match TypeScript expectations
- [ ] Optional fields have correct union with undefined
- [ ] Array types infer correct element types

Integration:

- [ ] `createHandler` accepts ArkType schemas
- [ ] `parseParams` uses ArkType for validation
- [ ] Existing parseParams tests still pass

**Acceptance Criteria:**

- [ ] ArkType installed and builds successfully
- [ ] Schema helper functions cover all current TypeToken patterns
- [ ] Complete TypeToken→ArkType translation reference documented
- [ ] `createHandler` accepts ArkType schemas
- [ ] Type inference works (no explicit type annotations needed)
- [ ] ArkType error messages are human-readable
- [ ] Existing parseParams tests pass with new implementation
- [ ] Build size increase <50KB gzipped (measured in production build)

---

### Phase 2: Handler Migration

**Principal Owner:** Backend TypeScript Developer

**Goal:** Migrate all existing handlers from TypeToken to ArkType schemas

**Dependencies:** Phase 1

**Blast Radius:** `test/**/*.test.ts`

**Deliverables:**

- All 11 handlers migrated to ArkType schemas (in 3 batches)
- Handler registry created with schema metadata
- Backwards-compatible API (handlers work identically from user perspective)

**Technical Details:**

Files to create:

- `src/handlers/registry.ts` - Handler registry with schema metadata

Files to modify:

- `src/handlers/BackLinks.ts`
- `src/handlers/Kind.ts`
- `src/handlers/Children.ts`
- `src/handlers/Tasks.ts`
- `src/handlers/VideoGallery.ts`
- `src/handlers/PageEntry.ts`
- `src/handlers/IconPage.ts`
- `src/handlers/Accounts.ts`
- `src/handlers/Book.ts`
- `src/handlers/Journal.ts`
- `src/handlers/Debug.ts`

**Migration Batches:**

- Batch 1: BackLinks, Debug, VideoGallery, PageEntry (4 handlers)
- Batch 2: Kind, Children, Tasks, IconPage (4 handlers)
- Batch 3: Accounts, Book, Journal (3 handlers)

Run full test suite after each batch.

**Handler Registry Design:**

```typescript
import type { Type } from "arktype";

interface HandlerMetadata<TScalar = unknown, TOptions = unknown> {
  name: string;
  scalarSchema: Type<TScalar> | null;
  optionsSchema: Type<TOptions> | null;
  description: string;
  examples: string[];
}

// Singleton registry - handlers self-register at module load
const handlerRegistry = new Map<string, HandlerMetadata>();

export function registerHandler<TScalar, TOptions>(
  metadata: HandlerMetadata<TScalar, TOptions>
) {
  if (handlerRegistry.has(metadata.name)) {
    console.warn(`Handler ${metadata.name} already registered`);
  }
  handlerRegistry.set(metadata.name, metadata);
}

export function getHandlerMetadata(name: string): HandlerMetadata | undefined {
  return handlerRegistry.get(name);
}

export function getAllHandlers(): HandlerMetadata[] {
  return Array.from(handlerRegistry.values());
}
```

**Tests to Write:**

Happy Path:

- [ ] All 11 handlers register with registry
- [ ] Registry returns correct metadata for each handler
- [ ] Existing handler tests pass without modification

Backwards Compatibility:

- [ ] User-facing handler API unchanged
- [ ] All existing km codeblock examples still work
- [ ] Error messages maintain quality

Schema Validation:

- [ ] Each handler's schema validates correctly
- [ ] Invalid inputs rejected with clear errors
- [ ] Optional parameters work as before

Type Tests:

- [ ] Handler event types infer correctly
- [ ] Scalar and option types match schema

Integration:

- [ ] Full handler invocation works end-to-end
- [ ] Registry lookups are fast (<1ms)

**Acceptance Criteria:**

- [ ] All 11 handlers use ArkType schemas
- [ ] Handler registry populated with all handlers
- [ ] Each handler has description and examples in metadata
- [ ] All existing tests pass
- [ ] No user-facing behavior changes

---

### Phase 3: CodeMirror Autocomplete Extension

**Principal Owner:** Frontend Developer

**Goal:** Implement rich autocomplete for `km` blocks using CodeMirror 6

**Dependencies:** Phase 2 (handler registry)

**Blast Radius:** `test/unit/language/**/*.test.ts` (new tests)

**Deliverables:**

- Handler name autocomplete (e.g., typing "Ba" suggests "BackLinks")
- Option key autocomplete (e.g., typing "{" after handler shows available options)
- Option value autocomplete for enums
- Snippets with placeholders for common patterns
- Shared parsing utilities for Phase 4 reuse

**Technical Details:**

Files to create:

- `src/utils/language/km-parser.ts` - Shared parsing utilities for context detection

Files to modify:

- `src/utils/language/autocomplete.ts` - Complete rewrite
- `src/main.ts` - Register CodeMirror extensions via `this.registerEditorExtension()`

**CodeMirror Extension Registration:**

```typescript
// In src/main.ts onload()
import { km_lang } from "~/utils/language/km_lang";

async onload() {
  // ... existing code ...

  // Register CodeMirror extensions for km blocks
  this.registerEditorExtension(km_lang());
}
```

**Shared Parsing Utilities (km-parser.ts):**

```typescript
export interface ParseContext {
  handlerName: string | null;
  isInsideParens: boolean;
  isInsideOptionsHash: boolean;
  currentOptionKey: string | null;
  cursorOffset: number;
}

export function parseKmContext(text: string, cursorPos: number): ParseContext {
  // Handle edge cases:
  // - Multi-line option objects
  // - Cursor inside string literals
  // - Incomplete/malformed syntax while typing
  // - Comments (if supported)
}

export function isAtLineStart(text: string): boolean;
export function isInsideOptionsHash(text: string): boolean;
export function getHandlerFromContext(text: string): string | null;
export function getOptionStart(cursorPos: number, text: string): number;
```

**Autocomplete Implementation:**

```typescript
import { autocompletion, CompletionContext, CompletionResult } from "@codemirror/autocomplete";
import { getAllHandlers, getHandlerMetadata } from "~/handlers/registry";
import { parseKmContext } from "./km-parser";

function kmCompletions(context: CompletionContext): CompletionResult | null {
  const line = context.state.doc.lineAt(context.pos);
  const text = line.text.slice(0, context.pos - line.from);
  const ctx = parseKmContext(text, context.pos - line.from);

  const handlers = getAllHandlers();

  // Handler name completion (at start of line)
  if (!ctx.handlerName && !ctx.isInsideParens) {
    return {
      from: line.from,
      options: handlers.map(h => ({
        label: h.name,
        type: "function",
        detail: h.description,
        apply: `${h.name}()`,
        info: () => createHandlerInfo(h),
      })),
    };
  }

  // Option key completion (inside options hash)
  if (ctx.isInsideOptionsHash && ctx.handlerName) {
    const meta = getHandlerMetadata(ctx.handlerName);
    if (meta?.optionsSchema) {
      return {
        from: getOptionStart(context.pos, text),
        options: getOptionCompletions(meta.optionsSchema),
      };
    }
  }

  return null;
}

export function km_autocomplete() {
  return autocompletion({
    override: [kmCompletions],
    activateOnTyping: true, // Automatic trigger
  });
}
```

**Tests to Write:**

Happy Path:

- [ ] Handler names autocomplete from first character
- [ ] Option keys autocomplete inside `{}`
- [ ] Enum values autocomplete for enum-typed options
- [ ] Completion info displays handler description

Edge Cases:

- [ ] Autocomplete works at various cursor positions
- [ ] Autocomplete handles partial input correctly
- [ ] Autocomplete filters based on context
- [ ] Multi-line blocks work correctly
- [ ] Nested structures handled

Performance:

- [ ] Autocomplete responds in <50ms
- [ ] No lag with 11+ handlers in registry

Integration:

- [ ] CodeMirror extension activates on km blocks
- [ ] Autocomplete integrates with Obsidian editor

**Acceptance Criteria:**

- [ ] Handler names autocomplete from first character
- [ ] Option keys autocomplete inside `{}`
- [ ] Enum values show as suggestions for enum-typed options
- [ ] Completion info shows handler description and examples
- [ ] Performance: <50ms response time
- [ ] Works immediately when entering `km` block
- [ ] ViewPlugin implements proper `destroy()` cleanup

---

### Phase 4: CodeMirror Inline Validation Extension

**Principal Owner:** Frontend Developer

**Goal:** Show validation errors inline while editing `km` blocks

**Dependencies:** Phase 2 (handler registry with ArkType schemas), Phase 3 (shared km-parser.ts)

**Blast Radius:** `test/unit/language/**/*.test.ts` (new tests)

**Deliverables:**

- Real-time syntax validation
- Red underlines for errors with hover tooltips
- Warning underlines for potential issues
- Validation debounced to avoid lag
- Quick fixes for common errors

**Technical Details:**

Files to create:

- `src/utils/language/km-linter.ts` - Linting extension

Reuses:

- `src/utils/language/km-parser.ts` - From Phase 3

**Linter Implementation:**

```typescript
import { linter, Diagnostic } from "@codemirror/lint";
import { EditorView } from "@codemirror/view";
import { parseKmContext, parseKmBlock } from "./km-parser";
import { getHandlerMetadata } from "~/handlers/registry";

interface ParseError {
  start: number;
  end: number;
  severity: "error" | "warning" | "info";
  message: string;
  quickFixes?: { label: string; replacement: string }[];
}

function validateKmBlock(content: string): ParseError[] {
  const errors: ParseError[] = [];

  // 1. Syntax errors: Unbalanced parens, invalid JSON
  // 2. Unknown handler: Handler name not in registry
  // 3. Unknown option: Option key not in schema
  // 4. Type mismatch: Value doesn't match expected type
  // 5. Missing required: Required scalar param missing

  return errors;
}

export const kmLinter = linter((view: EditorView): Diagnostic[] => {
  const diagnostics: Diagnostic[] = [];
  const content = view.state.doc.toString();
  const errors = validateKmBlock(content);

  for (const error of errors) {
    diagnostics.push({
      from: error.start,
      to: error.end,
      severity: error.severity,
      message: error.message,
      actions: error.quickFixes?.map(fix => ({
        name: fix.label,
        apply: (view, from, to) => {
          view.dispatch({
            changes: { from, to, insert: fix.replacement }
          });
        }
      })),
    });
  }

  return diagnostics;
}, { delay: 300 }); // 300ms debounce
```

**Tests to Write:**

Happy Path:

- [ ] Syntax errors show red underlines
- [ ] Hover shows error messages
- [ ] Errors clear when fixed

Error Categories:

- [ ] Unknown handler detected
- [ ] Unknown option detected
- [ ] Type mismatch detected
- [ ] Missing required parameter detected

Performance:

- [ ] Validation debounced properly (300ms)
- [ ] No editor lag during typing

Integration:

- [ ] Linter integrates with CodeMirror
- [ ] Quick fixes work when applicable

Edge Cases:

- [ ] Multiple errors in same block
- [ ] Error position accuracy with multiline content
- [ ] Recovery after fixing errors

**Acceptance Criteria:**

- [ ] Red underlines appear for errors within 500ms
- [ ] Hover shows error message
- [ ] Error position is accurate (underlines correct text)
- [ ] Quick fixes work for common errors (e.g., typos in option names)
- [ ] Validation doesn't cause editor lag
- [ ] Errors clear when fixed
- [ ] ViewPlugin implements proper `destroy()` cleanup

---

### Phase 5: Enhanced Error Display in Rendered Blocks

**Principal Owner:** Backend TypeScript Developer

**Goal:** Improve error messages shown when rendering fails

**Dependencies:** Phase 1 (ArkType provides detailed errors)

**Blast Radius:** `test/codeblockParser.test.ts`

**Deliverables:**

- Leverage ArkType's detailed error messages
- Show expected vs actual type with examples
- Suggest closest valid option for typos
- Include link to documentation

**Technical Details:**

Files to modify:

- `src/events/codeblockParser.ts` - Error rendering
- `src/api/formatting/blockquote.ts` - Error callout styling

**ArkType Error Handling:**

```typescript
import type { ArkErrors } from "arktype";

function formatArkTypeError(errors: ArkErrors, handlerName: string): string[] {
  const content: string[] = [];

  for (const error of errors) {
    content.push(`<b>Problem:</b> ${error.message}`);
    content.push(`<b>Expected:</b> ${error.expected}`);
    content.push(`<b>Received:</b> ${error.actual}`);

    if (error.path.length > 0) {
      content.push(`<b>At:</b> ${error.path.join(".")}`);
    }
  }

  return content;
}
```

**Typo Suggestion (Levenshtein distance):**

```typescript
function suggestClosestOption(
  invalidKey: string,
  validKeys: string[]
): string | null {
  let closest: string | null = null;
  let minDistance = Infinity;

  for (const key of validKeys) {
    const distance = levenshteinDistance(invalidKey, key);
    if (distance < minDistance && distance <= 3) {
      minDistance = distance;
      closest = key;
    }
  }

  return closest;
}
```

**Enhanced Error Display:**

```typescript
render.callout("error", `Invalid options for ${handlerName}`, {
  content: [
    `<b>Problem:</b> Unknown option "${invalidKey}"`,
    closest ? `<b>Did you mean:</b> <code>${closest}</code>` : null,
    `<b>Valid options:</b>`,
    `<ul>`,
    ...validOptions.map(opt =>
      `<li><code>${opt.name}</code>: ${opt.description} (${opt.type})</li>`
    ),
    `</ul>`,
    `<a href="obsidian://km/docs/handlers/${handlerName}">View documentation</a>`,
  ].filter(Boolean),
});
```

**Tests to Write:**

Happy Path:

- [ ] ArkType errors formatted clearly
- [ ] Expected vs actual shown
- [ ] Typo suggestions work

Edge Cases:

- [ ] Multiple errors displayed properly
- [ ] Nested validation errors handled
- [ ] Long error messages truncated appropriately
- [ ] No close match for typos handled gracefully

Integration:

- [ ] Error display integrates with render API
- [ ] Error callouts styled correctly

**Acceptance Criteria:**

- [ ] Error messages explain what's wrong
- [ ] Error messages suggest how to fix it
- [ ] Typos in option names suggest closest match
- [ ] Type errors show expected vs actual
- [ ] Examples shown where helpful

---

### Phase 6: Documentation

**Principal Owner:** Backend TypeScript Developer

**Goal:** Create comprehensive documentation for users and developers

**Dependencies:** Phases 1-5

**Blast Radius:** N/A (documentation only)

**Deliverables:**

- `docs/km-type-guardrails.md` - User and developer guide
- Updated handler examples in documentation
- In-editor help via autocomplete tooltips

**Technical Details:**

Document structure for `docs/km-type-guardrails.md`:

```markdown
# KM Block Type Guardrails

## For Plugin Users

### Autocomplete
- How to trigger autocomplete (automatic on typing)
- Understanding suggestions
- Keyboard shortcuts (Ctrl+Space for manual trigger)

### Understanding Errors

#### Inline Errors (While Editing)
- Red underlines indicate problems
- Hover for details
- Quick fixes available for common errors

#### Rendered Errors (After Exiting Editor)
- Error callouts explain what went wrong
- "Did you mean?" suggestions for typos
- Links to handler documentation

### Handler Reference
- Quick reference for each handler
- Parameters and options
- Examples

## For Handler Developers

### Creating a Handler
- Using createHandler with ArkType
- Defining scalar parameters
- Defining options schema
- Adding description and examples for registry

### Schema Design
- Available types (see TypeToken→ArkType translation table)
- Optional vs required
- Complex types (unions, arrays)

### Best Practices
- Schema naming conventions
- Documentation requirements
- Testing your handler
```

**Acceptance Criteria:**

- [ ] Documentation saved to `docs/km-type-guardrails.md`
- [ ] User section covers autocomplete and error handling
- [ ] Developer section covers schema definition
- [ ] All handlers documented with examples
- [ ] Document reviewed and approved

---

## Cross-Cutting Concerns

### Testing Strategy (Expanded)

**Unit Tests:**

- Schema validation edge cases (Phase 1)
- Handler schema definitions (Phase 2)
- Autocomplete context detection (Phase 3)
- Linter error detection (Phase 4)
- Error message formatting (Phase 5)

**Integration Tests:**

- Full handler parsing with ArkType (Phase 1-2)
- CodeMirror extension behavior (Phase 3-4)
- End-to-end km block rendering with validation (Phase 5)

**Type Tests:**

- ArkType schema type inference (Phase 1)
- Handler event type correctness (Phase 2)
- Completion result types (Phase 3)

**Regression Tests:**

- Run full test suite after EACH phase
- All existing parseParams tests must pass (Phase 1)
- All existing handler tests must pass (Phase 2)
- No performance regressions (all phases)

**Test Organization:**

- Use `tests/unit/WIP/` during each phase for new tests
- Organize by feature/subdirectory for multi-file suites
- Migrate to permanent location after user review

**Testing Workflow (per phase):**

1. Follow TDD 5-step workflow
2. Create snapshot before starting phase
3. Write tests in `tests/unit/WIP/` BEFORE implementation
4. Verify tests fail initially (red)
5. Implement to make tests pass (green)
6. Refactor with tests as safety net
7. Migrate tests from WIP after user review

### Security Considerations

- User input is already sandboxed within Obsidian
- ArkType validation prevents code injection in schemas
- No new attack vectors introduced

### Performance Considerations

- ArkType is pre-compiled, validation is fast
- CodeMirror linting debounced to 300ms
- Handler registry is a simple Map lookup (O(1))
- Autocomplete sources are memoized
- ViewPlugin cleanup prevents memory leaks

---

## Parallelization Opportunities

| Parallel Group | Phases | Reason |
|----------------|--------|--------|
| Group A | Phase 0, Phase 1 | Foundation - must complete first |
| Group B | Phase 2, Phase 5 | Both depend only on Phase 1 |
| Group C | Phase 3, Phase 4 | Both depend on Phase 2 |
| Group D | Phase 6 | Documentation after implementation |

### Parallelization Diagram

```
Timeline:
─────────────────────────────────────────────────────────────────►

Phase 0: ████ (Spike)
              │
Phase 1:      ████████████ (ArkType Integration)
                          │
               ┌──────────┴──────────┐
               ▼                     ▼
Phase 2:  ████████████       Phase 5: ████████
(Handler Migration)           (Error Display)
                          │
               ┌──────────┴──────────┐
               ▼                     ▼
Phase 3:  ████████████       Phase 4: ████████████
(Autocomplete)                (Inline Validation)
                          │                    │
                          └──────────┬─────────┘
                                     ▼
Phase 6:                       ████████████
                               (Documentation)
```

### Synchronization Points

1. **After Phase 0:** Go/no-go decision on ArkType
2. **After Phase 1:** Schema system must be finalized before handler migration
3. **After Phase 2:** Handler registry must be complete for CodeMirror extensions
4. **Between Phases 3 & 4:** km-parser.ts from Phase 3 is shared with Phase 4
5. **Final:** All phases complete before documentation finalized

---

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| ArkType not suitable | High | Phase 0 spike validates before commitment |
| ArkType learning curve | Medium | Create helper functions matching TypeToken patterns |
| CodeMirror 6 complexity | High | Phase 3 prototype validates approach; shared utilities reduce complexity |
| Bundle size increase | Low | ArkType is ~14KB gzipped, within budget; measured in spike |
| Breaking changes to handlers | High | Maintain backwards-compatible API surface; batched migration |
| Performance regression | Medium | Profile autocomplete/validation; set budgets; debounce |
| Memory leaks in ViewPlugin | Medium | Implement proper destroy() cleanup |

---

## Resolved Questions

1. **Should we support a migration path where both TypeToken and ArkType work during transition?**
   → No. Phase 0 spike validates ArkType before full commitment. If spike fails, we reconsider.

2. **What level of Obsidian API is needed for CodeMirror extension registration?**
   → Use `this.registerEditorExtension()` in plugin's `onload()` method.

3. **Should autocomplete trigger automatically or require a keystroke (Ctrl+Space)?**
   → **Automatic** triggering (modern IDE behavior) with Ctrl+Space as manual fallback.

---

## Appendix: Handler Schema Audit

Current handlers and their schemas:

| Handler | Scalar Params | Options |
|---------|--------------|---------|
| BackLinks | None | `ignoreTags: string[]`, `dedupe?: boolean`, `exclude?: string \| string[]`, `excludeCompletedTasks?: boolean` |
| Kind | `kind: string`, `category?: string`, `subcategory?: string` | `noClassificationResults: boolean`, `show: string[]`, `hide: string[]` |
| Children | (TBD - Phase 2) | (TBD) |
| Tasks | (TBD - Phase 2) | (TBD) |
| VideoGallery | (TBD - Phase 2) | (TBD) |
| PageEntry | (TBD - Phase 2) | (TBD) |
| IconPage | (TBD - Phase 2) | (TBD) |
| Accounts | (TBD - Phase 2) | (TBD) |
| Book | (TBD - Phase 2) | (TBD) |
| Journal | (TBD - Phase 2) | (TBD) |
| Debug | (TBD - Phase 2) | (TBD) |

*(Full schema audit will be completed in Phase 2)*
