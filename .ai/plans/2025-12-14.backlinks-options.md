# BackLinks Handler Options Enhancement

**Created:** 2025-12-14
**Status:** Implemented

## Implementation Summary

**Completed:** 2025-12-14

**Files Changed:**
- `src/handlers/BackLinks.ts` - Added type definitions, filter functions, and handler integration
- `test/BackLinks.test.ts` - New test file with 22 tests

**Test Results:**
- 22 tests passing
- Build successful

## Review Summary

**Reviews Completed:** 2025-12-14

**Reviewers:**
- Backend TS Developer: Approve with Changes
- Schema Architect: Approve with Changes
- Feature Tester: Approve with Changes

**Key Changes from Review:**

1. **Remove `Suggest<T>` from Classification type** - `Suggest<T>` works at compile-time with known literals, not runtime-loaded kind tags. Use simple template literal type with JSDoc examples instead.

2. **Add classification normalization** - Strip leading `#` from classification strings to match `kindTags` format.

3. **Clarify getPageInfo error handling** - Pages without PageInfo are NOT excluded (conservative filtering - keep links we can't analyze).

4. **Add filter order documentation** - Order optimizes by reducing set size before expensive operations (dedupe → classification → completed tasks).

5. **Add performance monitoring** - Log warning if filter chain takes >100ms.

6. **Verify inlinkTasks structure** - Need to confirm task linking direction during implementation.

7. **Add mock infrastructure for testing** - Create `createMockDataArray`, `createMockLink`, `createMockPageInfo` helpers.

8. **Use `@type-challenges/utils` for type tests** - Follow existing pattern with `Expect<Equal<>>`.

**Resolved Concerns:**
- TypeToken mismatch → Use `opt(array(string))` at runtime, cast to `Classification[]` in interface (documented)
- Filter order → Documented with performance rationale
- Missing test fixtures → Added mock strategy section

## Executive Summary

Enhance the `BackLinks` handler to support three new options: `dedupe` (removes backlinks already shown in page body), `exclude` (filters by page classification), and `excludeCompletedTasks` (removes completed task references). These options improve the utility of backlink displays by reducing noise and providing targeted filtering.

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Add `dedupe` option to filter out backlinks that are already linked in the page body | High | Backend TS Developer |
| FR-2 | Add `exclude` option to filter backlinks by classification (kind/category/subcategory) | High | Schema Architect + Backend TS Developer |
| FR-3 | Add `excludeCompletedTasks` option to filter out completed task references | Medium | Backend TS Developer |
| FR-4 | Maintain backward compatibility with existing `ignoreTags` option | High | Backend TS Developer |
| FR-5 | Provide helpful UI feedback when filtering removes all backlinks | Low | Backend TS Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Type safety - all options should be properly typed with inference | Full coverage | Schema Architect |
| NFR-2 | Performance - filtering should not significantly impact render time | <50ms additional | Backend TS Developer |
| NFR-3 | Developer UX - provide JSDoc examples for common classifications | Documentation | Schema Architect |

## Architecture Overview

### Current BackLinks Handler Flow

```
km codeblock → codeblockParser → BackLinks handler
                                        ↓
                              page.inlinks (raw links)
                                        ↓
                              filter self-references
                                        ↓
                              filter by ignoreTags (existing)
                                        ↓
                              render table
```

### Enhanced Flow with New Options

```
km codeblock → codeblockParser → BackLinks handler
                                        ↓
                              page.inlinks (raw links)
                                        ↓
                              filter self-references
                                        ↓
                    ┌─────────────────────────────────────┐
                    │  NEW: Apply filtering chain         │
                    │  1. ignoreTags (existing)           │
                    │  2. dedupe (vs page outlinks)       │
                    │  3. exclude (by classification)     │
                    │  4. excludeCompletedTasks           │
                    └─────────────────────────────────────┘
                                        ↓
                              render table
```

### Data Flow for Each Option

**dedupe:**
```
page.outlinks → extract paths → Set<string>
inlinks.filter(link => !outlinkPaths.has(link.path))
```

**exclude (classification):**
```
Classification string → parse kind/category/subcategory
For each backlink:
  - Get PageInfo via getPageInfo(link)
  - Check if pageInfo matches any excluded classification
  - Filter if match found
```

**excludeCompletedTasks:**
```
page.inlinkTasks → filter completed → extract paths → Set<string>
Separate logic for links that ONLY appear in completed tasks
(Links appearing in both completed tasks AND regular content should remain)
```

## Phases

### Phase 1: Type Definitions and Schema

**Principal Owner:** Schema Architect

**Goal:** Define the `BackLinkOptions` type and `Classification` type utility

**Dependencies:** None

**Deliverables:**
- `Classification` type with JSDoc examples
- `normalizeClassification` helper function
- Updated `BackLinkOptions` interface with all three new options
- Updated options definition in handler registration

**Technical Details:**

Files to modify:
- `src/handlers/BackLinks.ts` - Add type definitions at top of file

Key type definitions:
```typescript
/**
 * Classification pattern supporting:
 * - kind only: `"software"`
 * - kind/category: `"software/development"`
 * - kind/category/subcategory: `"hardware/automation/switch"`
 *
 * Note: Omit the leading `#` symbol - it will be normalized internally.
 *
 * @example
 * // Exclude all software pages
 * { exclude: "software" }
 *
 * // Exclude pages in specific category
 * { exclude: "hardware/automation" }
 *
 * // Exclude multiple classifications
 * { exclude: ["software/development", "hardware/automation/switch"] }
 */
type Classification = `${string}${"" | `/${string}` | `/${string}/${string}`}`;

/**
 * Normalize classification by removing leading # if present
 */
function normalizeClassification(classification: string): string {
  return classification.startsWith('#')
    ? classification.slice(1)
    : classification;
}

// Extended BackLinkOptions (for documentation - actual types come from TypeToken)
interface BackLinkOptions {
  columns?: ColumnChoice[];
  filterTags?: Tag[];
  sortProperty?: string;
  sortOrder?: "ASC" | "DESC";

  /**
   * Remove backlinks that are already shown in the page body.
   * @default true
   */
  dedupe?: boolean;

  /**
   * Exclude backlinks by classification (kind, kind/category, or kind/category/subcategory).
   * Can be a single classification or an array.
   */
  exclude?: Classification | Classification[];

  /**
   * Remove backlinks that only appear in completed tasks.
   * @default true
   */
  excludeCompletedTasks?: boolean;
}
```

Handler options definition update:
```typescript
.options({
  ignoreTags: "array(string)",
  dedupe: "opt(bool)",
  exclude: "opt(array(string))",  // Runtime: string[], Type: Classification[] (see BackLinkOptions interface)
  excludeCompletedTasks: "opt(bool)",
})
```

**Acceptance Criteria:**
- [ ] `Classification` type correctly represents kind/category/subcategory patterns
- [ ] `BackLinkOptions` interface includes all three new options with JSDoc
- [ ] Handler options definition includes new options with correct TypeToken values
- [ ] Existing options remain unchanged and backward compatible

---

### Phase 2: Dedupe Filter Implementation

**Principal Owner:** Backend TS Developer

**Goal:** Implement the `dedupe` option to filter backlinks already appearing in page body

**Dependencies:** Phase 1 (types must be defined)

**Deliverables:**
- `filterDedupe` helper function
- Integration into BackLinks handler filter chain
- Default value handling (true)

**Technical Details:**

Files to modify:
- `src/handlers/BackLinks.ts`

Implementation approach:
```typescript
function filterDedupe(p: KindModelPlugin, page: PageInfoBlock) {
  return (links: DataArray<Link>, dedupe: boolean = true): DataArray<Link> => {
    if (!dedupe) return links;

    // Get all outgoing links from the current page body
    const outlinkPaths = new Set(
      page.outlinks.map(l => l.path)
    );

    // Filter out backlinks that are also outlinks (already in page body)
    return links.where(l => !outlinkPaths.has(l.path));
  };
}
```

Edge cases to handle:
- Page with no outlinks (should return all backlinks)
- Self-referential links (already filtered by existing logic)
- Links in frontmatter vs body (consider using `outlinksExcludingTasks`)

**Acceptance Criteria:**
- [ ] Backlinks already shown in page body are filtered when `dedupe: true`
- [ ] Backlinks are preserved when `dedupe: false`
- [ ] Default behavior is `dedupe: true` (filtered)
- [ ] Performance is acceptable (<50ms overhead)

---

### Phase 3: Classification Exclude Filter Implementation

**Principal Owner:** Backend TS Developer

**Goal:** Implement the `exclude` option to filter backlinks by classification

**Dependencies:** Phase 1 (types), Phase 2 (filter chain pattern)

**Deliverables:**
- `parseClassification` helper to parse "kind/category/subcategory" strings
- `matchesClassification` helper to check if a page matches a classification
- `filterByClassification` filter function
- Integration into BackLinks handler

**Technical Details:**

Files to modify:
- `src/handlers/BackLinks.ts`

Helper functions:
```typescript
interface ParsedClassification {
  kind: string;
  category?: string;
  subcategory?: string;
}

function parseClassification(classification: Classification): ParsedClassification {
  const parts = classification.split('/');
  return {
    kind: parts[0],
    category: parts[1],
    subcategory: parts[2],
  };
}

/**
 * Check if a page matches any of the given classification patterns.
 *
 * Note: If we can't get PageInfo for a link, we return false (doesn't match exclusion),
 * meaning we KEEP the link. This is conservative filtering - we don't filter out
 * pages we can't analyze.
 */
function matchesClassification(
  p: KindModelPlugin,
  link: Link,
  classifications: Classification[]
): boolean {
  const pageInfo = getPageInfo(p)(link);
  // Conservative: if we can't analyze the page, don't exclude it
  if (!pageInfo) return false;

  return classifications.some(classification => {
    const parsed = parseClassification(normalizeClassification(classification));

    // Check if page's kind matches (kindTags are without # prefix)
    const kindMatches = pageInfo.kindTags.includes(parsed.kind);
    if (!kindMatches) return false;
    if (!parsed.category) return true; // Just kind match

    // Check category (pages can have multiple categories)
    const categoryMatches = pageInfo.categories.some(
      c => c.category === parsed.category
    );
    if (!categoryMatches) return false;
    if (!parsed.subcategory) return true; // Kind + category match

    // Check subcategory
    return pageInfo.subcategories.some(
      s => s.subcategory === parsed.subcategory
    );
  });
}

function filterByClassification(p: KindModelPlugin) {
  return (
    links: DataArray<Link>,
    exclude?: Classification | Classification[]
  ): DataArray<Link> => {
    if (!exclude) return links;

    const exclusions = Array.isArray(exclude) ? exclude : [exclude];
    return links.where(l => !matchesClassification(p, l, exclusions));
  };
}
```

**Acceptance Criteria:**
- [ ] Can exclude by kind only (e.g., `"software"`)
- [ ] Can exclude by kind/category (e.g., `"software/development"`)
- [ ] Can exclude by kind/category/subcategory (e.g., `"hardware/automation/switch"`)
- [ ] Can provide array of exclusions
- [ ] Non-matching backlinks are preserved
- [ ] Gracefully handles pages without classification info

---

### Phase 4: Exclude Completed Tasks Filter Implementation

**Principal Owner:** Backend TS Developer

**Goal:** Implement the `excludeCompletedTasks` option

**Dependencies:** Phase 1 (types), Phase 2 (filter chain pattern)

**Deliverables:**
- `filterCompletedTasks` helper function
- Integration into BackLinks handler

**Technical Details:**

Files to modify:
- `src/handlers/BackLinks.ts`

Key insight from codebase analysis:
- `page.inlinkTasks` contains task-based backlinks
- Each `ObsidianTask` has `completed`, `checked`, `fullyCompleted` properties
- Need to identify links that ONLY appear via completed tasks

Implementation:
```typescript
function filterCompletedTasks(
  p: KindModelPlugin,
  page: PageInfoBlock
) {
  return (
    links: DataArray<Link>,
    excludeCompleted: boolean = true
  ): DataArray<Link> => {
    if (!excludeCompleted) return links;

    // Get paths from completed tasks
    const completedTaskPaths = new Set(
      page.inlinkTasks
        .filter(t => t.completed)
        .map(t => t.link?.path)
        .filter(Boolean)
    );

    // Get paths from non-completed tasks (and regular inlinks)
    const nonCompletedPaths = new Set(
      page.inlinkTasks
        .filter(t => !t.completed)
        .map(t => t.link?.path)
        .filter(Boolean)
    );

    // Filter out links that ONLY appear in completed tasks
    return links.where(l => {
      if (!completedTaskPaths.has(l.path)) return true;
      // Keep if also appears in non-completed context
      return nonCompletedPaths.has(l.path);
    });
  };
}
```

Edge cases:
- Link appears in both completed and non-completed tasks (should keep)
- Link appears in regular content AND completed task (should keep)
- Link ONLY appears via completed task (should filter)

**Acceptance Criteria:**
- [ ] Links from completed tasks only are filtered when `excludeCompletedTasks: true`
- [ ] Links appearing in multiple contexts are preserved
- [ ] Default behavior is `excludeCompletedTasks: true`
- [ ] Works correctly with existing `inlinkTasks` data

---

### Phase 5: Integration and Filter Chain

**Principal Owner:** Backend TS Developer

**Goal:** Integrate all filters into a cohesive filter chain in the BackLinks handler

**Dependencies:** Phases 1-4

**Deliverables:**
- Unified filter chain in handler
- UI feedback for filtered-out links
- Updated "no backlinks" message with filter context

**Technical Details:**

Files to modify:
- `src/handlers/BackLinks.ts`

Handler integration:
```typescript
export const BackLinks = createHandler("BackLinks")
  .scalar()
  .options({
    ignoreTags: "array(string)",
    dedupe: "opt(bool)",
    exclude: "opt(array(string))",
    excludeCompletedTasks: "opt(bool)",
  })
  .handler(async (evt) => {
    const { plugin: p, page, createTable, dv, options } = evt;
    const { inline_codeblock, bulletPoints, light } = p.api.format;

    // Build filter chain
    const whereTags = (l: Link) => Array.isArray(options?.ignoreTags)
      ? keepPage(p)(l, options?.ignoreTags)
      : true;

    // Apply all filters
    let links = (dv.array(page.inlinks) as DataArray<Link>)
      .sort(p => p?.path)
      .where(p => p.path !== page.path && whereTags(p));

    // Apply new filters in optimized order:
    // 1. dedupe - cheap Set lookup, reduces set size first
    // 2. classification - expensive (calls getPageInfo per link)
    // 3. completed tasks - cheap Set lookup
    const filterStart = Date.now();

    links = filterDedupe(page)(links, options?.dedupe ?? true);
    links = filterByClassification(p)(links, options?.exclude);
    links = filterCompletedTasks(page)(links, options?.excludeCompletedTasks ?? true);

    const filterTime = Date.now() - filterStart;
    if (filterTime > 100) {
      p.warn(`BackLinks filtering took ${filterTime}ms for ${links.length} remaining links`);
    }

    // Build exception message for "no results"
    const filterDescriptions: string[] = [];
    if (options?.ignoreTags) {
      filterDescriptions.push(`tagged with ${options.ignoreTags.map(inline_codeblock).join(", ")}`);
    }
    if (options?.dedupe !== false) {
      filterDescriptions.push("already linked in page body");
    }
    if (options?.exclude) {
      const exc = Array.isArray(options.exclude) ? options.exclude : [options.exclude];
      filterDescriptions.push(`classified as ${exc.map(inline_codeblock).join(", ")}`);
    }
    if (options?.excludeCompletedTasks !== false) {
      filterDescriptions.push("completed task references");
    }

    const exception = filterDescriptions.length > 0
      ? light(` <i style="display:flex">(excluding: ${filterDescriptions.join(", ")})</i>`)
      : "";

    await createTable(/* ... existing columns ... */)(/* ... */)(links);
    return true;
  });
```

**Acceptance Criteria:**
- [ ] All filters work together in correct order
- [ ] "No backlinks" message describes active filters
- [ ] Handler maintains backward compatibility
- [ ] Performance remains acceptable with all filters enabled

---

### Phase 6: Testing

**Principal Owner:** Feature Tester

**Goal:** Comprehensive test coverage for new options

**Dependencies:** Phases 1-5

**Deliverables:**
- Mock utilities for DataArray, Link, PageInfo, ObsidianTask
- Unit tests for each filter function
- Integration tests for filter combinations
- Type tests for Classification type

**Technical Details:**

Files to create:
- `test/BackLinks.test.ts` (in root test directory, following existing pattern)
- `test/helpers/mockDataArray.ts` (utility for DataArray mocking)

**Mock Utilities to Create:**

```typescript
// test/helpers/mockDataArray.ts
import type { DataArray } from '~/types';

export function createMockDataArray<T>(values: T[]): DataArray<T> {
  const mock = {
    length: values.length,
    values,
    where: (predicate: (elem: T, index: number, arr: T[]) => boolean) =>
      createMockDataArray(values.filter(predicate)),
    filter: (predicate: (elem: T, index: number, arr: T[]) => boolean) =>
      createMockDataArray(values.filter(predicate)),
    map: <U>(f: (elem: T, index: number, arr: T[]) => U) =>
      createMockDataArray(values.map(f)),
    sort: <U>(key: (elem: T) => U) =>
      createMockDataArray([...values].sort((a, b) => {
        const aKey = key(a);
        const bKey = key(b);
        return aKey < bKey ? -1 : aKey > bKey ? 1 : 0;
      })),
    array: () => values,
  } as unknown as DataArray<T>;
  return mock;
}

export function createMockLink(path: string, display?: string): Link {
  return {
    path,
    display: display || path.split('/').pop()?.replace('.md', ''),
    type: 'file',
    embed: false,
  } as Link;
}

export function createMockPageInfo(overrides?: Partial<PageInfo>): PageInfo {
  return {
    __kind: 'PageInfo',
    name: 'test-page',
    path: 'test/test-page.md',
    kindTags: [],
    categories: [],
    subcategories: [],
    outlinks: [],
    inlinks: [],
    inlinkTasks: [],
    ...overrides,
  } as PageInfo;
}

export function createMockTask(
  path: string,
  completed: boolean,
  checked: boolean = completed
): ObsidianTask {
  return {
    completed,
    checked,
    fullyCompleted: completed,
    text: `Task linking to [[${path}]]`,
    status: completed ? 'x' : ' ',
    link: { path } as FileLink,
    outlinks: [],
    subtasks: [],
  } as ObsidianTask;
}
```

**Test Scenarios:**

**Dedupe tests:**
- Page with outlinks matching some backlinks → those are filtered
- Page with no outlinks → all backlinks remain
- `dedupe: false` → no filtering
- Same link appears multiple times in outlinks (Set deduplication)

**Classification exclude tests:**
- Exclude single kind → matching pages filtered
- Exclude kind/category → more specific filtering
- Exclude kind/category/subcategory → most specific filtering
- Exclude array of classifications → union filtering
- Non-matching pages → preserved
- Page with `#software` tag and `exclude: "software"` (normalization)
- Page without PageInfo → preserved (conservative filtering)
- Empty classification string → ignored
- Malformed classification (e.g., "kind//category") → handled gracefully

**Completed tasks tests:**
- Link only in completed task → filtered
- Link in completed AND non-completed task → preserved
- Link in regular content (not task) → preserved
- `excludeCompletedTasks: false` → no filtering
- Task with `checked: true` but `completed: false` → not filtered

**Integration tests:**
- All filters enabled → correct cumulative filtering
- All filters disabled → no filtering beyond self-reference
- Various option combinations
- Backward compatibility with existing `ignoreTags` option

**Type tests (using @type-challenges/utils):**
```typescript
import { Expect, Equal } from "@type-challenges/utils";

type cases = [
  // Classification accepts valid patterns
  Expect<Equal<Classification, `${string}` | `${string}/${string}` | `${string}/${string}/${string}`>>,
  // BackLinkOptions accepts new options
  Expect<Equal<BackLinkOptions['dedupe'], boolean | undefined>>,
  Expect<Equal<BackLinkOptions['excludeCompletedTasks'], boolean | undefined>>,
];
```

**Performance test:**
```typescript
it("performance - filters 100 links in <50ms", () => {
  const links = Array.from({ length: 100 }, (_, i) =>
    createMockLink(`page-${i}.md`)
  );
  const mockDataArray = createMockDataArray(links);

  const start = performance.now();
  // Apply all filters
  const end = performance.now();

  expect(end - start).toBeLessThan(50);
});
```

**Acceptance Criteria:**
- [ ] >80% code coverage for new filter code
- [ ] All edge cases have explicit tests
- [ ] Type tests verify Classification type behavior
- [ ] Performance test verifies <50ms for 100 links
- [ ] Backward compatibility tests for existing `ignoreTags`
- [ ] Tests pass in CI

---

## Cross-Cutting Concerns

### Testing Strategy

- **Unit tests:** Each filter function tested in isolation with mock data (see Phase 6 mock utilities)
- **Integration tests:** Handler tested with mocked PageInfo structures
- **Type tests:** Classification type validated with `@type-challenges/utils` (`Expect<Equal<>>` pattern)
- **Mock strategy:** Use factory functions (`createMockDataArray`, `createMockLink`, etc.) rather than mocking Obsidian/Dataview directly

### Performance Considerations

- `getPageInfo` is called per backlink for classification filtering - cache if needed
- Set-based lookups for path comparison (O(1) vs O(n))
- Consider lazy evaluation if backlink count is high

### Backward Compatibility

- All new options have sensible defaults
- `dedupe: true` and `excludeCompletedTasks: true` are defaults (match expected behavior from image)
- Existing `ignoreTags` option unchanged
- No breaking changes to existing API

## Parallelization Opportunities

| Parallel Group | Phases | Reason |
|----------------|--------|--------|
| Group A | Phase 1 | Foundation - must complete first |
| Group B | Phase 2, 3, 4 | Independent filter implementations |
| Group C | Phase 5 | Integration - depends on Group B |
| Group D | Phase 6 | Testing - can start after Phase 5 |

```
Timeline:
─────────────────────────────────────────────────────►

Phase 1: ████ (Types/Schema)
              │
Phase 2: ─────┴─███████ (Dedupe)
Phase 3: ─────┴─███████ (Classification) ├── Parallel
Phase 4: ─────┴─███████ (Completed Tasks)
                       │
Phase 5: ──────────────┴─████ (Integration)
                             │
Phase 6: ────────────────────┴─██████ (Testing)
```

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| Performance degradation with many backlinks | Medium | Profile filter chain, add caching for getPageInfo if needed |
| Classification matching edge cases | Low | Comprehensive test coverage, clear documentation |
| Breaking existing user configurations | High | All new options have defaults matching existing behavior |
| Complex filter interactions | Medium | Clear filter order, integration tests |

## Open Questions

- [x] Should `dedupe` consider only body links or also frontmatter links? → **Use `page.outlinks` which includes all outgoing links**
- [x] Should classification matching be case-sensitive? → **Yes, match kindTags exactly (they are typically lowercase)**
- [ ] Should there be an `include` option as complement to `exclude`? *(future enhancement)*
- [ ] Should filter statistics be shown (e.g., "3 backlinks filtered")? *(future enhancement)*
- [x] How to handle pages without PageInfo? → **Conservative filtering: keep links we can't analyze**

## Implementation Notes

### Existing Infrastructure Leveraged

1. **Page.outlinks** - Already available for dedupe comparison
2. **Page.inlinkTasks** - Already separates task-based backlinks with `completed` flag
3. **getPageInfo()** - Provides full classification data for each backlink
4. **Handler options system** - TypeToken system supports boolean and array types
5. **createTable** - Already has `renderWhenNoRecords` for empty state feedback

### Code Location Reference

- Handler: `src/handlers/BackLinks.ts`
- Handler factory: `src/handlers/createHandler.ts`
- Type definitions: `src/types/Handler.ts`
- PageInfo: `src/page/getPageInfo.ts`
- Param parsing: `src/helpers/parseParams.ts`
